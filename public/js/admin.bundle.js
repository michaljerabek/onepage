/******/ (function(modules) { // webpackBootstrap
/******/ 	var parentHotUpdateCallback = this["webpackHotUpdate"];
/******/ 	this["webpackHotUpdate"] =
/******/ 	function webpackHotUpdateCallback(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if(parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	} ;
/******/
/******/ 	function hotDownloadUpdateChunk(chunkId) { // eslint-disable-line no-unused-vars
/******/ 		var head = document.getElementsByTagName("head")[0];
/******/ 		var script = document.createElement("script");
/******/ 		script.type = "text/javascript";
/******/ 		script.charset = "utf-8";
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
/******/ 		head.appendChild(script);
/******/ 	}
/******/
/******/ 	function hotDownloadManifest() { // eslint-disable-line no-unused-vars
/******/ 		return new Promise(function(resolve, reject) {
/******/ 			if(typeof XMLHttpRequest === "undefined")
/******/ 				return reject(new Error("No browser support"));
/******/ 			try {
/******/ 				var request = new XMLHttpRequest();
/******/ 				var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 				request.open("GET", requestPath, true);
/******/ 				request.timeout = 10000;
/******/ 				request.send(null);
/******/ 			} catch(err) {
/******/ 				return reject(err);
/******/ 			}
/******/ 			request.onreadystatechange = function() {
/******/ 				if(request.readyState !== 4) return;
/******/ 				if(request.status === 0) {
/******/ 					// timeout
/******/ 					reject(new Error("Manifest request to " + requestPath + " timed out."));
/******/ 				} else if(request.status === 404) {
/******/ 					// no update available
/******/ 					resolve();
/******/ 				} else if(request.status !== 200 && request.status !== 304) {
/******/ 					// other failure
/******/ 					reject(new Error("Manifest request to " + requestPath + " failed."));
/******/ 				} else {
/******/ 					// success
/******/ 					try {
/******/ 						var update = JSON.parse(request.responseText);
/******/ 					} catch(e) {
/******/ 						reject(e);
/******/ 						return;
/******/ 					}
/******/ 					resolve(update);
/******/ 				}
/******/ 			};
/******/ 		});
/******/ 	}

/******/
/******/
/******/ 	var hotApplyOnUpdate = true;
/******/ 	var hotCurrentHash = "9576a4c750105ebab72d"; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentParents = []; // eslint-disable-line no-unused-vars
/******/
/******/ 	function hotCreateRequire(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var me = installedModules[moduleId];
/******/ 		if(!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if(me.hot.active) {
/******/ 				if(installedModules[request]) {
/******/ 					if(installedModules[request].parents.indexOf(moduleId) < 0)
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 					if(me.children.indexOf(request) < 0)
/******/ 						me.children.push(request);
/******/ 				} else hotCurrentParents = [moduleId];
/******/ 			} else {
/******/ 				console.warn("[HMR] unexpected require(" + request + ") from disposed module " + moduleId);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		for(var name in __webpack_require__) {
/******/ 			if(Object.prototype.hasOwnProperty.call(__webpack_require__, name)) {
/******/ 				Object.defineProperty(fn, name, (function(name) {
/******/ 					return {
/******/ 						configurable: true,
/******/ 						enumerable: true,
/******/ 						get: function() {
/******/ 							return __webpack_require__[name];
/******/ 						},
/******/ 						set: function(value) {
/******/ 							__webpack_require__[name] = value;
/******/ 						}
/******/ 					};
/******/ 				}(name)));
/******/ 			}
/******/ 		}
/******/ 		Object.defineProperty(fn, "e", {
/******/ 			enumerable: true,
/******/ 			value: function(chunkId) {
/******/ 				if(hotStatus === "ready")
/******/ 					hotSetStatus("prepare");
/******/ 				hotChunksLoading++;
/******/ 				return __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {
/******/ 					finishChunkLoading();
/******/ 					throw err;
/******/ 				});
/******/
/******/ 				function finishChunkLoading() {
/******/ 					hotChunksLoading--;
/******/ 					if(hotStatus === "prepare") {
/******/ 						if(!hotWaitingFilesMap[chunkId]) {
/******/ 							hotEnsureUpdateChunk(chunkId);
/******/ 						}
/******/ 						if(hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 							hotUpdateDownloaded();
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		});
/******/ 		return fn;
/******/ 	}
/******/
/******/ 	function hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],
/******/
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfAccepted = true;
/******/ 				else if(typeof dep === "function")
/******/ 					hot._selfAccepted = dep;
/******/ 				else if(typeof dep === "object")
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback;
/******/ 				else
/******/ 					hot._acceptedDependencies[dep] = callback;
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfDeclined = true;
/******/ 				else if(typeof dep === "number")
/******/ 					hot._declinedDependencies[dep] = true;
/******/ 				else
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if(idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if(!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if(idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		return hot;
/******/ 	}
/******/
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for(var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailableFilesMap = {};
/******/ 	var hotDeferred;
/******/
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;
/******/
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = (+id) + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/
/******/ 	function hotCheck(apply) {
/******/ 		if(hotStatus !== "idle") throw new Error("check() is only allowed in idle status");
/******/ 		hotApplyOnUpdate = apply;
/******/ 		hotSetStatus("check");
/******/ 		return hotDownloadManifest().then(function(update) {
/******/ 			if(!update) {
/******/ 				hotSetStatus("idle");
/******/ 				return null;
/******/ 			}
/******/
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotAvailableFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			for(var i = 0; i < update.c.length; i++)
/******/ 				hotAvailableFilesMap[update.c[i]] = true;
/******/ 			hotUpdateNewHash = update.h;
/******/
/******/ 			hotSetStatus("prepare");
/******/ 			var promise = new Promise(function(resolve, reject) {
/******/ 				hotDeferred = {
/******/ 					resolve: resolve,
/******/ 					reject: reject
/******/ 				};
/******/ 			});
/******/ 			hotUpdate = {};
/******/ 			var chunkId = 0;
/******/ 			{ // eslint-disable-line no-lone-blocks
/******/ 				/*globals chunkId */
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if(hotStatus === "prepare" && hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 			return promise;
/******/ 		});
/******/ 	}
/******/
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		if(!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for(var moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if(!hotAvailableFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var deferred = hotDeferred;
/******/ 		hotDeferred = null;
/******/ 		if(!deferred) return;
/******/ 		if(hotApplyOnUpdate) {
/******/ 			hotApply(hotApplyOnUpdate).then(function(result) {
/******/ 				deferred.resolve(result);
/******/ 			}, function(err) {
/******/ 				deferred.reject(err);
/******/ 			});
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for(var id in hotUpdate) {
/******/ 				if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			deferred.resolve(outdatedModules);
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotApply(options) {
/******/ 		if(hotStatus !== "ready") throw new Error("apply() is only allowed in ready status");
/******/ 		options = options || {};
/******/
/******/ 		var cb;
/******/ 		var i;
/******/ 		var j;
/******/ 		var module;
/******/ 		var moduleId;
/******/
/******/ 		function getAffectedStuff(module) {
/******/ 			var outdatedModules = [module];
/******/ 			var outdatedDependencies = {};
/******/
/******/ 			var queue = outdatedModules.slice();
/******/ 			while(queue.length > 0) {
/******/ 				var moduleId = queue.pop();
/******/ 				module = installedModules[moduleId];
/******/ 				if(!module || module.hot._selfAccepted)
/******/ 					continue;
/******/ 				if(module.hot._selfDeclined) {
/******/ 					return new Error("Aborted because of self decline: " + moduleId);
/******/ 				}
/******/ 				if(__webpack_require__.s === moduleId) {
/******/ 					return;
/******/ 				}
/******/ 				for(var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if(parent.hot._declinedDependencies[moduleId]) {
/******/ 						return new Error("Aborted because of declined dependency: " + moduleId + " in " + parentId);
/******/ 					}
/******/ 					if(outdatedModules.indexOf(parentId) >= 0) continue;
/******/ 					if(parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if(!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push(parentId);
/******/ 				}
/******/ 			}
/******/
/******/ 			return [outdatedModules, outdatedDependencies];
/******/ 		}
/******/
/******/ 		function addAllToSet(a, b) {
/******/ 			for(var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if(a.indexOf(item) < 0)
/******/ 					a.push(item);
/******/ 			}
/******/ 		}
/******/
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/ 		for(var id in hotUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				moduleId = toModuleId(id);
/******/ 				var result = getAffectedStuff(moduleId);
/******/ 				if(!result) {
/******/ 					if(options.ignoreUnaccepted)
/******/ 						continue;
/******/ 					hotSetStatus("abort");
/******/ 					return Promise.reject(new Error("Aborted because " + moduleId + " is not accepted"));
/******/ 				}
/******/ 				if(result instanceof Error) {
/******/ 					hotSetStatus("abort");
/******/ 					return Promise.reject(result);
/******/ 				}
/******/ 				appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 				addAllToSet(outdatedModules, result[0]);
/******/ 				for(moduleId in result[1]) {
/******/ 					if(Object.prototype.hasOwnProperty.call(result[1], moduleId)) {
/******/ 						if(!outdatedDependencies[moduleId])
/******/ 							outdatedDependencies[moduleId] = [];
/******/ 						addAllToSet(outdatedDependencies[moduleId], result[1][moduleId]);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for(i = 0; i < outdatedModules.length; i++) {
/******/ 			moduleId = outdatedModules[i];
/******/ 			if(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 		}
/******/
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		var idx;
/******/ 		var queue = outdatedModules.slice();
/******/ 		while(queue.length > 0) {
/******/ 			moduleId = queue.pop();
/******/ 			module = installedModules[moduleId];
/******/ 			if(!module) continue;
/******/
/******/ 			var data = {};
/******/
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for(j = 0; j < disposeHandlers.length; j++) {
/******/ 				cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/
/******/ 			// remove "parents" references from all children
/******/ 			for(j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if(!child) continue;
/******/ 				idx = child.parents.indexOf(moduleId);
/******/ 				if(idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// remove outdated dependency from module children
/******/ 		var dependency;
/******/ 		var moduleOutdatedDependencies;
/******/ 		for(moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				module = installedModules[moduleId];
/******/ 				moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 				for(j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 					dependency = moduleOutdatedDependencies[j];
/******/ 					idx = module.children.indexOf(dependency);
/******/ 					if(idx >= 0) module.children.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Not in "apply" phase
/******/ 		hotSetStatus("apply");
/******/
/******/ 		hotCurrentHash = hotUpdateNewHash;
/******/
/******/ 		// insert new code
/******/ 		for(moduleId in appliedUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for(moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				module = installedModules[moduleId];
/******/ 				moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 				var callbacks = [];
/******/ 				for(i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 					dependency = moduleOutdatedDependencies[i];
/******/ 					cb = module.hot._acceptedDependencies[dependency];
/******/ 					if(callbacks.indexOf(cb) >= 0) continue;
/******/ 					callbacks.push(cb);
/******/ 				}
/******/ 				for(i = 0; i < callbacks.length; i++) {
/******/ 					cb = callbacks[i];
/******/ 					try {
/******/ 						cb(outdatedDependencies);
/******/ 					} catch(err) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Load self accepted modules
/******/ 		for(i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch(err) {
/******/ 				if(typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch(err) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				} else if(!error)
/******/ 					error = err;
/******/ 			}
/******/ 		}
/******/
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if(error) {
/******/ 			hotSetStatus("fail");
/******/ 			return Promise.reject(error);
/******/ 		}
/******/
/******/ 		hotSetStatus("idle");
/******/ 		return Promise.resolve(outdatedModules);
/******/ 	}

/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {},
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: hotCurrentParents,
/******/ 			children: []
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));

/******/ 		// Flag the module as loaded
/******/ 		module.l = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "http://127.0.0.1:80/";

/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };

/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire(218)(__webpack_require__.s = 218);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*
		Ractive.js v0.8.0-edge
		Mon May 02 2016 22:23:02 GMT+0000 (UTC) - commit 3c485fe5c9b4724a6ddd33d52aa89e2c828c8d80

		http://ractivejs.org
		http://twitter.com/RactiveJS

		Released under the MIT License.
	*/


	(function (global, factory) {
	   true ? module.exports = factory() :
	  typeof define === 'function' && define.amd ? define(factory) :
	  ((function() { var current = global.Ractive; var next = factory(); next.noConflict = function() { global.Ractive = current; return next; }; return global.Ractive = next; })());
	}(this, function () { 'use strict';

	  var defaults = {
	  	// render placement:
	  	el:                     void 0,
	  	append:				    false,

	  	// template:
	  	template:               null,

	  	// parse:
	  	delimiters:             [ '{{', '}}' ],
	  	tripleDelimiters:       [ '{{{', '}}}' ],
	  	staticDelimiters:       [ '[[', ']]' ],
	  	staticTripleDelimiters: [ '[[[', ']]]' ],
	  	csp: 					true,
	  	interpolate:            false,
	  	preserveWhitespace:     false,
	  	sanitize:               false,
	  	stripComments:          true,

	  	// data & binding:
	  	data:                   {},
	  	computed:               {},
	  	magic:                  false,
	  	modifyArrays:           true,
	  	adapt:                  [],
	  	isolated:               false,
	  	twoway:                 true,
	  	lazy:                   false,

	  	// transitions:
	  	noIntro:                false,
	  	transitionsEnabled:     true,
	  	complete:               void 0,

	  	// css:
	  	css:                    null,
	  	noCssTransform:         false
	  };

	  // These are a subset of the easing equations found at
	  // https://raw.github.com/danro/easing-js - license info
	  // follows:

	  // --------------------------------------------------
	  // easing.js v0.5.4
	  // Generic set of easing functions with AMD support
	  // https://github.com/danro/easing-js
	  // This code may be freely distributed under the MIT license
	  // http://danro.mit-license.org/
	  // --------------------------------------------------
	  // All functions adapted from Thomas Fuchs & Jeremy Kahn
	  // Easing Equations (c) 2003 Robert Penner, BSD license
	  // https://raw.github.com/danro/easing-js/master/LICENSE
	  // --------------------------------------------------

	  // In that library, the functions named easeIn, easeOut, and
	  // easeInOut below are named easeInCubic, easeOutCubic, and
	  // (you guessed it) easeInOutCubic.
	  //
	  // You can add additional easing functions to this list, and they
	  // will be globally available.


	  var easing = {
	  	linear: function ( pos ) { return pos; },
	  	easeIn: function ( pos ) { return Math.pow( pos, 3 ); },
	  	easeOut: function ( pos ) { return ( Math.pow( ( pos - 1 ), 3 ) + 1 ); },
	  	easeInOut: function ( pos ) {
	  		if ( ( pos /= 0.5 ) < 1 ) { return ( 0.5 * Math.pow( pos, 3 ) ); }
	  		return ( 0.5 * ( Math.pow( ( pos - 2 ), 3 ) + 2 ) );
	  	}
	  };

	  var legacy = null;

	  /*global console, navigator */

	  var win = typeof window !== 'undefined' ? window : null;
	  var doc = win ? document : null;

	  var isClient = !!doc;
	  var isJsdom = ( typeof navigator !== 'undefined' && /jsDom/.test( navigator.appName ) );
	  var hasConsole = ( typeof console !== 'undefined' && typeof console.warn === 'function' && typeof console.warn.apply === 'function' );

	  var magicSupported;
	  try {
	  	Object.defineProperty({}, 'test', { value: 0 });
	  	magicSupported = true;
	  } catch ( e ) {
	  	magicSupported = false;
	  }

	  var svg = doc ?
	  	doc.implementation.hasFeature( 'http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1' ) :
	  	false;

	  var vendors = [ 'o', 'ms', 'moz', 'webkit' ];

	  var html   = 'http://www.w3.org/1999/xhtml';
	  var mathml = 'http://www.w3.org/1998/Math/MathML';
	  var svg$1    = 'http://www.w3.org/2000/svg';
	  var xlink  = 'http://www.w3.org/1999/xlink';
	  var xml    = 'http://www.w3.org/XML/1998/namespace';
	  var xmlns  = 'http://www.w3.org/2000/xmlns';

	  var namespaces = { html: html, mathml: mathml, svg: svg$1, xlink: xlink, xml: xml, xmlns: xmlns };

	  var createElement;
	  var matches;
	  var div;
	  var methodNames;
	  var unprefixed;
	  var prefixed;
	  var i;
	  var j;
	  var makeFunction;
	  // Test for SVG support
	  if ( !svg ) {
	  	createElement = function ( type, ns, extend ) {
	  		if ( ns && ns !== html ) {
	  			throw 'This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you\'re trying to render SVG in an older browser. See http://docs.ractivejs.org/latest/svg-and-older-browsers for more information';
	  		}

	  		return extend ?
	  			doc.createElement( type, extend ) :
	  			doc.createElement( type );
	  	};
	  } else {
	  	createElement = function ( type, ns, extend ) {
	  		if ( !ns || ns === html ) {
	  			return extend ?
	  				doc.createElement( type, extend ) :
	  				doc.createElement( type );
	  		}

	  		return extend ?
	  			doc.createElementNS( ns, type, extend ) :
	  			doc.createElementNS( ns, type );
	  	};
	  }

	  function createDocumentFragment () {
	  	return doc.createDocumentFragment();
	  }

	  function getElement ( input ) {
	  	var output;

	  	if ( !input || typeof input === 'boolean' ) { return; }

	  	if ( !win || !doc || !input ) {
	  		return null;
	  	}

	  	// We already have a DOM node - no work to do. (Duck typing alert!)
	  	if ( input.nodeType ) {
	  		return input;
	  	}

	  	// Get node from string
	  	if ( typeof input === 'string' ) {
	  		// try ID first
	  		output = doc.getElementById( input );

	  		// then as selector, if possible
	  		if ( !output && doc.querySelector ) {
	  			output = doc.querySelector( input );
	  		}

	  		// did it work?
	  		if ( output && output.nodeType ) {
	  			return output;
	  		}
	  	}

	  	// If we've been given a collection (jQuery, Zepto etc), extract the first item
	  	if ( input[0] && input[0].nodeType ) {
	  		return input[0];
	  	}

	  	return null;
	  }

	  if ( !isClient ) {
	  	matches = null;
	  } else {
	  	div = createElement( 'div' );
	  	methodNames = [ 'matches', 'matchesSelector' ];

	  	makeFunction = function ( methodName ) {
	  		return function ( node, selector ) {
	  			return node[ methodName ]( selector );
	  		};
	  	};

	  	i = methodNames.length;

	  	while ( i-- && !matches ) {
	  		unprefixed = methodNames[i];

	  		if ( div[ unprefixed ] ) {
	  			matches = makeFunction( unprefixed );
	  		} else {
	  			j = vendors.length;
	  			while ( j-- ) {
	  				prefixed = vendors[i] + unprefixed.substr( 0, 1 ).toUpperCase() + unprefixed.substring( 1 );

	  				if ( div[ prefixed ] ) {
	  					matches = makeFunction( prefixed );
	  					break;
	  				}
	  			}
	  		}
	  	}

	  	// IE8...
	  	if ( !matches ) {
	  		matches = function ( node, selector ) {
	  			var nodes, parentNode, i;

	  			parentNode = node.parentNode;

	  			if ( !parentNode ) {
	  				// empty dummy <div>
	  				div.innerHTML = '';

	  				parentNode = div;
	  				node = node.cloneNode();

	  				div.appendChild( node );
	  			}

	  			nodes = parentNode.querySelectorAll( selector );

	  			i = nodes.length;
	  			while ( i-- ) {
	  				if ( nodes[i] === node ) {
	  					return true;
	  				}
	  			}

	  			return false;
	  		};
	  	}
	  }

	  function detachNode ( node ) {
	  	if ( node && typeof node.parentNode !== 'unknown' && node.parentNode ) {
	  		node.parentNode.removeChild( node );
	  	}

	  	return node;
	  }

	  function safeToStringValue( value ) {
	  	return ( value == null || !value.toString ) ? '' : '' + value;
	  }

	  var create;
	  var defineProperty;
	  var defineProperties;
	  try {
	  	Object.defineProperty({}, 'test', { get: function() {}, set: function() {} });

	  	if ( doc ) {
	  		Object.defineProperty( createElement( 'div' ), 'test', { value: 0 });
	  	}

	  	defineProperty = Object.defineProperty;
	  } catch ( err ) {
	  	// Object.defineProperty doesn't exist, or we're in IE8 where you can
	  	// only use it with DOM objects (what were you smoking, MSFT?)
	  	defineProperty = function ( obj, prop, desc ) {
	  		obj[ prop ] = desc.value;
	  	};
	  }

	  try {
	  	try {
	  		Object.defineProperties({}, { test: { value: 0 } });
	  	} catch ( err ) {
	  		// TODO how do we account for this? noMagic = true;
	  		throw err;
	  	}

	  	if ( doc ) {
	  		Object.defineProperties( createElement( 'div' ), { test: { value: 0 } });
	  	}

	  	defineProperties = Object.defineProperties;
	  } catch ( err ) {
	  	defineProperties = function ( obj, props ) {
	  		var prop;

	  		for ( prop in props ) {
	  			if ( props.hasOwnProperty( prop ) ) {
	  				defineProperty( obj, prop, props[ prop ] );
	  			}
	  		}
	  	};
	  }

	  try {
	  	Object.create( null );

	  	create = Object.create;
	  } catch ( err ) {
	  	// sigh
	  	create = (function () {
	  		var F = function () {};

	  		return function ( proto, props ) {
	  			var obj;

	  			if ( proto === null ) {
	  				return {};
	  			}

	  			F.prototype = proto;
	  			obj = new F();

	  			if ( props ) {
	  				Object.defineProperties( obj, props );
	  			}

	  			return obj;
	  		};
	  	}());
	  }

	  function extendObj ( target ) {
	  	var sources = [], len = arguments.length - 1;
	  	while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];

	  	var prop;

	  	sources.forEach( function ( source ) {
	  		for ( prop in source ) {
	  			if ( hasOwn.call( source, prop ) ) {
	  				target[ prop ] = source[ prop ];
	  			}
	  		}
	  	});

	  	return target;
	  }

	  function fillGaps ( target ) {
	  	var sources = [], len = arguments.length - 1;
	  	while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];

	  	sources.forEach( function ( s ) {
	  		for ( var key in s ) {
	  			if ( hasOwn.call( s, key ) && !( key in target ) ) {
	  				target[ key ] = s[ key ];
	  			}
	  		}
	  	});

	  	return target;
	  }

	  var hasOwn = Object.prototype.hasOwnProperty;

	  var toString = Object.prototype.toString;
	  // thanks, http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/
	  function isArray ( thing ) {
	  	return toString.call( thing ) === '[object Array]';
	  }

	  function isEqual ( a, b ) {
	  	if ( a === null && b === null ) {
	  		return true;
	  	}

	  	if ( typeof a === 'object' || typeof b === 'object' ) {
	  		return false;
	  	}

	  	return a === b;
	  }

	  // http://stackoverflow.com/questions/18082/validate-numbers-in-javascript-isnumeric
	  function isNumeric ( thing ) {
	  	return !isNaN( parseFloat( thing ) ) && isFinite( thing );
	  }

	  function isObject ( thing ) {
	  	return ( thing && toString.call( thing ) === '[object Object]' );
	  }

	  function noop () {}

	  var alreadyWarned = {};
	  var log;
	  var printWarning;
	  var welcome;
	  if ( hasConsole ) {
	  	var welcomeIntro = [
	  		("%cRactive.js %c0.8.0-edge %cin debug mode, %cmore..."),
	  		'color: rgb(114, 157, 52); font-weight: normal;',
	  		'color: rgb(85, 85, 85); font-weight: normal;',
	  		'color: rgb(85, 85, 85); font-weight: normal;',
	  		'color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;'
	  	];
	  	var welcomeMessage = "You're running Ractive 0.8.0-edge in debug mode - messages will be printed to the console to help you fix problems and optimise your application.\n\nTo disable debug mode, add this line at the start of your app:\n  Ractive.DEBUG = false;\n\nTo disable debug mode when your app is minified, add this snippet:\n  Ractive.DEBUG = /unminified/.test(function(){/*unminified*/});\n\nGet help and support:\n  http://docs.ractivejs.org\n  http://stackoverflow.com/questions/tagged/ractivejs\n  http://groups.google.com/forum/#!forum/ractive-js\n  http://twitter.com/ractivejs\n\nFound a bug? Raise an issue:\n  https://github.com/ractivejs/ractive/issues\n\n";

	  	welcome = function () {
	  		var hasGroup = !!console.groupCollapsed;
	  		console[ hasGroup ? 'groupCollapsed' : 'log' ].apply( console, welcomeIntro );
	  		console.log( welcomeMessage );
	  		if ( hasGroup ) {
	  			console.groupEnd( welcomeIntro );
	  		}

	  		welcome = noop;
	  	};

	  	printWarning = function ( message, args ) {
	  		welcome();

	  		// extract information about the instance this message pertains to, if applicable
	  		if ( typeof args[ args.length - 1 ] === 'object' ) {
	  			var options = args.pop();
	  			var ractive = options ? options.ractive : null;

	  			if ( ractive ) {
	  				// if this is an instance of a component that we know the name of, add
	  				// it to the message
	  				var name;
	  				if ( ractive.component && ( name = ractive.component.name ) ) {
	  					message = "<" + name + "> " + message;
	  				}

	  				var node;
	  				if ( node = ( options.node || ( ractive.fragment && ractive.fragment.rendered && ractive.find( '*' ) ) ) ) {
	  					args.push( node );
	  				}
	  			}
	  		}

	  		console.warn.apply( console, [ '%cRactive.js: %c' + message, 'color: rgb(114, 157, 52);', 'color: rgb(85, 85, 85);' ].concat( args ) );
	  	};

	  	log = function () {
	  		console.log.apply( console, arguments );
	  	};
	  } else {
	  	printWarning = log = welcome = noop;
	  }

	  function format ( message, args ) {
	  	return message.replace( /%s/g, function () { return args.shift(); } );
	  }

	  function fatal ( message ) {
	  	var args = [], len = arguments.length - 1;
	  	while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	  	message = format( message, args );
	  	throw new Error( message );
	  }

	  function logIfDebug () {
	  	if ( Ractive.DEBUG ) {
	  		log.apply( null, arguments );
	  	}
	  }

	  function warn ( message ) {
	  	var args = [], len = arguments.length - 1;
	  	while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	  	message = format( message, args );
	  	printWarning( message, args );
	  }

	  function warnOnce ( message ) {
	  	var args = [], len = arguments.length - 1;
	  	while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	  	message = format( message, args );

	  	if ( alreadyWarned[ message ] ) {
	  		return;
	  	}

	  	alreadyWarned[ message ] = true;
	  	printWarning( message, args );
	  }

	  function warnIfDebug () {
	  	if ( Ractive.DEBUG ) {
	  		warn.apply( null, arguments );
	  	}
	  }

	  function warnOnceIfDebug () {
	  	if ( Ractive.DEBUG ) {
	  		warnOnce.apply( null, arguments );
	  	}
	  }

	  // Error messages that are used (or could be) in multiple places
	  var badArguments = 'Bad arguments';
	  var noRegistryFunctionReturn = 'A function was specified for "%s" %s, but no %s was returned';
	  var missingPlugin = function ( name, type ) { return ("Missing \"" + name + "\" " + type + " plugin. You may need to download a plugin via http://docs.ractivejs.org/latest/plugins#" + type + "s"); };

	  function findInViewHierarchy ( registryName, ractive, name ) {
	  	var instance = findInstance( registryName, ractive, name );
	  	return instance ? instance[ registryName ][ name ] : null;
	  }

	  function findInstance ( registryName, ractive, name ) {
	  	while ( ractive ) {
	  		if ( name in ractive[ registryName ] ) {
	  			return ractive;
	  		}

	  		if ( ractive.isolated ) {
	  			return null;
	  		}

	  		ractive = ractive.parent;
	  	}
	  }

	  function interpolate ( from, to, ractive, type ) {
	  	if ( from === to ) return null;

	  	if ( type ) {
	  		var interpol = findInViewHierarchy( 'interpolators', ractive, type );
	  		if ( interpol ) return interpol( from, to ) || null;

	  		fatal( missingPlugin( type, 'interpolator' ) );
	  	}

	  	return interpolators.number( from, to ) ||
	  	       interpolators.array( from, to ) ||
	  	       interpolators.object( from, to ) ||
	  	       null;
	  }

	  function snap ( to ) {
	  	return function () { return to; };
	  }

	  var interpolators = {
	  	number: function ( from, to ) {
	  		var delta;

	  		if ( !isNumeric( from ) || !isNumeric( to ) ) {
	  			return null;
	  		}

	  		from = +from;
	  		to = +to;

	  		delta = to - from;

	  		if ( !delta ) {
	  			return function () { return from; };
	  		}

	  		return function ( t ) {
	  			return from + ( t * delta );
	  		};
	  	},

	  	array: function ( from, to ) {
	  		var intermediate, interpolators, len, i;

	  		if ( !isArray( from ) || !isArray( to ) ) {
	  			return null;
	  		}

	  		intermediate = [];
	  		interpolators = [];

	  		i = len = Math.min( from.length, to.length );
	  		while ( i-- ) {
	  			interpolators[i] = interpolate( from[i], to[i] );
	  		}

	  		// surplus values - don't interpolate, but don't exclude them either
	  		for ( i=len; i<from.length; i+=1 ) {
	  			intermediate[i] = from[i];
	  		}

	  		for ( i=len; i<to.length; i+=1 ) {
	  			intermediate[i] = to[i];
	  		}

	  		return function ( t ) {
	  			var i = len;

	  			while ( i-- ) {
	  				intermediate[i] = interpolators[i]( t );
	  			}

	  			return intermediate;
	  		};
	  	},

	  	object: function ( from, to ) {
	  		var properties, len, interpolators, intermediate, prop;

	  		if ( !isObject( from ) || !isObject( to ) ) {
	  			return null;
	  		}

	  		properties = [];
	  		intermediate = {};
	  		interpolators = {};

	  		for ( prop in from ) {
	  			if ( hasOwn.call( from, prop ) ) {
	  				if ( hasOwn.call( to, prop ) ) {
	  					properties.push( prop );
	  					interpolators[ prop ] = interpolate( from[ prop ], to[ prop ] ) || snap( to[ prop ] );
	  				}

	  				else {
	  					intermediate[ prop ] = from[ prop ];
	  				}
	  			}
	  		}

	  		for ( prop in to ) {
	  			if ( hasOwn.call( to, prop ) && !hasOwn.call( from, prop ) ) {
	  				intermediate[ prop ] = to[ prop ];
	  			}
	  		}

	  		len = properties.length;

	  		return function ( t ) {
	  			var i = len, prop;

	  			while ( i-- ) {
	  				prop = properties[i];

	  				intermediate[ prop ] = interpolators[ prop ]( t );
	  			}

	  			return intermediate;
	  		};
	  	}
	  };

	  var refPattern = /\[\s*(\*|[0-9]|[1-9][0-9]+)\s*\]/g;
	  var splitPattern = /([^\\](?:\\\\)*)\./;
	  var escapeKeyPattern = /\\|\./g;
	  var unescapeKeyPattern = /((?:\\)+)\1|\\(\.)/g;

	  function escapeKey ( key ) {
	  	if ( typeof key === 'string' ) {
	  		return key.replace( escapeKeyPattern, '\\$&' );
	  	}

	  	return key;
	  }

	  function normalise ( ref ) {
	  	return ref ? ref.replace( refPattern, '.$1' ) : '';
	  }

	  function splitKeypathI ( keypath ) {
	  	var result = [],
	  		match;

	  	keypath = normalise( keypath );

	  	while ( match = splitPattern.exec( keypath ) ) {
	  		var index = match.index + match[1].length;
	  		result.push( keypath.substr( 0, index ) );
	  		keypath = keypath.substr( index + 1 );
	  	}

	  	result.push(keypath);

	  	return result;
	  }

	  function unescapeKey ( key ) {
	  	if ( typeof key === 'string' ) {
	  		return key.replace( unescapeKeyPattern, '$1$2' );
	  	}

	  	return key;
	  }

	  var errorMessage = 'Cannot add to a non-numeric value';

	  function add ( ractive, keypath, d ) {
	  	if ( typeof keypath !== 'string' || !isNumeric( d ) ) {
	  		throw new Error( 'Bad arguments' );
	  	}

	  	var changes;

	  	if ( /\*/.test( keypath ) ) {
	  		changes = {};

	  		ractive.viewmodel.findMatches( splitKeypathI( keypath ) ).forEach( function ( model ) {
	  			var value = model.get();

	  			if ( !isNumeric( value ) ) throw new Error( errorMessage );

	  			changes[ model.getKeypath() ] = value + d;
	  		});

	  		return ractive.set( changes );
	  	}

	  	var value = ractive.get( keypath );

	  	if ( !isNumeric( value ) ) {
	  		throw new Error( errorMessage );
	  	}

	  	return ractive.set( keypath, +value + d );
	  }

	  function Ractive$add ( keypath, d ) {
	  	return add( this, keypath, ( d === undefined ? 1 : +d ) );
	  }

	  // TODO: deprecate in future release
	  var deprecations = {
	  	construct: {
	  		deprecated: 'beforeInit',
	  		replacement: 'onconstruct'
	  	},
	  	render: {
	  		deprecated: 'init',
	  		message: 'The "init" method has been deprecated ' +
	  			'and will likely be removed in a future release. ' +
	  			'You can either use the "oninit" method which will fire ' +
	  			'only once prior to, and regardless of, any eventual ractive ' +
	  			'instance being rendered, or if you need to access the ' +
	  			'rendered DOM, use "onrender" instead. ' +
	  			'See http://docs.ractivejs.org/latest/migrating for more information.'
	  	},
	  	complete: {
	  		deprecated: 'complete',
	  		replacement: 'oncomplete'
	  	}
	  };

	  var Hook = function Hook ( event ) {
	  	this.event = event;
	  	this.method = 'on' + event;
	  	this.deprecate = deprecations[ event ];
	  };

	  Hook.prototype.call = function call ( method, ractive, arg ) {
	  	if ( ractive[ method ] ) {
	  		arg ? ractive[ method ]( arg ) : ractive[ method ]();
	  		return true;
	  	}
	  };

	  Hook.prototype.fire = function fire ( ractive, arg ) {
	  	this.call( this.method, ractive, arg );

	  	// handle deprecations
	  	if ( !ractive[ this.method ] && this.deprecate && this.call( this.deprecate.deprecated, ractive, arg ) ) {
	  		if ( this.deprecate.message ) {
	  			warnIfDebug( this.deprecate.message );
	  		} else {
	  			warnIfDebug( 'The method "%s" has been deprecated in favor of "%s" and will likely be removed in a future release. See http://docs.ractivejs.org/latest/migrating for more information.', this.deprecate.deprecated, this.deprecate.replacement );
	  		}
	  	}

	  	// TODO should probably use internal method, in case ractive.fire was overwritten
	  	arg ? ractive.fire( this.event, arg ) : ractive.fire( this.event );
	  };

	  function addToArray ( array, value ) {
	  	var index = array.indexOf( value );

	  	if ( index === -1 ) {
	  		array.push( value );
	  	}
	  }

	  function arrayContains ( array, value ) {
	  	for ( var i = 0, c = array.length; i < c; i++ ) {
	  		if ( array[i] == value ) {
	  			return true;
	  		}
	  	}

	  	return false;
	  }

	  function arrayContentsMatch ( a, b ) {
	  	var i;

	  	if ( !isArray( a ) || !isArray( b ) ) {
	  		return false;
	  	}

	  	if ( a.length !== b.length ) {
	  		return false;
	  	}

	  	i = a.length;
	  	while ( i-- ) {
	  		if ( a[i] !== b[i] ) {
	  			return false;
	  		}
	  	}

	  	return true;
	  }

	  function ensureArray ( x ) {
	  	if ( typeof x === 'string' ) {
	  		return [ x ];
	  	}

	  	if ( x === undefined ) {
	  		return [];
	  	}

	  	return x;
	  }

	  function lastItem ( array ) {
	  	return array[ array.length - 1 ];
	  }

	  function removeFromArray ( array, member ) {
	  	if ( !array ) {
	  		return;
	  	}

	  	var index = array.indexOf( member );

	  	if ( index !== -1 ) {
	  		array.splice( index, 1 );
	  	}
	  }

	  function toArray ( arrayLike ) {
	  	var array = [], i = arrayLike.length;
	  	while ( i-- ) {
	  		array[i] = arrayLike[i];
	  	}

	  	return array;
	  }

	  var _Promise;
	  var PENDING = {};
	  var FULFILLED = {};
	  var REJECTED = {};
	  if ( typeof Promise === 'function' ) {
	  	// use native Promise
	  	_Promise = Promise;
	  } else {
	  	_Promise = function ( callback ) {
	  		var fulfilledHandlers = [],
	  			rejectedHandlers = [],
	  			state = PENDING,

	  			result,
	  			dispatchHandlers,
	  			makeResolver,
	  			fulfil,
	  			reject,

	  			promise;

	  		makeResolver = function ( newState ) {
	  			return function ( value ) {
	  				if ( state !== PENDING ) {
	  					return;
	  				}

	  				result = value;
	  				state = newState;

	  				dispatchHandlers = makeDispatcher( ( state === FULFILLED ? fulfilledHandlers : rejectedHandlers ), result );

	  				// dispatch onFulfilled and onRejected handlers asynchronously
	  				wait( dispatchHandlers );
	  			};
	  		};

	  		fulfil = makeResolver( FULFILLED );
	  		reject = makeResolver( REJECTED );

	  		try {
	  			callback( fulfil, reject );
	  		} catch ( err ) {
	  			reject( err );
	  		}

	  		promise = {
	  			// `then()` returns a Promise - 2.2.7
	  			then: function ( onFulfilled, onRejected ) {
	  				var promise2 = new _Promise( function ( fulfil, reject ) {

	  					var processResolutionHandler = function ( handler, handlers, forward ) {

	  						// 2.2.1.1
	  						if ( typeof handler === 'function' ) {
	  							handlers.push( function ( p1result ) {
	  								var x;

	  								try {
	  									x = handler( p1result );
	  									resolve( promise2, x, fulfil, reject );
	  								} catch ( err ) {
	  									reject( err );
	  								}
	  							});
	  						} else {
	  							// Forward the result of promise1 to promise2, if resolution handlers
	  							// are not given
	  							handlers.push( forward );
	  						}
	  					};

	  					// 2.2
	  					processResolutionHandler( onFulfilled, fulfilledHandlers, fulfil );
	  					processResolutionHandler( onRejected, rejectedHandlers, reject );

	  					if ( state !== PENDING ) {
	  						// If the promise has resolved already, dispatch the appropriate handlers asynchronously
	  						wait( dispatchHandlers );
	  					}

	  				});

	  				return promise2;
	  			}
	  		};

	  		promise[ 'catch' ] = function ( onRejected ) {
	  			return this.then( null, onRejected );
	  		};

	  		return promise;
	  	};

	  	_Promise.all = function ( promises ) {
	  		return new _Promise( function ( fulfil, reject ) {
	  			var result = [], pending, i, processPromise;

	  			if ( !promises.length ) {
	  				fulfil( result );
	  				return;
	  			}

	  			processPromise = function ( promise, i ) {
	  				if ( promise && typeof promise.then === 'function' ) {
	  					promise.then( function ( value ) {
	  						result[i] = value;
	  						--pending || fulfil( result );
	  					}, reject );
	  				}

	  				else {
	  					result[i] = promise;
	  					--pending || fulfil( result );
	  				}
	  			};

	  			pending = i = promises.length;
	  			while ( i-- ) {
	  				processPromise( promises[i], i );
	  			}
	  		});
	  	};

	  	_Promise.resolve = function ( value ) {
	  		return new _Promise( function ( fulfil ) {
	  			fulfil( value );
	  		});
	  	};

	  	_Promise.reject = function ( reason ) {
	  		return new _Promise( function ( fulfil, reject ) {
	  			reject( reason );
	  		});
	  	};
	  }

	  var Promise$1 = _Promise;

	  // TODO use MutationObservers or something to simulate setImmediate
	  function wait ( callback ) {
	  	setTimeout( callback, 0 );
	  }

	  function makeDispatcher ( handlers, result ) {
	  	return function () {
	  		var handler;

	  		while ( handler = handlers.shift() ) {
	  			handler( result );
	  		}
	  	};
	  }

	  function resolve ( promise, x, fulfil, reject ) {
	  	// Promise Resolution Procedure
	  	var then;

	  	// 2.3.1
	  	if ( x === promise ) {
	  		throw new TypeError( 'A promise\'s fulfillment handler cannot return the same promise' );
	  	}

	  	// 2.3.2
	  	if ( x instanceof _Promise ) {
	  		x.then( fulfil, reject );
	  	}

	  	// 2.3.3
	  	else if ( x && ( typeof x === 'object' || typeof x === 'function' ) ) {
	  		try {
	  			then = x.then; // 2.3.3.1
	  		} catch ( e ) {
	  			reject( e ); // 2.3.3.2
	  			return;
	  		}

	  		// 2.3.3.3
	  		if ( typeof then === 'function' ) {
	  			var called, resolvePromise, rejectPromise;

	  			resolvePromise = function ( y ) {
	  				if ( called ) {
	  					return;
	  				}
	  				called = true;
	  				resolve( promise, y, fulfil, reject );
	  			};

	  			rejectPromise = function ( r ) {
	  				if ( called ) {
	  					return;
	  				}
	  				called = true;
	  				reject( r );
	  			};

	  			try {
	  				then.call( x, resolvePromise, rejectPromise );
	  			} catch ( e ) {
	  				if ( !called ) { // 2.3.3.3.4.1
	  					reject( e ); // 2.3.3.3.4.2
	  					called = true;
	  					return;
	  				}
	  			}
	  		}

	  		else {
	  			fulfil( x );
	  		}
	  	}

	  	else {
	  		fulfil( x );
	  	}
	  }

	  var TransitionManager = function TransitionManager ( callback, parent ) {
	  	this.callback = callback;
	  	this.parent = parent;

	  	this.intros = [];
	  	this.outros = [];

	  	this.children = [];
	  	this.totalChildren = this.outroChildren = 0;

	  	this.detachQueue = [];
	  	this.outrosComplete = false;

	  	if ( parent ) {
	  		parent.addChild( this );
	  	}
	  };

	  TransitionManager.prototype.add = function add ( transition ) {
	  	var list = transition.isIntro ? this.intros : this.outros;
	  	list.push( transition );
	  };

	  TransitionManager.prototype.addChild = function addChild ( child ) {
	  	this.children.push( child );

	  	this.totalChildren += 1;
	  	this.outroChildren += 1;
	  };

	  TransitionManager.prototype.decrementOutros = function decrementOutros () {
	  	this.outroChildren -= 1;
	  	check( this );
	  };

	  TransitionManager.prototype.decrementTotal = function decrementTotal () {
	  	this.totalChildren -= 1;
	  	check( this );
	  };

	  TransitionManager.prototype.detachNodes = function detachNodes () {
	  	this.detachQueue.forEach( detach );
	  	this.children.forEach( _detachNodes );
	  };

	  TransitionManager.prototype.remove = function remove ( transition ) {
	  	var list = transition.isIntro ? this.intros : this.outros;
	  	removeFromArray( list, transition );
	  	check( this );
	  };

	  TransitionManager.prototype.start = function start () {
	  	detachImmediate( this );
	  	this.intros.concat( this.outros ).forEach( function ( t ) { return t.start(); } );
	  	this.ready = true;
	  	check( this );
	  };

	  function detach ( element ) {
	  	element.detach();
	  }

	  function _detachNodes ( tm ) { // _ to avoid transpiler quirk
	  	tm.detachNodes();
	  }

	  function check ( tm ) {
	  	if ( !tm.ready || tm.outros.length || tm.outroChildren ) return;

	  	// If all outros are complete, and we haven't already done this,
	  	// we notify the parent if there is one, otherwise
	  	// start detaching nodes
	  	if ( !tm.outrosComplete ) {
	  		if ( tm.parent && !tm.parent.outrosComplete ) {
	  			tm.parent.decrementOutros( tm );
	  		} else {
	  			tm.detachNodes();
	  		}

	  		tm.outrosComplete = true;
	  	}

	  	// Once everything is done, we can notify parent transition
	  	// manager and call the callback
	  	if ( !tm.intros.length && !tm.totalChildren ) {
	  		if ( typeof tm.callback === 'function' ) {
	  			tm.callback();
	  		}

	  		if ( tm.parent ) {
	  			tm.parent.decrementTotal();
	  		}
	  	}
	  }

	  // check through the detach queue to see if a node is up or downstream from a
	  // transition and if not, go ahead and detach it
	  function detachImmediate ( manager ) {
	  	var queue = manager.detachQueue;
	  	var outros = collectAllOutros( manager );

	  	var i = queue.length, j = 0, node, trans;
	  	start: while ( i-- ) {
	  		node = queue[i].node;
	  		j = outros.length;
	  		while ( j-- ) {
	  			trans = outros[j].node;
	  			// check to see if the node is, contains, or is contained by the transitioning node
	  			if ( trans === node || trans.contains( node ) || node.contains( trans ) ) continue start;
	  		}

	  		// no match, we can drop it
	  		queue[i].detach();
	  		queue.splice( i, 1 );
	  	}
	  }

	  function collectAllOutros ( manager, list ) {
	  	if ( !list ) {
	  		list = [];
	  		var parent = manager;
	  		while ( parent.parent ) parent = parent.parent;
	  		return collectAllOutros( parent, list );
	  	} else {
	  		var i = manager.children.length;
	  		while ( i-- ) {
	  			list = collectAllOutros( manager.children[i], list );
	  		}
	  		list = list.concat( manager.outros );
	  		return list;
	  	}
	  }

	  var changeHook = new Hook( 'change' );

	  var batch;

	  var runloop = {
	  	start: function ( instance, returnPromise ) {
	  		var promise, fulfilPromise;

	  		if ( returnPromise ) {
	  			promise = new Promise$1( function ( f ) { return ( fulfilPromise = f ); } );
	  		}

	  		batch = {
	  			previousBatch: batch,
	  			transitionManager: new TransitionManager( fulfilPromise, batch && batch.transitionManager ),
	  			fragments: [],
	  			tasks: [],
	  			immediateObservers: [],
	  			deferredObservers: [],
	  			ractives: [],
	  			instance: instance
	  		};

	  		return promise;
	  	},

	  	end: function () {
	  		flushChanges();
	  		batch = batch.previousBatch;
	  	},

	  	addFragment: function ( fragment ) {
	  		addToArray( batch.fragments, fragment );
	  	},

	  	addInstance: function ( instance ) {
	  		if ( batch ) addToArray( batch.ractives, instance );
	  	},

	  	addObserver: function ( observer, defer ) {
	  		addToArray( defer ? batch.deferredObservers : batch.immediateObservers, observer );
	  	},

	  	registerTransition: function ( transition ) {
	  		transition._manager = batch.transitionManager;
	  		batch.transitionManager.add( transition );
	  	},

	  	// synchronise node detachments with transition ends
	  	detachWhenReady: function ( thing ) {
	  		batch.transitionManager.detachQueue.push( thing );
	  	},

	  	scheduleTask: function ( task, postRender ) {
	  		var _batch;

	  		if ( !batch ) {
	  			task();
	  		} else {
	  			_batch = batch;
	  			while ( postRender && _batch.previousBatch ) {
	  				// this can't happen until the DOM has been fully updated
	  				// otherwise in some situations (with components inside elements)
	  				// transitions and decorators will initialise prematurely
	  				_batch = _batch.previousBatch;
	  			}

	  			_batch.tasks.push( task );
	  		}
	  	}
	  };

	  function dispatch ( observer ) {
	  	observer.dispatch();
	  }

	  function flushChanges () {
	  	var which = batch.immediateObservers;
	  	batch.immediateObservers = [];
	  	which.forEach( dispatch );

	  	// Now that changes have been fully propagated, we can update the DOM
	  	// and complete other tasks
	  	var i = batch.fragments.length;
	  	var fragment;

	  	which = batch.fragments;
	  	batch.fragments = [];
	  	var ractives = batch.ractives;
	  	batch.ractives = [];

	  	while ( i-- ) {
	  		fragment = which[i];

	  		// TODO deprecate this. It's annoying and serves no useful function
	  		var ractive = fragment.ractive;
	  		changeHook.fire( ractive, ractive.viewmodel.changes );
	  		ractive.viewmodel.changes = {};
	  		removeFromArray( ractives, ractive );

	  		fragment.update();
	  	}

	  	i = ractives.length;
	  	while ( i-- ) {
	  		var ractive$1 = ractives[i];
	  		changeHook.fire( ractive$1, ractive$1.viewmodel.changes );
	  		ractive$1.viewmodel.changes = {};
	  	}

	  	batch.transitionManager.start();

	  	which = batch.deferredObservers;
	  	batch.deferredObservers = [];
	  	which.forEach( dispatch );

	  	var tasks = batch.tasks;
	  	batch.tasks = [];

	  	for ( i = 0; i < tasks.length; i += 1 ) {
	  		tasks[i]();
	  	}

	  	// If updating the view caused some model blowback - e.g. a triple
	  	// containing <option> elements caused the binding on the <select>
	  	// to update - then we start over
	  	if ( batch.fragments.length || batch.immediateObservers.length || batch.deferredObservers.length || batch.ractives.length ) return flushChanges();
	  }

	  var noAnimation = Promise$1.resolve();
	  defineProperty( noAnimation, 'stop', { value: noop });

	  var linear = easing.linear;

	  function getOptions ( options, instance ) {
	  	options = options || {};

	  	var easing;
	  	if ( options.easing ) {
	  		easing = typeof options.easing === 'function' ?
	  			options.easing :
	  			instance.easing[ options.easing ];
	  	}

	  	return {
	  		easing: easing || linear,
	  		duration: 'duration' in options ? options.duration : 400,
	  		complete: options.complete || noop,
	  		step: options.step || noop
	  	};
	  }

	  function Ractive$animate ( keypath, to, options ) {
	  	if ( typeof keypath === 'object' ) {
	  		var keys = Object.keys( keypath );

	  		throw new Error( ("ractive.animate(...) no longer supports objects. Instead of ractive.animate({\n  " + (keys.map( function ( key ) { return ("'" + key + "': " + (keypath[ key ])); } ).join( '\n  ' )) + "\n}, {...}), do\n\n" + (keys.map( function ( key ) { return ("ractive.animate('" + key + "', " + (keypath[ key ]) + ", {...});"); } ).join( '\n' )) + "\n") );
	  	}

	  	options = getOptions( options, this );

	  	var model = this.viewmodel.joinAll( splitKeypathI( keypath ) );
	  	var from = model.get();

	  	// don't bother animating values that stay the same
	  	if ( isEqual( from, to ) ) {
	  		options.complete( options.to );
	  		return noAnimation; // TODO should this have .then and .catch methods?
	  	}

	  	var interpolator = interpolate( from, to, this, options.interpolator );

	  	// if we can't interpolate the value, set it immediately
	  	if ( !interpolator ) {
	  		runloop.start();
	  		model.set( to );
	  		runloop.end();

	  		return noAnimation;
	  	}

	  	return model.animate( from, to, options, interpolator );
	  }

	  var detachHook = new Hook( 'detach' );

	  function Ractive$detach () {
	  	if ( this.isDetached ) {
	  		return this.el;
	  	}

	  	if ( this.el ) {
	  		removeFromArray( this.el.__ractive_instances__, this );
	  	}

	  	this.el = this.fragment.detach();
	  	this.isDetached = true;

	  	detachHook.fire( this );
	  	return this.el;
	  }

	  function Ractive$find ( selector ) {
	  	if ( !this.el ) throw new Error( ("Cannot call ractive.find('" + selector + "') unless instance is rendered to the DOM") );

	  	return this.fragment.find( selector );
	  }

	  function sortByDocumentPosition ( node, otherNode ) {
	  	if ( node.compareDocumentPosition ) {
	  		var bitmask = node.compareDocumentPosition( otherNode );
	  		return ( bitmask & 2 ) ? 1 : -1;
	  	}

	  	// In old IE, we can piggy back on the mechanism for
	  	// comparing component positions
	  	return sortByItemPosition( node, otherNode );
	  }

	  function sortByItemPosition ( a, b ) {
	  	var ancestryA = getAncestry( a.component || a._ractive.proxy );
	  	var ancestryB = getAncestry( b.component || b._ractive.proxy );

	  	var oldestA = lastItem( ancestryA );
	  	var oldestB = lastItem( ancestryB );
	  	var mutualAncestor;

	  	// remove items from the end of both ancestries as long as they are identical
	  	// - the final one removed is the closest mutual ancestor
	  	while ( oldestA && ( oldestA === oldestB ) ) {
	  		ancestryA.pop();
	  		ancestryB.pop();

	  		mutualAncestor = oldestA;

	  		oldestA = lastItem( ancestryA );
	  		oldestB = lastItem( ancestryB );
	  	}

	  	// now that we have the mutual ancestor, we can find which is earliest
	  	oldestA = oldestA.component || oldestA;
	  	oldestB = oldestB.component || oldestB;

	  	var fragmentA = oldestA.parentFragment;
	  	var fragmentB = oldestB.parentFragment;

	  	// if both items share a parent fragment, our job is easy
	  	if ( fragmentA === fragmentB ) {
	  		var indexA = fragmentA.items.indexOf( oldestA );
	  		var indexB = fragmentB.items.indexOf( oldestB );

	  		// if it's the same index, it means one contains the other,
	  		// so we see which has the longest ancestry
	  		return ( indexA - indexB ) || ancestryA.length - ancestryB.length;
	  	}

	  	// if mutual ancestor is a section, we first test to see which section
	  	// fragment comes first
	  	var fragments = mutualAncestor.iterations;
	  	if ( fragments ) {
	  		var indexA$1 = fragments.indexOf( fragmentA );
	  		var indexB$1 = fragments.indexOf( fragmentB );

	  		return ( indexA$1 - indexB$1 ) || ancestryA.length - ancestryB.length;
	  	}

	  	throw new Error( 'An unexpected condition was met while comparing the position of two components. Please file an issue at https://github.com/ractivejs/ractive/issues - thanks!' );
	  }

	  function getParent ( item ) {
	  	var parentFragment = item.parentFragment;

	  	if ( parentFragment ) return parentFragment.owner;

	  	if ( item.component && ( parentFragment = item.component.parentFragment ) ) {
	  		return parentFragment.owner;
	  	}
	  }

	  function getAncestry ( item ) {
	  	var ancestry = [ item ];
	  	var ancestor = getParent( item );

	  	while ( ancestor ) {
	  		ancestry.push( ancestor );
	  		ancestor = getParent( ancestor );
	  	}

	  	return ancestry;
	  }


	  var Query = function Query ( ractive, selector, live, isComponentQuery ) {
	  	this.ractive = ractive;
	  	this.selector = selector;
	  	this.live = live;
	  	this.isComponentQuery = isComponentQuery;

	  	this.result = [];

	  	this.dirty = true;
	  };

	  Query.prototype.add = function add ( item ) {
	  	this.result.push( item );
	  	this.makeDirty();
	  };

	  Query.prototype.cancel = function cancel () {
	  	var liveQueries = this._root[ this.isComponentQuery ? 'liveComponentQueries' : 'liveQueries' ];
	  	var selector = this.selector;

	  	var index = liveQueries.indexOf( selector );

	  	if ( index !== -1 ) {
	  		liveQueries.splice( index, 1 );
	  		liveQueries[ selector ] = null;
	  	}
	  };

	  Query.prototype.init = function init () {
	  	this.dirty = false;
	  };

	  Query.prototype.makeDirty = function makeDirty () {
	  	var this$1 = this;

	  		if ( !this.dirty ) {
	  		this.dirty = true;

	  		// Once the DOM has been updated, ensure the query
	  		// is correctly ordered
	  		runloop.scheduleTask( function () { return this$1.update(); } );
	  	}
	  };

	  Query.prototype.remove = function remove ( nodeOrComponent ) {
	  	var index = this.result.indexOf( this.isComponentQuery ? nodeOrComponent.instance : nodeOrComponent );
	  	if ( index !== -1 ) this.result.splice( index, 1 );
	  };

	  Query.prototype.update = function update () {
	  	this.result.sort( this.isComponentQuery ? sortByItemPosition : sortByDocumentPosition );
	  	this.dirty = false;
	  };

	  Query.prototype.test = function test ( item ) {
	  	return this.isComponentQuery ?
	  		( !this.selector || item.name === this.selector ) :
	  		( item ? matches( item, this.selector ) : null );
	  };

	  function Ractive$findAll ( selector, options ) {
	  	if ( !this.el ) throw new Error( ("Cannot call ractive.findAll('" + selector + "', ...) unless instance is rendered to the DOM") );

	  	options = options || {};
	  	var liveQueries = this._liveQueries;

	  	// Shortcut: if we're maintaining a live query with this
	  	// selector, we don't need to traverse the parallel DOM
	  	var query = liveQueries[ selector ];
	  	if ( query ) {
	  		// Either return the exact same query, or (if not live) a snapshot
	  		return ( options && options.live ) ? query : query.slice();
	  	}

	  	query = new Query( this, selector, !!options.live, false );

	  	// Add this to the list of live queries Ractive needs to maintain,
	  	// if applicable
	  	if ( query.live ) {
	  		liveQueries.push( selector );
	  		liveQueries[ '_' + selector ] = query;
	  	}

	  	this.fragment.findAll( selector, query );

	  	query.init();
	  	return query.result;
	  }

	  function Ractive$findAllComponents ( selector, options ) {
	  	options = options || {};
	  	var liveQueries = this._liveComponentQueries;

	  	// Shortcut: if we're maintaining a live query with this
	  	// selector, we don't need to traverse the parallel DOM
	  	var query = liveQueries[ selector ];
	  	if ( query ) {
	  		// Either return the exact same query, or (if not live) a snapshot
	  		return ( options && options.live ) ? query : query.slice();
	  	}

	  	query = new Query( this, selector, !!options.live, true );

	  	// Add this to the list of live queries Ractive needs to maintain,
	  	// if applicable
	  	if ( query.live ) {
	  		liveQueries.push( selector );
	  		liveQueries[ '_' + selector ] = query;
	  	}

	  	this.fragment.findAllComponents( selector, query );

	  	query.init();
	  	return query.result;
	  }

	  function Ractive$findComponent ( selector ) {
	  	return this.fragment.findComponent( selector );
	  }

	  function Ractive$findContainer ( selector ) {
	  	if ( this.container ) {
	  		if ( this.container.component && this.container.component.name === selector ) {
	  			return this.container;
	  		} else {
	  			return this.container.findContainer( selector );
	  		}
	  	}

	  	return null;
	  }

	  function Ractive$findParent ( selector ) {

	  	if ( this.parent ) {
	  		if ( this.parent.component && this.parent.component.name === selector ) {
	  			return this.parent;
	  		} else {
	  			return this.parent.findParent ( selector );
	  		}
	  	}

	  	return null;
	  }

	  function enqueue ( ractive, event ) {
	  	if ( ractive.event ) {
	  		ractive._eventQueue.push( ractive.event );
	  	}

	  	ractive.event = event;
	  }

	  function dequeue ( ractive ) {
	  	if ( ractive._eventQueue.length ) {
	  		ractive.event = ractive._eventQueue.pop();
	  	} else {
	  		ractive.event = null;
	  	}
	  }

	  var starMaps = {};

	  // This function takes a keypath such as 'foo.bar.baz', and returns
	  // all the variants of that keypath that include a wildcard in place
	  // of a key, such as 'foo.bar.*', 'foo.*.baz', 'foo.*.*' and so on.
	  // These are then checked against the dependants map (ractive.viewmodel.depsMap)
	  // to see if any pattern observers are downstream of one or more of
	  // these wildcard keypaths (e.g. 'foo.bar.*.status')
	  function getPotentialWildcardMatches ( keypath ) {
	  	var keys, starMap, mapper, i, result, wildcardKeypath;

	  	keys = splitKeypathI( keypath );
	  	if( !( starMap = starMaps[ keys.length ]) ) {
	  		starMap = getStarMap( keys.length );
	  	}

	  	result = [];

	  	mapper = function ( star, i ) {
	  		return star ? '*' : keys[i];
	  	};

	  	i = starMap.length;
	  	while ( i-- ) {
	  		wildcardKeypath = starMap[i].map( mapper ).join( '.' );

	  		if ( !result.hasOwnProperty( wildcardKeypath ) ) {
	  			result.push( wildcardKeypath );
	  			result[ wildcardKeypath ] = true;
	  		}
	  	}

	  	return result;
	  }

	  // This function returns all the possible true/false combinations for
	  // a given number - e.g. for two, the possible combinations are
	  // [ true, true ], [ true, false ], [ false, true ], [ false, false ].
	  // It does so by getting all the binary values between 0 and e.g. 11
	  function getStarMap ( num ) {
	  	var ones = '', max, binary, starMap, mapper, i, j, l, map;

	  	if ( !starMaps[ num ] ) {
	  		starMap = [];

	  		while ( ones.length < num ) {
	  			ones += 1;
	  		}

	  		max = parseInt( ones, 2 );

	  		mapper = function ( digit ) {
	  			return digit === '1';
	  		};

	  		for ( i = 0; i <= max; i += 1 ) {
	  			binary = i.toString( 2 );
	  			while ( binary.length < num ) {
	  				binary = '0' + binary;
	  			}

	  			map = [];
	  			l = binary.length;
	  			for (j = 0; j < l; j++) {
	  				map.push( mapper( binary[j] ) );
	  			}
	  			starMap[i] = map;
	  		}

	  		starMaps[ num ] = starMap;
	  	}

	  	return starMaps[ num ];
	  }

	  var wildcardCache = {};

	  function fireEvent ( ractive, eventName, options ) {
	  	if ( options === void 0 ) options = {};

	  	if ( !eventName ) { return; }

	  	if ( !options.event ) {
	  		options.event = {
	  			name: eventName,
	  			// until event not included as argument default
	  			_noArg: true
	  		};
	  	} else {
	  		options.event.name = eventName;
	  	}

	  	var eventNames = getWildcardNames( eventName );

	  	fireEventAs( ractive, eventNames, options.event, options.args, true );
	  }

	  function getWildcardNames ( eventName ) {
	  	if ( wildcardCache.hasOwnProperty( eventName ) ) {
	  		return wildcardCache[ eventName ];
	  	} else {
	  		return wildcardCache[ eventName ] = getPotentialWildcardMatches( eventName );
	  	}
	  }

	  function fireEventAs  ( ractive, eventNames, event, args, initialFire ) {

	  	if ( initialFire === void 0 ) initialFire = false;

	  	var subscribers, i, bubble = true;

	  	enqueue( ractive, event );

	  	for ( i = eventNames.length; i >= 0; i-- ) {
	  		subscribers = ractive._subs[ eventNames[ i ] ];

	  		if ( subscribers ) {
	  			bubble = notifySubscribers( ractive, subscribers, event, args ) && bubble;
	  		}
	  	}

	  	dequeue( ractive );

	  	if ( ractive.parent && bubble ) {

	  		if ( initialFire && ractive.component ) {
	  			var fullName = ractive.component.name + '.' + eventNames[ eventNames.length-1 ];
	  			eventNames = getWildcardNames( fullName );

	  			if( event && !event.component ) {
	  				event.component = ractive;
	  			}
	  		}

	  		fireEventAs( ractive.parent, eventNames, event, args );
	  	}
	  }

	  function notifySubscribers ( ractive, subscribers, event, args ) {
	  	var originalEvent = null, stopEvent = false;

	  	if ( event && !event._noArg ) {
	  		args = [ event ].concat( args );
	  	}

	  	// subscribers can be modified inflight, e.g. "once" functionality
	  	// so we need to copy to make sure everyone gets called
	  	subscribers = subscribers.slice();

	  	for ( var i = 0, len = subscribers.length; i < len; i += 1 ) {
	  		if ( subscribers[ i ].apply( ractive, args ) === false ) {
	  			stopEvent = true;
	  		}
	  	}

	  	if ( event && !event._noArg && stopEvent && ( originalEvent = event.original ) ) {
	  		originalEvent.preventDefault && originalEvent.preventDefault();
	  		originalEvent.stopPropagation && originalEvent.stopPropagation();
	  	}

	  	return !stopEvent;
	  }

	  function Ractive$fire ( eventName ) {
	  	var args = [], len = arguments.length - 1;
	  	while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	  	fireEvent( this, eventName, { args: args });
	  }

	  function badReference ( key ) {
	  	throw new Error( ("An index or key reference (" + key + ") cannot have child properties") );
	  }

	  function resolveAmbiguousReference ( fragment, ref ) {
	  	var localViewmodel = fragment.findContext().root;
	  	var keys = splitKeypathI( ref );
	  	var key = keys[0];

	  	var hasContextChain;
	  	var crossedComponentBoundary;
	  	var aliases;

	  	while ( fragment ) {
	  		// repeated fragments
	  		if ( fragment.isIteration ) {
	  			if ( key === fragment.parent.keyRef ) {
	  				if ( keys.length > 1 ) badReference( key );
	  				return fragment.context.getKeyModel();
	  			}

	  			if ( key === fragment.parent.indexRef ) {
	  				if ( keys.length > 1 ) badReference( key );
	  				return fragment.context.getIndexModel( fragment.index );
	  			}
	  		}

	  		// alias node or iteration
	  		if ( ( ( aliases = fragment.owner.aliases ) || ( aliases = fragment.aliases ) ) && aliases.hasOwnProperty( key ) ) {
	  			var model = aliases[ key ];

	  			if ( keys.length === 1 ) return model;
	  			else if ( typeof model.joinAll === 'function' ) {
	  				return model.joinAll( keys.slice( 1 ) );
	  			}
	  		}

	  		if ( fragment.context ) {
	  			// TODO better encapsulate the component check
	  			if ( !fragment.isRoot || fragment.ractive.component ) hasContextChain = true;

	  			if ( fragment.context.has( key ) ) {
	  				if ( crossedComponentBoundary ) {
	  					localViewmodel.map( key, fragment.context.joinKey( key ) );
	  				}

	  				return fragment.context.joinAll( keys );
	  			}
	  		}

	  		if ( fragment.componentParent && !fragment.ractive.isolated ) {
	  			// ascend through component boundary
	  			fragment = fragment.componentParent;
	  			crossedComponentBoundary = true;
	  		} else {
	  			fragment = fragment.parent;
	  		}
	  	}

	  	if ( !hasContextChain ) {
	  		return localViewmodel.joinAll( keys );
	  	}
	  }

	  var stack = [];
	  var captureGroup;

	  function startCapturing () {
	  	stack.push( captureGroup = [] );
	  }

	  function stopCapturing () {
	  	var dependencies = stack.pop();
	  	captureGroup = stack[ stack.length - 1 ];
	  	return dependencies;
	  }

	  function capture ( model ) {
	  	if ( captureGroup ) {
	  		captureGroup.push( model );
	  	}
	  }

	  function bind               ( x ) { x.bind(); }
	  function cancel             ( x ) { x.cancel(); }
	  function handleChange       ( x ) { x.handleChange(); }
	  function mark               ( x ) { x.mark(); }
	  function render             ( x ) { x.render(); }
	  function rebind             ( x ) { x.rebind(); }
	  function teardown           ( x ) { x.teardown(); }
	  function unbind             ( x ) { x.unbind(); }
	  function unrender           ( x ) { x.unrender(); }
	  function unrenderAndDestroy ( x ) { x.unrender( true ); }
	  function update             ( x ) { x.update(); }
	  function toString$1           ( x ) { return x.toString(); }
	  function toEscapedString    ( x ) { return x.toString( true ); }

	  var requestAnimationFrame;

	  // If window doesn't exist, we don't need requestAnimationFrame
	  if ( !win ) {
	  	requestAnimationFrame = null;
	  } else {
	  	// https://gist.github.com/paulirish/1579671
	  	(function(vendors, lastTime, win) {

	  		var x, setTimeout;

	  		if ( win.requestAnimationFrame ) {
	  			return;
	  		}

	  		for ( x = 0; x < vendors.length && !win.requestAnimationFrame; ++x ) {
	  			win.requestAnimationFrame = win[vendors[x]+'RequestAnimationFrame'];
	  		}

	  		if ( !win.requestAnimationFrame ) {
	  			setTimeout = win.setTimeout;

	  			win.requestAnimationFrame = function(callback) {
	  				var currTime, timeToCall, id;

	  				currTime = Date.now();
	  				timeToCall = Math.max( 0, 16 - (currTime - lastTime ) );
	  				id = setTimeout( function() { callback(currTime + timeToCall); }, timeToCall );

	  				lastTime = currTime + timeToCall;
	  				return id;
	  			};
	  		}

	  	}( vendors, 0, win ));

	  	requestAnimationFrame = win.requestAnimationFrame;
	  }

	  var rAF = requestAnimationFrame;

	  var getTime = ( win && win.performance && typeof win.performance.now === 'function' ) ?
	  	function () { return win.performance.now(); } :
	  	function () { return Date.now(); };

	  // TODO what happens if a transition is aborted?

	  var tickers = [];
	  var running = false;

	  function tick () {
	  	runloop.start();

	  	var now = getTime();

	  	var i;
	  	var ticker;

	  	for ( i = 0; i < tickers.length; i += 1 ) {
	  		ticker = tickers[i];

	  		if ( !ticker.tick( now ) ) {
	  			// ticker is complete, remove it from the stack, and decrement i so we don't miss one
	  			tickers.splice( i--, 1 );
	  		}
	  	}

	  	runloop.end();

	  	if ( tickers.length ) {
	  		rAF( tick );
	  	} else {
	  		running = false;
	  	}
	  }

	  var Ticker = function Ticker ( options ) {
	  	this.duration = options.duration;
	  	this.step = options.step;
	  	this.complete = options.complete;
	  	this.easing = options.easing;

	  	this.start = getTime();
	  	this.end = this.start + this.duration;

	  	this.running = true;

	  	tickers.push( this );
	  	if ( !running ) rAF( tick );
	  };

	  Ticker.prototype.tick = function tick$1 ( now ) {
	  	if ( !this.running ) return false;

	  	if ( now > this.end ) {
	  		if ( this.step ) this.step( 1 );
	  		if ( this.complete ) this.complete( 1 );

	  		return false;
	  	}

	  	var elapsed = now - this.start;
	  	var eased = this.easing( elapsed / this.duration );

	  	if ( this.step ) this.step( eased );

	  	return true;
	  };

	  Ticker.prototype.stop = function stop () {
	  	if ( this.abort ) this.abort();
	  	this.running = false;
	  };

	  var prefixers = {};

	  // TODO this is legacy. sooner we can replace the old adaptor API the better
	  function prefixKeypath ( obj, prefix ) {
	  	var prefixed = {}, key;

	  	if ( !prefix ) {
	  		return obj;
	  	}

	  	prefix += '.';

	  	for ( key in obj ) {
	  		if ( obj.hasOwnProperty( key ) ) {
	  			prefixed[ prefix + key ] = obj[ key ];
	  		}
	  	}

	  	return prefixed;
	  }

	  function getPrefixer ( rootKeypath ) {
	  	var rootDot;

	  	if ( !prefixers[ rootKeypath ] ) {
	  		rootDot = rootKeypath ? rootKeypath + '.' : '';

	  		prefixers[ rootKeypath ] = function ( relativeKeypath, value ) {
	  			var obj;

	  			if ( typeof relativeKeypath === 'string' ) {
	  				obj = {};
	  				obj[ rootDot + relativeKeypath ] = value;
	  				return obj;
	  			}

	  			if ( typeof relativeKeypath === 'object' ) {
	  				// 'relativeKeypath' is in fact a hash, not a keypath
	  				return rootDot ? prefixKeypath( relativeKeypath, rootKeypath ) : relativeKeypath;
	  			}
	  		};
	  	}

	  	return prefixers[ rootKeypath ];
	  }

	  var KeyModel = function KeyModel ( key ) {
	  	this.value = key;
	  	this.isReadonly = true;
	  	this.dependants = [];
	  };

	  KeyModel.prototype.get = function get () {
	  	return unescapeKey( this.value );
	  };

	  KeyModel.prototype.getKeypath = function getKeypath () {
	  	return unescapeKey( this.value );
	  };

	  KeyModel.prototype.rebind = function rebind ( key ) {
	  	this.value = key;
	  	this.dependants.forEach( handleChange );
	  };

	  KeyModel.prototype.register = function register ( dependant ) {
	  	this.dependants.push( dependant );
	  };

	  KeyModel.prototype.unregister = function unregister ( dependant ) {
	  	removeFromArray( this.dependants, dependant );
	  };

	  var KeypathModel = function KeypathModel ( parent, ractive ) {
	  	this.parent = parent;
	  	this.ractive = ractive;
	  	this.value = ractive ? parent.getKeypath( ractive ) : parent.getKeypath();
	  	this.dependants = [];
	  	this.children = [];
	  };

	  KeypathModel.prototype.addChild = function addChild( model ) {
	  	this.children.push( model );
	  	model.owner = this;
	  };

	  KeypathModel.prototype.get = function get () {
	  	return this.value;
	  };

	  KeypathModel.prototype.getKeypath = function getKeypath () {
	  	return this.value;
	  };

	  KeypathModel.prototype.handleChange = function handleChange$1 () {
	  	this.value = this.ractive ? this.parent.getKeypath( this.ractive ) : this.parent.getKeypath();
	  	if ( this.ractive && this.owner ) {
	  		this.ractive.viewmodel.keypathModels[ this.owner.value ] = this;
	  	}
	  	this.children.forEach( handleChange );
	  	this.dependants.forEach( handleChange );
	  };

	  KeypathModel.prototype.register = function register ( dependant ) {
	  	this.dependants.push( dependant );
	  };

	  KeypathModel.prototype.removeChild = function removeChild( model ) {
	  	removeFromArray( this.children, model );
	  };

	  KeypathModel.prototype.teardown = function teardown$1 () {
	  	if ( this.owner ) this.owner.removeChild( this );
	  	this.children.forEach( teardown );
	  };

	  KeypathModel.prototype.unregister = function unregister ( dependant ) {
	  	removeFromArray( this.dependants, dependant );
	  };

	  var hasProp = Object.prototype.hasOwnProperty;

	  function updateFromBindings ( model ) {
	  	model.updateFromBindings( true );
	  }

	  function updateKeypathDependants ( model ) {
	  	model.updateKeypathDependants();
	  }

	  var originatingModel = null;

	  var Model = function Model ( parent, key ) {
	  	this.deps = [];

	  	this.children = [];
	  	this.childByKey = {};

	  	this.indexModels = [];

	  	this.unresolved = [];
	  	this.unresolvedByKey = {};

	  	this.bindings = [];
	  	this.patternObservers = [];

	  	this.value = undefined;

	  	this.ticker = null;

	  	if ( parent ) {
	  		this.parent = parent;
	  		this.root = parent.root;
	  		this.key = unescapeKey( key );
	  		this.isReadonly = parent.isReadonly;

	  		if ( parent.value ) {
	  			this.value = parent.value[ this.key ];
	  			this.adapt();
	  		}
	  	}
	  };

	  Model.prototype.adapt = function adapt () {
	  	var this$1 = this;

	  		var adaptors = this.root.adaptors;
	  	var len = adaptors.length;

	  	this.rewrap = false;

	  	// Exit early if no adaptors
	  	if ( len === 0 ) return;

	  	var value = this.value;

	  	// TODO remove this legacy nonsense
	  	var ractive = this.root.ractive;
	  	var keypath = this.getKeypath();

	  	// tear previous adaptor down if present
	  	if ( this.wrapper ) {
	  		var shouldTeardown = !this.wrapper.reset || this.wrapper.reset( value ) === false;

	  		if ( shouldTeardown ) {
	  			this.wrapper.teardown();
	  			this.wrapper = null;

	  			// don't branch for undefined values
	  			if ( this.value !== undefined ) {
	  				var parentValue = this.parent.value || this.parent.createBranch( this.key );
	  				if ( parentValue[ this.key ] !== this.value ) parentValue[ this.key ] = value;
	  			}
	  		} else {
	  			this.value = this.wrapper.get();
	  			return;
	  		}
	  	}

	  	var i;

	  	for ( i = 0; i < len; i += 1 ) {
	  		var adaptor = adaptors[i];
	  		if ( adaptor.filter( value, keypath, ractive ) ) {
	  			this$1.wrapper = adaptor.wrap( ractive, value, keypath, getPrefixer( keypath ) );
	  			this$1.wrapper.value = this$1.value;
	  			this$1.wrapper.__model = this$1; // massive temporary hack to enable array adaptor

	  			this$1.value = this$1.wrapper.get();

	  			break;
	  		}
	  	}
	  };

	  Model.prototype.addUnresolved = function addUnresolved ( key, resolver ) {
	  	if ( !this.unresolvedByKey[ key ] ) {
	  		this.unresolved.push( key );
	  		this.unresolvedByKey[ key ] = [];
	  	}

	  	this.unresolvedByKey[ key ].push( resolver );
	  };

	  Model.prototype.animate = function animate ( from, to, options, interpolator ) {
	  	var this$1 = this;

	  		if ( this.ticker ) this.ticker.stop();

	  	var fulfilPromise;
	  	var promise = new Promise$1( function ( fulfil ) { return fulfilPromise = fulfil; } );

	  	this.ticker = new Ticker({
	  		duration: options.duration,
	  		easing: options.easing,
	  		step: function ( t ) {
	  			var value = interpolator( t );
	  			this$1.applyValue( value );
	  			if ( options.step ) options.step( t, value );
	  		},
	  		complete: function () {
	  			this$1.applyValue( to );
	  			if ( options.complete ) options.complete( to );

	  			this$1.ticker = null;
	  			fulfilPromise();
	  		}
	  	});

	  	promise.stop = this.ticker.stop;
	  	return promise;
	  };

	  Model.prototype.applyValue = function applyValue ( value ) {
	  	if ( isEqual( value, this.value ) ) return;

	  	// TODO deprecate this nonsense
	  	this.registerChange( this.getKeypath(), value );

	  	if ( this.parent.wrapper && this.parent.wrapper.set ) {
	  		this.parent.wrapper.set( this.key, value );
	  		this.parent.value = this.parent.wrapper.get();

	  		this.value = this.parent.value[ this.key ];
	  		this.adapt();
	  	} else if ( this.wrapper ) {
	  		this.value = value;
	  		this.adapt();
	  	} else {
	  		var parentValue = this.parent.value || this.parent.createBranch( this.key );
	  		parentValue[ this.key ] = value;

	  		this.value = value;
	  		this.adapt();
	  	}

	  	this.parent.clearUnresolveds();
	  	this.clearUnresolveds();

	  	// notify dependants
	  	var previousOriginatingModel = originatingModel; // for the array.length special case
	  	originatingModel = this;

	  	this.children.forEach( mark );
	  	this.deps.forEach( handleChange );

	  	this.notifyUpstream();

	  	originatingModel = previousOriginatingModel;
	  };

	  Model.prototype.clearUnresolveds = function clearUnresolveds ( specificKey ) {
	  	var this$1 = this;

	  		var i = this.unresolved.length;

	  	while ( i-- ) {
	  		var key = this$1.unresolved[i];

	  		if ( specificKey && key !== specificKey ) continue;

	  		var resolvers = this$1.unresolvedByKey[ key ];
	  		var hasKey = this$1.has( key );

	  		var j = resolvers.length;
	  		while ( j-- ) {
	  			if ( hasKey ) resolvers[j].attemptResolution();
	  			if ( resolvers[j].resolved ) resolvers.splice( j, 1 );
	  		}

	  		if ( !resolvers.length ) {
	  			this$1.unresolved.splice( i, 1 );
	  			this$1.unresolvedByKey[ key ] = null;
	  		}
	  	}
	  };

	  Model.prototype.createBranch = function createBranch ( key ) {
	  	var branch = isNumeric( key ) ? [] : {};
	  	this.set( branch );

	  	return branch;
	  };

	  Model.prototype.findMatches = function findMatches ( keys ) {
	  	var len = keys.length;

	  	var existingMatches = [ this ];
	  	var matches;
	  	var i;

	  	var loop = function (  ) {
	  		var key = keys[i];

	  		if ( key === '*' ) {
	  			matches = [];
	  			existingMatches.forEach( function ( model ) {
	  				matches.push.apply( matches, model.getValueChildren( model.get() ) );
	  			});
	  		} else {
	  			matches = existingMatches.map( function ( model ) { return model.joinKey( key ); } );
	  		}

	  		existingMatches = matches;
	  	};

	  		for ( i = 0; i < len; i += 1 ) loop(  );

	  	return matches;
	  };

	  Model.prototype.get = function get ( shouldCapture ) {
	  	if ( shouldCapture ) capture( this );
	  	return this.value;
	  };

	  Model.prototype.getIndexModel = function getIndexModel ( fragmentIndex ) {
	  	var indexModels = this.parent.indexModels;

	  	// non-numeric keys are a special of a numeric index in a object iteration
	  	if ( typeof this.key === 'string' && fragmentIndex !== undefined ) {
	  		return new KeyModel( fragmentIndex );
	  	} else if ( !indexModels[ this.key ] ) {
	  		indexModels[ this.key ] = new KeyModel( this.key );
	  	}

	  	return indexModels[ this.key ];
	  };

	  Model.prototype.getKeyModel = function getKeyModel () {
	  	// TODO... different to IndexModel because key can never change
	  	return new KeyModel( escapeKey( this.key ) );
	  };

	  Model.prototype.getKeypathModel = function getKeypathModel ( ractive ) {
	  	var keypath = this.getKeypath(), model = this.keypathModel || ( this.keypathModel = new KeypathModel( this ) );

	  	if ( ractive && ractive.component ) {
	  		var mapped = this.getKeypath( ractive );
	  		if ( mapped !== keypath ) {
	  			var map = ractive.viewmodel.keypathModels || ( ractive.viewmodel.keypathModels = {} );
	  			var child = map[ keypath ] || ( map[ keypath ] = new KeypathModel( this, ractive ) );
	  			model.addChild( child );
	  			return child;
	  		}
	  	}

	  	return model;
	  };

	  Model.prototype.getKeypath = function getKeypath ( ractive ) {
	  	var root = this.parent.isRoot ? escapeKey( this.key ) : this.parent.getKeypath() + '.' + escapeKey( this.key );

	  	if ( ractive && ractive.component ) {
	  		var map = ractive.viewmodel.mappings;
	  		for ( var k in map ) {
	  			if ( root.indexOf( map[ k ].getKeypath() ) >= 0 ) {
	  				root = root.replace( map[ k ].getKeypath(), k );
	  				break;
	  			}
	  		}
	  	}

	  	return root;
	  };

	  Model.prototype.getValueChildren = function getValueChildren ( value ) {
	  	var this$1 = this;

	  		var children;
	  	if ( isArray( value ) ) {
	  		children = [];
	  		// special case - array.length. This is a horrible kludge, but
	  		// it'll do for now. Alternatives welcome
	  		if ( originatingModel && originatingModel.parent === this && originatingModel.key === 'length' ) {
	  			children.push( originatingModel );
	  		}
	  		value.forEach( function ( m, i ) {
	  			children.push( this$1.joinKey( i ) );
	  		});

	  	}

	  	else if ( isObject( value ) || typeof value === 'function' ) {
	  		children = Object.keys( value ).map( function ( key ) { return this$1.joinKey( key ); } );
	  	}

	  	else if ( value != null ) {
	  		return [];
	  	}

	  	return children;
	  };

	  Model.prototype.has = function has ( key ) {
	  	var value = this.get();
	  	if ( !value ) return false;

	  	key = unescapeKey( key );
	  	if ( hasProp.call( value, key ) ) return true;

	  	// We climb up the constructor chain to find if one of them contains the key
	  	var constructor = value.constructor;
	  	while ( constructor !== Function && constructor !== Array && constructor !== Object ) {
	  		if ( hasProp.call( constructor.prototype, key ) ) return true;
	  		constructor = constructor.constructor;
	  	}

	  	return false;
	  };

	  Model.prototype.joinKey = function joinKey ( key ) {
	  	if ( key === undefined || key === '' ) return this;

	  	if ( !this.childByKey.hasOwnProperty( key ) ) {
	  		var child = new Model( this, key );
	  		this.children.push( child );
	  		this.childByKey[ key ] = child;
	  	}

	  	return this.childByKey[ key ];
	  };

	  Model.prototype.joinAll = function joinAll ( keys ) {
	  	var model = this;
	  	for ( var i = 0; i < keys.length; i += 1 ) {
	  		model = model.joinKey( keys[i] );
	  	}

	  	return model;
	  };

	  Model.prototype.mark = function mark$1 () {
	  	var value = this.retrieve();

	  	if ( !isEqual( value, this.value ) ) {
	  		var old = this.value;
	  		this.value = value;

	  		// make sure the wrapper stays in sync
	  		if ( old !== value || this.rewrap ) this.adapt();

	  		this.children.forEach( mark );

	  		this.deps.forEach( handleChange );
	  		this.clearUnresolveds();
	  	}
	  };

	  Model.prototype.merge = function merge ( array, comparator ) {
	  	var oldArray = comparator ? this.value.map( comparator ) : this.value;
	  	var newArray = comparator ? array.map( comparator ) : array;

	  	var oldLength = oldArray.length;

	  	var usedIndices = {};
	  	var firstUnusedIndex = 0;

	  	var newIndices = oldArray.map( function ( item ) {
	  		var index;
	  		var start = firstUnusedIndex;

	  		do {
	  			index = newArray.indexOf( item, start );

	  			if ( index === -1 ) {
	  				return -1;
	  			}

	  			start = index + 1;
	  		} while ( ( usedIndices[ index ] === true ) && start < oldLength );

	  		// keep track of the first unused index, so we don't search
	  		// the whole of newArray for each item in oldArray unnecessarily
	  		if ( index === firstUnusedIndex ) {
	  			firstUnusedIndex += 1;
	  		}
	  		// allow next instance of next "equal" to be found item
	  		usedIndices[ index ] = true;
	  		return index;
	  	});

	  	this.parent.value[ this.key ] = array;
	  	this._merged = true;
	  	this.shuffle( newIndices );
	  };

	  Model.prototype.notifyUpstream = function notifyUpstream () {
	  	var parent = this.parent, prev = this;
	  	while ( parent ) {
	  		if ( parent.patternObservers.length ) parent.patternObservers.forEach( function ( o ) { return o.notify( prev.key ); } );
	  		parent.deps.forEach( handleChange );
	  		prev = parent;
	  		parent = parent.parent;
	  	}
	  };

	  Model.prototype.register = function register ( dep ) {
	  	this.deps.push( dep );
	  };

	  Model.prototype.registerChange = function registerChange ( key, value ) {
	  	if ( !this.isRoot ) {
	  		this.root.registerChange( key, value );
	  	} else {
	  		this.changes[ key ] = value;
	  		runloop.addInstance( this.root.ractive );
	  	}
	  };

	  Model.prototype.registerPatternObserver = function registerPatternObserver ( observer ) {
	  	this.patternObservers.push( observer );
	  	this.register( observer );
	  };

	  Model.prototype.registerTwowayBinding = function registerTwowayBinding ( binding ) {
	  	this.bindings.push( binding );
	  };

	  Model.prototype.removeUnresolved = function removeUnresolved ( key, resolver ) {
	  	var resolvers = this.unresolvedByKey[ key ];

	  	if ( resolvers ) {
	  		removeFromArray( resolvers, resolver );
	  	}
	  };

	  Model.prototype.retrieve = function retrieve () {
	  	return this.parent.value ? this.parent.value[ this.key ] : undefined;
	  };

	  Model.prototype.set = function set ( value ) {
	  	if ( this.ticker ) this.ticker.stop();
	  	this.applyValue( value );
	  };

	  Model.prototype.shuffle = function shuffle ( newIndices ) {
	  	var this$1 = this;

	  		var indexModels = [];

	  	newIndices.forEach( function ( newIndex, oldIndex ) {
	  		if ( newIndex !== oldIndex && this$1.childByKey[oldIndex] ) this$1.childByKey[oldIndex].shuffled();

	  		if ( !~newIndex ) return;

	  		var model = this$1.indexModels[ oldIndex ];

	  		if ( !model ) return;

	  		indexModels[ newIndex ] = model;

	  		if ( newIndex !== oldIndex ) {
	  			model.rebind( newIndex );
	  		}
	  	});

	  	this.indexModels = indexModels;

	  	// shuffles need to happen before marks...
	  	this.deps.forEach( function ( dep ) {
	  		if ( dep.shuffle ) dep.shuffle( newIndices );
	  	});

	  	this.updateKeypathDependants();
	  	this.mark();

	  	// ...but handleChange must happen after (TODO document why)
	  	this.deps.forEach( function ( dep ) {
	  		if ( !dep.shuffle ) dep.handleChange();
	  	});
	  };

	  Model.prototype.shuffled = function shuffled () {
	  	var this$1 = this;

	  		var i = this.children.length;
	  	while ( i-- ) {
	  		this$1.children[i].shuffled();
	  	}
	  	if ( this.wrapper ) {
	  		this.wrapper.teardown();
	  		this.wrapper = null;
	  		this.rewrap = true;
	  	}
	  };

	  Model.prototype.teardown = function teardown$1 () {
	  	this.children.forEach( teardown );
	  	if ( this.wrapper ) this.wrapper.teardown();
	  	if ( this.keypathModels ) {
	  		for ( var k in this.keypathModels ) {
	  			this.keypathModels[ k ].teardown();
	  		}
	  	}
	  };

	  Model.prototype.unregister = function unregister ( dependant ) {
	  	removeFromArray( this.deps, dependant );
	  };

	  Model.prototype.unregisterPatternObserver = function unregisterPatternObserver ( observer ) {
	  	removeFromArray( this.patternObservers, observer );
	  	this.unregister( observer );
	  };

	  Model.prototype.unregisterTwowayBinding = function unregisterTwowayBinding ( binding ) {
	  	removeFromArray( this.bindings, binding );
	  };

	  Model.prototype.updateFromBindings = function updateFromBindings$1 ( cascade ) {
	  	var this$1 = this;

	  		var i = this.bindings.length;
	  	while ( i-- ) {
	  		var value = this$1.bindings[i].getValue();
	  		if ( value !== this$1.value ) this$1.set( value );
	  	}

	  	if ( cascade ) {
	  		this.children.forEach( updateFromBindings );
	  	}
	  };

	  Model.prototype.updateKeypathDependants = function updateKeypathDependants$1 () {
	  	this.children.forEach( updateKeypathDependants );
	  	if ( this.keypathModel ) this.keypathModel.handleChange();
	  };

	  var GlobalModel = (function (Model) {
	  	function GlobalModel ( ) {
	  		Model.call( this, null, '@global' );
	  		this.value = typeof global !== 'undefined' ? global : window;
	  		this.isRoot = true;
	  		this.root = this;
	  		this.adaptors = [];
	  	}

	  	GlobalModel.prototype = Object.create( Model && Model.prototype );
	  	GlobalModel.prototype.constructor = GlobalModel;

	  	GlobalModel.prototype.getKeypath = function getKeypath() {
	  		return '@global';
	  	};

	  	// global model doesn't contribute changes events because it has no instance
	  	GlobalModel.prototype.registerChange = function registerChange () {};

	  	return GlobalModel;
	  }(Model));

	  var GlobalModel$1 = new GlobalModel();

	  function resolveReference ( fragment, ref ) {
	  	var context = fragment.findContext();

	  	// special references
	  	// TODO does `this` become `.` at parse time?
	  	if ( ref === '.' || ref === 'this' ) return context;
	  	if ( ref === '@keypath' ) return context.getKeypathModel( fragment.ractive );
	  	if ( ref === '@rootpath' ) return context.getKeypathModel();
	  	if ( ref === '@index' ) {
	  		var repeater = fragment.findRepeatingFragment();
	  		// make sure the found fragment is actually an iteration
	  		if ( !repeater.isIteration ) return;
	  		return repeater.context.getIndexModel( repeater.index );
	  	}
	  	if ( ref === '@key' ) return fragment.findRepeatingFragment().context.getKeyModel();
	  	if ( ref === '@ractive' ) {
	  		return fragment.ractive.viewmodel.getRactiveModel();
	  	}
	  	if ( ref === '@global' ) {
	  		return GlobalModel$1;
	  	}

	  	// ancestor references
	  	if ( ref[0] === '~' ) return fragment.ractive.viewmodel.joinAll( splitKeypathI( ref.slice( 2 ) ) );
	  	if ( ref[0] === '.' ) {
	  		var parts = ref.split( '/' );

	  		while ( parts[0] === '.' || parts[0] === '..' ) {
	  			var part = parts.shift();

	  			if ( part === '..' ) {
	  				context = context.parent;
	  			}
	  		}

	  		ref = parts.join( '/' );

	  		// special case - `{{.foo}}` means the same as `{{./foo}}`
	  		if ( ref[0] === '.' ) ref = ref.slice( 1 );
	  		return context.joinAll( splitKeypathI( ref ) );
	  	}

	  	return resolveAmbiguousReference( fragment, ref );
	  }

	  function Ractive$get ( keypath ) {
	  	if ( !keypath ) return this.viewmodel.get( true );

	  	var keys = splitKeypathI( keypath );
	  	var key = keys[0];

	  	var model;

	  	if ( !this.viewmodel.has( key ) ) {
	  		// if this is an inline component, we may need to create
	  		// an implicit mapping
	  		if ( this.component && !this.isolated ) {
	  			model = resolveReference( this.component.parentFragment, key );

	  			if ( model ) {
	  				this.viewmodel.map( key, model );
	  			}
	  		}
	  	}

	  	model = this.viewmodel.joinAll( keys );
	  	return model.get( true );
	  }

	  var insertHook = new Hook( 'insert' );

	  function Ractive$insert ( target, anchor ) {
	  	if ( !this.fragment.rendered ) {
	  		// TODO create, and link to, documentation explaining this
	  		throw new Error( 'The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.' );
	  	}

	  	target = getElement( target );
	  	anchor = getElement( anchor ) || null;

	  	if ( !target ) {
	  		throw new Error( 'You must specify a valid target to insert into' );
	  	}

	  	target.insertBefore( this.detach(), anchor );
	  	this.el = target;

	  	( target.__ractive_instances__ || ( target.__ractive_instances__ = [] ) ).push( this );
	  	this.isDetached = false;

	  	fireInsertHook( this );
	  }

	  function fireInsertHook( ractive ) {
	  	insertHook.fire( ractive );

	  	ractive.findAllComponents('*').forEach( function ( child ) {
	  		fireInsertHook( child.instance );
	  	});
	  }

	  function link( there, here ) {
	  	if ( here === there || (there + '.').indexOf( here + '.' ) === 0 || (here + '.').indexOf( there + '.' ) === 0 ) {
	  		throw new Error( 'A keypath cannot be linked to itself.' );
	  	}

	  	var promise = runloop.start();

	  	var model;
	  	var ln = this._links[ here ];

	  	if ( ln ) {
	  		if ( ln.source.model.str !== there || ln.dest.model.str !== here ) {
	  			ln.unlink();
	  			delete this._links[ here ];
	  			this.viewmodel.joinAll( splitKeypathI( here ) ).set( ln.initialValue );
	  		} else { // already linked, so nothing to do
	  			runloop.end();
	  			return promise;
	  		}
	  	}

	  	// may need to allow a mapping to resolve implicitly
	  	var sourcePath = splitKeypathI( there );
	  	if ( !this.viewmodel.has( sourcePath[0] ) && this.component ) {
	  		model = resolveReference( this.component.parentFragment, sourcePath[0] );

	  		if ( model ) {
	  			this.viewmodel.map( sourcePath[0], model );
	  		}
	  	}

	  	ln = new Link( this.viewmodel.joinAll( sourcePath ), this.viewmodel.joinAll( splitKeypathI( here ) ), this );
	  	this._links[ here ] = ln;
	  	ln.source.handleChange();

	  	runloop.end();

	  	return promise;
	  }

	  var Link = function Link ( source, dest, ractive ) {
	  	this.source = new LinkSide( source, this );
	  	this.dest = new LinkSide( dest, this );
	  	this.ractive = ractive;
	  	this.locked = false;
	  	this.initialValue = dest.get();
	  };

	  Link.prototype.sync = function sync ( side ) {
	  	if ( !this.locked ) {
	  		this.locked = true;

	  		if ( side === this.dest ) {
	  			this.source.model.set( this.dest.model.get() );
	  		} else {
	  			this.dest.model.set( this.source.model.get() );
	  		}

	  		this.locked = false;
	  	}
	  };

	  Link.prototype.unlink = function unlink () {
	  	this.source.model.unregister( this.source );
	  	this.dest.model.unregister( this.dest );
	  };

	  var LinkSide = function LinkSide ( model, owner ) {
	  	this.model = model;
	  	this.owner = owner;
	  	model.register( this );
	  };

	  LinkSide.prototype.handleChange = function handleChange () {
	  	this.owner.sync( this );
	  };

	  var comparators = {};

	  function getComparator ( option ) {
	  	if ( !option ) return null; // use existing arrays
	  	if ( option === true ) return JSON.stringify;
	  	if ( typeof option === 'function' ) return option;

	  	if ( typeof option === 'string' ) {
	  		return comparators[ option ] || ( comparators[ option ] = function ( thing ) { return thing[ option ]; } );
	  	}

	  	throw new Error( 'If supplied, options.compare must be a string, function, or `true`' ); // TODO link to docs
	  }

	  function Ractive$merge ( keypath, array, options ) {
	  	var model = this.viewmodel.joinAll( splitKeypathI( keypath ) );
	  	var promise = runloop.start( this, true );
	  	var value = model.get();

	  	if ( array === value ) {
	  		throw new Error( 'You cannot merge an array with itself' ); // TODO link to docs
	  	} else if ( !isArray( value ) || !isArray( array ) ) {
	  		throw new Error( 'You cannot merge an array with a non-array' );
	  	}

	  	var comparator = getComparator( options && options.compare );
	  	model.merge( array, comparator );

	  	runloop.end();
	  	return promise;
	  }

	  function observe ( keypath, callback, options ) {
	  	var this$1 = this;

	  	var observers = [];
	  	var map;

	  	if ( isObject( keypath ) ) {
	  		map = keypath;
	  		options = callback || {};

	  		Object.keys( map ).forEach( function ( keypath ) {
	  			var callback = map[ keypath ];

	  			keypath.split( ' ' ).forEach( function ( keypath ) {
	  				observers.push( createObserver( this$1, keypath, callback, options ) );
	  			});
	  		});
	  	}

	  	else {
	  		var keypaths;

	  		if ( typeof keypath === 'function' ) {
	  			options = callback;
	  			callback = keypath;
	  			keypaths = [ '' ];
	  		} else {
	  			keypaths = keypath.split( ' ' );
	  		}

	  		keypaths.forEach( function ( keypath ) {
	  			observers.push( createObserver( this$1, keypath, callback, options || {} ) );
	  		});
	  	}

	  	// add observers to the Ractive instance, so they can be
	  	// cancelled on ractive.teardown()
	  	this._observers.push.apply( this._observers, observers );

	  	return {
	  		cancel: function () {
	  			observers.forEach( function ( observer ) {
	  				removeFromArray ( this$1._observers, observer );
	  				observer.cancel();
	  			} );
	  		}
	  	};
	  }

	  function createObserver ( ractive, keypath, callback, options ) {
	  	var viewmodel = ractive.viewmodel;

	  	var keys = splitKeypathI( keypath );
	  	var wildcardIndex = keys.indexOf( '*' );

	  	// normal keypath - no wildcards
	  	if ( !~wildcardIndex ) {
	  		var key = keys[0];

	  		// if not the root model itself, check if viewmodel has key.
	  		if ( key !== '' && !viewmodel.has( key ) ) {
	  			// if this is an inline component, we may need to create an implicit mapping
	  			if ( ractive.component ) {
	  				var model = resolveReference( ractive.component.parentFragment, key );
	  				if ( model ) viewmodel.map( key, model );
	  			}
	  		}

	  		var model$1 = viewmodel.joinAll( keys );
	  		return new Observer( ractive, model$1, callback, options );
	  	}

	  	// pattern observers - more complex case
	  	var baseModel = wildcardIndex === 0 ?
	  		viewmodel :
	  		viewmodel.joinAll( keys.slice( 0, wildcardIndex ) );

	  	return new PatternObserver( ractive, baseModel, keys.splice( wildcardIndex ), callback, options );
	  }

	  var Observer = function Observer ( ractive, model, callback, options ) {
	  	this.context = options.context || ractive;
	  	this.model = model;
	  	this.keypath = model.getKeypath( ractive );
	  	this.callback = callback;

	  	this.oldValue = undefined;
	  	this.newValue = model.get();

	  	this.defer = options.defer;
	  	this.once = options.once;
	  	this.strict = options.strict;

	  	this.dirty = false;

	  	if ( options.init !== false ) {
	  		this.dispatch();
	  	} else {
	  		this.oldValue = this.newValue;
	  	}

	  	model.register( this );
	  };

	  Observer.prototype.cancel = function cancel () {
	  	this.model.unregister( this );
	  };

	  Observer.prototype.dispatch = function dispatch () {
	  	this.callback.call( this.context, this.newValue, this.oldValue, this.keypath );
	  	this.oldValue = this.newValue;
	  	this.dirty = false;
	  };

	  Observer.prototype.handleChange = function handleChange () {
	  	if ( !this.dirty ) {
	  		this.newValue = this.model.get();

	  		if ( this.strict && this.newValue === this.oldValue ) return;

	  		runloop.addObserver( this, this.defer );
	  		this.dirty = true;

	  		if ( this.once ) this.cancel();
	  	}
	  };

	  var PatternObserver = function PatternObserver ( ractive, baseModel, keys, callback, options ) {
	  	var this$1 = this;

	  		this.context = options.context || ractive;
	  	this.ractive = ractive;
	  	this.baseModel = baseModel;
	  	this.keys = keys;
	  	this.callback = callback;

	  	var pattern = keys.join( '\\.' ).replace( /\*/g, '(.+)' );
	  	var baseKeypath = baseModel.getKeypath( ractive );
	  	this.pattern = new RegExp( ("^" + (baseKeypath ? baseKeypath + '\\.' : '') + "" + pattern + "$") );

	  	this.oldValues = {};
	  	this.newValues = {};

	  	this.defer = options.defer;
	  	this.once = options.once;
	  	this.strict = options.strict;

	  	this.dirty = false;
	  	this.changed = [];
	  	this.partial = false;

	  	var models = baseModel.findMatches( this.keys );

	  	models.forEach( function ( model ) {
	  		this$1.newValues[ model.getKeypath( this$1.ractive ) ] = model.get();
	  	});

	  	if ( options.init !== false ) {
	  		this.dispatch();
	  	} else {
	  		this.oldValues = this.newValues;
	  	}

	  	baseModel.registerPatternObserver( this );
	  };

	  PatternObserver.prototype.cancel = function cancel () {
	  	this.baseModel.unregisterPatternObserver( this );
	  };

	  PatternObserver.prototype.dispatch = function dispatch () {
	  	var this$1 = this;

	  		Object.keys( this.newValues ).forEach( function ( keypath ) {
	  		if ( this$1.newKeys && !this$1.newKeys[ keypath ] ) return;

	  		var newValue = this$1.newValues[ keypath ];
	  		var oldValue = this$1.oldValues[ keypath ];

	  		if ( this$1.strict && newValue === oldValue ) return;
	  		if ( isEqual( newValue, oldValue ) ) return;

	  		var args = [ newValue, oldValue, keypath ];
	  		if ( keypath ) {
	  			var wildcards = this$1.pattern.exec( keypath ).slice( 1 );
	  			args = args.concat( wildcards );
	  		}

	  		this$1.callback.apply( this$1.context, args );
	  	});

	  	if ( this.partial ) {
	  		for ( var k in this.newValues ) {
	  			this.oldValues[k] = this.newValues[k];
	  		}
	  	} else {
	  		this.oldValues = this.newValues;
	  	}

	  	this.newKeys = null;
	  	this.dirty = false;
	  };

	  PatternObserver.prototype.notify = function notify ( key ) {
	  	this.changed.push( key );
	  };

	  PatternObserver.prototype.shuffle = function shuffle ( newIndices ) {
	  	var this$1 = this;

	  		if ( !isArray( this.baseModel.value ) ) return;

	  	var base = this.baseModel.getKeypath( this.ractive );
	  	var max = this.baseModel.value.length;
	  	var suffix = this.keys.length > 1 ? '.' + this.keys.slice( 1 ).join( '.' ) : '';

	  	this.newKeys = {};
	  	for ( var i = 0; i < newIndices.length; i++ ) {
	  		if ( newIndices[ i ] === -1 || newIndices[ i ] === i ) continue;
	  		this$1.newKeys[ ("" + base + "." + i + "" + suffix) ] = true;
	  	}

	  	for ( var i$1 = newIndices.touchedFrom; i$1 < max; i$1++ ) {
	  		this$1.newKeys[ ("" + base + "." + i$1 + "" + suffix) ] = true;
	  	}
	  };

	  PatternObserver.prototype.handleChange = function handleChange () {
	  	var this$1 = this;

	  		if ( !this.dirty ) {
	  		this.newValues = {};

	  		// handle case where previously extant keypath no longer exists -
	  		// observer should still fire, with undefined as new value
	  		// TODO huh. according to the test suite that's not the case...
	  		// Object.keys( this.oldValues ).forEach( keypath => {
	  		// this.newValues[ keypath ] = undefined;
	  		// });

	  		if ( !this.changed.length ) {
	  			this.baseModel.findMatches( this.keys ).forEach( function ( model ) {
	  				var keypath = model.getKeypath( this$1.ractive );
	  				this$1.newValues[ keypath ] = model.get();
	  			});
	  			this.partial = false;
	  		} else {
	  			var ok = this.baseModel.isRoot ?
	  				this.changed :
	  				this.changed.map( function ( key ) { return this$1.baseModel.getKeypath( this$1.ractive ) + '.' + escapeKey( key ); } );

	  			this.baseModel.findMatches( this.keys ).forEach( function ( model ) {
	  				var keypath = model.getKeypath( this$1.ractive );
	  				// is this model on a changed keypath?
	  				if ( ok.filter( function ( k ) { return keypath.indexOf( k ) === 0 && ( keypath.length === k.length || keypath[k.length] === '.' ); } ).length ) {
	  					this$1.newValues[ keypath ] = model.get();
	  				}
	  			});
	  			this.partial = true;
	  		}

	  		runloop.addObserver( this, this.defer );
	  		this.dirty = true;
	  		this.changed.length = 0;

	  		if ( this.once ) this.cancel();
	  	}
	  };

	  function observeList ( keypath, callback, options ) {
	  	if ( typeof keypath !== 'string' ) {
	  		throw new Error( 'ractive.observeList() must be passed a string as its first argument' );
	  	}

	  	var model = this.viewmodel.joinAll( splitKeypathI( keypath ) );
	  	var observer = new ListObserver( this, model, callback, options || {} );

	  	// add observer to the Ractive instance, so it can be
	  	// cancelled on ractive.teardown()
	  	this._observers.push( observer );

	  	return {
	  		cancel: function () {
	  			observer.cancel();
	  		}
	  	};
	  }

	  function negativeOne () {
	  	return -1;
	  }

	  var ListObserver = function ListObserver ( context, model, callback, options ) {
	  	this.context = context;
	  	this.model = model;
	  	this.keypath = model.getKeypath();
	  	this.callback = callback;

	  	this.pending = null;

	  	model.register( this );

	  	if ( options.init !== false ) {
	  		this.sliced = [];
	  		this.shuffle([]);
	  		this.handleChange();
	  	} else {
	  		this.sliced = this.slice();
	  	}
	  };

	  ListObserver.prototype.handleChange = function handleChange () {
	  	if ( this.pending ) {
	  		// post-shuffle
	  		this.callback( this.pending );
	  		this.pending = null;
	  	}

	  	else {
	  		// entire array changed
	  		this.shuffle( this.sliced.map( negativeOne ) );
	  		this.handleChange();
	  	}
	  };

	  ListObserver.prototype.shuffle = function shuffle ( newIndices ) {
	  	var this$1 = this;

	  		var newValue = this.slice();

	  	var inserted = [];
	  	var deleted = [];
	  	var start;

	  	var hadIndex = {};

	  	newIndices.forEach( function ( newIndex, oldIndex ) {
	  		hadIndex[ newIndex ] = true;

	  		if ( newIndex !== oldIndex && start === undefined ) {
	  			start = oldIndex;
	  		}

	  		if ( newIndex === -1 ) {
	  			deleted.push( this$1.sliced[ oldIndex ] );
	  		}
	  	});

	  	if ( start === undefined ) start = newIndices.length;

	  	var len = newValue.length;
	  	for ( var i = 0; i < len; i += 1 ) {
	  		if ( !hadIndex[i] ) inserted.push( newValue[i] );
	  	}

	  	this.pending = { inserted: inserted, deleted: deleted, start: start };
	  	this.sliced = newValue;
	  };

	  ListObserver.prototype.slice = function slice () {
	  	var value = this.model.get();
	  	return isArray( value ) ? value.slice() : [];
	  };

	  var onceOptions = { init: false, once: true };

	  function observeOnce ( keypath, callback, options ) {
	  	if ( isObject( keypath ) || typeof keypath === 'function' ) {
	  		options = extendObj( callback || {}, onceOptions );
	  		return this.observe( keypath, options );
	  	}

	  	options = extendObj( options || {}, onceOptions );
	  	return this.observe( keypath, callback, options );
	  }

	  function trim ( str ) { return str.trim(); };

	  function notEmptyString ( str ) { return str !== ''; };

	  function Ractive$off ( eventName, callback ) {
	  	// if no arguments specified, remove all callbacks
	  	var this$1 = this;

	  	if ( !eventName ) {
	  		// TODO use this code instead, once the following issue has been resolved
	  		// in PhantomJS (tests are unpassable otherwise!)
	  		// https://github.com/ariya/phantomjs/issues/11856
	  		// defineProperty( this, '_subs', { value: create( null ), configurable: true });
	  		for ( eventName in this._subs ) {
	  			delete this._subs[ eventName ];
	  		}
	  	}

	  	else {
	  		// Handle multiple space-separated event names
	  		var eventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );

	  		eventNames.forEach( function ( eventName ) {
	  			var subscribers = this$1._subs[ eventName ];

	  			// If we have subscribers for this event...
	  			if ( subscribers ) {
	  				// ...if a callback was specified, only remove that
	  				if ( callback ) {
	  					var index = subscribers.indexOf( callback );
	  					if ( index !== -1 ) {
	  						subscribers.splice( index, 1 );
	  					}
	  				}

	  				// ...otherwise remove all callbacks
	  				else {
	  					this$1._subs[ eventName ] = [];
	  				}
	  			}
	  		});
	  	}

	  	return this;
	  }

	  function Ractive$on ( eventName, callback ) {
	  	// allow multiple listeners to be bound in one go
	  	var this$1 = this;

	  	if ( typeof eventName === 'object' ) {
	  		var listeners = [];
	  		var n;

	  		for ( n in eventName ) {
	  			if ( eventName.hasOwnProperty( n ) ) {
	  				listeners.push( this.on( n, eventName[ n ] ) );
	  			}
	  		}

	  		return {
	  			cancel: function () {
	  				var listener;
	  				while ( listener = listeners.pop() ) listener.cancel();
	  			}
	  		};
	  	}

	  	// Handle multiple space-separated event names
	  	var eventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );

	  	eventNames.forEach( function ( eventName ) {
	  		( this$1._subs[ eventName ] || ( this$1._subs[ eventName ] = [] ) ).push( callback );
	  	});

	  	return {
	  		cancel: function () { return this$1.off( eventName, callback ); }
	  	};
	  }

	  function Ractive$once ( eventName, handler ) {
	  	var listener = this.on( eventName, function () {
	  		handler.apply( this, arguments );
	  		listener.cancel();
	  	});

	  	// so we can still do listener.cancel() manually
	  	return listener;
	  }

	  // This function takes an array, the name of a mutator method, and the
	  // arguments to call that mutator method with, and returns an array that
	  // maps the old indices to their new indices.

	  // So if you had something like this...
	  //
	  //     array = [ 'a', 'b', 'c', 'd' ];
	  //     array.push( 'e' );
	  //
	  // ...you'd get `[ 0, 1, 2, 3 ]` - in other words, none of the old indices
	  // have changed. If you then did this...
	  //
	  //     array.unshift( 'z' );
	  //
	  // ...the indices would be `[ 1, 2, 3, 4, 5 ]` - every item has been moved
	  // one higher to make room for the 'z'. If you removed an item, the new index
	  // would be -1...
	  //
	  //     array.splice( 2, 2 );
	  //
	  // ...this would result in [ 0, 1, -1, -1, 2, 3 ].
	  //
	  // This information is used to enable fast, non-destructive shuffling of list
	  // sections when you do e.g. `ractive.splice( 'items', 2, 2 );

	  function getNewIndices ( length, methodName, args ) {
	  	var spliceArguments, newIndices = [], removeStart, removeEnd, balance, i;

	  	spliceArguments = getSpliceEquivalent( length, methodName, args );

	  	if ( !spliceArguments ) {
	  		return null; // TODO support reverse and sort?
	  	}

	  	balance = ( spliceArguments.length - 2 ) - spliceArguments[1];

	  	removeStart = Math.min( length, spliceArguments[0] );
	  	removeEnd = removeStart + spliceArguments[1];

	  	for ( i = 0; i < removeStart; i += 1 ) {
	  		newIndices.push( i );
	  	}

	  	for ( ; i < removeEnd; i += 1 ) {
	  		newIndices.push( -1 );
	  	}

	  	for ( ; i < length; i += 1 ) {
	  		newIndices.push( i + balance );
	  	}

	  	// there is a net shift for the rest of the array starting with index + balance
	  	if ( balance !== 0 ) {
	  		newIndices.touchedFrom = spliceArguments[0];
	  	} else {
	  		newIndices.touchedFrom = length;
	  	}

	  	return newIndices;
	  }


	  // The pop, push, shift an unshift methods can all be represented
	  // as an equivalent splice
	  function getSpliceEquivalent ( length, methodName, args ) {
	  	switch ( methodName ) {
	  		case 'splice':
	  			if ( args[0] !== undefined && args[0] < 0 ) {
	  				args[0] = length + Math.max( args[0], -length );
	  			}

	  			while ( args.length < 2 ) {
	  				args.push( length - args[0] );
	  			}

	  			// ensure we only remove elements that exist
	  			args[1] = Math.min( args[1], length - args[0] );

	  			return args;

	  		case 'sort':
	  		case 'reverse':
	  			return null;

	  		case 'pop':
	  			if ( length ) {
	  				return [ length - 1, 1 ];
	  			}
	  			return [ 0, 0 ];

	  		case 'push':
	  			return [ length, 0 ].concat( args );

	  		case 'shift':
	  			return [ 0, length ? 1 : 0 ];

	  		case 'unshift':
	  			return [ 0, 0 ].concat( args );
	  	}
	  }

	  var arrayProto = Array.prototype;

	  function makeArrayMethod ( methodName ) {
	  	return function ( keypath ) {
	  		var args = [], len = arguments.length - 1;
	  		while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	  		var model = this.viewmodel.joinAll( splitKeypathI( keypath ) );
	  		var array = model.get();

	  		if ( !isArray( array ) ) {
	  			if ( array === undefined ) {
	  				array = [];
	  				var result$1 = arrayProto[ methodName ].apply( array, args );
	  				return this.set( keypath, array ).then( function () { return result$1; } );
	  			} else {
	  				throw new Error( ("shuffle array method " + methodName + " called on non-array at " + (model.getKeypath())) );
	  			}
	  		}

	  		var newIndices = getNewIndices( array.length, methodName, args );
	  		var result = arrayProto[ methodName ].apply( array, args );

	  		var promise = runloop.start( this, true ).then( function () { return result; } );
	  		promise.result = result;

	  		if ( newIndices ) {
	  			model.shuffle( newIndices );
	  		} else {
	  			model.set( result );
	  		}

	  		runloop.end();

	  		return promise;
	  	};
	  }

	  var pop = makeArrayMethod( 'pop' );

	  var push = makeArrayMethod( 'push' );

	  var PREFIX = '/* Ractive.js component styles */';

	  // Holds current definitions of styles.
	  var styleDefinitions = [];

	  // Flag to tell if we need to update the CSS
	  var isDirty = false;

	  // These only make sense on the browser. See additional setup below.
	  var styleElement = null;
	  var useCssText = null;

	  function addCSS( styleDefinition ) {
	  	styleDefinitions.push( styleDefinition );
	  	isDirty = true;
	  }

	  function applyCSS() {

	  	// Apply only seems to make sense when we're in the DOM. Server-side renders
	  	// can call toCSS to get the updated CSS.
	  	if ( !doc || !isDirty ) return;

	  	if ( useCssText ) {
	  		styleElement.styleSheet.cssText = getCSS( null );
	  	} else {
	  		styleElement.innerHTML = getCSS( null );
	  	}

	  	isDirty = false;
	  }

	  function getCSS( cssIds ) {

	  	var filteredStyleDefinitions = cssIds ? styleDefinitions.filter( function ( style ) { return ~cssIds.indexOf( style.id ); } ) : styleDefinitions;

	  	return filteredStyleDefinitions.reduce( function ( styles, style ) { return ("" + styles + "\n\n/* {" + (style.id) + "} */\n" + (style.styles)); }, PREFIX );

	  }

	  // If we're on the browser, additional setup needed.
	  if ( doc && ( !styleElement || !styleElement.parentNode ) ) {

	  	styleElement = doc.createElement( 'style' );
	  	styleElement.type = 'text/css';

	  	doc.getElementsByTagName( 'head' )[ 0 ].appendChild( styleElement );

	  	useCssText = !!styleElement.styleSheet;
	  }

	  var renderHook = new Hook( 'render' );
	  var completeHook = new Hook( 'complete' );

	  function render$1 ( ractive, target, anchor, occupants ) {
	  	// if `noIntro` is `true`, temporarily disable transitions
	  	var transitionsEnabled = ractive.transitionsEnabled;
	  	if ( ractive.noIntro ) ractive.transitionsEnabled = false;

	  	var promise = runloop.start( ractive, true );
	  	runloop.scheduleTask( function () { return renderHook.fire( ractive ); }, true );

	  	if ( ractive.fragment.rendered ) {
	  		throw new Error( 'You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first' );
	  	}

	  	anchor = getElement( anchor ) || ractive.anchor;

	  	ractive.el = target;
	  	ractive.anchor = anchor;

	  	// ensure encapsulated CSS is up-to-date
	  	if ( ractive.cssId ) applyCSS();

	  	if ( target ) {
	  		( target.__ractive_instances__ || ( target.__ractive_instances__ = [] ) ).push( ractive );

	  		if ( anchor ) {
	  			var docFrag = doc.createDocumentFragment();
	  			ractive.fragment.render( docFrag );
	  			target.insertBefore( docFrag, anchor );
	  		} else {
	  			ractive.fragment.render( target, occupants );
	  		}
	  	}

	  	runloop.end();
	  	ractive.transitionsEnabled = transitionsEnabled;

	  	return promise.then( function () { return completeHook.fire( ractive ); } );
	  }

	  function Ractive$render ( target, anchor ) {
	  	target = getElement( target ) || this.el;

	  	if ( !this.append && target ) {
	  		// Teardown any existing instances *before* trying to set up the new one -
	  		// avoids certain weird bugs
	  		var others = target.__ractive_instances__;
	  		if ( others ) others.forEach( teardown );

	  		// make sure we are the only occupants
	  		if ( !this.enhance ) {
	  			target.innerHTML = ''; // TODO is this quicker than removeChild? Initial research inconclusive
	  		}
	  	}

	  	var occupants = this.enhance ? toArray( target.childNodes ) : null;
	  	var promise = render$1( this, target, anchor, occupants );

	  	if ( occupants ) {
	  		while ( occupants.length ) target.removeChild( occupants.pop() );
	  	}

	  	return promise;
	  }

	  var adaptConfigurator = {
	  	extend: function ( Parent, proto, options ) {
	  		proto.adapt = combine( proto.adapt, ensureArray( options.adapt ) );
	  	},

	  	init: function () {}
	  };

	  function combine ( a, b ) {
	  	var c = a.slice();
	  	var i = b.length;

	  	while ( i-- ) {
	  		if ( !~c.indexOf( b[i] ) ) {
	  			c.push( b[i] );
	  		}
	  	}

	  	return c;
	  }

	  var selectorsPattern = /(?:^|\})?\s*([^\{\}]+)\s*\{/g;
	  var commentsPattern = /\/\*.*?\*\//g;
	  var selectorUnitPattern = /((?:(?:\[[^\]+]\])|(?:[^\s\+\>~:]))+)((?:::?[^\s\+\>\~\(:]+(?:\([^\)]+\))?)*\s*[\s\+\>\~]?)\s*/g;
	  var excludePattern = /^(?:@|\d+%)/;
	  var dataRvcGuidPattern = /\[data-ractive-css~="\{[a-z0-9-]+\}"]/g;

	  function trim$1 ( str ) {
	  	return str.trim();
	  }

	  function extractString ( unit ) {
	  	return unit.str;
	  }

	  function transformSelector ( selector, parent ) {
	  	var selectorUnits = [];
	  	var match;

	  	while ( match = selectorUnitPattern.exec( selector ) ) {
	  		selectorUnits.push({
	  			str: match[0],
	  			base: match[1],
	  			modifiers: match[2]
	  		});
	  	}

	  	// For each simple selector within the selector, we need to create a version
	  	// that a) combines with the id, and b) is inside the id
	  	var base = selectorUnits.map( extractString );

	  	var transformed = [];
	  	var i = selectorUnits.length;

	  	while ( i-- ) {
	  		var appended = base.slice();

	  		// Pseudo-selectors should go after the attribute selector
	  		var unit = selectorUnits[i];
	  		appended[i] = unit.base + parent + unit.modifiers || '';

	  		var prepended = base.slice();
	  		prepended[i] = parent + ' ' + prepended[i];

	  		transformed.push( appended.join( ' ' ), prepended.join( ' ' ) );
	  	}

	  	return transformed.join( ', ' );
	  }

	  function transformCss ( css, id ) {
	  	var dataAttr = "[data-ractive-css~=\"{" + id + "}\"]";

	  	var transformed;

	  	if ( dataRvcGuidPattern.test( css ) ) {
	  		transformed = css.replace( dataRvcGuidPattern, dataAttr );
	  	} else {
	  		transformed = css
	  		.replace( commentsPattern, '' )
	  		.replace( selectorsPattern, function ( match, $1 ) {
	  			// don't transform at-rules and keyframe declarations
	  			if ( excludePattern.test( $1 ) ) return match;

	  			var selectors = $1.split( ',' ).map( trim$1 );
	  			var transformed = selectors
	  				.map( function ( selector ) { return transformSelector( selector, dataAttr ); } )
	  				.join( ', ' ) + ' ';

	  			return match.replace( $1, transformed );
	  		});
	  	}

	  	return transformed;
	  }

	  function s4() {
	  	return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
	  }

	  function uuid() {
	  	return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
	  }

	  var cssConfigurator = {
	  	name: 'css',

	  	// Called when creating a new component definition
	  	extend: function ( Parent, proto, options ) {
	  		if ( !options.css ) return;

	  		var id = uuid();
	  		var styles = options.noCssTransform ? options.css : transformCss( options.css, id );

	  		proto.cssId = id;

	  		addCSS( { id: id, styles: styles } );

	  	},

	  	// Called when creating a new component instance
	  	init: function ( Parent, target, options ) {
	  		if ( !options.css ) return;

	  		warnIfDebug( ("\nThe css option is currently not supported on a per-instance basis and will be discarded. Instead, we recommend instantiating from a component definition with a css option.\n\nconst Component = Ractive.extend({\n\t...\n\tcss: '/* your css */',\n\t...\n});\n\nconst componentInstance = new Component({ ... })\n\t\t") );
	  	}

	  };

	  function bind$1 ( fn, context ) {
	  	if ( !/this/.test( fn.toString() ) ) return fn;

	  	var bound = fn.bind( context );
	  	for ( var prop in fn ) bound[ prop ] = fn[ prop ];

	  	return bound;
	  }

	  function validate ( data ) {
	  	// Warn if userOptions.data is a non-POJO
	  	if ( data && data.constructor !== Object ) {
	  		if ( typeof data === 'function' ) {
	  			// TODO do we need to support this in the new Ractive() case?
	  		} else if ( typeof data !== 'object' ) {
	  			fatal( ("data option must be an object or a function, `" + data + "` is not valid") );
	  		} else {
	  			warnIfDebug( 'If supplied, options.data should be a plain JavaScript object - using a non-POJO as the root object may work, but is discouraged' );
	  		}
	  	}
	  }

	  var dataConfigurator = {
	  	name: 'data',

	  	extend: function ( Parent, proto, options ) {
	  		var key;
	  		var value;

	  		// check for non-primitives, which could cause mutation-related bugs
	  		if ( options.data && isObject( options.data ) ) {
	  			for ( key in options.data ) {
	  				value = options.data[ key ];

	  				if ( value && typeof value === 'object' ) {
	  					if ( isObject( value ) || isArray( value ) ) {
	  						warnIfDebug( ("Passing a `data` option with object and array properties to Ractive.extend() is discouraged, as mutating them is likely to cause bugs. Consider using a data function instead:\n\n  // this...\n  data: function () {\n    return {\n      myObject: {}\n    };\n  })\n\n  // instead of this:\n  data: {\n    myObject: {}\n  }") );
	  					}
	  				}
	  			}
	  		}

	  		proto.data = combine$1( proto.data, options.data );
	  	},

	  	init: function ( Parent, ractive, options ) {
	  		var result = combine$1( Parent.prototype.data, options.data );

	  		if ( typeof result === 'function' ) result = result.call( ractive );

	  		// bind functions to the ractive instance at the top level,
	  		// unless it's a non-POJO (in which case alarm bells should ring)
	  		if ( result && result.constructor === Object ) {
	  			for ( var prop in result ) {
	  				if ( typeof result[ prop ] === 'function' ) result[ prop ] = bind$1( result[ prop ], ractive );
	  			}
	  		}

	  		return result || {};
	  	},

	  	reset: function ( ractive ) {
	  		var result = this.init( ractive.constructor, ractive, ractive.viewmodel );
	  		ractive.viewmodel.root.set( result );
	  		return true;
	  	}
	  };

	  function combine$1 ( parentValue, childValue ) {
	  	validate( childValue );

	  	var parentIsFn = typeof parentValue === 'function';
	  	var childIsFn = typeof childValue === 'function';

	  	// Very important, otherwise child instance can become
	  	// the default data object on Ractive or a component.
	  	// then ractive.set() ends up setting on the prototype!
	  	if ( !childValue && !parentIsFn ) {
	  		childValue = {};
	  	}

	  	// Fast path, where we just need to copy properties from
	  	// parent to child
	  	if ( !parentIsFn && !childIsFn ) {
	  		return fromProperties( childValue, parentValue );
	  	}

	  	return function () {
	  		var child = childIsFn ? callDataFunction( childValue, this ) : childValue;
	  		var parent = parentIsFn ? callDataFunction( parentValue, this ) : parentValue;

	  		return fromProperties( child, parent );
	  	};
	  }

	  function callDataFunction ( fn, context ) {
	  	var data = fn.call( context );

	  	if ( !data ) return;

	  	if ( typeof data !== 'object' ) {
	  		fatal( 'Data function must return an object' );
	  	}

	  	if ( data.constructor !== Object ) {
	  		warnOnceIfDebug( 'Data function returned something other than a plain JavaScript object. This might work, but is strongly discouraged' );
	  	}

	  	return data;
	  }

	  function fromProperties ( primary, secondary ) {
	  	if ( primary && secondary ) {
	  		for ( var key in secondary ) {
	  			if ( !( key in primary ) ) {
	  				primary[ key ] = secondary[ key ];
	  			}
	  		}

	  		return primary;
	  	}

	  	return primary || secondary;
	  }

	  var TEMPLATE_VERSION = 3;

	  var pattern = /\$\{([^\}]+)\}/g;

	  function fromExpression ( body, length ) {
	  	if ( length === void 0 ) length = 0;

	  	var args = new Array( length );

	  	while ( length-- ) {
	  		args[length] = "_" + length;
	  	}

	  	// Functions created directly with new Function() look like this:
	  	//     function anonymous (_0 /**/) { return _0*2 }
	  	//
	  	// With this workaround, we get a little more compact:
	  	//     function (_0){return _0*2}
	  	return new Function( [], ("return function (" + (args.join(',')) + "){return(" + body + ");};") )();
	  }

	  function fromComputationString ( str, bindTo ) {
	  	var hasThis;

	  	var functionBody = 'return (' + str.replace( pattern, function ( match, keypath ) {
	  		hasThis = true;
	  		return ("__ractive.get(\"" + keypath + "\")");
	  	}) + ');';

	  	if ( hasThis ) functionBody = "var __ractive = this; " + functionBody;
	  	var fn = new Function( functionBody );
	  	return hasThis ? fn.bind( bindTo ) : fn;
	  }

	  var functions = create( null );

	  function getFunction ( str, i ) {
	  	if ( functions[ str ] ) return functions[ str ];
	  	return functions[ str ] = createFunction( str, i );
	  }

	  function addFunctions( template ) {
	  	if ( !template ) return;

	  	var exp = template.e;

	  	if ( !exp ) return;

	  	Object.keys( exp ).forEach( function ( str ) {
	  		if ( functions[ str ] ) return;
	  		functions[ str ] = exp[ str ];
	  	});
	  }

	  var Parser;
	  var ParseError;
	  var leadingWhitespace = /^\s+/;
	  ParseError = function ( message ) {
	  	this.name = 'ParseError';
	  	this.message = message;
	  	try {
	  		throw new Error(message);
	  	} catch (e) {
	  		this.stack = e.stack;
	  	}
	  };

	  ParseError.prototype = Error.prototype;

	  Parser = function ( str, options ) {
	  	var this$1 = this;

	  	var items, item, lineStart = 0;

	  	this.str = str;
	  	this.options = options || {};
	  	this.pos = 0;

	  	this.lines = this.str.split( '\n' );
	  	this.lineEnds = this.lines.map( function ( line ) {
	  		var lineEnd = lineStart + line.length + 1; // +1 for the newline

	  		lineStart = lineEnd;
	  		return lineEnd;
	  	}, 0 );

	  	// Custom init logic
	  	if ( this.init ) this.init( str, options );

	  	items = [];

	  	while ( ( this$1.pos < this$1.str.length ) && ( item = this$1.read() ) ) {
	  		items.push( item );
	  	}

	  	this.leftover = this.remaining();
	  	this.result = this.postProcess ? this.postProcess( items, options ) : items;
	  };

	  Parser.prototype = {
	  	read: function ( converters ) {
	  		var this$1 = this;

	  		var pos, i, len, item;

	  		if ( !converters ) converters = this.converters;

	  		pos = this.pos;

	  		len = converters.length;
	  		for ( i = 0; i < len; i += 1 ) {
	  			this$1.pos = pos; // reset for each attempt

	  			if ( item = converters[i]( this$1 ) ) {
	  				return item;
	  			}
	  		}

	  		return null;
	  	},

	  	getLinePos: function ( char ) {
	  		var this$1 = this;

	  		var lineNum = 0, lineStart = 0, columnNum;

	  		while ( char >= this$1.lineEnds[ lineNum ] ) {
	  			lineStart = this$1.lineEnds[ lineNum ];
	  			lineNum += 1;
	  		}

	  		columnNum = char - lineStart;
	  		return [ lineNum + 1, columnNum + 1, char ]; // line/col should be one-based, not zero-based!
	  	},

	  	error: function ( message ) {
	  		var pos = this.getLinePos( this.pos );
	  		var lineNum = pos[0];
	  		var columnNum = pos[1];

	  		var line = this.lines[ pos[0] - 1 ];
	  		var numTabs = 0;
	  		var annotation = line.replace( /\t/g, function ( match, char ) {
	  			if ( char < pos[1] ) {
	  				numTabs += 1;
	  			}

	  			return '  ';
	  		}) + '\n' + new Array( pos[1] + numTabs ).join( ' ' ) + '^----';

	  		var error = new ParseError( ("" + message + " at line " + lineNum + " character " + columnNum + ":\n" + annotation) );

	  		error.line = pos[0];
	  		error.character = pos[1];
	  		error.shortMessage = message;

	  		throw error;
	  	},

	  	matchString: function ( string ) {
	  		if ( this.str.substr( this.pos, string.length ) === string ) {
	  			this.pos += string.length;
	  			return string;
	  		}
	  	},

	  	matchPattern: function ( pattern ) {
	  		var match;

	  		if ( match = pattern.exec( this.remaining() ) ) {
	  			this.pos += match[0].length;
	  			return match[1] || match[0];
	  		}
	  	},

	  	allowWhitespace: function () {
	  		this.matchPattern( leadingWhitespace );
	  	},

	  	remaining: function () {
	  		return this.str.substring( this.pos );
	  	},

	  	nextChar: function () {
	  		return this.str.charAt( this.pos );
	  	}
	  };

	  Parser.extend = function ( proto ) {
	  	var Parent = this, Child, key;

	  	Child = function ( str, options ) {
	  		Parser.call( this, str, options );
	  	};

	  	Child.prototype = create( Parent.prototype );

	  	for ( key in proto ) {
	  		if ( hasOwn.call( proto, key ) ) {
	  			Child.prototype[ key ] = proto[ key ];
	  		}
	  	}

	  	Child.extend = Parser.extend;
	  	return Child;
	  };

	  var Parser$1 = Parser;

	  var TEXT              = 1;
	  var INTERPOLATOR      = 2;
	  var TRIPLE            = 3;
	  var SECTION           = 4;
	  var INVERTED          = 5;
	  var CLOSING           = 6;
	  var ELEMENT           = 7;
	  var PARTIAL           = 8;
	  var COMMENT           = 9;
	  var DELIMCHANGE       = 10;
	  var CLOSING_TAG       = 14;
	  var COMPONENT         = 15;
	  var YIELDER           = 16;
	  var INLINE_PARTIAL    = 17;
	  var DOCTYPE           = 18;
	  var ALIAS             = 19;

	  var NUMBER_LITERAL    = 20;
	  var STRING_LITERAL    = 21;
	  var ARRAY_LITERAL     = 22;
	  var OBJECT_LITERAL    = 23;
	  var BOOLEAN_LITERAL   = 24;
	  var REGEXP_LITERAL    = 25;

	  var GLOBAL            = 26;
	  var KEY_VALUE_PAIR    = 27;


	  var REFERENCE         = 30;
	  var REFINEMENT        = 31;
	  var MEMBER            = 32;
	  var PREFIX_OPERATOR   = 33;
	  var BRACKETED         = 34;
	  var CONDITIONAL       = 35;
	  var INFIX_OPERATOR    = 36;

	  var INVOCATION        = 40;

	  var SECTION_IF        = 50;
	  var SECTION_UNLESS    = 51;
	  var SECTION_EACH      = 52;
	  var SECTION_WITH      = 53;
	  var SECTION_IF_WITH   = 54;

	  var ELSE              = 60;
	  var ELSEIF            = 61;

	  var delimiterChangePattern = /^[^\s=]+/;
	  var whitespacePattern = /^\s+/;
	  function readDelimiterChange ( parser ) {
	  	var start, opening, closing;

	  	if ( !parser.matchString( '=' ) ) {
	  		return null;
	  	}

	  	start = parser.pos;

	  	// allow whitespace before new opening delimiter
	  	parser.allowWhitespace();

	  	opening = parser.matchPattern( delimiterChangePattern );
	  	if ( !opening ) {
	  		parser.pos = start;
	  		return null;
	  	}

	  	// allow whitespace (in fact, it's necessary...)
	  	if ( !parser.matchPattern( whitespacePattern ) ) {
	  		return null;
	  	}

	  	closing = parser.matchPattern( delimiterChangePattern );
	  	if ( !closing ) {
	  		parser.pos = start;
	  		return null;
	  	}

	  	// allow whitespace before closing '='
	  	parser.allowWhitespace();

	  	if ( !parser.matchString( '=' ) ) {
	  		parser.pos = start;
	  		return null;
	  	}

	  	return [ opening, closing ];
	  }

	  var regexpPattern = /^(\/(?:[^\n\r\u2028\u2029/\\[]|\\.|\[(?:[^\n\r\u2028\u2029\]\\]|\\.)*])+\/(?:([gimuy])(?![a-z]*\2))*(?![a-zA-Z_$0-9]))/;

	  function readNumberLiteral ( parser ) {
	  	var result;

	  	if ( result = parser.matchPattern( regexpPattern ) ) {
	  		return {
	  			t: REGEXP_LITERAL,
	  			v: result
	  		};
	  	}

	  	return null;
	  }

	  var delimiterChangeToken = { t: DELIMCHANGE, exclude: true };

	  function readMustache ( parser ) {
	  	var mustache, i;

	  	// If we're inside a <script> or <style> tag, and we're not
	  	// interpolating, bug out
	  	if ( parser.interpolate[ parser.inside ] === false ) {
	  		return null;
	  	}

	  	for ( i = 0; i < parser.tags.length; i += 1 ) {
	  		if ( mustache = readMustacheOfType( parser, parser.tags[i] ) ) {
	  			return mustache;
	  		}
	  	}
	  }

	  function readMustacheOfType ( parser, tag ) {
	  	var start, mustache, reader, i;

	  	start = parser.pos;

	  	if ( parser.matchString( '\\' + tag.open ) ) {
	  		if ( start === 0 || parser.str[ start - 1 ] !== '\\' ) {
	  			return tag.open;
	  		}
	  	} else if ( !parser.matchString( tag.open ) ) {
	  		return null;
	  	}

	  	// delimiter change?
	  	if ( mustache = readDelimiterChange( parser ) ) {
	  		// find closing delimiter or abort...
	  		if ( !parser.matchString( tag.close ) ) {
	  			return null;
	  		}

	  		// ...then make the switch
	  		tag.open = mustache[0];
	  		tag.close = mustache[1];
	  		parser.sortMustacheTags();

	  		return delimiterChangeToken;
	  	}

	  	parser.allowWhitespace();

	  	// illegal section closer
	  	if ( parser.matchString( '/' ) ) {
	  		parser.pos -= 1;
	  		var rewind = parser.pos;
	  		if ( !readNumberLiteral( parser ) ) {
	  			parser.pos = rewind - ( tag.close.length );
	  			parser.error( 'Attempted to close a section that wasn\'t open' );
	  		} else {
	  			parser.pos = rewind;
	  		}
	  	}

	  	for ( i = 0; i < tag.readers.length; i += 1 ) {
	  		reader = tag.readers[i];

	  		if ( mustache = reader( parser, tag ) ) {
	  			if ( tag.isStatic ) {
	  				mustache.s = true; // TODO make this `1` instead - more compact
	  			}

	  			if ( parser.includeLinePositions ) {
	  				mustache.p = parser.getLinePos( start );
	  			}

	  			return mustache;
	  		}
	  	}

	  	parser.pos = start;
	  	return null;
	  }

	  var expectedExpression = 'Expected a JavaScript expression';
	  var expectedParen = 'Expected closing paren';

	  // bulletproof number regex from https://gist.github.com/Rich-Harris/7544330
	  var numberPattern = /^(?:[+-]?)0*(?:(?:(?:[1-9]\d*)?\.\d+)|(?:(?:0|[1-9]\d*)\.)|(?:0|[1-9]\d*))(?:[eE][+-]?\d+)?/;

	  function readNumberLiteral$1 ( parser ) {
	  	var result;

	  	if ( result = parser.matchPattern( numberPattern ) ) {
	  		return {
	  			t: NUMBER_LITERAL,
	  			v: result
	  		};
	  	}

	  	return null;
	  }

	  function readBooleanLiteral ( parser ) {
	  	var remaining = parser.remaining();

	  	if ( remaining.substr( 0, 4 ) === 'true' ) {
	  		parser.pos += 4;
	  		return {
	  			t: BOOLEAN_LITERAL,
	  			v: 'true'
	  		};
	  	}

	  	if ( remaining.substr( 0, 5 ) === 'false' ) {
	  		parser.pos += 5;
	  		return {
	  			t: BOOLEAN_LITERAL,
	  			v: 'false'
	  		};
	  	}

	  	return null;
	  }

	  var stringMiddlePattern;
	  var escapeSequencePattern;
	  var lineContinuationPattern;
	  // Match one or more characters until: ", ', \, or EOL/EOF.
	  // EOL/EOF is written as (?!.) (meaning there's no non-newline char next).
	  stringMiddlePattern = /^(?=.)[^"'\\]+?(?:(?!.)|(?=["'\\]))/;

	  // Match one escape sequence, including the backslash.
	  escapeSequencePattern = /^\\(?:['"\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;

	  // Match one ES5 line continuation (backslash + line terminator).
	  lineContinuationPattern = /^\\(?:\r\n|[\u000A\u000D\u2028\u2029])/;

	  // Helper for defining getDoubleQuotedString and getSingleQuotedString.
	  function makeQuotedStringMatcher ( okQuote ) {
	  	return function ( parser ) {
	  		var literal = '"';
	  		var done = false;
	  		var next;

	  		while ( !done ) {
	  			next = ( parser.matchPattern( stringMiddlePattern ) || parser.matchPattern( escapeSequencePattern ) ||
	  				parser.matchString( okQuote ) );
	  			if ( next ) {
	  				if ( next === ("\"") ) {
	  					literal += "\\\"";
	  				} else if ( next === ("\\'") ) {
	  					literal += "'";
	  				} else {
	  					literal += next;
	  				}
	  			} else {
	  				next = parser.matchPattern( lineContinuationPattern );
	  				if ( next ) {
	  					// convert \(newline-like) into a \u escape, which is allowed in JSON
	  					literal += '\\u' + ( '000' + next.charCodeAt(1).toString(16) ).slice( -4 );
	  				} else {
	  					done = true;
	  				}
	  			}
	  		}

	  		literal += '"';

	  		// use JSON.parse to interpret escapes
	  		return JSON.parse( literal );
	  	};
	  }

	  var getSingleQuotedString = makeQuotedStringMatcher( ("\"") );
	  var getDoubleQuotedString = makeQuotedStringMatcher( ("'") );

	  function readStringLiteral ( parser ) {
	  	var start, string;

	  	start = parser.pos;

	  	if ( parser.matchString( '"' ) ) {
	  		string = getDoubleQuotedString( parser );

	  		if ( !parser.matchString( '"' ) ) {
	  			parser.pos = start;
	  			return null;
	  		}

	  		return {
	  			t: STRING_LITERAL,
	  			v: string
	  		};
	  	}

	  	if ( parser.matchString( ("'") ) ) {
	  		string = getSingleQuotedString( parser );

	  		if ( !parser.matchString( ("'") ) ) {
	  			parser.pos = start;
	  			return null;
	  		}

	  		return {
	  			t: STRING_LITERAL,
	  			v: string
	  		};
	  	}

	  	return null;
	  }

	  var namePattern = /^[a-zA-Z_$][a-zA-Z_$0-9]*/;

	  var identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;

	  // http://mathiasbynens.be/notes/javascript-properties
	  // can be any name, string literal, or number literal
	  function readKey ( parser ) {
	  	var token;

	  	if ( token = readStringLiteral( parser ) ) {
	  		return identifier.test( token.v ) ? token.v : '"' + token.v.replace( /"/g, '\\"' ) + '"';
	  	}

	  	if ( token = readNumberLiteral$1( parser ) ) {
	  		return token.v;
	  	}

	  	if ( token = parser.matchPattern( namePattern ) ) {
	  		return token;
	  	}

	  	return null;
	  }

	  function readKeyValuePair ( parser ) {
	  	var start, key, value;

	  	start = parser.pos;

	  	// allow whitespace between '{' and key
	  	parser.allowWhitespace();

	  	var refKey = parser.nextChar() !== '\'' && parser.nextChar() !== '"';

	  	key = readKey( parser );
	  	if ( key === null ) {
	  		parser.pos = start;
	  		return null;
	  	}

	  	// allow whitespace between key and ':'
	  	parser.allowWhitespace();

	  	// es2015 shorthand property
	  	if ( refKey && ( parser.nextChar() === ',' || parser.nextChar() === '}' ) ) {
	  		if ( !namePattern.test( key ) ) {
	  			parser.error( ("Expected a valid reference, but found '" + key + "' instead.") );
	  		}

	  		return {
	  			t: KEY_VALUE_PAIR,
	  			k: key,
	  			v: {
	  				t: REFERENCE,
	  				n: key
	  			}
	  		};
	  	}

	  	// next character must be ':'
	  	if ( !parser.matchString( ':' ) ) {
	  		parser.pos = start;
	  		return null;
	  	}

	  	// allow whitespace between ':' and value
	  	parser.allowWhitespace();

	  	// next expression must be a, well... expression
	  	value = readExpression( parser );
	  	if ( value === null ) {
	  		parser.pos = start;
	  		return null;
	  	}

	  	return {
	  		t: KEY_VALUE_PAIR,
	  		k: key,
	  		v: value
	  	};
	  }

	  function readKeyValuePairs ( parser ) {
	  	var start, pairs, pair, keyValuePairs;

	  	start = parser.pos;

	  	pair = readKeyValuePair( parser );
	  	if ( pair === null ) {
	  		return null;
	  	}

	  	pairs = [ pair ];

	  	if ( parser.matchString( ',' ) ) {
	  		keyValuePairs = readKeyValuePairs( parser );

	  		if ( !keyValuePairs ) {
	  			parser.pos = start;
	  			return null;
	  		}

	  		return pairs.concat( keyValuePairs );
	  	}

	  	return pairs;
	  }

	  function readObjectLiteral ( parser ) {
	  	var start, keyValuePairs;

	  	start = parser.pos;

	  	// allow whitespace
	  	parser.allowWhitespace();

	  	if ( !parser.matchString( '{' ) ) {
	  		parser.pos = start;
	  		return null;
	  	}

	  	keyValuePairs = readKeyValuePairs( parser );

	  	// allow whitespace between final value and '}'
	  	parser.allowWhitespace();

	  	if ( !parser.matchString( '}' ) ) {
	  		parser.pos = start;
	  		return null;
	  	}

	  	return {
	  		t: OBJECT_LITERAL,
	  		m: keyValuePairs
	  	};
	  }

	  function readExpressionList ( parser ) {
	  	parser.allowWhitespace();

	  	var expr = readExpression( parser );

	  	if ( expr === null ) return null;

	  	var expressions = [ expr ];

	  	// allow whitespace between expression and ','
	  	parser.allowWhitespace();

	  	if ( parser.matchString( ',' ) ) {
	  		var next = readExpressionList( parser );
	  		if ( next === null ) parser.error( expectedExpression );

	  		expressions.push.apply( expressions, next );
	  	}

	  	return expressions;
	  }

	  function readArrayLiteral ( parser ) {
	  	var start, expressionList;

	  	start = parser.pos;

	  	// allow whitespace before '['
	  	parser.allowWhitespace();

	  	if ( !parser.matchString( '[' ) ) {
	  		parser.pos = start;
	  		return null;
	  	}

	  	expressionList = readExpressionList( parser );

	  	if ( !parser.matchString( ']' ) ) {
	  		parser.pos = start;
	  		return null;
	  	}

	  	return {
	  		t: ARRAY_LITERAL,
	  		m: expressionList
	  	};
	  }

	  function readLiteral ( parser ) {
	  	return readNumberLiteral$1( parser )  ||
	  	       readBooleanLiteral( parser ) ||
	  	       readStringLiteral( parser )  ||
	  	       readObjectLiteral( parser )  ||
	  	       readArrayLiteral( parser )   ||
	  	       readNumberLiteral( parser );
	  }

	  var prefixPattern = /^(?:~\/|(?:\.\.\/)+|\.\/(?:\.\.\/)*|\.)/;
	  var globals;
	  var keywords;
	  // if a reference is a browser global, we don't deference it later, so it needs special treatment
	  globals = /^(?:Array|console|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null|Object|Number|String|Boolean)\b/;

	  // keywords are not valid references, with the exception of `this`
	  keywords = /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/;

	  var legalReference = /^(?:[a-zA-Z$_0-9]|\\\.)+(?:(?:\.(?:[a-zA-Z$_0-9]|\\\.)+)|(?:\[[0-9]+\]))*/;
	  var relaxedName = /^[a-zA-Z_$][-\/a-zA-Z_$0-9]*/;

	  function readReference ( parser ) {
	  	var startPos, prefix, name, global, reference, fullLength, lastDotIndex;

	  	startPos = parser.pos;

	  	name = parser.matchPattern( /^@(?:keypath|rootpath|index|key|ractive|global)/ );

	  	if ( !name ) {
	  		prefix = parser.matchPattern( prefixPattern ) || '';
	  		name = ( !prefix && parser.relaxedNames && parser.matchPattern( relaxedName ) ) ||
	  		       parser.matchPattern( legalReference );

	  		if ( !name && prefix === '.' ) {
	  			prefix = '';
	  			name = '.';
	  		}
	  	}

	  	if ( !name ) {
	  		return null;
	  	}

	  	// bug out if it's a keyword (exception for ancestor/restricted refs - see https://github.com/ractivejs/ractive/issues/1497)
	  	if ( !prefix && !parser.relaxedNames && keywords.test( name ) ) {
	  		parser.pos = startPos;
	  		return null;
	  	}

	  	// if this is a browser global, stop here
	  	if ( !prefix && globals.test( name ) ) {
	  		global = globals.exec( name )[0];
	  		parser.pos = startPos + global.length;

	  		return {
	  			t: GLOBAL,
	  			v: global
	  		};
	  	}

	  	fullLength = ( prefix || '' ).length + name.length;
	  	reference = ( prefix || '' ) + normalise( name );

	  	if ( parser.matchString( '(' ) ) {
	  		// if this is a method invocation (as opposed to a function) we need
	  		// to strip the method name from the reference combo, else the context
	  		// will be wrong
	  		// but only if the reference was actually a member and not a refinement
	  		lastDotIndex = reference.lastIndexOf( '.' );
	  		if ( lastDotIndex !== -1 && name[ name.length - 1 ] !== ']' ) {
	  			var refLength = reference.length;
	  			reference = reference.substr( 0, lastDotIndex );
	  			parser.pos = startPos + (fullLength - ( refLength - lastDotIndex ) );
	  		} else {
	  			parser.pos -= 1;
	  		}
	  	}

	  	return {
	  		t: REFERENCE,
	  		n: reference.replace( /^this\./, './' ).replace( /^this$/, '.' )
	  	};
	  }

	  function readBracketedExpression ( parser ) {
	  	if ( !parser.matchString( '(' ) ) return null;

	  	parser.allowWhitespace();

	  	var expr = readExpression( parser );

	  	if ( !expr ) parser.error( expectedExpression );

	  	parser.allowWhitespace();

	  	if ( !parser.matchString( ')' ) ) parser.error( expectedParen );

	  	return {
	  		t: BRACKETED,
	  		x: expr
	  	};
	  }

	  function readPrimary ( parser ) {
	  	return readLiteral( parser )
	  		|| readReference( parser )
	  		|| readBracketedExpression( parser );
	  }

	  function readRefinement ( parser ) {
	  	// some things call for strict refinement (partial names), meaning no space between reference and refinement
	  	if ( !parser.strictRefinement ) {
	  		parser.allowWhitespace();
	  	}

	  	// "." name
	  	if ( parser.matchString( '.' ) ) {
	  		parser.allowWhitespace();

	  		var name = parser.matchPattern( namePattern );
	  		if ( name ) {
	  			return {
	  				t: REFINEMENT,
	  				n: name
	  			};
	  		}

	  		parser.error( 'Expected a property name' );
	  	}

	  	// "[" expression "]"
	  	if ( parser.matchString( '[' ) ) {
	  		parser.allowWhitespace();

	  		var expr = readExpression( parser );
	  		if ( !expr ) parser.error( expectedExpression );

	  		parser.allowWhitespace();

	  		if ( !parser.matchString( ']' ) ) parser.error( ("Expected ']'") );

	  		return {
	  			t: REFINEMENT,
	  			x: expr
	  		};
	  	}

	  	return null;
	  }

	  function readMemberOrInvocation ( parser ) {
	  	var expression = readPrimary( parser );

	  	if ( !expression ) return null;

	  	while ( expression ) {
	  		var refinement = readRefinement( parser );
	  		if ( refinement ) {
	  			expression = {
	  				t: MEMBER,
	  				x: expression,
	  				r: refinement
	  			};
	  		}

	  		else if ( parser.matchString( '(' ) ) {
	  			parser.allowWhitespace();
	  			var expressionList = readExpressionList( parser );

	  			parser.allowWhitespace();

	  			if ( !parser.matchString( ')' ) ) {
	  				parser.error( expectedParen );
	  			}

	  			expression = {
	  				t: INVOCATION,
	  				x: expression
	  			};

	  			if ( expressionList ) expression.o = expressionList;
	  		}

	  		else {
	  			break;
	  		}
	  	}

	  	return expression;
	  }

	  var readTypeOf;
	  var makePrefixSequenceMatcher;
	  makePrefixSequenceMatcher = function ( symbol, fallthrough ) {
	  	return function ( parser ) {
	  		var expression;

	  		if ( expression = fallthrough( parser ) ) {
	  			return expression;
	  		}

	  		if ( !parser.matchString( symbol ) ) {
	  			return null;
	  		}

	  		parser.allowWhitespace();

	  		expression = readExpression( parser );
	  		if ( !expression ) {
	  			parser.error( expectedExpression );
	  		}

	  		return {
	  			s: symbol,
	  			o: expression,
	  			t: PREFIX_OPERATOR
	  		};
	  	};
	  };

	  // create all prefix sequence matchers, return readTypeOf
	  (function() {
	  	var i, len, matcher, prefixOperators, fallthrough;

	  	prefixOperators = '! ~ + - typeof'.split( ' ' );

	  	fallthrough = readMemberOrInvocation;
	  	for ( i = 0, len = prefixOperators.length; i < len; i += 1 ) {
	  		matcher = makePrefixSequenceMatcher( prefixOperators[i], fallthrough );
	  		fallthrough = matcher;
	  	}

	  	// typeof operator is higher precedence than multiplication, so provides the
	  	// fallthrough for the multiplication sequence matcher we're about to create
	  	// (we're skipping void and delete)
	  	readTypeOf = fallthrough;
	  }());

	  var readTypeof = readTypeOf;

	  var readLogicalOr;
	  var makeInfixSequenceMatcher;
	  makeInfixSequenceMatcher = function ( symbol, fallthrough ) {
	  	return function ( parser ) {
	  		var start, left, right;

	  		left = fallthrough( parser );
	  		if ( !left ) {
	  			return null;
	  		}

	  		// Loop to handle left-recursion in a case like `a * b * c` and produce
	  		// left association, i.e. `(a * b) * c`.  The matcher can't call itself
	  		// to parse `left` because that would be infinite regress.
	  		while ( true ) {
	  			start = parser.pos;

	  			parser.allowWhitespace();

	  			if ( !parser.matchString( symbol ) ) {
	  				parser.pos = start;
	  				return left;
	  			}

	  			// special case - in operator must not be followed by [a-zA-Z_$0-9]
	  			if ( symbol === 'in' && /[a-zA-Z_$0-9]/.test( parser.remaining().charAt( 0 ) ) ) {
	  				parser.pos = start;
	  				return left;
	  			}

	  			parser.allowWhitespace();

	  			// right operand must also consist of only higher-precedence operators
	  			right = fallthrough( parser );
	  			if ( !right ) {
	  				parser.pos = start;
	  				return left;
	  			}

	  			left = {
	  				t: INFIX_OPERATOR,
	  				s: symbol,
	  				o: [ left, right ]
	  			};

	  			// Loop back around.  If we don't see another occurrence of the symbol,
	  			// we'll return left.
	  		}
	  	};
	  };

	  // create all infix sequence matchers, and return readLogicalOr
	  (function() {
	  	var i, len, matcher, infixOperators, fallthrough;

	  	// All the infix operators on order of precedence (source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence)
	  	// Each sequence matcher will initially fall through to its higher precedence
	  	// neighbour, and only attempt to match if one of the higher precedence operators
	  	// (or, ultimately, a literal, reference, or bracketed expression) already matched
	  	infixOperators = '* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||'.split( ' ' );

	  	// A typeof operator is higher precedence than multiplication
	  	fallthrough = readTypeof;
	  	for ( i = 0, len = infixOperators.length; i < len; i += 1 ) {
	  		matcher = makeInfixSequenceMatcher( infixOperators[i], fallthrough );
	  		fallthrough = matcher;
	  	}

	  	// Logical OR is the fallthrough for the conditional matcher
	  	readLogicalOr = fallthrough;
	  }());

	  var readLogicalOr$1 = readLogicalOr;

	  // The conditional operator is the lowest precedence operator, so we start here
	  function getConditional ( parser ) {
	  	var start, expression, ifTrue, ifFalse;

	  	expression = readLogicalOr$1( parser );
	  	if ( !expression ) {
	  		return null;
	  	}

	  	start = parser.pos;

	  	parser.allowWhitespace();

	  	if ( !parser.matchString( '?' ) ) {
	  		parser.pos = start;
	  		return expression;
	  	}

	  	parser.allowWhitespace();

	  	ifTrue = readExpression( parser );
	  	if ( !ifTrue ) {
	  		parser.error( expectedExpression );
	  	}

	  	parser.allowWhitespace();

	  	if ( !parser.matchString( ':' ) ) {
	  		parser.error( 'Expected ":"' );
	  	}

	  	parser.allowWhitespace();

	  	ifFalse = readExpression( parser );
	  	if ( !ifFalse ) {
	  		parser.error( expectedExpression );
	  	}

	  	return {
	  		t: CONDITIONAL,
	  		o: [ expression, ifTrue, ifFalse ]
	  	};
	  }

	  function readExpression ( parser ) {
	  	// The conditional operator is the lowest precedence operator (except yield,
	  	// assignment operators, and commas, none of which are supported), so we
	  	// start there. If it doesn't match, it 'falls through' to progressively
	  	// higher precedence operators, until it eventually matches (or fails to
	  	// match) a 'primary' - a literal or a reference. This way, the abstract syntax
	  	// tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.
	  	return getConditional( parser );
	  }

	  function flattenExpression ( expression ) {
	  	var refs;

	  	extractRefs( expression, refs = [] );

	  	return {
	  		r: refs,
	  		s: stringify( expression )
	  	};

	  	function stringify ( node ) {
	  		switch ( node.t ) {
	  			case BOOLEAN_LITERAL:
	  			case GLOBAL:
	  			case NUMBER_LITERAL:
	  			case REGEXP_LITERAL:
	  				return node.v;

	  			case STRING_LITERAL:
	  				return JSON.stringify( String( node.v ) );

	  			case ARRAY_LITERAL:
	  				return '[' + ( node.m ? node.m.map( stringify ).join( ',' ) : '' ) + ']';

	  			case OBJECT_LITERAL:
	  				return '{' + ( node.m ? node.m.map( stringify ).join( ',' ) : '' ) + '}';

	  			case KEY_VALUE_PAIR:
	  				return node.k + ':' + stringify( node.v );

	  			case PREFIX_OPERATOR:
	  				return ( node.s === 'typeof' ? 'typeof ' : node.s ) + stringify( node.o );

	  			case INFIX_OPERATOR:
	  				return stringify( node.o[0] ) + ( node.s.substr( 0, 2 ) === 'in' ? ' ' + node.s + ' ' : node.s ) + stringify( node.o[1] );

	  			case INVOCATION:
	  				return stringify( node.x ) + '(' + ( node.o ? node.o.map( stringify ).join( ',' ) : '' ) + ')';

	  			case BRACKETED:
	  				return '(' + stringify( node.x ) + ')';

	  			case MEMBER:
	  				return stringify( node.x ) + stringify( node.r );

	  			case REFINEMENT:
	  				return ( node.n ? '.' + node.n : '[' + stringify( node.x ) + ']' );

	  			case CONDITIONAL:
	  				return stringify( node.o[0] ) + '?' + stringify( node.o[1] ) + ':' + stringify( node.o[2] );

	  			case REFERENCE:
	  				return '_' + refs.indexOf( node.n );

	  			default:
	  				throw new Error( 'Expected legal JavaScript' );
	  		}
	  	}
	  }

	  // TODO maybe refactor this?
	  function extractRefs ( node, refs ) {
	  	var i, list;

	  	if ( node.t === REFERENCE ) {
	  		if ( refs.indexOf( node.n ) === -1 ) {
	  			refs.unshift( node.n );
	  		}
	  	}

	  	list = node.o || node.m;
	  	if ( list ) {
	  		if ( isObject( list ) ) {
	  			extractRefs( list, refs );
	  		} else {
	  			i = list.length;
	  			while ( i-- ) {
	  				extractRefs( list[i], refs );
	  			}
	  		}
	  	}

	  	if ( node.x ) {
	  		extractRefs( node.x, refs );
	  	}

	  	if ( node.r ) {
	  		extractRefs( node.r, refs );
	  	}

	  	if ( node.v ) {
	  		extractRefs( node.v, refs );
	  	}
	  }

	  function refineExpression ( expression, mustache ) {
	  	var referenceExpression;

	  	if ( expression ) {
	  		while ( expression.t === BRACKETED && expression.x ) {
	  			expression = expression.x;
	  		}

	  		if ( expression.t === REFERENCE ) {
	  			mustache.r = expression.n;
	  		} else {
	  			if ( referenceExpression = getReferenceExpression( expression ) ) {
	  				mustache.rx = referenceExpression;
	  			} else {
	  				mustache.x = flattenExpression( expression );
	  			}
	  		}

	  		return mustache;
	  	}
	  }

	  // TODO refactor this! it's bewildering
	  function getReferenceExpression ( expression ) {
	  	var members = [], refinement;

	  	while ( expression.t === MEMBER && expression.r.t === REFINEMENT ) {
	  		refinement = expression.r;

	  		if ( refinement.x ) {
	  			if ( refinement.x.t === REFERENCE ) {
	  				members.unshift( refinement.x );
	  			} else {
	  				members.unshift( flattenExpression( refinement.x ) );
	  			}
	  		} else {
	  			members.unshift( refinement.n );
	  		}

	  		expression = expression.x;
	  	}

	  	if ( expression.t !== REFERENCE ) {
	  		return null;
	  	}

	  	return {
	  		r: expression.n,
	  		m: members
	  	};
	  }

	  function readTriple ( parser, tag ) {
	  	var expression = readExpression( parser ), triple;

	  	if ( !expression ) {
	  		return null;
	  	}

	  	if ( !parser.matchString( tag.close ) ) {
	  		parser.error( ("Expected closing delimiter '" + (tag.close) + "'") );
	  	}

	  	triple = { t: TRIPLE };
	  	refineExpression( expression, triple ); // TODO handle this differently - it's mysterious

	  	return triple;
	  }

	  function readUnescaped ( parser, tag ) {
	  	var expression, triple;

	  	if ( !parser.matchString( '&' ) ) {
	  		return null;
	  	}

	  	parser.allowWhitespace();

	  	expression = readExpression( parser );

	  	if ( !expression ) {
	  		return null;
	  	}

	  	if ( !parser.matchString( tag.close ) ) {
	  		parser.error( ("Expected closing delimiter '" + (tag.close) + "'") );
	  	}

	  	triple = { t: TRIPLE };
	  	refineExpression( expression, triple ); // TODO handle this differently - it's mysterious

	  	return triple;
	  }

	  var legalAlias = /^(?:[a-zA-Z$_0-9]|\\\.)+(?:(?:(?:[a-zA-Z$_0-9]|\\\.)+)|(?:\[[0-9]+\]))*/;
	  var asRE = /^as/i;

	  function readAliases( parser ) {
	  	var aliases = [], alias, start = parser.pos;

	  	parser.allowWhitespace();

	  	alias = readAlias( parser );

	  	if ( alias ) {
	  		alias.x = refineExpression( alias.x, {} );
	  		aliases.push( alias );

	  		parser.allowWhitespace();

	  		while ( parser.matchString(',') ) {
	  			alias = readAlias( parser );

	  			if ( !alias ) {
	  				parser.error( 'Expected another alias.' );
	  			}

	  			alias.x = refineExpression( alias.x, {} );
	  			aliases.push( alias );

	  			parser.allowWhitespace();
	  		}

	  		return aliases;
	  	}

	  	parser.pos = start;
	  	return null;
	  }

	  function readAlias( parser ) {
	  	var expr, alias, start = parser.pos;

	  	parser.allowWhitespace();

	  	expr = readExpression( parser, [] );

	  	if ( !expr ) {
	  		parser.pos = start;
	  		return null;
	  	}

	  	parser.allowWhitespace();

	  	if ( !parser.matchPattern( asRE ) ) {
	  		parser.pos = start;
	  		return null;
	  	}

	  	parser.allowWhitespace();

	  	alias = parser.matchPattern( legalAlias );

	  	if ( !alias ) {
	  		parser.error( 'Expected a legal alias name.' );
	  	}

	  	return { n: alias, x: expr };
	  }

	  function readPartial ( parser, tag ) {
	  	if ( !parser.matchString( '>' ) ) return null;

	  	parser.allowWhitespace();

	  	// Partial names can include hyphens, so we can't use readExpression
	  	// blindly. Instead, we use the `relaxedNames` flag to indicate that
	  	// `foo-bar` should be read as a single name, rather than 'subtract
	  	// bar from foo'
	  	parser.relaxedNames = parser.strictRefinement = true;
	  	var expression = readExpression( parser );
	  	parser.relaxedNames = parser.strictRefinement = false;

	  	if ( !expression ) return null;

	  	var partial = { t: PARTIAL };
	  	refineExpression( expression, partial ); // TODO...

	  	parser.allowWhitespace();

	  	// check for alias context e.g. `{{>foo bar as bat, bip as bop}}` then
	  	// turn it into `{{#with bar as bat, bip as bop}}{{>foo}}{{/with}}`
	  	var aliases = readAliases( parser );
	  	if ( aliases ) {
	  		partial = {
	  			t: ALIAS,
	  			z: aliases,
	  			f: [ partial ]
	  		};
	  	}

	  	// otherwise check for literal context e.g. `{{>foo bar}}` then
	  	// turn it into `{{#with bar}}{{>foo}}{{/with}}`
	  	else {
	  		var context = readExpression( parser );
	  		if ( context) {
	  			partial = {
	  				t: SECTION,
	  				n: SECTION_WITH,
	  				f: [ partial ]
	  			};

	  			refineExpression( context, partial );
	  		}
	  	}

	  	parser.allowWhitespace();

	  	if ( !parser.matchString( tag.close ) ) {
	  		parser.error( ("Expected closing delimiter '" + (tag.close) + "'") );
	  	}

	  	return partial;
	  }

	  function readComment ( parser, tag ) {
	  	var index;

	  	if ( !parser.matchString( '!' ) ) {
	  		return null;
	  	}

	  	index = parser.remaining().indexOf( tag.close );

	  	if ( index !== -1 ) {
	  		parser.pos += index + tag.close.length;
	  		return { t: COMMENT };
	  	}
	  }

	  function readExpressionOrReference ( parser, expectedFollowers ) {
	  	var start, expression, i;

	  	start = parser.pos;
	  	expression = readExpression( parser );

	  	if ( !expression ) {
	  		// valid reference but invalid expression e.g. `{{new}}`?
	  		var ref = parser.matchPattern( /^(\w+)/ );
	  		if ( ref ) {
	  			return {
	  				t: REFERENCE,
	  				n: ref
	  			};
	  		}

	  		return null;
	  	}

	  	for ( i = 0; i < expectedFollowers.length; i += 1 ) {
	  		if ( parser.remaining().substr( 0, expectedFollowers[i].length ) === expectedFollowers[i] ) {
	  			return expression;
	  		}
	  	}

	  	parser.pos = start;
	  	return readReference( parser );
	  }

	  function readInterpolator ( parser, tag ) {
	  	var start, expression, interpolator, err;

	  	start = parser.pos;

	  	// TODO would be good for perf if we could do away with the try-catch
	  	try {
	  		expression = readExpressionOrReference( parser, [ tag.close ]);
	  	} catch ( e ) {
	  		err = e;
	  	}

	  	if ( !expression ) {
	  		if ( parser.str.charAt( start ) === '!' ) {
	  			// special case - comment
	  			parser.pos = start;
	  			return null;
	  		}

	  		if ( err ) {
	  			throw err;
	  		}
	  	}

	  	if ( !parser.matchString( tag.close ) ) {
	  		parser.error( ("Expected closing delimiter '" + (tag.close) + "' after reference") );

	  		if ( !expression ) {
	  			// special case - comment
	  			if ( parser.nextChar() === '!' ) {
	  				return null;
	  			}

	  			parser.error( ("Expected expression or legal reference") );
	  		}
	  	}

	  	interpolator = { t: INTERPOLATOR };
	  	refineExpression( expression, interpolator ); // TODO handle this differently - it's mysterious

	  	return interpolator;
	  }

	  var yieldPattern = /^yield\s*/;

	  function readYielder ( parser, tag ) {
	  	if ( !parser.matchPattern( yieldPattern ) ) return null;

	  	var name = parser.matchPattern( /^[a-zA-Z_$][a-zA-Z_$0-9\-]*/ );

	  	parser.allowWhitespace();

	  	if ( !parser.matchString( tag.close ) ) {
	  		parser.error( ("expected legal partial name") );
	  	}

	  	var yielder = { t: YIELDER };
	  	if ( name ) yielder.n = name;

	  	return yielder;
	  }

	  function readClosing ( parser, tag ) {
	  	var start, remaining, index, closing;

	  	start = parser.pos;

	  	if ( !parser.matchString( tag.open ) ) {
	  		return null;
	  	}

	  	parser.allowWhitespace();

	  	if ( !parser.matchString( '/' ) ) {
	  		parser.pos = start;
	  		return null;
	  	}

	  	parser.allowWhitespace();

	  	remaining = parser.remaining();
	  	index = remaining.indexOf( tag.close );

	  	if ( index !== -1 ) {
	  		closing = {
	  			t: CLOSING,
	  			r: remaining.substr( 0, index ).split( ' ' )[0]
	  		};

	  		parser.pos += index;

	  		if ( !parser.matchString( tag.close ) ) {
	  			parser.error( ("Expected closing delimiter '" + (tag.close) + "'") );
	  		}

	  		return closing;
	  	}

	  	parser.pos = start;
	  	return null;
	  }

	  var elsePattern = /^\s*else\s*/;

	  function readElse ( parser, tag ) {
	  	var start = parser.pos;

	  	if ( !parser.matchString( tag.open ) ) {
	  		return null;
	  	}

	  	if ( !parser.matchPattern( elsePattern ) ) {
	  		parser.pos = start;
	  		return null;
	  	}

	  	if ( !parser.matchString( tag.close ) ) {
	  		parser.error( ("Expected closing delimiter '" + (tag.close) + "'") );
	  	}

	  	return {
	  		t: ELSE
	  	};
	  }

	  var elsePattern$1 = /^\s*elseif\s+/;

	  function readElseIf ( parser, tag ) {
	  	var start = parser.pos;

	  	if ( !parser.matchString( tag.open ) ) {
	  		return null;
	  	}

	  	if ( !parser.matchPattern( elsePattern$1 ) ) {
	  		parser.pos = start;
	  		return null;
	  	}

	  	var expression = readExpression( parser );

	  	if ( !parser.matchString( tag.close ) ) {
	  		parser.error( ("Expected closing delimiter '" + (tag.close) + "'") );
	  	}

	  	return {
	  		t: ELSEIF,
	  		x: expression
	  	};
	  }

	  var handlebarsBlockCodes = {
	  	'each':    SECTION_EACH,
	  	'if':      SECTION_IF,
	  	'with':    SECTION_IF_WITH,
	  	'unless':  SECTION_UNLESS
	  };

	  var indexRefPattern = /^\s*:\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/;
	  var keyIndexRefPattern = /^\s*,\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/;
	  var handlebarsBlockPattern = new RegExp( '^(' + Object.keys( handlebarsBlockCodes ).join( '|' ) + ')\\b' );
	  function readSection ( parser, tag ) {
	  	var start, expression, section, child, children, hasElse, block, unlessBlock, conditions, closed, i, expectedClose, aliasOnly = false;

	  	start = parser.pos;

	  	if ( parser.matchString( '^' ) ) {
	  		section = { t: SECTION, f: [], n: SECTION_UNLESS };
	  	} else if ( parser.matchString( '#' ) ) {
	  		section = { t: SECTION, f: [] };

	  		if ( parser.matchString( 'partial' ) ) {
	  			parser.pos = start - parser.standardDelimiters[0].length;
	  			parser.error( 'Partial definitions can only be at the top level of the template, or immediately inside components' );
	  		}

	  		if ( block = parser.matchPattern( handlebarsBlockPattern ) ) {
	  			expectedClose = block;
	  			section.n = handlebarsBlockCodes[ block ];
	  		}
	  	} else {
	  		return null;
	  	}

	  	parser.allowWhitespace();

	  	if ( block === 'with' ) {
	  		var aliases = readAliases( parser );
	  		if ( aliases ) {
	  			aliasOnly = true;
	  			section.z = aliases;
	  			section.t = ALIAS;
	  		}
	  	} else if ( block === 'each' ) {
	  		var alias = readAlias( parser );
	  		if ( alias ) {
	  			section.z = [ { n: alias.n, x: { r: '.' } } ];
	  			expression = alias.x;
	  		}
	  	}

	  	if ( !aliasOnly ) {
	  		if ( !expression ) expression = readExpression( parser );

	  		if ( !expression ) {
	  			parser.error( 'Expected expression' );
	  		}

	  		// optional index and key references
	  		if ( i = parser.matchPattern( indexRefPattern ) ) {
	  			var extra;

	  			if ( extra = parser.matchPattern( keyIndexRefPattern ) ) {
	  				section.i = i + ',' + extra;
	  			} else {
	  				section.i = i;
	  			}
	  		}
	  	}

	  	parser.allowWhitespace();

	  	if ( !parser.matchString( tag.close ) ) {
	  		parser.error( ("Expected closing delimiter '" + (tag.close) + "'") );
	  	}

	  	parser.sectionDepth += 1;
	  	children = section.f;

	  	conditions = [];

	  	do {
	  		if ( child = readClosing( parser, tag ) ) {
	  			if ( expectedClose && child.r !== expectedClose ) {
	  				parser.error( ("Expected " + (tag.open) + "/" + expectedClose + "" + (tag.close)) );
	  			}

	  			parser.sectionDepth -= 1;
	  			closed = true;
	  		}

	  		else if ( !aliasOnly && ( child = readElseIf( parser, tag ) ) ) {
	  			if ( section.n === SECTION_UNLESS ) {
	  				parser.error( '{{else}} not allowed in {{#unless}}' );
	  			}

	  			if ( hasElse ) {
	  				parser.error( 'illegal {{elseif...}} after {{else}}' );
	  			}

	  			if ( !unlessBlock ) {
	  				unlessBlock = createUnlessBlock( expression );
	  			}

	  			unlessBlock.f.push({
	  				t: SECTION,
	  				n: SECTION_IF,
	  				x: flattenExpression( combine$2( conditions.concat( child.x ) ) ),
	  				f: children = []
	  			});

	  			conditions.push( invert( child.x ) );
	  		}

	  		else if ( !aliasOnly && ( child = readElse( parser, tag ) ) ) {
	  			if ( section.n === SECTION_UNLESS ) {
	  				parser.error( '{{else}} not allowed in {{#unless}}' );
	  			}

	  			if ( hasElse ) {
	  				parser.error( 'there can only be one {{else}} block, at the end of a section' );
	  			}

	  			hasElse = true;

	  			// use an unless block if there's no elseif
	  			if ( !unlessBlock ) {
	  				unlessBlock = createUnlessBlock( expression );
	  				children = unlessBlock.f;
	  			} else {
	  				unlessBlock.f.push({
	  					t: SECTION,
	  					n: SECTION_IF,
	  					x: flattenExpression( combine$2( conditions ) ),
	  					f: children = []
	  				});
	  			}
	  		}

	  		else {
	  			child = parser.read( READERS );

	  			if ( !child ) {
	  				break;
	  			}

	  			children.push( child );
	  		}
	  	} while ( !closed );

	  	if ( unlessBlock ) {
	  		section.l = unlessBlock;
	  	}

	  	if ( !aliasOnly ) {
	  		refineExpression( expression, section );
	  	}

	  	// TODO if a section is empty it should be discarded. Don't do
	  	// that here though - we need to clean everything up first, as
	  	// it may contain removeable whitespace. As a temporary measure,
	  	// to pass the existing tests, remove empty `f` arrays
	  	if ( !section.f.length ) {
	  		delete section.f;
	  	}

	  	return section;
	  }

	  function createUnlessBlock ( expression ) {
	  	var unlessBlock = {
	  		t: SECTION,
	  		n: SECTION_UNLESS,
	  		f: []
	  	};

	  	refineExpression( expression, unlessBlock );
	  	return unlessBlock;
	  }

	  function invert ( expression ) {
	  	if ( expression.t === PREFIX_OPERATOR && expression.s === '!' ) {
	  		return expression.o;
	  	}

	  	return {
	  		t: PREFIX_OPERATOR,
	  		s: '!',
	  		o: parensIfNecessary( expression )
	  	};
	  }

	  function combine$2 ( expressions ) {
	  	if ( expressions.length === 1 ) {
	  		return expressions[0];
	  	}

	  	return {
	  		t: INFIX_OPERATOR,
	  		s: '&&',
	  		o: [
	  			parensIfNecessary( expressions[0] ),
	  			parensIfNecessary( combine$2( expressions.slice( 1 ) ) )
	  		]
	  	};
	  }

	  function parensIfNecessary ( expression ) {
	  	// TODO only wrap if necessary
	  	return {
	  		t: BRACKETED,
	  		x: expression
	  	};
	  }

	  var OPEN_COMMENT = '<!--';
	  var CLOSE_COMMENT = '-->';
	  function readHtmlComment ( parser ) {
	  	var start, content, remaining, endIndex, comment;

	  	start = parser.pos;

	  	if ( !parser.matchString( OPEN_COMMENT ) ) {
	  		return null;
	  	}

	  	remaining = parser.remaining();
	  	endIndex = remaining.indexOf( CLOSE_COMMENT );

	  	if ( endIndex === -1 ) {
	  		parser.error( 'Illegal HTML - expected closing comment sequence (\'-->\')' );
	  	}

	  	content = remaining.substr( 0, endIndex );
	  	parser.pos += endIndex + 3;

	  	comment = {
	  		t: COMMENT,
	  		c: content
	  	};

	  	if ( parser.includeLinePositions ) {
	  		comment.p = parser.getLinePos( start );
	  	}

	  	return comment;
	  }

	  // https://github.com/kangax/html-minifier/issues/63#issuecomment-37763316
	  var booleanAttributes = /^(allowFullscreen|async|autofocus|autoplay|checked|compact|controls|declare|default|defaultChecked|defaultMuted|defaultSelected|defer|disabled|enabled|formNoValidate|hidden|indeterminate|inert|isMap|itemScope|loop|multiple|muted|noHref|noResize|noShade|noValidate|noWrap|open|pauseOnExit|readOnly|required|reversed|scoped|seamless|selected|sortable|translate|trueSpeed|typeMustMatch|visible)$/i;
	  var voidElementNames = /^(?:area|base|br|col|command|doctype|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;

	  var htmlEntities = { quot: 34, amp: 38, apos: 39, lt: 60, gt: 62, nbsp: 160, iexcl: 161, cent: 162, pound: 163, curren: 164, yen: 165, brvbar: 166, sect: 167, uml: 168, copy: 169, ordf: 170, laquo: 171, not: 172, shy: 173, reg: 174, macr: 175, deg: 176, plusmn: 177, sup2: 178, sup3: 179, acute: 180, micro: 181, para: 182, middot: 183, cedil: 184, sup1: 185, ordm: 186, raquo: 187, frac14: 188, frac12: 189, frac34: 190, iquest: 191, Agrave: 192, Aacute: 193, Acirc: 194, Atilde: 195, Auml: 196, Aring: 197, AElig: 198, Ccedil: 199, Egrave: 200, Eacute: 201, Ecirc: 202, Euml: 203, Igrave: 204, Iacute: 205, Icirc: 206, Iuml: 207, ETH: 208, Ntilde: 209, Ograve: 210, Oacute: 211, Ocirc: 212, Otilde: 213, Ouml: 214, times: 215, Oslash: 216, Ugrave: 217, Uacute: 218, Ucirc: 219, Uuml: 220, Yacute: 221, THORN: 222, szlig: 223, agrave: 224, aacute: 225, acirc: 226, atilde: 227, auml: 228, aring: 229, aelig: 230, ccedil: 231, egrave: 232, eacute: 233, ecirc: 234, euml: 235, igrave: 236, iacute: 237, icirc: 238, iuml: 239, eth: 240, ntilde: 241, ograve: 242, oacute: 243, ocirc: 244, otilde: 245, ouml: 246, divide: 247, oslash: 248, ugrave: 249, uacute: 250, ucirc: 251, uuml: 252, yacute: 253, thorn: 254, yuml: 255, OElig: 338, oelig: 339, Scaron: 352, scaron: 353, Yuml: 376, fnof: 402, circ: 710, tilde: 732, Alpha: 913, Beta: 914, Gamma: 915, Delta: 916, Epsilon: 917, Zeta: 918, Eta: 919, Theta: 920, Iota: 921, Kappa: 922, Lambda: 923, Mu: 924, Nu: 925, Xi: 926, Omicron: 927, Pi: 928, Rho: 929, Sigma: 931, Tau: 932, Upsilon: 933, Phi: 934, Chi: 935, Psi: 936, Omega: 937, alpha: 945, beta: 946, gamma: 947, delta: 948, epsilon: 949, zeta: 950, eta: 951, theta: 952, iota: 953, kappa: 954, lambda: 955, mu: 956, nu: 957, xi: 958, omicron: 959, pi: 960, rho: 961, sigmaf: 962, sigma: 963, tau: 964, upsilon: 965, phi: 966, chi: 967, psi: 968, omega: 969, thetasym: 977, upsih: 978, piv: 982, ensp: 8194, emsp: 8195, thinsp: 8201, zwnj: 8204, zwj: 8205, lrm: 8206, rlm: 8207, ndash: 8211, mdash: 8212, lsquo: 8216, rsquo: 8217, sbquo: 8218, ldquo: 8220, rdquo: 8221, bdquo: 8222, dagger: 8224, Dagger: 8225, bull: 8226, hellip: 8230, permil: 8240, prime: 8242, Prime: 8243, lsaquo: 8249, rsaquo: 8250, oline: 8254, frasl: 8260, euro: 8364, image: 8465, weierp: 8472, real: 8476, trade: 8482, alefsym: 8501, larr: 8592, uarr: 8593, rarr: 8594, darr: 8595, harr: 8596, crarr: 8629, lArr: 8656, uArr: 8657, rArr: 8658, dArr: 8659, hArr: 8660, forall: 8704, part: 8706, exist: 8707, empty: 8709, nabla: 8711, isin: 8712, notin: 8713, ni: 8715, prod: 8719, sum: 8721, minus: 8722, lowast: 8727, radic: 8730, prop: 8733, infin: 8734, ang: 8736, and: 8743, or: 8744, cap: 8745, cup: 8746, 'int': 8747, there4: 8756, sim: 8764, cong: 8773, asymp: 8776, ne: 8800, equiv: 8801, le: 8804, ge: 8805, sub: 8834, sup: 8835, nsub: 8836, sube: 8838, supe: 8839, oplus: 8853, otimes: 8855, perp: 8869, sdot: 8901, lceil: 8968, rceil: 8969, lfloor: 8970, rfloor: 8971, lang: 9001, rang: 9002, loz: 9674, spades: 9824, clubs: 9827, hearts: 9829, diams: 9830	};
	  var controlCharacters = [ 8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376 ];
	  var entityPattern = new RegExp( '&(#?(?:x[\\w\\d]+|\\d+|' + Object.keys( htmlEntities ).join( '|' ) + '));?', 'g' );
	  var codePointSupport = typeof String.fromCodePoint === 'function';
	  var codeToChar = codePointSupport ? String.fromCodePoint : String.fromCharCode;

	  function decodeCharacterReferences ( html ) {
	  	return html.replace( entityPattern, function ( match, entity ) {
	  		var code;

	  		// Handle named entities
	  		if ( entity[0] !== '#' ) {
	  			code = htmlEntities[ entity ];
	  		} else if ( entity[1] === 'x' ) {
	  			code = parseInt( entity.substring( 2 ), 16 );
	  		} else {
	  			code = parseInt( entity.substring( 1 ), 10 );
	  		}

	  		if ( !code ) {
	  			return match;
	  		}

	  		return codeToChar( validateCode( code ) );
	  	});
	  }

	  var lessThan = /</g;
	  var greaterThan = />/g;
	  var amp = /&/g;
	  var invalid = 65533;

	  function escapeHtml ( str ) {
	  	return str
	  		.replace( amp, '&amp;' )
	  		.replace( lessThan, '&lt;' )
	  		.replace( greaterThan, '&gt;' );
	  }

	  // some code points are verboten. If we were inserting HTML, the browser would replace the illegal
	  // code points with alternatives in some cases - since we're bypassing that mechanism, we need
	  // to replace them ourselves
	  //
	  // Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters
	  function validateCode ( code ) {
	  	if ( !code ) {
	  		return invalid;
	  	}

	  	// line feed becomes generic whitespace
	  	if ( code === 10 ) {
	  		return 32;
	  	}

	  	// ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)
	  	if ( code < 128 ) {
	  		return code;
	  	}

	  	// code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need
	  	// to correct the mistake or we'll end up with missing € signs and so on
	  	if ( code <= 159 ) {
	  		return controlCharacters[ code - 128 ];
	  	}

	  	// basic multilingual plane
	  	if ( code < 55296 ) {
	  		return code;
	  	}

	  	// UTF-16 surrogate halves
	  	if ( code <= 57343 ) {
	  		return invalid;
	  	}

	  	// rest of the basic multilingual plane
	  	if ( code <= 65535 ) {
	  		return code;
	  	} else if ( !codePointSupport ) {
	  		return invalid;
	  	}

	  	// supplementary multilingual plane 0x10000 - 0x1ffff
	  	if ( code >= 65536 && code <= 131071 ) {
	  		return code;
	  	}

	  	// supplementary ideographic plane 0x20000 - 0x2ffff
	  	if ( code >= 131072 && code <= 196607 ) {
	  		return code;
	  	}

	  	return invalid;
	  }

	  var leadingLinebreak = /^[ \t\f\r\n]*\r?\n/;
	  var trailingLinebreak = /\r?\n[ \t\f\r\n]*$/;
	  function stripStandalones ( items ) {
	  	var i, current, backOne, backTwo, lastSectionItem;

	  	for ( i=1; i<items.length; i+=1 ) {
	  		current = items[i];
	  		backOne = items[i-1];
	  		backTwo = items[i-2];

	  		// if we're at the end of a [text][comment][text] sequence...
	  		if ( isString( current ) && isComment( backOne ) && isString( backTwo ) ) {

	  			// ... and the comment is a standalone (i.e. line breaks either side)...
	  			if ( trailingLinebreak.test( backTwo ) && leadingLinebreak.test( current ) ) {

	  				// ... then we want to remove the whitespace after the first line break
	  				items[i-2] = backTwo.replace( trailingLinebreak, '\n' );

	  				// and the leading line break of the second text token
	  				items[i] = current.replace( leadingLinebreak, '' );
	  			}
	  		}

	  		// if the current item is a section, and it is preceded by a linebreak, and
	  		// its first item is a linebreak...
	  		if ( isSection( current ) && isString( backOne ) ) {
	  			if ( trailingLinebreak.test( backOne ) && isString( current.f[0] ) && leadingLinebreak.test( current.f[0] ) ) {
	  				items[i-1] = backOne.replace( trailingLinebreak, '\n' );
	  				current.f[0] = current.f[0].replace( leadingLinebreak, '' );
	  			}
	  		}

	  		// if the last item was a section, and it is followed by a linebreak, and
	  		// its last item is a linebreak...
	  		if ( isString( current ) && isSection( backOne ) ) {
	  			lastSectionItem = lastItem( backOne.f );

	  			if ( isString( lastSectionItem ) && trailingLinebreak.test( lastSectionItem ) && leadingLinebreak.test( current ) ) {
	  				backOne.f[ backOne.f.length - 1 ] = lastSectionItem.replace( trailingLinebreak, '\n' );
	  				items[i] = current.replace( leadingLinebreak, '' );
	  			}
	  		}
	  	}

	  	return items;
	  }

	  function isString ( item ) {
	  	return typeof item === 'string';
	  }

	  function isComment ( item ) {
	  	return item.t === COMMENT || item.t === DELIMCHANGE;
	  }

	  function isSection ( item ) {
	  	return ( item.t === SECTION || item.t === INVERTED ) && item.f;
	  }

	  function trimWhitespace ( items, leadingPattern, trailingPattern ) {
	  	var item;

	  	if ( leadingPattern ) {
	  		item = items[0];
	  		if ( typeof item === 'string' ) {
	  			item = item.replace( leadingPattern, '' );

	  			if ( !item ) {
	  				items.shift();
	  			} else {
	  				items[0] = item;
	  			}
	  		}
	  	}

	  	if ( trailingPattern ) {
	  		item = lastItem( items );
	  		if ( typeof item === 'string' ) {
	  			item = item.replace( trailingPattern, '' );

	  			if ( !item ) {
	  				items.pop();
	  			} else {
	  				items[ items.length - 1 ] = item;
	  			}
	  		}
	  	}
	  }

	  var contiguousWhitespace = /[ \t\f\r\n]+/g;
	  var preserveWhitespaceElements = /^(?:pre|script|style|textarea)$/i;
	  var leadingWhitespace$1 = /^[ \t\f\r\n]+/;
	  var trailingWhitespace = /[ \t\f\r\n]+$/;
	  var leadingNewLine = /^(?:\r\n|\r|\n)/;
	  var trailingNewLine = /(?:\r\n|\r|\n)$/;

	  function cleanup ( items, stripComments, preserveWhitespace, removeLeadingWhitespace, removeTrailingWhitespace ) {
	  	var i,
	  		item,
	  		previousItem,
	  		nextItem,
	  		preserveWhitespaceInsideFragment,
	  		removeLeadingWhitespaceInsideFragment,
	  		removeTrailingWhitespaceInsideFragment,
	  		key;

	  	// First pass - remove standalones and comments etc
	  	stripStandalones( items );

	  	i = items.length;
	  	while ( i-- ) {
	  		item = items[i];

	  		// Remove delimiter changes, unsafe elements etc
	  		if ( item.exclude ) {
	  			items.splice( i, 1 );
	  		}

	  		// Remove comments, unless we want to keep them
	  		else if ( stripComments && item.t === COMMENT ) {
	  			items.splice( i, 1 );
	  		}
	  	}

	  	// If necessary, remove leading and trailing whitespace
	  	trimWhitespace( items, removeLeadingWhitespace ? leadingWhitespace$1 : null, removeTrailingWhitespace ? trailingWhitespace : null );

	  	i = items.length;
	  	while ( i-- ) {
	  		item = items[i];

	  		// Recurse
	  		if ( item.f ) {
	  			var isPreserveWhitespaceElement = item.t === ELEMENT && preserveWhitespaceElements.test( item.e );
	  			preserveWhitespaceInsideFragment = preserveWhitespace || isPreserveWhitespaceElement;

	  			if ( !preserveWhitespace && isPreserveWhitespaceElement ) {
	  				trimWhitespace( item.f, leadingNewLine, trailingNewLine );
	  			}

	  			if ( !preserveWhitespaceInsideFragment ) {
	  				previousItem = items[ i - 1 ];
	  				nextItem = items[ i + 1 ];

	  				// if the previous item was a text item with trailing whitespace,
	  				// remove leading whitespace inside the fragment
	  				if ( !previousItem || ( typeof previousItem === 'string' && trailingWhitespace.test( previousItem ) ) ) {
	  					removeLeadingWhitespaceInsideFragment = true;
	  				}

	  				// and vice versa
	  				if ( !nextItem || ( typeof nextItem === 'string' && leadingWhitespace$1.test( nextItem ) ) ) {
	  					removeTrailingWhitespaceInsideFragment = true;
	  				}
	  			}

	  			cleanup( item.f, stripComments, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );
	  		}

	  		// Split if-else blocks into two (an if, and an unless)
	  		if ( item.l ) {
	  			cleanup( item.l.f, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );

	  			items.splice( i + 1, 0, item.l );
	  			delete item.l; // TODO would be nice if there was a way around this
	  		}

	  		// Clean up element attributes
	  		if ( item.a ) {
	  			for ( key in item.a ) {
	  				if ( item.a.hasOwnProperty( key ) && typeof item.a[ key ] !== 'string' ) {
	  					cleanup( item.a[ key ], stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );
	  				}
	  			}
	  		}

	  		// Clean up conditional attributes
	  		if ( item.m ) {
	  			cleanup( item.m, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );
	  		}

	  		// Clean up event handlers
	  		if ( item.v ) {
	  			for ( key in item.v ) {
	  				if ( item.v.hasOwnProperty( key ) ) {
	  					// clean up names
	  					if ( isArray( item.v[ key ].n ) ) {
	  						cleanup( item.v[ key ].n, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );
	  					}

	  					// clean up params
	  					if ( isArray( item.v[ key ].d ) ) {
	  						cleanup( item.v[ key ].d, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );
	  					}
	  				}
	  			}
	  		}
	  	}

	  	// final pass - fuse text nodes together
	  	i = items.length;
	  	while ( i-- ) {
	  		if ( typeof items[i] === 'string' ) {
	  			if ( typeof items[i+1] === 'string' ) {
	  				items[i] = items[i] + items[i+1];
	  				items.splice( i + 1, 1 );
	  			}

	  			if ( !preserveWhitespace ) {
	  				items[i] = items[i].replace( contiguousWhitespace, ' ' );
	  			}

	  			if ( items[i] === '' ) {
	  				items.splice( i, 1 );
	  			}
	  		}
	  	}
	  }

	  var closingTagPattern = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\-]*)\s*\>/;

	  function readClosingTag ( parser ) {
	  	var start, tag;

	  	start = parser.pos;

	  	// are we looking at a closing tag?
	  	if ( !parser.matchString( '</' ) ) {
	  		return null;
	  	}

	  	if ( tag = parser.matchPattern( closingTagPattern ) ) {
	  		if ( parser.inside && tag !== parser.inside ) {
	  			parser.pos = start;
	  			return null;
	  		}

	  		return {
	  			t: CLOSING_TAG,
	  			e: tag
	  		};
	  	}

	  	// We have an illegal closing tag, report it
	  	parser.pos -= 2;
	  	parser.error( 'Illegal closing tag' );
	  }

	  var pattern$1 = /[-/\\^$*+?.()|[\]{}]/g;

	  function escapeRegExp ( str ) {
	  	return str.replace( pattern$1, '\\$&' );
	  }

	  var regExpCache = {};

	  function getLowestIndex ( haystack, needles ) {
	  	return haystack.search( regExpCache[needles.join()] || ( regExpCache[needles.join()] = new RegExp( needles.map( escapeRegExp ).join( '|' ) ) ) );
	  }

	  var attributeNamePattern = /^[^\s"'>\/=]+/;
	  var unquotedAttributeValueTextPattern = /^[^\s"'=<>`]+/;
	  function readAttribute ( parser ) {
	  	var attr, name, value;

	  	parser.allowWhitespace();

	  	name = parser.matchPattern( attributeNamePattern );
	  	if ( !name ) {
	  		return null;
	  	}

	  	attr = { name: name };

	  	value = readAttributeValue( parser );
	  	if ( value != null ) { // not null/undefined
	  		attr.value = value;
	  	}

	  	return attr;
	  }

	  function readAttributeValue ( parser ) {
	  	var start, valueStart, startDepth, value;

	  	start = parser.pos;

	  	// next character must be `=`, `/`, `>` or whitespace
	  	if ( !/[=\/>\s]/.test( parser.nextChar() ) ) {
	  		parser.error( 'Expected `=`, `/`, `>` or whitespace' );
	  	}

	  	parser.allowWhitespace();

	  	if ( !parser.matchString( '=' ) ) {
	  		parser.pos = start;
	  		return null;
	  	}

	  	parser.allowWhitespace();

	  	valueStart = parser.pos;
	  	startDepth = parser.sectionDepth;

	  	value = readQuotedAttributeValue( parser, ("'") ) ||
	  			readQuotedAttributeValue( parser, ("\"") ) ||
	  			readUnquotedAttributeValue( parser );

	  	if ( value === null ) {
	  		parser.error( 'Expected valid attribute value' );
	  	}

	  	if ( parser.sectionDepth !== startDepth ) {
	  		parser.pos = valueStart;
	  		parser.error( 'An attribute value must contain as many opening section tags as closing section tags' );
	  	}

	  	if ( !value.length ) {
	  		return '';
	  	}

	  	if ( value.length === 1 && typeof value[0] === 'string' ) {
	  		return decodeCharacterReferences( value[0] );
	  	}

	  	return value;
	  }

	  function readUnquotedAttributeValueToken ( parser ) {
	  	var start, text, haystack, needles, index;

	  	start = parser.pos;

	  	text = parser.matchPattern( unquotedAttributeValueTextPattern );

	  	if ( !text ) {
	  		return null;
	  	}

	  	haystack = text;
	  	needles = parser.tags.map( function ( t ) { return t.open; } ); // TODO refactor... we do this in readText.js as well

	  	if ( ( index = getLowestIndex( haystack, needles ) ) !== -1 ) {
	  		text = text.substr( 0, index );
	  		parser.pos = start + text.length;
	  	}

	  	return text;
	  }

	  function readUnquotedAttributeValue ( parser ) {
	  	var tokens, token;

	  	parser.inAttribute = true;

	  	tokens = [];

	  	token = readMustache( parser ) || readUnquotedAttributeValueToken( parser );
	  	while ( token !== null ) {
	  		tokens.push( token );
	  		token = readMustache( parser ) || readUnquotedAttributeValueToken( parser );
	  	}

	  	if ( !tokens.length ) {
	  		return null;
	  	}

	  	parser.inAttribute = false;
	  	return tokens;
	  }

	  function readQuotedAttributeValue ( parser, quoteMark ) {
	  	var start, tokens, token;

	  	start = parser.pos;

	  	if ( !parser.matchString( quoteMark ) ) {
	  		return null;
	  	}

	  	parser.inAttribute = quoteMark;

	  	tokens = [];

	  	token = readMustache( parser ) || readQuotedStringToken( parser, quoteMark );
	  	while ( token !== null ) {
	  		tokens.push( token );
	  		token = readMustache( parser ) || readQuotedStringToken( parser, quoteMark );
	  	}

	  	if ( !parser.matchString( quoteMark ) ) {
	  		parser.pos = start;
	  		return null;
	  	}

	  	parser.inAttribute = false;

	  	return tokens;
	  }

	  function readQuotedStringToken ( parser, quoteMark ) {
	  	var haystack = parser.remaining();

	  	var needles = parser.tags.map( function ( t ) { return t.open; } ); // TODO refactor... we do this in readText.js as well
	  	needles.push( quoteMark );

	  	var index = getLowestIndex( haystack, needles );

	  	if ( index === -1 ) {
	  		parser.error( 'Quoted attribute value must have a closing quote' );
	  	}

	  	if ( !index ) {
	  		return null;
	  	}

	  	parser.pos += index;
	  	return haystack.substr( 0, index );
	  }

	  // simple JSON parser, without the restrictions of JSON parse
	  // (i.e. having to double-quote keys).
	  //
	  // If passed a hash of values as the second argument, ${placeholders}
	  // will be replaced with those values

	  var specials = {
	  	'true': true,
	  	'false': false,
	  	'null': null,
	  	undefined: undefined
	  };

	  var specialsPattern = new RegExp( '^(?:' + Object.keys( specials ).join( '|' ) + ')' );
	  var numberPattern$1 = /^(?:[+-]?)(?:(?:(?:0|[1-9]\d*)?\.\d+)|(?:(?:0|[1-9]\d*)\.)|(?:0|[1-9]\d*))(?:[eE][+-]?\d+)?/;
	  var placeholderPattern = /\$\{([^\}]+)\}/g;
	  var placeholderAtStartPattern = /^\$\{([^\}]+)\}/;
	  var onlyWhitespace = /^\s*$/;

	  var JsonParser = Parser$1.extend({
	  	init: function ( str, options ) {
	  		this.values = options.values;
	  		this.allowWhitespace();
	  	},

	  	postProcess: function ( result ) {
	  		if ( result.length !== 1 || !onlyWhitespace.test( this.leftover ) ) {
	  			return null;
	  		}

	  		return { value: result[0].v };
	  	},

	  	converters: [
	  		function getPlaceholder ( parser ) {
	  			if ( !parser.values ) return null;

	  			var placeholder = parser.matchPattern( placeholderAtStartPattern );

	  			if ( placeholder && ( parser.values.hasOwnProperty( placeholder ) ) ) {
	  				return { v: parser.values[ placeholder ] };
	  			}
	  		},

	  		function getSpecial ( parser ) {
	  			var special = parser.matchPattern( specialsPattern );
	  			if ( special ) return { v: specials[ special ] };
	  		},

	  		function getNumber ( parser ) {
	  			var number = parser.matchPattern( numberPattern$1 );
	  			if ( number ) return { v: +number };
	  		},

	  		function getString ( parser ) {
	  			var stringLiteral = readStringLiteral( parser );
	  			var values = parser.values;

	  			if ( stringLiteral && values ) {
	  				return {
	  					v: stringLiteral.v.replace( placeholderPattern, function ( match, $1 ) { return ( $1 in values ? values[ $1 ] : $1 ); } )
	  				};
	  			}

	  			return stringLiteral;
	  		},

	  		function getObject ( parser ) {
	  			if ( !parser.matchString( '{' ) ) return null;

	  			var result = {};

	  			parser.allowWhitespace();

	  			if ( parser.matchString( '}' ) ) {
	  				return { v: result };
	  			}

	  			var pair;
	  			while ( pair = getKeyValuePair( parser ) ) {
	  				result[ pair.key ] = pair.value;

	  				parser.allowWhitespace();

	  				if ( parser.matchString( '}' ) ) {
	  					return { v: result };
	  				}

	  				if ( !parser.matchString( ',' ) ) {
	  					return null;
	  				}
	  			}

	  			return null;
	  		},

	  		function getArray ( parser ) {
	  			if ( !parser.matchString( '[' ) ) return null;

	  			var result = [];

	  			parser.allowWhitespace();

	  			if ( parser.matchString( ']' ) ) {
	  				return { v: result };
	  			}

	  			var valueToken;
	  			while ( valueToken = parser.read() ) {
	  				result.push( valueToken.v );

	  				parser.allowWhitespace();

	  				if ( parser.matchString( ']' ) ) {
	  					return { v: result };
	  				}

	  				if ( !parser.matchString( ',' ) ) {
	  					return null;
	  				}

	  				parser.allowWhitespace();
	  			}

	  			return null;
	  		}
	  	]
	  });

	  function getKeyValuePair ( parser ) {
	  	parser.allowWhitespace();

	  	var key = readKey( parser );

	  	if ( !key ) return null;

	  	var pair = { key: key };

	  	parser.allowWhitespace();
	  	if ( !parser.matchString( ':' ) ) {
	  		return null;
	  	}
	  	parser.allowWhitespace();

	  	var valueToken = parser.read();

	  	if ( !valueToken ) return null;

	  	pair.value = valueToken.v;
	  	return pair;
	  }

	  function parseJSON ( str, values ) {
	  	var parser = new JsonParser( str, { values: values });
	  	return parser.result;
	  }

	  var methodCallPattern = /^([a-zA-Z_$][a-zA-Z_$0-9]*)\(/;
	  var methodCallExcessPattern = /\)\s*$/;
	  var spreadPattern = /(\s*,{0,1}\s*\.{3}arguments\s*)$/;
	  var ExpressionParser;
	  ExpressionParser = Parser$1.extend({
	  	converters: [ readExpression ]
	  });

	  // TODO clean this up, it's shocking
	  function processDirective ( tokens, parentParser ) {
	  	var result,
	  		match,
	  		token,
	  		colonIndex,
	  		directiveName,
	  		directiveArgs,
	  		parsed;

	  	if ( typeof tokens === 'string' ) {
	  		if ( match = methodCallPattern.exec( tokens ) ) {
	  			var end = tokens.lastIndexOf(')');

	  			// check for invalid method calls
	  			if ( !methodCallExcessPattern.test( tokens ) ) {
	  				parentParser.error( ("Invalid input after method call expression '" + (tokens.slice(end + 1)) + "'") );
	  			}

	  			result = { m: match[1] };
	  			var sliced = tokens.slice( result.m.length + 1, end );

	  			// does the method include spread of ...arguments?
	  			var args = sliced.replace( spreadPattern, '' );

	  			// if so, other arguments should be appended to end of method arguments
	  			if ( sliced !== args ) {
	  				result.g = true;
	  			}

	  			if ( args ) {
	  				var parser = new ExpressionParser( '[' + args + ']' );
	  				result.a = flattenExpression( parser.result[0] );
	  			}

	  			return result;
	  		}

	  		if ( tokens.indexOf( ':' ) === -1 ) {
	  			return tokens.trim();
	  		}

	  		tokens = [ tokens ];
	  	}

	  	result = {};

	  	directiveName = [];
	  	directiveArgs = [];

	  	if ( tokens ) {
	  		while ( tokens.length ) {
	  			token = tokens.shift();

	  			if ( typeof token === 'string' ) {
	  				colonIndex = token.indexOf( ':' );

	  				if ( colonIndex === -1 ) {
	  					directiveName.push( token );
	  				} else {
	  					// is the colon the first character?
	  					if ( colonIndex ) {
	  						// no
	  						directiveName.push( token.substr( 0, colonIndex ) );
	  					}

	  					// if there is anything after the colon in this token, treat
	  					// it as the first token of the directiveArgs fragment
	  					if ( token.length > colonIndex + 1 ) {
	  						directiveArgs[0] = token.substring( colonIndex + 1 );
	  					}

	  					break;
	  				}
	  			}

	  			else {
	  				directiveName.push( token );
	  			}
	  		}

	  		directiveArgs = directiveArgs.concat( tokens );
	  	}

	  	if ( !directiveName.length ) {
	  		result = '';
	  	} else if ( directiveArgs.length || typeof directiveName !== 'string' ) {
	  		result = {
	  			// TODO is this really necessary? just use the array
	  			n: ( directiveName.length === 1 && typeof directiveName[0] === 'string' ? directiveName[0] : directiveName )
	  		};

	  		if ( directiveArgs.length === 1 && typeof directiveArgs[0] === 'string' ) {
	  			parsed = parseJSON( '[' + directiveArgs[0] + ']' );
	  			result.a = parsed ? parsed.value : [ directiveArgs[0].trim() ];
	  		}

	  		else {
	  			result.d = directiveArgs;
	  		}
	  	} else {
	  		result = directiveName;
	  	}

	  	return result;
	  }

	  var tagNamePattern = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\-]*/;
	  var validTagNameFollower = /^[\s\n\/>]/;
	  var onPattern = /^on/;
	  var proxyEventPattern = /^on-([a-zA-Z\\*\\.$_][a-zA-Z\\*\\.$_0-9\-]+)$/;
	  var reservedEventNames = /^(?:change|reset|teardown|update|construct|config|init|render|unrender|detach|insert)$/;
	  var directives = { 'intro-outro': 't0', intro: 't1', outro: 't2', decorator: 'o' };
	  var exclude = { exclude: true };
	  var disallowedContents;
	  // based on http://developers.whatwg.org/syntax.html#syntax-tag-omission
	  disallowedContents = {
	  	li: [ 'li' ],
	  	dt: [ 'dt', 'dd' ],
	  	dd: [ 'dt', 'dd' ],
	  	p: 'address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul'.split( ' ' ),
	  	rt: [ 'rt', 'rp' ],
	  	rp: [ 'rt', 'rp' ],
	  	optgroup: [ 'optgroup' ],
	  	option: [ 'option', 'optgroup' ],
	  	thead: [ 'tbody', 'tfoot' ],
	  	tbody: [ 'tbody', 'tfoot' ],
	  	tfoot: [ 'tbody' ],
	  	tr: [ 'tr', 'tbody' ],
	  	td: [ 'td', 'th', 'tr' ],
	  	th: [ 'td', 'th', 'tr' ]
	  };

	  function readElement ( parser ) {
	  	var start,
	  		element,
	  		directiveName,
	  		match,
	  		addProxyEvent,
	  		attribute,
	  		directive,
	  		selfClosing,
	  		children,
	  		partials,
	  		hasPartials,
	  		child,
	  		closed,
	  		pos,
	  		remaining,
	  		closingTag;

	  	start = parser.pos;

	  	if ( parser.inside || parser.inAttribute ) {
	  		return null;
	  	}

	  	if ( !parser.matchString( '<' ) ) {
	  		return null;
	  	}

	  	// if this is a closing tag, abort straight away
	  	if ( parser.nextChar() === '/' ) {
	  		return null;
	  	}

	  	element = {};
	  	if ( parser.includeLinePositions ) {
	  		element.p = parser.getLinePos( start );
	  	}

	  	if ( parser.matchString( '!' ) ) {
	  		element.t = DOCTYPE;
	  		if ( !parser.matchPattern( /^doctype/i ) ) {
	  			parser.error( 'Expected DOCTYPE declaration' );
	  		}

	  		element.a = parser.matchPattern( /^(.+?)>/ );
	  		return element;
	  	}

	  	element.t = ELEMENT;

	  	// element name
	  	element.e = parser.matchPattern( tagNamePattern );
	  	if ( !element.e ) {
	  		return null;
	  	}

	  	// next character must be whitespace, closing solidus or '>'
	  	if ( !validTagNameFollower.test( parser.nextChar() ) ) {
	  		parser.error( 'Illegal tag name' );
	  	}

	  	addProxyEvent = function ( name, directive ) {
	  		var directiveName = directive.n || directive;

	  		if ( reservedEventNames.test( directiveName ) ) {
	  			parser.pos -= directiveName.length;
	  			parser.error( 'Cannot use reserved event names (change, reset, teardown, update, construct, config, init, render, unrender, detach, insert)' );
	  		}

	  		element.v[ name ] = directive;
	  	};

	  	parser.allowWhitespace();

	  	// directives and attributes
	  	while ( attribute = readMustache( parser ) || readAttribute( parser ) ) {
	  		// regular attributes
	  		if ( attribute.name ) {
	  			// intro, outro, decorator
	  			if ( directiveName = directives[ attribute.name ] ) {
	  				element[ directiveName ] = processDirective( attribute.value, parser );
	  			}

	  			// on-click etc
	  			else if ( match = proxyEventPattern.exec( attribute.name ) ) {
	  				if ( !element.v ) element.v = {};
	  				directive = processDirective( attribute.value, parser );
	  				addProxyEvent( match[1], directive );
	  			}

	  			else {
	  				if ( !parser.sanitizeEventAttributes || !onPattern.test( attribute.name ) ) {
	  					if ( !element.a ) element.a = {};
	  					element.a[ attribute.name ] = attribute.value || ( attribute.value === '' ? '' : 0 );
	  				}
	  			}
	  		}

	  		// {{#if foo}}class='foo'{{/if}}
	  		else {
	  			if ( !element.m ) element.m = [];
	  			element.m.push( attribute );
	  		}

	  		parser.allowWhitespace();
	  	}

	  	// allow whitespace before closing solidus
	  	parser.allowWhitespace();

	  	// self-closing solidus?
	  	if ( parser.matchString( '/' ) ) {
	  		selfClosing = true;
	  	}

	  	// closing angle bracket
	  	if ( !parser.matchString( '>' ) ) {
	  		return null;
	  	}

	  	var lowerCaseName = element.e.toLowerCase();
	  	var preserveWhitespace = parser.preserveWhitespace;

	  	if ( !selfClosing && !voidElementNames.test( element.e ) ) {
	  		parser.elementStack.push( lowerCaseName );

	  		// Special case - if we open a script element, further tags should
	  		// be ignored unless they're a closing script element
	  		if ( lowerCaseName === 'script' || lowerCaseName === 'style' || lowerCaseName === 'textarea' ) {
	  			parser.inside = lowerCaseName;
	  		}

	  		children = [];
	  		partials = create( null );

	  		do {
	  			pos = parser.pos;
	  			remaining = parser.remaining();

	  			if ( !remaining ) {
	  				parser.error( ("Missing end " + (parser.elementStack.length > 1 ? 'tags' : 'tag') + " (" + (parser.elementStack.reverse().map( function ( x ) { return ("</" + x + ">"); } ).join( '' )) + ")") );
	  			}

	  			// if for example we're in an <li> element, and we see another
	  			// <li> tag, close the first so they become siblings
	  			if ( !canContain( lowerCaseName, remaining ) ) {
	  				closed = true;
	  			}

	  			// closing tag
	  			else if ( closingTag = readClosingTag( parser ) ) {
	  				closed = true;

	  				var closingTagName = closingTag.e.toLowerCase();

	  				// if this *isn't* the closing tag for the current element...
	  				if ( closingTagName !== lowerCaseName ) {
	  					// rewind parser
	  					parser.pos = pos;

	  					// if it doesn't close a parent tag, error
	  					if ( !~parser.elementStack.indexOf( closingTagName ) ) {
	  						var errorMessage = 'Unexpected closing tag';

	  						// add additional help for void elements, since component names
	  						// might clash with them
	  						if ( voidElementNames.test( closingTagName ) ) {
	  							errorMessage += " (<" + closingTagName + "> is a void element - it cannot contain children)";
	  						}

	  						parser.error( errorMessage );
	  					}
	  				}
	  			}

	  			// implicit close by closing section tag. TODO clean this up
	  			else if ( child = readClosing( parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] } ) ) {
	  				closed = true;
	  				parser.pos = pos;
	  			}

	  			else {
	  				if ( child = parser.read( PARTIAL_READERS ) ) {
	  					if ( partials[ child.n ] ) {
	  						parser.pos = pos;
	  						parser.error( 'Duplicate partial definition' );
	  					}

	  					cleanup( child.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace );

	  					partials[ child.n ] = child.f;
	  					hasPartials = true;
	  				}

	  				else {
	  					if ( child = parser.read( READERS ) ) {
	  						children.push( child );
	  					} else {
	  						closed = true;
	  					}
	  				}
	  			}
	  		} while ( !closed );

	  		if ( children.length ) {
	  			element.f = children;
	  		}

	  		if ( hasPartials ) {
	  			element.p = partials;
	  		}

	  		parser.elementStack.pop();
	  	}

	  	parser.inside = null;

	  	if ( parser.sanitizeElements && parser.sanitizeElements.indexOf( lowerCaseName ) !== -1 ) {
	  		return exclude;
	  	}

	  	return element;
	  }

	  function canContain ( name, remaining ) {
	  	var match, disallowed;

	  	match = /^<([a-zA-Z][a-zA-Z0-9]*)/.exec( remaining );
	  	disallowed = disallowedContents[ name ];

	  	if ( !match || !disallowed ) {
	  		return true;
	  	}

	  	return !~disallowed.indexOf( match[1].toLowerCase() );
	  }

	  function readText ( parser ) {
	  	var index, remaining, disallowed, barrier;

	  	remaining = parser.remaining();

	  	if ( parser.textOnlyMode ) {
	  		disallowed = parser.tags.map( function ( t ) { return t.open; } );
	  		disallowed = disallowed.concat( parser.tags.map( function ( t ) { return '\\' + t.open; } ) );

	  		index = getLowestIndex( remaining, disallowed );
	  	} else {
	  		barrier = parser.inside ? '</' + parser.inside : '<';

	  		if ( parser.inside && !parser.interpolate[ parser.inside ] ) {
	  			index = remaining.indexOf( barrier );
	  		} else {
	  			disallowed = parser.tags.map( function ( t ) { return t.open; } );
	  			disallowed = disallowed.concat( parser.tags.map( function ( t ) { return '\\' + t.open; } ) );

	  			// http://developers.whatwg.org/syntax.html#syntax-attributes
	  			if ( parser.inAttribute === true ) {
	  				// we're inside an unquoted attribute value
	  				disallowed.push( ("\""), ("'"), ("="), ("<"), (">"), '`' );
	  			} else if ( parser.inAttribute ) {
	  				// quoted attribute value
	  				disallowed.push( parser.inAttribute );
	  			} else {
	  				disallowed.push( barrier );
	  			}

	  			index = getLowestIndex( remaining, disallowed );
	  		}
	  	}

	  	if ( !index ) {
	  		return null;
	  	}

	  	if ( index === -1 ) {
	  		index = remaining.length;
	  	}

	  	parser.pos += index;

	  	if ( ( parser.inside && parser.inside !== 'textarea' ) || parser.textOnlyMode ) {
	  		return remaining.substr( 0, index );
	  	} else {
	  		return decodeCharacterReferences( remaining.substr( 0, index ) );
	  	}
	  }

	  var startPattern = /^<!--\s*/;
	  var namePattern$1 = /s*>\s*([a-zA-Z_$][-a-zA-Z_$0-9]*)\s*/;
	  var finishPattern = /\s*-->/;

	  function readPartialDefinitionComment ( parser ) {
	  	var start = parser.pos;
	  	var open = parser.standardDelimiters[0];
	  	var close = parser.standardDelimiters[1];

	  	if ( !parser.matchPattern( startPattern ) || !parser.matchString( open ) ) {
	  		parser.pos = start;
	  		return null;
	  	}

	  	var name = parser.matchPattern( namePattern$1 );

	  	warnOnceIfDebug( ("Inline partial comments are deprecated.\nUse this...\n  {{#partial " + name + "}} ... {{/partial}}\n\n...instead of this:\n  <!-- {{>" + name + "}} --> ... <!-- {{/" + name + "}} -->'") );

	  	// make sure the rest of the comment is in the correct place
	  	if ( !parser.matchString( close ) || !parser.matchPattern( finishPattern ) ) {
	  		parser.pos = start;
	  		return null;
	  	}

	  	var content = [];
	  	var closed;

	  	var endPattern = new RegExp('^<!--\\s*' + escapeRegExp( open ) + '\\s*\\/\\s*' + name + '\\s*' + escapeRegExp( close ) + '\\s*-->');

	  	do {
	  		if ( parser.matchPattern( endPattern ) ) {
	  			closed = true;
	  		}

	  		else {
	  			var child = parser.read( READERS );
	  			if ( !child ) {
	  				parser.error( ("expected closing comment ('<!-- " + open + "/" + name + "" + close + " -->')") );
	  			}

	  			content.push( child );
	  		}
	  	} while ( !closed );

	  	return {
	  		t: INLINE_PARTIAL,
	  		f: content,
	  		n: name
	  	};
	  }

	  var partialDefinitionSectionPattern = /^#\s*partial\s+/;

	  function readPartialDefinitionSection ( parser ) {
	  	var start, name, content, child, closed;

	  	start = parser.pos;

	  	var delimiters = parser.standardDelimiters;

	  	if ( !parser.matchString( delimiters[0] ) ) {
	  		return null;
	  	}

	  	if ( !parser.matchPattern( partialDefinitionSectionPattern ) ) {
	  		parser.pos = start;
	  		return null;
	  	}

	  	name = parser.matchPattern( /^[a-zA-Z_$][a-zA-Z_$0-9\-\/]*/ );

	  	if ( !name ) {
	  		parser.error( 'expected legal partial name' );
	  	}

	  	if ( !parser.matchString( delimiters[1] ) ) {
	  		parser.error( ("Expected closing delimiter '" + (delimiters[1]) + "'") );
	  	}

	  	content = [];

	  	do {
	  		// TODO clean this up
	  		if ( child = readClosing( parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] }) ) {
	  			if ( !child.r === 'partial' ) {
	  				parser.error( ("Expected " + (delimiters[0]) + "/partial" + (delimiters[1])) );
	  			}

	  			closed = true;
	  		}

	  		else {
	  			child = parser.read( READERS );

	  			if ( !child ) {
	  				parser.error( ("Expected " + (delimiters[0]) + "/partial" + (delimiters[1])) );
	  			}

	  			content.push( child );
	  		}
	  	} while ( !closed );

	  	return {
	  		t: INLINE_PARTIAL,
	  		n: name,
	  		f: content
	  	};
	  }

	  function readTemplate ( parser ) {
	  	var fragment = [];
	  	var partials = create( null );
	  	var hasPartials = false;

	  	var preserveWhitespace = parser.preserveWhitespace;

	  	while ( parser.pos < parser.str.length ) {
	  		var pos = parser.pos, item, partial;

	  		if ( partial = parser.read( PARTIAL_READERS ) ) {
	  			if ( partials[ partial.n ] ) {
	  				parser.pos = pos;
	  				parser.error( 'Duplicated partial definition' );
	  			}

	  			cleanup( partial.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace );

	  			partials[ partial.n ] = partial.f;
	  			hasPartials = true;
	  		} else if ( item = parser.read( READERS ) ) {
	  			fragment.push( item );
	  		} else  {
	  			parser.error( 'Unexpected template content' );
	  		}
	  	}

	  	var result = {
	  		v: TEMPLATE_VERSION,
	  		t: fragment
	  	};

	  	if ( hasPartials ) {
	  		result.p = partials;
	  	}

	  	return result;
	  }

	  function insertExpressions ( obj, expr ) {

	  	Object.keys( obj ).forEach( function ( key ) {
	  		if  ( isExpression( key, obj ) ) return addTo( obj, expr );

	  		var ref = obj[ key ];
	  		if ( hasChildren( ref ) ) insertExpressions( ref, expr );
	   	});
	  }

	  function isExpression( key, obj ) {
	  	return key === 's' && isArray( obj.r );
	  }

	  function addTo( obj, expr ) {
	  	var s = obj.s, r = obj.r;
	  	if ( !expr[ s ] ) expr[ s ] = fromExpression( s, r.length );
	  }

	  function hasChildren( ref ) {
	  	return isArray( ref ) || isObject( ref );
	  }

	  // See https://github.com/ractivejs/template-spec for information
	  // about the Ractive template specification

	  var STANDARD_READERS = [ readPartial, readUnescaped, readSection, readYielder, readInterpolator, readComment ];
	  var TRIPLE_READERS = [ readTriple ];
	  var STATIC_READERS = [ readUnescaped, readSection, readInterpolator ]; // TODO does it make sense to have a static section?

	  var StandardParser;

	  function parse ( template, options ) {
	  	return new StandardParser( template, options || {} ).result;
	  }

	  parse.computedStrings = function( computed ) {
	  	if ( !computed ) return [];

	  	Object.keys( computed ).forEach( function ( key ) {
	  		var value = computed[ key ];
	  		if ( typeof value === 'string' ) {
	  			computed[ key ] = fromComputationString( value );
	  		}
	  	});
	  };


	  var READERS = [ readMustache, readHtmlComment, readElement, readText ];
	  var PARTIAL_READERS = [ readPartialDefinitionComment, readPartialDefinitionSection ];

	  StandardParser = Parser$1.extend({
	  	init: function ( str, options ) {
	  		var tripleDelimiters = options.tripleDelimiters || [ '{{{', '}}}' ],
	  			staticDelimiters = options.staticDelimiters || [ '[[', ']]' ],
	  			staticTripleDelimiters = options.staticTripleDelimiters || [ '[[[', ']]]' ];

	  		this.standardDelimiters = options.delimiters || [ '{{', '}}' ];

	  		this.tags = [
	  			{ isStatic: false, isTriple: false, open: this.standardDelimiters[0], close: this.standardDelimiters[1], readers: STANDARD_READERS },
	  			{ isStatic: false, isTriple: true,  open: tripleDelimiters[0],        close: tripleDelimiters[1],        readers: TRIPLE_READERS },
	  			{ isStatic: true,  isTriple: false, open: staticDelimiters[0],        close: staticDelimiters[1],        readers: STATIC_READERS },
	  			{ isStatic: true,  isTriple: true,  open: staticTripleDelimiters[0],  close: staticTripleDelimiters[1],  readers: TRIPLE_READERS }
	  		];

	  		this.sortMustacheTags();

	  		this.sectionDepth = 0;
	  		this.elementStack = [];

	  		this.interpolate = {
	  			script: !options.interpolate || options.interpolate.script !== false,
	  			style: !options.interpolate || options.interpolate.style !== false,
	  			textarea: true
	  		};

	  		if ( options.sanitize === true ) {
	  			options.sanitize = {
	  				// blacklist from https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json
	  				elements: 'applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title'.split( ' ' ),
	  				eventAttributes: true
	  			};
	  		}

	  		this.stripComments = options.stripComments !== false;
	  		this.preserveWhitespace = options.preserveWhitespace;
	  		this.sanitizeElements = options.sanitize && options.sanitize.elements;
	  		this.sanitizeEventAttributes = options.sanitize && options.sanitize.eventAttributes;
	  		this.includeLinePositions = options.includeLinePositions;
	  		this.textOnlyMode = options.textOnlyMode;
	  		this.csp = options.csp;
	  	},

	  	postProcess: function ( result ) {
	  		// special case - empty string
	  		if ( !result.length ) {
	  			return { t: [], v: TEMPLATE_VERSION };
	  		}

	  		if ( this.sectionDepth > 0 ) {
	  			this.error( 'A section was left open' );
	  		}

	  		cleanup( result[0].t, this.stripComments, this.preserveWhitespace, !this.preserveWhitespace, !this.preserveWhitespace );

	  		if ( this.csp !== false ) {
	  			var expr = {};
	  			insertExpressions( result[0].t, expr );
	  			if ( Object.keys( expr ).length ) result[0].e = expr;
	  		}

	  		return result[0];
	  	},

	  	converters: [
	  		readTemplate
	  	],

	  	sortMustacheTags: function () {
	  		// Sort in order of descending opening delimiter length (longer first),
	  		// to protect against opening delimiters being substrings of each other
	  		this.tags.sort( function ( a, b ) {
	  			return b.open.length - a.open.length;
	  		});
	  	}
	  });

	  var parseOptions = [
	  	'delimiters',
	  	'tripleDelimiters',
	  	'staticDelimiters',
	  	'staticTripleDelimiters',
	  	'csp',
	  	'interpolate',
	  	'preserveWhitespace',
	  	'sanitize',
	  	'stripComments'
	  ];

	  var TEMPLATE_INSTRUCTIONS = "Either preparse or use a ractive runtime source that includes the parser. ";

	  var COMPUTATION_INSTRUCTIONS = "Either use:\n\n\tRactive.parse.computedStrings( component.computed )\n\nat build time to pre-convert the strings to functions, or use functions instead of strings in computed properties.";


	  function throwNoParse ( method, error, instructions ) {
	  	if ( !method ) {
	  		fatal( ("Missing Ractive.parse - cannot parse " + error + ". " + instructions) );
	  	}
	  }

	  function createFunction ( body, length ) {
	  	throwNoParse( fromExpression, 'new expression function', TEMPLATE_INSTRUCTIONS );
	  	return fromExpression( body, length );
	  }

	  function createFunctionFromString ( str, bindTo ) {
	  	throwNoParse( fromComputationString, 'compution string "${str}"', COMPUTATION_INSTRUCTIONS );
	  	return fromComputationString( str, bindTo );
	  }

	  var parser = {

	  	fromId: function ( id, options ) {
	  		if ( !doc ) {
	  			if ( options && options.noThrow ) { return; }
	  			throw new Error( ("Cannot retrieve template #" + id + " as Ractive is not running in a browser.") );
	  		}

	  		if ( id ) id = id.replace( /^#/, '' );

	  		var template;

	  		if ( !( template = doc.getElementById( id ) )) {
	  			if ( options && options.noThrow ) { return; }
	  			throw new Error( ("Could not find template element with id #" + id) );
	  		}

	  		if ( template.tagName.toUpperCase() !== 'SCRIPT' ) {
	  			if ( options && options.noThrow ) { return; }
	  			throw new Error( ("Template element with id #" + id + ", must be a <script> element") );
	  		}

	  		return ( 'textContent' in template ? template.textContent : template.innerHTML );

	  	},

	  	isParsed: function ( template) {
	  		return !( typeof template === 'string' );
	  	},

	  	getParseOptions: function ( ractive ) {
	  		// Could be Ractive or a Component
	  		if ( ractive.defaults ) { ractive = ractive.defaults; }

	  		return parseOptions.reduce( function ( val, key ) {
	  			val[ key ] = ractive[ key ];
	  			return val;
	  		}, {});
	  	},

	  	parse: function ( template, options ) {
	  		throwNoParse( parse, 'template', TEMPLATE_INSTRUCTIONS );
	  		var parsed = parse( template, options );
	  		addFunctions( parsed );
	  		return parsed;
	  	},

	  	parseFor: function( template, ractive ) {
	  		return this.parse( template, this.getParseOptions( ractive ) );
	  	}
	  };

	  var templateConfigurator = {
	  	name: 'template',

	  	extend: function ( Parent, proto, options ) {
	  		// only assign if exists
	  		if ( 'template' in options ) {
	  			var template = options.template;

	  			if ( typeof template === 'function' ) {
	  				proto.template = template;
	  			} else {
	  				proto.template = parseTemplate( template, proto );
	  			}
	  		}
	  	},

	  	init: function ( Parent, ractive, options ) {
	  		// TODO because of prototypal inheritance, we might just be able to use
	  		// ractive.template, and not bother passing through the Parent object.
	  		// At present that breaks the test mocks' expectations
	  		var template = 'template' in options ? options.template : Parent.prototype.template;
	  		template = template || { v: TEMPLATE_VERSION, t: [] };

	  		if ( typeof template === 'function' ) {
	  			var fn = template;
	  			template = getDynamicTemplate( ractive, fn );

	  			ractive._config.template = {
	  				fn: fn,
	  				result: template
	  			};
	  		}

	  		template = parseTemplate( template, ractive );

	  		// TODO the naming of this is confusing - ractive.template refers to [...],
	  		// but Component.prototype.template refers to {v:1,t:[],p:[]}...
	  		// it's unnecessary, because the developer never needs to access
	  		// ractive.template
	  		ractive.template = template.t;

	  		if ( template.p ) {
	  			extendPartials( ractive.partials, template.p );
	  		}
	  	},

	  	reset: function ( ractive ) {
	  		var result = resetValue( ractive );

	  		if ( result ) {
	  			var parsed = parseTemplate( result, ractive );

	  			ractive.template = parsed.t;
	  			extendPartials( ractive.partials, parsed.p, true );

	  			return true;
	  		}
	  	}
	  };

	  function resetValue ( ractive ) {
	  	var initial = ractive._config.template;

	  	// If this isn't a dynamic template, there's nothing to do
	  	if ( !initial || !initial.fn ) {
	  		return;
	  	}

	  	var result = getDynamicTemplate( ractive, initial.fn );

	  	// TODO deep equality check to prevent unnecessary re-rendering
	  	// in the case of already-parsed templates
	  	if ( result !== initial.result ) {
	  		initial.result = result;
	  		return result;
	  	}
	  }

	  function getDynamicTemplate ( ractive, fn ) {
	  	return fn.call( ractive, {
	  		fromId: parser.fromId,
	  		isParsed: parser.isParsed,
	  		parse: function ( template, options ) {
	  			if ( options === void 0 ) options = parser.getParseOptions( ractive );

	  			return parser.parse( template, options );
	  		}
	  	});
	  }

	  function parseTemplate ( template, ractive ) {
	  	if ( typeof template === 'string' ) {
	  		// parse will validate and add expression functions
	  		template = parseAsString( template, ractive );
	  	}
	  	else {
	  		// need to validate and add exp for already parsed template
	  		validate$1( template );
	  		addFunctions( template );
	  	}

	  	return template;
	  }

	  function parseAsString ( template, ractive ) {
	  	// ID of an element containing the template?
	  	if ( template[0] === '#' ) {
	  		template = parser.fromId( template );
	  	}

	  	return parser.parseFor( template, ractive );
	  }

	  function validate$1( template ) {

	  	// Check that the template even exists
	  	if ( template == undefined ) {
	  		throw new Error( ("The template cannot be " + template + ".") );
	  	}

	  	// Check the parsed template has a version at all
	  	else if ( typeof template.v !== 'number' ) {
	  		throw new Error( 'The template parser was passed a non-string template, but the template doesn\'t have a version.  Make sure you\'re passing in the template you think you are.' );
	  	}

	  	// Check we're using the correct version
	  	else if ( template.v !== TEMPLATE_VERSION ) {
	  		throw new Error( ("Mismatched template version (expected " + TEMPLATE_VERSION + ", got " + (template.v) + ") Please ensure you are using the latest version of Ractive.js in your build process as well as in your app") );
	  	}
	  }

	  function extendPartials ( existingPartials, newPartials, overwrite ) {
	  	if ( !newPartials ) return;

	  	// TODO there's an ambiguity here - we need to overwrite in the `reset()`
	  	// case, but not initially...

	  	for ( var key in newPartials ) {
	  		if ( overwrite || !existingPartials.hasOwnProperty( key ) ) {
	  			existingPartials[ key ] = newPartials[ key ];
	  		}
	  	}
	  }

	  var registryNames = [
	  	'adaptors',
	  	'components',
	  	'computed',
	  	'decorators',
	  	'easing',
	  	'events',
	  	'interpolators',
	  	'partials',
	  	'transitions'
	  ];

	  var Registry = function Registry ( name, useDefaults ) {
	  	this.name = name;
	  	this.useDefaults = useDefaults;
	  };

	  Registry.prototype.extend = function extend ( Parent, proto, options ) {
	  	this.configure(
	  		this.useDefaults ? Parent.defaults : Parent,
	  		this.useDefaults ? proto : proto.constructor,
	  		options );
	  };

	  Registry.prototype.init = function init () {
	  	// noop
	  };

	  Registry.prototype.configure = function configure ( Parent, target, options ) {
	  	var name = this.name;
	  	var option = options[ name ];

	  	var registry = create( Parent[name] );

	  	for ( var key in option ) {
	  		registry[ key ] = option[ key ];
	  	}

	  	target[ name ] = registry;
	  };

	  Registry.prototype.reset = function reset ( ractive ) {
	  	var registry = ractive[ this.name ];
	  	var changed = false;

	  	Object.keys( registry ).forEach( function ( key ) {
	  		var item = registry[ key ];

	  		if ( item._fn ) {
	  			if ( item._fn.isOwner ) {
	  				registry[key] = item._fn;
	  			} else {
	  				delete registry[key];
	  			}
	  			changed = true;
	  		}
	  	});

	  	return changed;
	  };

	  var registries = registryNames.map( function ( name ) { return new Registry( name, name === 'computed' ); } );

	  function wrap ( parent, name, method ) {
	  	if ( !/_super/.test( method ) ) return method;

	  	function wrapper () {
	  		var superMethod = getSuperMethod( wrapper._parent, name );
	  		var hasSuper = '_super' in this;
	  		var oldSuper = this._super;

	  		this._super = superMethod;

	  		var result = method.apply( this, arguments );

	  		if ( hasSuper ) {
	  			this._super = oldSuper;
	  		} else {
	  			delete this._super;
	  		}

	  		return result;
	  	}

	  	wrapper._parent = parent;
	  	wrapper._method = method;

	  	return wrapper;
	  }

	  function getSuperMethod ( parent, name ) {
	  	if ( name in parent ) {
	  		var value = parent[ name ];

	  		return typeof value === 'function' ?
	  			value :
	  			function () { return value; };
	  	}

	  	return noop;
	  }

	  function getMessage( deprecated, correct, isError ) {
	  	return "options." + deprecated + " has been deprecated in favour of options." + correct + "."
	  		+ ( isError ? (" You cannot specify both options, please use options." + correct + ".") : '' );
	  }

	  function deprecateOption ( options, deprecatedOption, correct ) {
	  	if ( deprecatedOption in options ) {
	  		if( !( correct in options ) ) {
	  			warnIfDebug( getMessage( deprecatedOption, correct ) );
	  			options[ correct ] = options[ deprecatedOption ];
	  		} else {
	  			throw new Error( getMessage( deprecatedOption, correct, true ) );
	  		}
	  	}
	  }

	  function deprecate ( options ) {
	  	deprecateOption( options, 'beforeInit', 'onconstruct' );
	  	deprecateOption( options, 'init', 'onrender' );
	  	deprecateOption( options, 'complete', 'oncomplete' );
	  	deprecateOption( options, 'eventDefinitions', 'events' );

	  	// Using extend with Component instead of options,
	  	// like Human.extend( Spider ) means adaptors as a registry
	  	// gets copied to options. So we have to check if actually an array
	  	if ( isArray( options.adaptors ) ) {
	  		deprecateOption( options, 'adaptors', 'adapt' );
	  	}
	  }

	  var custom = {
	  	adapt: adaptConfigurator,
	  	css: cssConfigurator,
	  	data: dataConfigurator,
	  	template: templateConfigurator
	  };

	  var defaultKeys = Object.keys( defaults );

	  var isStandardKey = makeObj( defaultKeys.filter( function ( key ) { return !custom[ key ]; } ) );

	  // blacklisted keys that we don't double extend
	  var isBlacklisted = makeObj( defaultKeys.concat( registries.map( function ( r ) { return r.name; } ) ) );

	  var order = [].concat(
	  	defaultKeys.filter( function ( key ) { return !registries[ key ] && !custom[ key ]; } ),
	  	registries,
	  	//custom.data,
	  	custom.template,
	  	custom.css
	  );

	  var config = {
	  	extend: function ( Parent, proto, options ) { return configure( 'extend', Parent, proto, options ); },

	  	init: function ( Parent, ractive, options ) { return configure( 'init', Parent, ractive, options ); },

	  	reset: function ( ractive ) {
	  		return order.filter( function ( c ) {
	  			return c.reset && c.reset( ractive );
	  		}).map( function ( c ) { return c.name; } );
	  	},

	  	// this defines the order. TODO this isn't used anywhere in the codebase,
	  	// only in the test suite - should get rid of it
	  	order: order
	  };

	  function configure ( method, Parent, target, options ) {
	  	deprecate( options );

	  	for ( var key in options ) {
	  		if ( isStandardKey.hasOwnProperty( key ) ) {
	  			var value = options[ key ];

	  			// warn the developer if they passed a function and ignore its value

	  			// NOTE: we allow some functions on "el" because we duck type element lists
	  			// and some libraries or ef'ed-up virtual browsers (phantomJS) return a
	  			// function object as the result of querySelector methods
	  			if ( key !== 'el' && typeof value === 'function' ) {
	  				warnIfDebug( ("" + key + " is a Ractive option that does not expect a function and will be ignored"),
	  					method === 'init' ? target : null );
	  			}
	  			else {
	  				target[ key ] = value;
	  			}
	  		}
	  	}

	  	// disallow combination of `append` and `enhance`
	  	if ( options.append && options.enhance ) {
	  		throw new Error( 'Cannot use append and enhance at the same time' );
	  	}

	  	registries.forEach( function ( registry ) {
	  		registry[ method ]( Parent, target, options );
	  	});

	  	adaptConfigurator[ method ]( Parent, target, options );
	  	templateConfigurator[ method ]( Parent, target, options );
	  	cssConfigurator[ method ]( Parent, target, options );

	  	extendOtherMethods( Parent.prototype, target, options );
	  }

	  function extendOtherMethods ( parent, target, options ) {
	  	for ( var key in options ) {
	  		if ( !isBlacklisted[ key ] && options.hasOwnProperty( key ) ) {
	  			var member = options[ key ];

	  			// if this is a method that overwrites a method, wrap it:
	  			if ( typeof member === 'function' ) {
	  				member = wrap( parent, key, member );
	  			}

	  			target[ key ] = member;
	  		}
	  	}
	  }

	  function makeObj ( array ) {
	  	var obj = {};
	  	array.forEach( function ( x ) { return obj[x] = true; } );
	  	return obj;
	  }

	  var shouldRerender = [ 'template', 'partials', 'components', 'decorators', 'events' ];

	  var completeHook$1 = new Hook( 'complete' );
	  var resetHook = new Hook( 'reset' );
	  var renderHook$1 = new Hook( 'render' );
	  var unrenderHook = new Hook( 'unrender' );

	  function Ractive$reset ( data ) {
	  	data = data || {};

	  	if ( typeof data !== 'object' ) {
	  		throw new Error( 'The reset method takes either no arguments, or an object containing new data' );
	  	}

	  	// TEMP need to tidy this up
	  	data = dataConfigurator.init( this.constructor, this, { data: data });

	  	var promise = runloop.start( this, true );

	  	// If the root object is wrapped, try and use the wrapper's reset value
	  	var wrapper = this.viewmodel.wrapper;
	  	if ( wrapper && wrapper.reset ) {
	  		if ( wrapper.reset( data ) === false ) {
	  			// reset was rejected, we need to replace the object
	  			this.viewmodel.set( data );
	  		}
	  	} else {
	  		this.viewmodel.set( data );
	  	}

	  	// reset config items and track if need to rerender
	  	var changes = config.reset( this );
	  	var rerender;

	  	var i = changes.length;
	  	while ( i-- ) {
	  		if ( shouldRerender.indexOf( changes[i] ) > -1 ) {
	  			rerender = true;
	  			break;
	  		}
	  	}

	  	if ( rerender ) {
	  		unrenderHook.fire( this );
	  		this.fragment.resetTemplate( this.template );
	  		renderHook$1.fire( this );
	  		completeHook$1.fire( this );
	  	}

	  	runloop.end();

	  	resetHook.fire( this, data );

	  	return promise;
	  }

	  function collect( source, name, dest ) {
	  	source.forEach( function ( item ) {
	  		// queue to rerender if the item is a partial and the current name matches
	  		if ( item.type === PARTIAL && ( item.refName ===  name || item.name === name ) ) {
	  			dest.push( item );
	  			return; // go no further
	  		}

	  		// if it has a fragment, process its items
	  		if ( item.fragment ) {
	  			collect( item.fragment.iterations || item.fragment.items, name, dest );
	  		}

	  		// or if it is itself a fragment, process its items
	  		else if ( isArray( item.items ) ) {
	  			collect( item.items, name, dest );
	  		}

	  		// or if it is a component, step in and process its items
	  		else if ( item.type === COMPONENT && item.instance ) {
	  			// ...unless the partial is shadowed
	  			if ( item.instance.partials[ name ] ) return;
	  			collect( item.instance.fragment.items, name, dest );
	  		}

	  		// if the item is an element, process its attributes too
	  		if ( item.type === ELEMENT ) {
	  			if ( isArray( item.attributes ) ) {
	  				collect( item.attributes, name, dest );
	  			}

	  			if ( isArray( item.conditionalAttributes ) ) {
	  				collect( item.conditionalAttributes, name, dest );
	  			}
	  		}
	  	});
	  }

	  function forceResetTemplate ( partial ) {
	  	partial.forceResetTemplate();
	  }

	  function resetPartial ( name, partial ) {
	  	var collection = [];
	  	collect( this.fragment.items, name, collection );

	  	var promise = runloop.start( this, true );

	  	this.partials[ name ] = partial;
	  	collection.forEach( forceResetTemplate );

	  	runloop.end();

	  	return promise;
	  }

	  var Item = function Item ( options ) {
	  	this.parentFragment = options.parentFragment;
	  	this.ractive = options.parentFragment.ractive;

	  	this.template = options.template;
	  	this.index = options.index;
	  	this.type = options.template.t;

	  	this.dirty = false;
	  };

	  Item.prototype.bubble = function bubble () {
	  	if ( !this.dirty ) {
	  		this.dirty = true;
	  		this.parentFragment.bubble();
	  	}
	  };

	  Item.prototype.find = function find () {
	  	return null;
	  };

	  Item.prototype.findAll = function findAll () {
	  	// noop
	  };

	  Item.prototype.findComponent = function findComponent () {
	  	return null;
	  };

	  Item.prototype.findAllComponents = function findAllComponents () {
	  	// noop;
	  };

	  Item.prototype.findNextNode = function findNextNode () {
	  	return this.parentFragment.findNextNode( this );
	  };

	  Item.prototype.valueOf = function valueOf () {
	  	return this.toString();
	  };

	  var ComputationChild = (function (Model) {
	  	function ComputationChild () {
	  		Model.apply(this, arguments);
	  	}

	  	ComputationChild.prototype = Object.create( Model && Model.prototype );
	  	ComputationChild.prototype.constructor = ComputationChild;

	  	ComputationChild.prototype.get = function get ( shouldCapture ) {
	  		if ( shouldCapture ) capture( this );

	  		var parentValue = this.parent.get();
	  		return parentValue ? parentValue[ this.key ] : undefined;
	  	};

	  	ComputationChild.prototype.handleChange = function handleChange$1 () {
	  		this.dirty = true;

	  		this.deps.forEach( handleChange );
	  		this.children.forEach( handleChange );
	  		this.clearUnresolveds(); // TODO is this necessary?
	  	};

	  	ComputationChild.prototype.joinKey = function joinKey ( key ) {
	  		if ( key === undefined || key === '' ) return this;

	  		if ( !this.childByKey.hasOwnProperty( key ) ) {
	  			var child = new ComputationChild( this, key );
	  			this.children.push( child );
	  			this.childByKey[ key ] = child;
	  		}

	  		return this.childByKey[ key ];
	  	};

	  	return ComputationChild;
	  }(Model));

	  function getValue ( model ) {
	  	return model ? model.get( true ) : undefined;
	  }

	  var ExpressionProxy = (function (Model) {
	  	function ExpressionProxy ( fragment, template ) {
	  		var this$1 = this;

	  		Model.call( this, fragment.ractive.viewmodel, null );

	  		this.fragment = fragment;
	  		this.template = template;

	  		this.isReadonly = true;

	  		this.fn = getFunction( template.s, template.r.length );
	  		this.computation = null;

	  		this.resolvers = [];
	  		this.models = this.template.r.map( function ( ref, index ) {
	  			var model = resolveReference( this$1.fragment, ref );
	  			var resolver;

	  			if ( !model ) {
	  				resolver = this$1.fragment.resolve( ref, function ( model ) {
	  					removeFromArray( this$1.resolvers, resolver );
	  					this$1.models[ index ] = model;
	  					this$1.bubble();
	  				});

	  				this$1.resolvers.push( resolver );
	  			}

	  			return model;
	  		});

	  		this.bubble();
	  	}

	  	ExpressionProxy.prototype = Object.create( Model && Model.prototype );
	  	ExpressionProxy.prototype.constructor = ExpressionProxy;

	  	ExpressionProxy.prototype.bubble = function bubble () {
	  		var this$1 = this;

	  		var ractive = this.fragment.ractive;

	  		// TODO the @ prevents computed props from shadowing keypaths, but the real
	  		// question is why it's a computed prop in the first place... (hint, it's
	  		// to do with {{else}} blocks)
	  		var key = '@' + this.template.s.replace( /_(\d+)/g, function ( match, i ) {
	  			if ( i >= this$1.models.length ) return match;

	  			var model = this$1.models[i];
	  			return model ? model.getKeypath() : '@undefined';
	  		});

	  		// TODO can/should we reuse computations?
	  		var signature = {
	  			getter: function () {
	  				var values = this$1.models.map( getValue );
	  				return this$1.fn.apply( ractive, values );
	  			},
	  			getterString: key
	  		};

	  		var computation = ractive.viewmodel.compute( key, signature );

	  		this.value = computation.get(); // TODO should not need this, eventually

	  		if ( this.computation ) {
	  			this.computation.unregister( this );
	  			// notify children...
	  		}

	  		this.computation = computation;
	  		computation.register( this );

	  		this.handleChange();
	  	};

	  	ExpressionProxy.prototype.get = function get ( shouldCapture ) {
	  		return this.computation.get( shouldCapture );
	  	};

	  	ExpressionProxy.prototype.getKeypath = function getKeypath () {
	  		return this.computation ? this.computation.getKeypath() : '@undefined';
	  	};

	  	ExpressionProxy.prototype.handleChange = function handleChange$1 () {
	  		this.deps.forEach( handleChange );
	  		this.children.forEach( handleChange );

	  		this.clearUnresolveds();
	  	};

	  	ExpressionProxy.prototype.joinKey = function joinKey ( key ) {
	  		if ( key === undefined || key === '' ) return this;

	  		if ( !this.childByKey.hasOwnProperty( key ) ) {
	  			var child = new ComputationChild( this, key );
	  			this.children.push( child );
	  			this.childByKey[ key ] = child;
	  		}

	  		return this.childByKey[ key ];
	  	};

	  	ExpressionProxy.prototype.mark = function mark () {
	  		this.handleChange();
	  	};

	  	ExpressionProxy.prototype.retrieve = function retrieve () {
	  		return this.get();
	  	};

	  	ExpressionProxy.prototype.teardown = function teardown () {
	  		this.unbind();
	  		this.fragment = undefined;
	  		if ( this.computation ) {
	  			this.computation.teardown();
	  		}
	  		this.computation = undefined;
	  		Model.prototype.teardown.call(this);
	  	};

	  	ExpressionProxy.prototype.unregister = function unregister( dep ) {
	  		Model.prototype.unregister.call( this, dep );
	  		if ( !this.deps.length ) this.teardown();
	  	};

	  	ExpressionProxy.prototype.unbind = function unbind$1 () {
	  		var this$1 = this;

	  		this.resolvers.forEach( unbind );

	  		var i = this.models.length;
	  		while ( i-- ) {
	  			if ( this$1.models[i] ) this$1.models[i].unregister( this$1 );
	  		}
	  	};

	  	return ExpressionProxy;
	  }(Model));

	  var ReferenceExpressionChild = (function (Model) {
	  	function ReferenceExpressionChild ( parent, key ) {
	  		Model.call ( this, parent, key );
	  	}

	  	ReferenceExpressionChild.prototype = Object.create( Model && Model.prototype );
	  	ReferenceExpressionChild.prototype.constructor = ReferenceExpressionChild;

	  	ReferenceExpressionChild.prototype.applyValue = function applyValue ( value ) {
	  		if ( isEqual( value, this.value ) ) return;

	  		var parent = this.parent, keys = [ this.key ];
	  		while ( parent ) {
	  			if ( parent.base ) {
	  				var target = parent.model.joinAll( keys );
	  				target.applyValue( value );
	  				break;
	  			}

	  			keys.unshift( parent.key );

	  			parent = parent.parent;
	  		}
	  	};

	  	ReferenceExpressionChild.prototype.joinKey = function joinKey ( key ) {
	  		if ( key === undefined || key === '' ) return this;

	  		if ( !this.childByKey.hasOwnProperty( key ) ) {
	  			var child = new ReferenceExpressionChild( this, key );
	  			this.children.push( child );
	  			this.childByKey[ key ] = child;
	  		}

	  		return this.childByKey[ key ];
	  	};

	  	return ReferenceExpressionChild;
	  }(Model));

	  var ReferenceExpressionProxy = (function (Model) {
	  	function ReferenceExpressionProxy ( fragment, template ) {
	  		var this$1 = this;

	  		Model.call( this, null, null );
	  		this.root = fragment.ractive.viewmodel;

	  		this.resolvers = [];

	  		this.base = resolve$1( fragment, template );
	  		var baseResolver;

	  		if ( !this.base ) {
	  			baseResolver = fragment.resolve( template.r, function ( model ) {
	  				this$1.base = model;
	  				this$1.bubble();

	  				removeFromArray( this$1.resolvers, baseResolver );
	  			});

	  			this.resolvers.push( baseResolver );
	  		}

	  		var intermediary = {
	  			handleChange: function () { return this$1.bubble(); }
	  		};

	  		this.members = template.m.map( function ( template, i ) {
	  			if ( typeof template === 'string' ) {
	  				return { get: function () { return template; } };
	  			}

	  			var model;
	  			var resolver;

	  			if ( template.t === REFERENCE ) {
	  				model = resolveReference( fragment, template.n );

	  				if ( model ) {
	  					model.register( intermediary );
	  				} else {
	  					resolver = fragment.resolve( template.n, function ( model ) {
	  						this$1.members[i] = model;

	  						model.register( intermediary );
	  						this$1.bubble();

	  						removeFromArray( this$1.resolvers, resolver );
	  					});

	  					this$1.resolvers.push( resolver );
	  				}

	  				return model;
	  			}

	  			model = new ExpressionProxy( fragment, template );
	  			model.register( intermediary );
	  			return model;
	  		});

	  		this.isUnresolved = true;
	  		this.bubble();
	  	}

	  	ReferenceExpressionProxy.prototype = Object.create( Model && Model.prototype );
	  	ReferenceExpressionProxy.prototype.constructor = ReferenceExpressionProxy;

	  	ReferenceExpressionProxy.prototype.bubble = function bubble () {
	  		var this$1 = this;

	  		if ( !this.base ) return;

	  		// if some members are not resolved, abort
	  		var i = this.members.length;
	  		while ( i-- ) {
	  			if ( !this$1.members[i] ) return;
	  		}

	  		this.isUnresolved = false;

	  		var keys = this.members.map( function ( model ) { return escapeKey( String( model.get() ) ); } );
	  		var model = this.base.joinAll( keys );

	  		if ( this.model ) {
	  			this.model.unregister( this );
	  			this.model.unregisterTwowayBinding( this );
	  		}

	  		this.model = model;
	  		this.parent = model.parent;

	  		model.register( this );
	  		model.registerTwowayBinding( this );

	  		if ( this.keypathModel ) this.keypathModel.handleChange();

	  		this.mark();
	  	};

	  	ReferenceExpressionProxy.prototype.forceResolution = function forceResolution () {
	  		this.resolvers.forEach( function ( resolver ) { return resolver.forceResolution(); } );
	  		this.bubble();
	  	};

	  	ReferenceExpressionProxy.prototype.get = function get () {
	  		return this.model ? this.model.get() : undefined;
	  	};

	  	// indirect two-way bindings
	  	ReferenceExpressionProxy.prototype.getValue = function getValue () {
	  		var this$1 = this;

	  		var i = this.bindings.length;
	  		while ( i-- ) {
	  			var value = this$1.bindings[i].getValue();
	  			if ( value !== this$1.value ) return value;
	  		}

	  		return this.value;
	  	};

	  	ReferenceExpressionProxy.prototype.getKeypath = function getKeypath () {
	  		return this.model ? this.model.getKeypath() : '@undefined';
	  	};

	  	ReferenceExpressionProxy.prototype.handleChange = function handleChange () {
	  		this.mark();
	  	};

	  	ReferenceExpressionProxy.prototype.joinKey = function joinKey ( key ) {
	  		if ( key === undefined || key === '' ) return this;

	  		if ( !this.childByKey.hasOwnProperty( key ) ) {
	  			var child = new ReferenceExpressionChild( this, key );
	  			this.children.push( child );
	  			this.childByKey[ key ] = child;
	  		}

	  		return this.childByKey[ key ];
	  	};

	  	ReferenceExpressionProxy.prototype.retrieve = function retrieve () {
	  		return this.get();
	  	};

	  	ReferenceExpressionProxy.prototype.set = function set ( value ) {
	  		if ( !this.model ) throw new Error( 'Unresolved reference expression. This should not happen!' );
	  		this.model.set( value );
	  	};

	  	ReferenceExpressionProxy.prototype.unbind = function unbind$1 () {
	  		this.resolvers.forEach( unbind );
	  	};

	  	return ReferenceExpressionProxy;
	  }(Model));

	  function resolve$1 ( fragment, template ) {
	  	if ( template.r ) {
	  		return resolveReference( fragment, template.r );
	  	}

	  	else if ( template.x ) {
	  		return new ExpressionProxy( fragment, template.x );
	  	}

	  	else {
	  		return new ReferenceExpressionProxy( fragment, template.rx );
	  	}
	  }

	  function resolveAliases( section ) {
	  	if ( section.template.z ) {
	  		section.aliases = {};

	  		var refs = section.template.z;
	  		for ( var i = 0; i < refs.length; i++ ) {
	  			section.aliases[ refs[i].n ] = resolve$1( section.parentFragment, refs[i].x );
	  		}
	  	}
	  }

	  var Alias = (function (Item) {
	  	function Alias ( options ) {
	  		Item.call( this, options );

	  		this.fragment = null;
	  	}

	  	Alias.prototype = Object.create( Item && Item.prototype );
	  	Alias.prototype.constructor = Alias;

	  	Alias.prototype.bind = function bind () {
	  		resolveAliases( this );

	  		this.fragment = new Fragment({
	  			owner: this,
	  			template: this.template.f
	  		}).bind();
	  	};

	  	Alias.prototype.detach = function detach () {
	  		return this.fragment ? this.fragment.detach() : createDocumentFragment();
	  	};

	  	Alias.prototype.find = function find ( selector ) {
	  		if ( this.fragment ) {
	  			return this.fragment.find( selector );
	  		}
	  	};

	  	Alias.prototype.findAll = function findAll ( selector, query ) {
	  		if ( this.fragment ) {
	  			this.fragment.findAll( selector, query );
	  		}
	  	};

	  	Alias.prototype.findComponent = function findComponent ( name ) {
	  		if ( this.fragment ) {
	  			return this.fragment.findComponent( name );
	  		}
	  	};

	  	Alias.prototype.findAllComponents = function findAllComponents ( name, query ) {
	  		if ( this.fragment ) {
	  			this.fragment.findAllComponents( name, query );
	  		}
	  	};

	  	Alias.prototype.firstNode = function firstNode ( skipParent ) {
	  		return this.fragment && this.fragment.firstNode( skipParent );
	  	};

	  	Alias.prototype.rebind = function rebind () {
	  		resolveAliases( this );
	  		if ( this.fragment ) this.fragment.rebind();
	  	};

	  	Alias.prototype.render = function render ( target ) {
	  		this.rendered = true;
	  		if ( this.fragment ) this.fragment.render( target );
	  	};

	  	Alias.prototype.toString = function toString ( escape ) {
	  		return this.fragment ? this.fragment.toString( escape ) : '';
	  	};

	  	Alias.prototype.unbind = function unbind () {
	  		this.aliases = {};
	  		if ( this.fragment ) this.fragment.unbind();
	  	};

	  	Alias.prototype.unrender = function unrender ( shouldDestroy ) {
	  		if ( this.rendered && this.fragment ) this.fragment.unrender( shouldDestroy );
	  		this.rendered = false;
	  	};

	  	Alias.prototype.update = function update () {
	  		if ( this.dirty ) {
	  			this.dirty = false;
	  			this.fragment.update();
	  		}
	  	};

	  	return Alias;
	  }(Item));

	  function processWrapper ( wrapper, array, methodName, newIndices ) {
	  	var __model = wrapper.__model;

	  	if ( newIndices ) {
	  		__model.shuffle( newIndices );
	  	} else {
	  		// If this is a sort or reverse, we just do root.set()...
	  		// TODO use merge logic?
	  		//root.viewmodel.mark( keypath );
	  	}
	  }

	  var mutatorMethods = [ 'pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift' ];
	  var patchedArrayProto = [];

	  mutatorMethods.forEach( function ( methodName ) {
	  	var method = function () {
	  		var this$1 = this;
	  		var args = [], len = arguments.length;
	  		while ( len-- ) args[ len ] = arguments[ len ];

	  		var newIndices = getNewIndices( this.length, methodName, args );

	  		// apply the underlying method
	  		var result = Array.prototype[ methodName ].apply( this, arguments );

	  		// trigger changes
	  		runloop.start();

	  		this._ractive.setting = true;
	  		var i = this._ractive.wrappers.length;
	  		while ( i-- ) {
	  			processWrapper( this$1._ractive.wrappers[i], this$1, methodName, newIndices );
	  		}

	  		runloop.end();

	  		this._ractive.setting = false;
	  		return result;
	  	};

	  	defineProperty( patchedArrayProto, methodName, {
	  		value: method
	  	});
	  });

	  var patchArrayMethods;
	  var unpatchArrayMethods;

	  // can we use prototype chain injection?
	  // http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/#wrappers_prototype_chain_injection
	  if ( ({}).__proto__ ) {
	  	// yes, we can
	  	patchArrayMethods = function ( array ) { return array.__proto__ = patchedArrayProto; };
	  	unpatchArrayMethods = function ( array ) { return array.__proto__ = Array.prototype; };
	  }

	  else {
	  	// no, we can't
	  	patchArrayMethods = function ( array ) {
	  		var i = mutatorMethods.length;
	  		while ( i-- ) {
	  			var methodName = mutatorMethods[i];
	  			defineProperty( array, methodName, {
	  				value: patchedArrayProto[ methodName ],
	  				configurable: true
	  			});
	  		}
	  	};

	  	unpatchArrayMethods = function ( array ) {
	  		var i = mutatorMethods.length;
	  		while ( i-- ) {
	  			delete array[ mutatorMethods[i] ];
	  		}
	  	};
	  }

	  patchArrayMethods.unpatch = unpatchArrayMethods; // TODO export separately?
	  var patch = patchArrayMethods;

	  var errorMessage$1 = 'Something went wrong in a rather interesting way';

	  var arrayAdaptor = {
	  	filter: function ( object ) {
	  		// wrap the array if a) b) it's an array, and b) either it hasn't been wrapped already,
	  		// or the array didn't trigger the get() itself
	  		return isArray( object ) && ( !object._ractive || !object._ractive.setting );
	  	},
	  	wrap: function ( ractive, array, keypath ) {
	  		return new ArrayWrapper( ractive, array, keypath );
	  	}
	  };

	  var ArrayWrapper = function ArrayWrapper ( ractive, array ) {
	  	this.root = ractive;
	  	this.value = array;
	  	this.__model = null; // filled in later

	  	// if this array hasn't already been ractified, ractify it
	  	if ( !array._ractive ) {
	  		// define a non-enumerable _ractive property to store the wrappers
	  		defineProperty( array, '_ractive', {
	  			value: {
	  				wrappers: [],
	  				instances: [],
	  				setting: false
	  			},
	  			configurable: true
	  		});

	  		patch( array );
	  	}

	  	// store the ractive instance, so we can handle transitions later
	  	if ( !array._ractive.instances[ ractive._guid ] ) {
	  		array._ractive.instances[ ractive._guid ] = 0;
	  		array._ractive.instances.push( ractive );
	  	}

	  	array._ractive.instances[ ractive._guid ] += 1;
	  	array._ractive.wrappers.push( this );
	  };

	  ArrayWrapper.prototype.get = function get () {
	  	return this.value;
	  };

	  ArrayWrapper.prototype.reset = function reset ( value ) {
	  	return this.value === value;
	  };

	  ArrayWrapper.prototype.teardown = function teardown () {
	  	var array, storage, wrappers, instances, index;

	  	array = this.value;
	  	storage = array._ractive;
	  	wrappers = storage.wrappers;
	  	instances = storage.instances;

	  	// if teardown() was invoked because we're clearing the cache as a result of
	  	// a change that the array itself triggered, we can save ourselves the teardown
	  	// and immediate setup
	  	if ( storage.setting ) {
	  		return false; // so that we don't remove it from cached wrappers
	  	}

	  	index = wrappers.indexOf( this );
	  	if ( index === -1 ) {
	  		throw new Error( errorMessage$1 );
	  	}

	  	wrappers.splice( index, 1 );

	  	// if nothing else depends on this array, we can revert it to its
	  	// natural state
	  	if ( !wrappers.length ) {
	  		delete array._ractive;
	  		patch.unpatch( this.value );
	  	}

	  	else {
	  		// remove ractive instance if possible
	  		instances[ this.root._guid ] -= 1;
	  		if ( !instances[ this.root._guid ] ) {
	  			index = instances.indexOf( this.root );

	  			if ( index === -1 ) {
	  				throw new Error( errorMessage$1 );
	  			}

	  			instances.splice( index, 1 );
	  		}
	  	}
	  };

	  var magicAdaptor;

	  try {
	  	Object.defineProperty({}, 'test', { get: function() {}, set: function() {} });

	  	magicAdaptor = {
	  		filter: function ( value ) {
	  			return value && typeof value === 'object';
	  		},
	  		wrap: function ( ractive, value, keypath ) {
	  			return new MagicWrapper( ractive, value, keypath );
	  		}
	  	};
	  } catch ( err ) {
	  	magicAdaptor = false;
	  }

	  var magicAdaptor$1 = magicAdaptor;

	  function createOrWrapDescriptor ( originalDescriptor, ractive, keypath ) {
	  	if ( originalDescriptor.set && originalDescriptor.set.__magic ) {
	  		originalDescriptor.set.__magic.dependants.push({ ractive: ractive, keypath: keypath });
	  		return originalDescriptor;
	  	}

	  	var setting;

	  	var dependants = [{ ractive: ractive, keypath: keypath }];

	  	var descriptor = {
	  		get: function () {
	  			return 'value' in originalDescriptor ? originalDescriptor.value : originalDescriptor.get();
	  		},
	  		set: function ( value ) {
	  			if ( setting ) return;

	  			if ( 'value' in originalDescriptor ) {
	  				originalDescriptor.value = value;
	  			} else {
	  				originalDescriptor.set( value );
	  			}

	  			setting = true;
	  			dependants.forEach( function (ref) {
	  				var ractive = ref.ractive;
	  				var keypath = ref.keypath;

	  				ractive.set( keypath, value );
	  			});
	  			setting = false;
	  		},
	  		enumerable: true
	  	};

	  	descriptor.set.__magic = { dependants: dependants, originalDescriptor: originalDescriptor };

	  	return descriptor;
	  }

	  function revert ( descriptor, ractive, keypath ) {
	  	if ( !descriptor.set || !descriptor.set.__magic ) return true;

	  	var dependants = descriptor.set.__magic;
	  	var i = dependants.length;
	  	while ( i-- ) {
	  		var dependant = dependants[i];
	  		if ( dependant.ractive === ractive && dependant.keypath === keypath ) {
	  			dependants.splice( i, 1 );
	  			return false;
	  		}
	  	}
	  }

	  var MagicWrapper = function MagicWrapper ( ractive, value, keypath ) {
	  	var this$1 = this;

	  		this.ractive = ractive;
	  	this.value = value;
	  	this.keypath = keypath;

	  	this.originalDescriptors = {};

	  	// wrap all properties with getters
	  	Object.keys( value ).forEach( function ( key ) {
	  		var originalDescriptor = Object.getOwnPropertyDescriptor( this$1.value, key );
	  		this$1.originalDescriptors[ key ] = originalDescriptor;

	  		var childKeypath = keypath ? ("" + keypath + "." + (escapeKey( key ))) : escapeKey( key );

	  		var descriptor = createOrWrapDescriptor( originalDescriptor, ractive, childKeypath );



	  		Object.defineProperty( this$1.value, key, descriptor );
	  	});
	  };

	  MagicWrapper.prototype.get = function get () {
	  	return this.value;
	  };

	  MagicWrapper.prototype.reset = function reset ( value ) {
	  	return this.value === value;
	  };

	  MagicWrapper.prototype.set = function set ( key, value ) {
	  	this.value[ key ] = value;
	  };

	  MagicWrapper.prototype.teardown = function teardown () {
	  	var this$1 = this;

	  		Object.keys( this.value ).forEach( function ( key ) {
	  		var descriptor = Object.getOwnPropertyDescriptor( this$1.value, key );
	  		if ( !descriptor.set || !descriptor.set.__magic ) return;

	  		revert( descriptor );

	  		if ( descriptor.set.__magic.dependants.length === 1 ) {
	  			Object.defineProperty( this$1.value, key, descriptor.set.__magic.originalDescriptor );
	  		}
	  	});
	  };

	  var MagicArrayWrapper = function MagicArrayWrapper ( ractive, array, keypath ) {
	  	this.value = array;

	  	this.magic = true;

	  	this.magicWrapper = magicAdaptor$1.wrap( ractive, array, keypath );
	  	this.arrayWrapper = arrayAdaptor.wrap( ractive, array, keypath );

	  	// ugh, this really is a terrible hack
	  	Object.defineProperty( this, '__model', {
	  		get: function () {
	  			return this.arrayWrapper.__model;
	  		},
	  		set: function ( model ) {
	  			this.arrayWrapper.__model = model;
	  		}
	  	});
	  };

	  MagicArrayWrapper.prototype.get = function get () {
	  	return this.value;
	  };

	  MagicArrayWrapper.prototype.teardown = function teardown () {
	  	this.arrayWrapper.teardown();
	  	this.magicWrapper.teardown();
	  };

	  MagicArrayWrapper.prototype.reset = function reset ( value ) {
	  	return this.arrayWrapper.reset( value ) && this.magicWrapper.reset( value );
	  };

	  var magicArrayAdaptor = {
	  	filter: function ( object, keypath, ractive ) {
	  		return magicAdaptor$1.filter( object, keypath, ractive ) && arrayAdaptor.filter( object );
	  	},

	  	wrap: function ( ractive, array, keypath ) {
	  		return new MagicArrayWrapper( ractive, array, keypath );
	  	}
	  };

	  // TODO this is probably a bit anal, maybe we should leave it out
	  function prettify ( fnBody ) {
	  	var lines = fnBody
	  		.replace( /^\t+/gm, function ( tabs ) { return tabs.split( '\t' ).join( '  ' ); } )
	  		.split( '\n' );

	  	var minIndent = lines.length < 2 ? 0 :
	  		lines.slice( 1 ).reduce( function ( prev, line ) {
	  			return Math.min( prev, /^\s*/.exec( line )[0].length );
	  		}, Infinity );

	  	return lines.map( function ( line, i ) {
	  		return '    ' + ( i ? line.substring( minIndent ) : line );
	  	}).join( '\n' );
	  }

	  // Ditto. This function truncates the stack to only include app code
	  function truncateStack ( stack ) {
	  	if ( !stack ) return '';

	  	var lines = stack.split( '\n' );
	  	var name = Computation.name + '.getValue';

	  	var truncated = [];

	  	var len = lines.length;
	  	for ( var i = 1; i < len; i += 1 ) {
	  		var line = lines[i];

	  		if ( ~line.indexOf( name ) ) {
	  			return truncated.join( '\n' );
	  		} else {
	  			truncated.push( line );
	  		}
	  	}
	  }

	  var Computation = (function (Model) {
	  	function Computation ( viewmodel, signature, key ) {
	  		Model.call( this, null, null );

	  		this.root = this.parent = viewmodel;
	  		this.signature = signature;

	  		this.key = key; // not actually used, but helps with debugging
	  		this.isExpression = key && key[0] === '@';

	  		this.isReadonly = !this.signature.setter;

	  		this.context = viewmodel.computationContext;

	  		this.dependencies = [];

	  		this.children = [];
	  		this.childByKey = {};

	  		this.deps = [];

	  		this.boundsSensitive = true;
	  		this.dirty = true;

	  		// TODO: is there a less hackish way to do this?
	  		this.shuffle = undefined;
	  	}

	  	Computation.prototype = Object.create( Model && Model.prototype );
	  	Computation.prototype.constructor = Computation;

	  	Computation.prototype.get = function get ( shouldCapture ) {
	  		if ( shouldCapture ) capture( this );

	  		if ( this.dirty ) {
	  			this.dirty = false;
	  			this.value = this.getValue();
	  			this.adapt();
	  		}

	  		return this.value;
	  	};

	  	Computation.prototype.getValue = function getValue () {
	  		startCapturing();
	  		var result;

	  		try {
	  			result = this.signature.getter.call( this.context );
	  		} catch ( err ) {
	  			warnIfDebug( ("Failed to compute " + (this.getKeypath()) + ": " + (err.message || err)) );

	  			// TODO this is all well and good in Chrome, but...
	  			// ...also, should encapsulate this stuff better, and only
	  			// show it if Ractive.DEBUG
	  			if ( hasConsole ) {
	  				if ( console.groupCollapsed ) console.groupCollapsed( '%cshow details', 'color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;' );
	  				var functionBody = prettify( this.signature.getterString );
	  				var stack = this.signature.getterUseStack ? '\n\n' + truncateStack( err.stack ) : '';
	  				console.error( ("" + (err.name) + ": " + (err.message) + "\n\n" + functionBody + "" + stack) );
	  				if ( console.groupCollapsed ) console.groupEnd();
	  			}
	  		}

	  		var dependencies = stopCapturing();
	  		this.setDependencies( dependencies );

	  		return result;
	  	};

	  	Computation.prototype.handleChange = function handleChange$1 () {
	  		this.dirty = true;

	  		this.deps.forEach( handleChange );
	  		this.children.forEach( handleChange );
	  		this.clearUnresolveds(); // TODO same question as on Model - necessary for primitives?
	  	};

	  	Computation.prototype.joinKey = function joinKey ( key ) {
	  		if ( key === undefined || key === '' ) return this;

	  		if ( !this.childByKey.hasOwnProperty( key ) ) {
	  			var child = new ComputationChild( this, key );
	  			this.children.push( child );
	  			this.childByKey[ key ] = child;
	  		}

	  		return this.childByKey[ key ];
	  	};

	  	Computation.prototype.mark = function mark () {
	  		this.handleChange();
	  	};

	  	Computation.prototype.set = function set ( value ) {
	  		if ( !this.signature.setter ) {
	  			throw new Error( ("Cannot set read-only computed value '" + (this.key) + "'") );
	  		}

	  		this.signature.setter( value );
	  	};

	  	Computation.prototype.setDependencies = function setDependencies ( dependencies ) {
	  		// unregister any soft dependencies we no longer have
	  		var this$1 = this;

	  		var i = this.dependencies.length;
	  		while ( i-- ) {
	  			var model = this$1.dependencies[i];
	  			if ( !~dependencies.indexOf( model ) ) model.unregister( this$1 );
	  		}

	  		// and add any new ones
	  		i = dependencies.length;
	  		while ( i-- ) {
	  			var model$1 = dependencies[i];
	  			if ( !~this$1.dependencies.indexOf( model$1 ) ) model$1.register( this$1 );
	  		}

	  		this.dependencies = dependencies;
	  	};

	  	Computation.prototype.teardown = function teardown () {
	  		var this$1 = this;

	  		var i = this.dependencies.length;
	  		while ( i-- ) {
	  			if ( this$1.dependencies[i] ) this$1.dependencies[i].unregister( this$1 );
	  		}
	  		if ( this.root.computations[this.key] === this ) delete this.root.computations[this.key];
	  		Model.prototype.teardown.call(this);
	  	};

	  	return Computation;
	  }(Model));

	  var RactiveModel = (function (Model) {
	  	function RactiveModel ( ractive ) {
	  		Model.call( this, null, '' );
	  		this.value = ractive;
	  		this.isRoot = true;
	  		this.root = this;
	  		this.adaptors = [];
	  		this.ractive = ractive;
	  		this.changes = {};
	  	}

	  	RactiveModel.prototype = Object.create( Model && Model.prototype );
	  	RactiveModel.prototype.constructor = RactiveModel;

	  	RactiveModel.prototype.getKeypath = function getKeypath() {
	  		return '@ractive';
	  	};

	  	return RactiveModel;
	  }(Model));

	  var hasProp$1 = Object.prototype.hasOwnProperty;

	  var RootModel = (function (Model) {
	  	function RootModel ( options ) {
	  		Model.call( this, null, null );

	  		// TODO deprecate this
	  		this.changes = {};

	  		this.isRoot = true;
	  		this.root = this;
	  		this.ractive = options.ractive; // TODO sever this link

	  		this.value = options.data;
	  		this.adaptors = options.adapt;
	  		this.adapt();

	  		this.mappings = {};

	  		this.computationContext = options.ractive;
	  		this.computations = {};
	  	}

	  	RootModel.prototype = Object.create( Model && Model.prototype );
	  	RootModel.prototype.constructor = RootModel;

	  	RootModel.prototype.applyChanges = function applyChanges () {
	  		this._changeHash = {};
	  		this.flush();

	  		return this._changeHash;
	  	};

	  	RootModel.prototype.compute = function compute ( key, signature ) {
	  		var computation = new Computation( this, signature, key );
	  		this.computations[ key ] = computation;

	  		return computation;
	  	};

	  	RootModel.prototype.extendChildren = function extendChildren ( fn ) {
	  		var mappings = this.mappings;
	  		Object.keys( mappings ).forEach( function ( key ) {
	  			fn( key, mappings[ key ] );
	  		});

	  		var computations = this.computations;
	  		Object.keys( computations ).forEach( function ( key ) {
	  			var computation = computations[ key ];
	  			// exclude template expressions
	  			if ( !computation.isExpression ) {
	  				fn( key, computation );
	  			}
	  		});
	  	};

	  	RootModel.prototype.get = function get ( shouldCapture ) {
	  		if ( shouldCapture ) capture( this );
	  		var result = extendObj( {}, this.value );

	  		this.extendChildren( function ( key, model ) {
	  			result[ key ] = model.value;
	  		});

	  		return result;
	  	};

	  	RootModel.prototype.getKeypath = function getKeypath () {
	  		return '';
	  	};

	  	RootModel.prototype.getRactiveModel = function getRactiveModel() {
	  		return this.ractiveModel || ( this.ractiveModel = new RactiveModel( this.ractive ) );
	  	};

	  	RootModel.prototype.getValueChildren = function getValueChildren () {
	  		var children = Model.prototype.getValueChildren.call( this, this.value );

	  		this.extendChildren( function ( key, model ) {
	  			children.push( model );
	  		});

	  		return children;
	  	};

	  	RootModel.prototype.handleChange = function handleChange$1 () {
	  		this.deps.forEach( handleChange );
	  	};

	  	RootModel.prototype.has = function has ( key ) {
	  		if ( ( key in this.mappings ) || ( key in this.computations ) ) return true;

	  		var value = this.value;

	  		key = unescapeKey( key );
	  		if ( hasProp$1.call( value, key ) ) return true;

	  		// We climb up the constructor chain to find if one of them contains the key
	  		var constructor = value.constructor;
	  		while ( constructor !== Function && constructor !== Array && constructor !== Object ) {
	  			if ( hasProp$1.call( constructor.prototype, key ) ) return true;
	  			constructor = constructor.constructor;
	  		}

	  		return false;
	  	};

	  	RootModel.prototype.joinKey = function joinKey ( key ) {
	  		if ( key === '@global' ) return GlobalModel$1;
	  		if ( key === '@ractive' ) return this.getRactiveModel();

	  		return this.mappings.hasOwnProperty( key ) ? this.mappings[ key ] :
	  		       this.computations.hasOwnProperty( key ) ? this.computations[ key ] :
	  		       Model.prototype.joinKey.call( this, key );
	  	};

	  	RootModel.prototype.map = function map ( localKey, origin ) {
	  		// TODO remapping
	  		this.mappings[ localKey ] = origin;
	  		origin.register( this );
	  	};

	  	RootModel.prototype.set = function set ( value ) {
	  		// TODO wrapping root node is a baaaad idea. We should prevent this
	  		var wrapper = this.wrapper;
	  		if ( wrapper ) {
	  			var shouldTeardown = !wrapper.reset || wrapper.reset( value ) === false;

	  			if ( shouldTeardown ) {
	  				wrapper.teardown();
	  				this.wrapper = null;
	  				this.value = value;
	  				this.adapt();
	  			}
	  		} else {
	  			this.value = value;
	  			this.adapt();
	  		}

	  		this.deps.forEach( handleChange );
	  		this.children.forEach( mark );
	  		this.clearUnresolveds(); // TODO do we need to do this with primitive values? if not, what about e.g. unresolved `length` property of null -> string?
	  	};

	  	RootModel.prototype.retrieve = function retrieve () {
	  		return this.value;
	  	};

	  	RootModel.prototype.teardown = function teardown () {
	  		var this$1 = this;

	  		var keys = Object.keys( this.mappings );
	  		var i = keys.length;
	  		while ( i-- ){
	  			if ( this$1.mappings[ keys[i] ] ) this$1.mappings[ keys[i] ].unregister( this$1 );
	  		}

	  		Model.prototype.teardown.call(this);
	  	};

	  	RootModel.prototype.update = function update () {
	  		// noop
	  	};

	  	RootModel.prototype.updateFromBindings = function updateFromBindings ( cascade ) {
	  		var this$1 = this;

	  		Model.prototype.updateFromBindings.call( this, cascade );

	  		if ( cascade ) {
	  			// TODO computations as well?
	  			Object.keys( this.mappings ).forEach( function ( key ) {
	  				var model = this$1.mappings[ key ];
	  				model.updateFromBindings( cascade );
	  			});
	  		}
	  	};

	  	return RootModel;
	  }(Model));

	  function getComputationSignature ( ractive, key, signature ) {
	  	var getter;
	  	var setter;

	  	// useful for debugging
	  	var getterString;
	  	var getterUseStack;
	  	var setterString;

	  	if ( typeof signature === 'function' ) {
	  		getter = bind$1( signature, ractive );
	  		getterString = signature.toString();
	  		getterUseStack = true;
	  	}

	  	if ( typeof signature === 'string' ) {
	  		getter = createFunctionFromString( signature, ractive );
	  		getterString = signature;
	  	}

	  	if ( typeof signature === 'object' ) {
	  		if ( typeof signature.get === 'string' ) {
	  			getter = createFunctionFromString( signature.get, ractive );
	  			getterString = signature.get;
	  		} else if ( typeof signature.get === 'function' ) {
	  			getter = bind$1( signature.get, ractive );
	  			getterString = signature.get.toString();
	  			getterUseStack = true;
	  		} else {
	  			fatal( '`%s` computation must have a `get()` method', key );
	  		}

	  		if ( typeof signature.set === 'function' ) {
	  			setter = bind$1( signature.set, ractive );
	  			setterString = signature.set.toString();
	  		}
	  	}

	  	return {
	  		getter: getter,
	  		setter: setter,
	  		getterString: getterString,
	  		setterString: setterString,
	  		getterUseStack: getterUseStack
	  	};
	  }

	  var constructHook = new Hook( 'construct' );

	  var registryNames$1 = [
	  	'adaptors',
	  	'components',
	  	'decorators',
	  	'easing',
	  	'events',
	  	'interpolators',
	  	'partials',
	  	'transitions'
	  ];

	  var uid = 0;

	  function construct ( ractive, options ) {
	  	if ( Ractive.DEBUG ) welcome();

	  	initialiseProperties( ractive );

	  	// TODO remove this, eventually
	  	defineProperty( ractive, 'data', { get: deprecateRactiveData });

	  	// TODO don't allow `onconstruct` with `new Ractive()`, there's no need for it
	  	constructHook.fire( ractive, options );

	  	// Add registries
	  	registryNames$1.forEach( function ( name ) {
	  		ractive[ name ] = extendObj( create( ractive.constructor[ name ] || null ), options[ name ] );
	  	});

	  	// Create a viewmodel
	  	var viewmodel = new RootModel({
	  		adapt: getAdaptors( ractive, ractive.adapt, options ),
	  		data: dataConfigurator.init( ractive.constructor, ractive, options ),
	  		ractive: ractive
	  	});

	  	ractive.viewmodel = viewmodel;

	  	// Add computed properties
	  	var computed = extendObj( create( ractive.constructor.prototype.computed ), options.computed );

	  	for ( var key in computed ) {
	  		var signature = getComputationSignature( ractive, key, computed[ key ] );
	  		viewmodel.compute( key, signature );
	  	}
	  }

	  function combine$3 ( a, b ) {
	  	var c = a.slice();
	  	var i = b.length;

	  	while ( i-- ) {
	  		if ( !~c.indexOf( b[i] ) ) {
	  			c.push( b[i] );
	  		}
	  	}

	  	return c;
	  }

	  function getAdaptors ( ractive, protoAdapt, options ) {
	  	protoAdapt = protoAdapt.map( lookup );
	  	var adapt = ensureArray( options.adapt ).map( lookup );

	  	adapt = combine$3( protoAdapt, adapt );

	  	var magic = 'magic' in options ? options.magic : ractive.magic;
	  	var modifyArrays = 'modifyArrays' in options ? options.modifyArrays : ractive.modifyArrays;

	  	if ( magic ) {
	  		if ( !magicSupported ) {
	  			throw new Error( 'Getters and setters (magic mode) are not supported in this browser' );
	  		}

	  		if ( modifyArrays ) {
	  			adapt.push( magicArrayAdaptor );
	  		}

	  		adapt.push( magicAdaptor$1 );
	  	}

	  	if ( modifyArrays ) {
	  		adapt.push( arrayAdaptor );
	  	}

	  	return adapt;


	  	function lookup ( adaptor ) {
	  		if ( typeof adaptor === 'string' ) {
	  			adaptor = findInViewHierarchy( 'adaptors', ractive, adaptor );

	  			if ( !adaptor ) {
	  				fatal( missingPlugin( adaptor, 'adaptor' ) );
	  			}
	  		}

	  		return adaptor;
	  	}
	  }

	  function initialiseProperties ( ractive ) {
	  	// Generate a unique identifier, for places where you'd use a weak map if it
	  	// existed
	  	ractive._guid = 'r-' + uid++;

	  	// events
	  	ractive._subs = create( null );

	  	// storage for item configuration from instantiation to reset,
	  	// like dynamic functions or original values
	  	ractive._config = {};

	  	// nodes registry
	  	ractive.nodes = {};

	  	// events
	  	ractive.event = null;
	  	ractive._eventQueue = [];

	  	// live queries
	  	ractive._liveQueries = [];
	  	ractive._liveComponentQueries = [];

	  	// observers
	  	ractive._observers = [];

	  	// links
	  	ractive._links = {};

	  	if(!ractive.component){
	  		ractive.root = ractive;
	  		ractive.parent = ractive.container = null; // TODO container still applicable?
	  	}

	  }

	  function deprecateRactiveData () {
	  	throw new Error( 'Using `ractive.data` is no longer supported - you must use the `ractive.get()` API instead' );
	  }

	  function getChildQueue ( queue, ractive ) {
	  	return queue[ ractive._guid ] || ( queue[ ractive._guid ] = [] );
	  }

	  function fire ( hookQueue, ractive ) {
	  	var childQueue = getChildQueue( hookQueue.queue, ractive );

	  	hookQueue.hook.fire( ractive );

	  	// queue is "live" because components can end up being
	  	// added while hooks fire on parents that modify data values.
	  	while ( childQueue.length ) {
	  		fire( hookQueue, childQueue.shift() );
	  	}

	  	delete hookQueue.queue[ ractive._guid ];
	  }

	  var HookQueue = function HookQueue ( event ) {
	  	this.hook = new Hook( event );
	  	this.inProcess = {};
	  	this.queue = {};
	  };

	  HookQueue.prototype.begin = function begin ( ractive ) {
	  	this.inProcess[ ractive._guid ] = true;
	  };

	  HookQueue.prototype.end = function end ( ractive ) {
	  	var parent = ractive.parent;

	  	// If this is *isn't* a child of a component that's in process,
	  	// it should call methods or fire at this point
	  	if ( !parent || !this.inProcess[ parent._guid ] ) {
	  		fire( this, ractive );
	  	}
	  	// elsewise, handoff to parent to fire when ready
	  	else {
	  		getChildQueue( this.queue, parent ).push( ractive );
	  	}

	  	delete this.inProcess[ ractive._guid ];
	  };

	  var configHook = new Hook( 'config' );
	  var initHook = new HookQueue( 'init' );

	  function initialise ( ractive, userOptions, options ) {
	  	Object.keys( ractive.viewmodel.computations ).forEach( function ( key ) {
	  		var computation = ractive.viewmodel.computations[ key ];

	  		if ( ractive.viewmodel.value.hasOwnProperty( key ) ) {
	  			computation.set( ractive.viewmodel.value[ key ] );
	  		}
	  	});

	  	// init config from Parent and options
	  	config.init( ractive.constructor, ractive, userOptions );

	  	configHook.fire( ractive );
	  	initHook.begin( ractive );

	  	var fragment;

	  	// Render virtual DOM
	  	if ( ractive.template ) {
	  		var cssIds;

	  		if ( options.cssIds || ractive.cssId ) {
	  			cssIds = options.cssIds ? options.cssIds.slice() : [];

	  			if ( ractive.cssId ) {
	  				cssIds.push( ractive.cssId );
	  			}
	  		}

	  		ractive.fragment = fragment = new Fragment({
	  			owner: ractive,
	  			template: ractive.template,
	  			cssIds: cssIds
	  		}).bind( ractive.viewmodel );
	  	}

	  	initHook.end( ractive );

	  	if ( fragment ) {
	  		// render automatically ( if `el` is specified )
	  		var el = getElement( ractive.el );
	  		if ( el ) {
	  			var promise = ractive.render( el, ractive.append );

	  			if ( Ractive.DEBUG_PROMISES ) {
	  				promise['catch']( function ( err ) {
	  					warnOnceIfDebug( 'Promise debugging is enabled, to help solve errors that happen asynchronously. Some browsers will log unhandled promise rejections, in which case you can safely disable promise debugging:\n  Ractive.DEBUG_PROMISES = false;' );
	  					warnIfDebug( 'An error happened during rendering', { ractive: ractive });
	  					logIfDebug( err );

	  					throw err;
	  				});
	  			}
	  		}
	  	}
	  }

	  function gatherRefs( fragment ) {
	  	var key = {}, index = {};

	  	// walk up the template gather refs as we go
	  	while ( fragment ) {
	  		if ( fragment.parent && ( fragment.parent.indexRef || fragment.parent.keyRef ) ) {
	  			var ref = fragment.parent.indexRef;
	  			if ( ref && !( ref in index ) ) index[ref] = fragment.index;
	  			ref = fragment.parent.keyRef;
	  			if ( ref && !( ref in key ) ) key[ref] = fragment.key;
	  		}

	  		if ( fragment.componentParent && !fragment.ractive.isolated ) {
	  			fragment = fragment.componentParent;
	  		} else {
	  			fragment = fragment.parent;
	  		}
	  	}

	  	return { key: key, index: index };
	  }

	  var eventPattern = /^event(?:\.(.+))?$/;
	  var argumentsPattern = /^arguments\.(\d*)$/;
	  var dollarArgsPattern = /^\$(\d*)$/;

	  var EventDirective = function EventDirective ( owner, event, template ) {
	  	this.owner = owner;
	  	this.event = event;
	  	this.template = template;

	  	this.ractive = owner.parentFragment.ractive;
	  	this.parentFragment = owner.parentFragment;

	  	this.context = null;
	  	this.passthru = false;

	  	// method calls
	  	this.method = null;
	  	this.resolvers = null;
	  	this.models = null;
	  	this.argsFn = null;

	  	// handler directive
	  	this.action = null;
	  	this.args = null;
	  };

	  EventDirective.prototype.bind = function bind () {
	  	var this$1 = this;

	  		this.context = this.parentFragment.findContext();

	  	var template = this.template;

	  	if ( template.m ) {
	  		this.method = template.m;

	  		// pass-thru "...arguments"
	  		this.passthru = !!template.g;

	  		if ( template.a ) {
	  			this.resolvers = [];
	  			this.models = template.a.r.map( function ( ref, i ) {

	  				if ( eventPattern.test( ref ) ) {
	  					// on-click="foo(event.node)"
	  					return {
	  						event: true,
	  						keys: ref.length > 5 ? splitKeypathI( ref.slice( 6 ) ) : [],
	  						unbind: noop
	  					};
	  				}

	  				var argMatch = argumentsPattern.exec( ref );
	  				if ( argMatch ) {
	  					// on-click="foo(arguments[0])"
	  					return {
	  						argument: true,
	  						index: argMatch[1]
	  					};
	  				}

	  				var dollarMatch = dollarArgsPattern.exec( ref );
	  				if ( dollarMatch ) {
	  					// on-click="foo($1)"
	  					return {
	  						argument: true,
	  						index: dollarMatch[1] - 1
	  					};
	  				}

	  				var resolver;

	  				var model = resolveReference( this$1.parentFragment, ref );
	  				if ( !model ) {
	  					resolver = this$1.parentFragment.resolve( ref, function ( model ) {
	  						this$1.models[i] = model;
	  						removeFromArray( this$1.resolvers, resolver );
	  					});

	  					this$1.resolvers.push( resolver );
	  				}

	  				return model;
	  			});

	  			this.argsFn = getFunction( template.a.s, template.a.r.length );
	  		}

	  	}

	  	else {
	  		// TODO deprecate this style of directive
	  		this.action = typeof template === 'string' ? // on-click='foo'
	  			template :
	  			typeof template.n === 'string' ? // on-click='{{dynamic}}'
	  				template.n :
	  				new Fragment({
	  					owner: this,
	  					template: template.n
	  				});

	  		this.args = template.a ? // static arguments
	  			( typeof template.a === 'string' ? [ template.a ] : template.a ) :
	  			template.d ? // dynamic arguments
	  				new Fragment({
	  					owner: this,
	  					template: template.d
	  				}) :
	  				[]; // no arguments
	  	}

	  	if ( this.template.n && typeof this.template.n !== 'string' ) this.action.bind();
	  	if ( this.template.d ) this.args.bind();
	  };

	  EventDirective.prototype.bubble = function bubble () {
	  	if ( !this.dirty ) {
	  		this.dirty = true;
	  		this.owner.bubble();
	  	}
	  };

	  EventDirective.prototype.fire = function fire ( event, passedArgs ) {

	  	// augment event object
	  	if ( passedArgs === void 0 ) passedArgs = [];

	  		if ( event ) {
	  		var refs = gatherRefs( this.parentFragment );
	  		event.keypath = this.context.getKeypath( this.ractive );
	  		event.rootpath = this.context.getKeypath();
	  		event.context = this.context.get();
	  		event.index = refs.index;
	  		event.key = refs.key;
	  	}

	  	if ( this.method ) {
	  		if ( typeof this.ractive[ this.method ] !== 'function' ) {
	  			throw new Error( ("Attempted to call a non-existent method (\"" + (this.method) + "\")") );
	  		}

	  		var args;

	  		if ( event ) passedArgs.unshift( event );

	  		if ( this.models ) {
	  			var values = this.models.map( function ( model ) {
	  				if ( !model ) return undefined;

	  				if ( model.event ) {
	  					var obj = event;
	  					var keys = model.keys.slice();

	  					while ( keys.length ) obj = obj[ keys.shift() ];
	  					return obj;
	  				}

	  				if ( model.argument ) {
	  					return passedArgs ? passedArgs[ model.index ] : void 0;
	  				}

	  				if ( model.wrapper ) {
	  					return model.wrapper.value;
	  				}

	  				return model.get();
	  			});

	  			args = this.argsFn.apply( null, values );
	  		}

	  		if ( this.passthru ) {
	  			args = args ? args.concat( passedArgs ) : passedArgs;
	  		}

	  		// make event available as `this.event`
	  		var ractive = this.ractive;
	  		var oldEvent = ractive.event;

	  		ractive.event = event;
	  		var result = ractive[ this.method ].apply( ractive, args );

	  		// Auto prevent and stop if return is explicitly false
	  		var original;
	  		if ( result === false && ( original = event.original ) ) {
	  			original.preventDefault && original.preventDefault();
	  			original.stopPropagation && original.stopPropagation();
	  		}

	  		ractive.event = oldEvent;
	  	}

	  	else {
	  		var action = this.action.toString();
	  		var args$1 = this.template.d ? this.args.getArgsList() : this.args;

	  		if ( passedArgs.length ) args$1 = args$1.concat( passedArgs );

	  		if ( event ) event.name = action;

	  		fireEvent( this.ractive, action, {
	  			event: event,
	  			args: args$1
	  		});
	  	}
	  };

	  EventDirective.prototype.rebind = function rebind () {
	  	this.unbind();
	  	this.bind();
	  };

	  EventDirective.prototype.render = function render () {
	  	this.event.listen( this );
	  };

	  EventDirective.prototype.unbind = function unbind$1 () {
	  	var template = this.template;

	  	if ( template.m ) {
	  		if ( this.resolvers ) this.resolvers.forEach( unbind );
	  		this.resolvers = [];

	  		this.models = null;
	  	}

	  	else {
	  		// TODO this is brittle and non-explicit, fix it
	  		if ( this.action.unbind ) this.action.unbind();
	  		if ( this.args.unbind ) this.args.unbind();
	  	}
	  };

	  EventDirective.prototype.unrender = function unrender () {
	  	this.event.unlisten();
	  };

	  EventDirective.prototype.update = function update () {
	  	if ( this.method || !this.dirty ) return; // nothing to do

	  	this.dirty = false;

	  	// ugh legacy
	  	if ( this.action.update ) this.action.update();
	  	if ( this.template.d ) this.args.update();
	  };

	  var RactiveEvent = function RactiveEvent ( ractive, name ) {
	  	this.ractive = ractive;
	  	this.name = name;
	  	this.handler = null;
	  };

	  RactiveEvent.prototype.listen = function listen ( directive ) {
	  	var ractive = this.ractive;

	  	this.handler = ractive.on( this.name, function () {
	  		var event;

	  		// semi-weak test, but what else? tag the event obj ._isEvent ?
	  		if ( arguments.length && arguments[0] && arguments[0].node ) {
	  			event = Array.prototype.shift.call( arguments );
	  			event.component = ractive;
	  		}

	  		var args = Array.prototype.slice.call( arguments );
	  		directive.fire( event, args );

	  		// cancel bubbling
	  		return false;
	  	});
	  };

	  RactiveEvent.prototype.unlisten = function unlisten () {
	  	this.handler.cancel();
	  };

	  // TODO it's unfortunate that this has to run every time a
	  // component is rendered... is there a better way?
	  function updateLiveQueries ( component ) {
	  	// Does this need to be added to any live queries?
	  	var instance = component.ractive;

	  	do {
	  		var liveQueries = instance._liveComponentQueries;

	  		var i = liveQueries.length;
	  		while ( i-- ) {
	  			var name = liveQueries[i];
	  			var query = liveQueries[ ("_" + name) ];

	  			if ( query.test( component ) ) {
	  				query.add( component.instance );
	  				// keep register of applicable selectors, for when we teardown
	  				component.liveQueries.push( query );
	  			}
	  		}
	  	} while ( instance = instance.parent );
	  }

	  function removeFromLiveComponentQueries ( component ) {
	  	var instance = component.ractive;

	  	while ( instance ) {
	  		var query = instance._liveComponentQueries[ ("_" + (component.name)) ];
	  		if ( query ) query.remove( component );

	  		instance = instance.parent;
	  	}
	  }

	  function makeDirty ( query ) {
	  	query.makeDirty();
	  }

	  var teardownHook = new Hook( 'teardown' );

	  var Component = (function (Item) {
	  	function Component ( options, ComponentConstructor ) {
	  		Item.call( this, options );
	  		this.type = COMPONENT; // override ELEMENT from super

	  		var instance = create( ComponentConstructor.prototype );

	  		this.instance = instance;
	  		this.name = options.template.e;
	  		this.parentFragment = options.parentFragment;
	  		this.complexMappings = [];

	  		this.liveQueries = [];

	  		if ( instance.el ) {
	  			warnIfDebug( ("The <" + (this.name) + "> component has a default 'el' property; it has been disregarded") );
	  		}

	  		var partials = options.template.p || {};
	  		if ( !( 'content' in partials ) ) partials.content = options.template.f || [];
	  		this._partials = partials; // TEMP

	  		this.yielders = {};

	  		// find container
	  		var fragment = options.parentFragment;
	  		var container;
	  		while ( fragment ) {
	  			if ( fragment.owner.type === YIELDER ) {
	  				container = fragment.owner.container;
	  				break;
	  			}

	  			fragment = fragment.parent;
	  		}

	  		// add component-instance-specific properties
	  		instance.parent = this.parentFragment.ractive;
	  		instance.container = container || null;
	  		instance.root = instance.parent.root;
	  		instance.component = this;

	  		construct( this.instance, { partials: partials });

	  		// for hackability, this could be an open option
	  		// for any ractive instance, but for now, just
	  		// for components and just for ractive...
	  		instance._inlinePartials = partials;

	  		this.eventHandlers = [];
	  		if ( this.template.v ) this.setupEvents();
	  	}

	  	Component.prototype = Object.create( Item && Item.prototype );
	  	Component.prototype.constructor = Component;

	  	Component.prototype.bind = function bind$1 () {
	  		var this$1 = this;

	  		var viewmodel = this.instance.viewmodel;
	  		var childData = viewmodel.value;

	  		// determine mappings
	  		if ( this.template.a ) {
	  			Object.keys( this.template.a ).forEach( function ( localKey ) {
	  				var template = this$1.template.a[ localKey ];
	  				var model;
	  				var fragment;

	  				if ( template === 0 ) {
	  					// empty attributes are `true`
	  					viewmodel.joinKey( localKey ).set( true );
	  				}

	  				else if ( typeof template === 'string' ) {
	  					var parsed = parseJSON( template );
	  					viewmodel.joinKey( localKey ).set( parsed ? parsed.value : template );
	  				}

	  				else if ( isArray( template ) ) {
	  					if ( template.length === 1 && template[0].t === INTERPOLATOR ) {
	  						model = resolve$1( this$1.parentFragment, template[0] );

	  						if ( !model ) {
	  							warnOnceIfDebug( ("The " + localKey + "='{{" + (template[0].r) + "}}' mapping is ambiguous, and may cause unexpected results. Consider initialising your data to eliminate the ambiguity"), { ractive: this$1.instance }); // TODO add docs page explaining this
	  							this$1.parentFragment.ractive.get( localKey ); // side-effect: create mappings as necessary
	  							model = this$1.parentFragment.findContext().joinKey( localKey );
	  						}

	  						viewmodel.map( localKey, model );

	  						if ( model.get() === undefined && localKey in childData ) {
	  							model.set( childData[ localKey ] );
	  						}
	  					}

	  					else {
	  						fragment = new Fragment({
	  							owner: this$1,
	  							template: template
	  						}).bind();

	  						model = viewmodel.joinKey( localKey );
	  						model.set( fragment.valueOf() );

	  						// this is a *bit* of a hack
	  						fragment.bubble = function () {
	  							Fragment.prototype.bubble.call( fragment );
	  							fragment.update();
	  							model.set( fragment.valueOf() );
	  						};

	  						this$1.complexMappings.push( fragment );
	  					}
	  				}
	  			});
	  		}

	  		initialise( this.instance, {
	  			partials: this._partials
	  		}, {
	  			cssIds: this.parentFragment.cssIds
	  		});

	  		this.eventHandlers.forEach( bind );
	  	};

	  	Component.prototype.bubble = function bubble () {
	  		if ( !this.dirty ) {
	  			this.dirty = true;
	  			this.parentFragment.bubble();
	  		}
	  	};

	  	Component.prototype.checkYielders = function checkYielders () {
	  		var this$1 = this;

	  		Object.keys( this.yielders ).forEach( function ( name ) {
	  			if ( this$1.yielders[ name ].length > 1 ) {
	  				runloop.end();
	  				throw new Error( ("A component template can only have one {{yield" + (name ? ' ' + name : '') + "}} declaration at a time") );
	  			}
	  		});
	  	};

	  	Component.prototype.detach = function detach () {
	  		return this.instance.fragment.detach();
	  	};

	  	Component.prototype.find = function find ( selector ) {
	  		return this.instance.fragment.find( selector );
	  	};

	  	Component.prototype.findAll = function findAll ( selector, query ) {
	  		this.instance.fragment.findAll( selector, query );
	  	};

	  	Component.prototype.findComponent = function findComponent ( name ) {
	  		if ( !name || this.name === name ) return this.instance;

	  		if ( this.instance.fragment ) {
	  			return this.instance.fragment.findComponent( name );
	  		}
	  	};

	  	Component.prototype.findAllComponents = function findAllComponents ( name, query ) {
	  		if ( query.test( this ) ) {
	  			query.add( this.instance );

	  			if ( query.live ) {
	  				this.liveQueries.push( query );
	  			}
	  		}

	  		this.instance.fragment.findAllComponents( name, query );
	  	};

	  	Component.prototype.firstNode = function firstNode ( skipParent ) {
	  		return this.instance.fragment.firstNode( skipParent );
	  	};

	  	Component.prototype.rebind = function rebind$1 () {
	  		var this$1 = this;

	  		this.complexMappings.forEach( rebind );

	  		this.liveQueries.forEach( makeDirty );

	  		// update relevant mappings
	  		var viewmodel = this.instance.viewmodel;
	  		viewmodel.mappings = {};

	  		if ( this.template.a ) {
	  			Object.keys( this.template.a ).forEach( function ( localKey ) {
	  				var template = this$1.template.a[ localKey ];
	  				var model;

	  				if ( isArray( template ) && template.length === 1 && template[0].t === INTERPOLATOR ) {
	  					model = resolve$1( this$1.parentFragment, template[0] );

	  					if ( !model ) {
	  						// TODO is this even possible?
	  						warnOnceIfDebug( ("The " + localKey + "='{{" + (template[0].r) + "}}' mapping is ambiguous, and may cause unexpected results. Consider initialising your data to eliminate the ambiguity"), { ractive: this$1.instance });
	  						this$1.parentFragment.ractive.get( localKey ); // side-effect: create mappings as necessary
	  						model = this$1.parentFragment.findContext().joinKey( localKey );
	  					}

	  					viewmodel.map( localKey, model );
	  				}
	  			});
	  		}

	  		this.instance.fragment.rebind( viewmodel );
	  	};

	  	Component.prototype.render = function render$1$$ ( target, occupants ) {
	  		render$1( this.instance, target, null, occupants );

	  		this.checkYielders();
	  		this.eventHandlers.forEach( render );
	  		updateLiveQueries( this );

	  		this.rendered = true;
	  	};

	  	Component.prototype.setupEvents = function setupEvents () {
	  		var this$1 = this;

	  		var handlers = this.eventHandlers;

	  		Object.keys( this.template.v ).forEach( function ( key ) {
	  			var eventNames = key.split( '-' );
	  			var template = this$1.template.v[ key ];

	  			eventNames.forEach( function ( eventName ) {
	  				var event = new RactiveEvent( this$1.instance, eventName );
	  				handlers.push( new EventDirective( this$1, event, template ) );
	  			});
	  		});
	  	};

	  	Component.prototype.toString = function toString () {
	  		return this.instance.toHTML();
	  	};

	  	Component.prototype.unbind = function unbind$1 () {
	  		this.complexMappings.forEach( unbind );

	  		var instance = this.instance;
	  		instance.viewmodel.teardown();
	  		instance.fragment.unbind();
	  		instance._observers.forEach( cancel );

	  		removeFromLiveComponentQueries( this );

	  		if ( instance.fragment.rendered && instance.el.__ractive_instances__ ) {
	  			removeFromArray( instance.el.__ractive_instances__, instance );
	  		}

	  		Object.keys( instance._links ).forEach( function ( k ) { return instance._links[k].unlink(); } );

	  		teardownHook.fire( instance );
	  	};

	  	Component.prototype.unrender = function unrender$1 ( shouldDestroy ) {
	  		var this$1 = this;

	  		this.shouldDestroy = shouldDestroy;
	  		this.instance.unrender();
	  		this.eventHandlers.forEach( unrender );
	  		this.liveQueries.forEach( function ( query ) { return query.remove( this$1.instance ); } );
	  	};

	  	Component.prototype.update = function update$1 () {
	  		this.dirty = false;
	  		this.instance.fragment.update();
	  		this.checkYielders();
	  		this.eventHandlers.forEach( update );
	  		this.complexMappings.forEach( update );
	  	};

	  	return Component;
	  }(Item));

	  var Doctype = (function (Item) {
	  	function Doctype () {
	  		Item.apply(this, arguments);
	  	}

	  	Doctype.prototype = Object.create( Item && Item.prototype );
	  	Doctype.prototype.constructor = Doctype;

	  	Doctype.prototype.bind = function bind () {
	  		// noop
	  	};

	  	Doctype.prototype.render = function render () {
	  		// noop
	  	};

	  	Doctype.prototype.teardown = function teardown () {
	  		// noop
	  	};

	  	Doctype.prototype.toString = function toString () {
	  		return '<!DOCTYPE' + this.template.a + '>';
	  	};

	  	Doctype.prototype.unbind = function unbind () {
	  		// noop
	  	};

	  	Doctype.prototype.unrender = function unrender () {
	  		// noop
	  	};

	  	return Doctype;
	  }(Item));

	  function camelCase ( hyphenatedStr ) {
	  	return hyphenatedStr.replace( /-([a-zA-Z])/g, function ( match, $1 ) {
	  		return $1.toUpperCase();
	  	});
	  }

	  var space = /\s+/;
	  var specials$1 = { 'float': 'cssFloat' };
	  var remove = /\/\*(?:[\s\S]*?)\*\//g;
	  var escape = /url\(\s*(['"])(?:\\[\s\S]|(?!\1).)*\1\s*\)|url\((?:\\[\s\S]|[^)])*\)|(['"])(?:\\[\s\S]|(?!\1).)*\2/gi;
	  var value = /\0(\d+)/g;

	  function readStyle ( css ) {
	      var values = [];

	      if ( typeof css !== 'string' ) return {};

	      return css.replace( escape, function ( match ) { return ("\u0000" + (values.push( match ) - 1)); })
	          .replace( remove, '' )
	          .split( ';' )
	          .filter( function ( rule ) { return !!rule.trim(); } )
	          .map( function ( rule ) { return rule.replace( value, function ( match, n ) { return values[ n ]; } ); } )
	          .reduce(function ( rules, rule ) {
	              var i = rule.indexOf(':');
	              var name = camelCase( rule.substr( 0, i ).trim() );
	              rules[ specials$1[ name ] || name ] = rule.substr( i + 1 ).trim();
	              return rules;
	          }, {});
	  }

	  function readClass ( str ) {
	    var list = str.split( space );

	    // remove any empty entries
	    var i = list.length;
	    while ( i-- ) {
	      if ( !list[i] ) list.splice( i, 1 );
	    }

	    return list;
	  }

	  var textTypes = [ undefined, 'text', 'search', 'url', 'email', 'hidden', 'password', 'search', 'reset', 'submit' ];

	  function getUpdateDelegate ( attribute ) {
	  	var element = attribute.element, name = attribute.name;

	  	if ( name === 'id' ) return updateId;

	  	if ( name === 'value' ) {
	  		// special case - selects
	  		if ( element.name === 'select' && name === 'value' ) {
	  			return element.getAttribute( 'multiple' ) ? updateMultipleSelectValue : updateSelectValue;
	  		}

	  		if ( element.name === 'textarea' ) return updateStringValue;

	  		// special case - contenteditable
	  		if ( element.getAttribute( 'contenteditable' ) != null ) return updateContentEditableValue;

	  		// special case - <input>
	  		if ( element.name === 'input' ) {
	  			var type = element.getAttribute( 'type' );

	  			// type='file' value='{{fileList}}'>
	  			if ( type === 'file' ) return noop; // read-only

	  			// type='radio' name='{{twoway}}'
	  			if ( type === 'radio' && element.binding && element.binding.attribute.name === 'name' ) return updateRadioValue;

	  			if ( ~textTypes.indexOf( type ) ) return updateStringValue;
	  		}

	  		return updateValue;
	  	}

	  	var node = element.node;

	  	// special case - <input type='radio' name='{{twoway}}' value='foo'>
	  	if ( attribute.isTwoway && name === 'name' ) {
	  		if ( node.type === 'radio' ) return updateRadioName;
	  		if ( node.type === 'checkbox' ) return updateCheckboxName;
	  	}

	  	if ( name === 'style' ) return updateStyleAttribute;

	  	if ( name.indexOf( 'style-' ) === 0 ) return updateInlineStyle;

	  	// special case - class names. IE fucks things up, again
	  	if ( name === 'class' && ( !node.namespaceURI || node.namespaceURI === html ) ) return updateClassName;

	  	if ( name.indexOf( 'class-' ) === 0 ) return updateInlineClass;

	  	if ( attribute.isBoolean ) return updateBoolean;

	  	if ( attribute.namespace && attribute.namespace !== attribute.node.namespaceURI ) return updateNamespacedAttribute;

	  	return updateAttribute;
	  }

	  function updateId () {
	  	var ref = this, node = ref.node;
	  	var value = this.getValue();

	  	delete this.ractive.nodes[ node.id ];
	  	this.ractive.nodes[ value ] = node;

	  	node.id = value;
	  }

	  function updateMultipleSelectValue () {
	  	var value = this.getValue();

	  	if ( !isArray( value ) ) value = [ value ];

	  	var options = this.node.options;
	  	var i = options.length;

	  	while ( i-- ) {
	  		var option = options[i];
	  		var optionValue = option._ractive ?
	  			option._ractive.value :
	  			option.value; // options inserted via a triple don't have _ractive

	  		option.selected = arrayContains( value, optionValue );
	  	}
	  }

	  function updateSelectValue () {
	  	var value = this.getValue();

	  	if ( !this.locked ) { // TODO is locked still a thing?
	  		this.node._ractive.value = value;

	  		var options = this.node.options;
	  		var i = options.length;

	  		while ( i-- ) {
	  			var option = options[i];
	  			var optionValue = option._ractive ?
	  				option._ractive.value :
	  				option.value; // options inserted via a triple don't have _ractive

	  			if ( optionValue == value ) { // double equals as we may be comparing numbers with strings
	  				option.selected = true;
	  				return;
	  			}
	  		}

	  		this.node.selectedIndex = -1;
	  	}
	  }


	  function updateContentEditableValue () {
	  	var value = this.getValue();

	  	if ( !this.locked ) {
	  		this.node.innerHTML = value === undefined ? '' : value;
	  	}
	  }

	  function updateRadioValue () {
	  	var node = this.node;
	  	var wasChecked = node.checked;

	  	var value = this.getValue();

	  	//node.value = this.element.getAttribute( 'value' );
	  	node.value = this.node._ractive.value = value;
	  	node.checked = value === this.element.getAttribute( 'name' );

	  	// This is a special case - if the input was checked, and the value
	  	// changed so that it's no longer checked, the twoway binding is
	  	// most likely out of date. To fix it we have to jump through some
	  	// hoops... this is a little kludgy but it works
	  	if ( wasChecked && !node.checked && this.element.binding && this.element.binding.rendered ) {
	  		this.element.binding.group.model.set( this.element.binding.group.getValue() );
	  	}
	  }

	  function updateValue () {
	  	if ( !this.locked ) {
	  		var value = this.getValue();

	  		this.node.value = this.node._ractive.value = value;
	  		this.node.setAttribute( 'value', value );
	  	}
	  }

	  function updateStringValue () {
	  	if ( !this.locked ) {
	  		var value = this.getValue();

	  		this.node._ractive.value = value;

	  		this.node.value = safeToStringValue( value );
	  		this.node.setAttribute( 'value', safeToStringValue( value ) );
	  	}
	  }

	  function updateRadioName () {
	  	this.node.checked = ( this.getValue() == this.node._ractive.value );
	  }

	  function updateCheckboxName () {
	  	var ref = this, element = ref.element, node = ref.node;
	  	var binding = element.binding;

	  	var value = this.getValue();
	  	var valueAttribute = element.getAttribute( 'value' );

	  	if ( !isArray( value ) ) {
	  		binding.isChecked = node.checked = ( value == valueAttribute );
	  	} else {
	  		var i = value.length;
	  		while ( i-- ) {
	  			if ( valueAttribute == value[i] ) {
	  				binding.isChecked = node.checked = true;
	  				return;
	  			}
	  		}
	  		binding.isChecked = node.checked = false;
	  	}
	  }

	  function updateStyleAttribute () {
	  	var props = readStyle( this.getValue() || '' );
	  	var style = this.node.style;
	  	var keys = Object.keys( props );
	  	var prev = this.previous || [];

	  	var i = 0;
	  	while ( i < keys.length ) {
	  		if ( keys[i] in style ) style[ keys[i] ] = props[ keys[i] ];
	  		i++;
	  	}

	  	// remove now-missing attrs
	  	i = prev.length;
	  	while ( i-- ) {
	  		if ( !~keys.indexOf( prev[i] ) && prev[i] in style ) style[ prev[i] ] = '';
	  	}

	  	this.previous = keys;
	  }

	  var camelize = /(-.)/g;
	  function updateInlineStyle () {
	  	if ( !this.styleName ) {
	  		this.styleName = this.name.substr( 6 ).replace( camelize, function ( s ) { return s.charAt( 1 ).toUpperCase(); } );
	  	}

	  	this.node.style[ this.styleName ] = this.getValue();
	  }

	  function updateClassName () {
	  	var value = readClass( safeToStringValue( this.getValue() ) );
	  	var attr = readClass( this.node.className );
	  	var prev = this.previous || [];

	  	var i = 0;
	  	while ( i < value.length ) {
	  		if ( !~attr.indexOf( value[i] ) ) attr.push( value[i] );
	  		i++;
	  	}

	  	// remove now-missing classes
	  	i = prev.length;
	  	while ( i-- ) {
	  		if ( !~value.indexOf( prev[i] ) ) {
	  			var idx = attr.indexOf( prev[i] );
	  			if ( ~idx ) attr.splice( idx, 1 );
	  		}
	  	}

	  	this.node.className = attr.join( ' ' );

	  	this.previous = value;
	  }

	  function updateInlineClass () {
	  	var name = this.name.substr( 6 );
	  	var attr = readClass( this.node.className );
	  	var value = this.getValue();

	  	if ( value && !~attr.indexOf( name ) ) attr.push( name );
	  	else if ( !value && ~attr.indexOf( name ) ) attr.splice( attr.indexOf( name ), 1 );

	  	this.node.className = attr.join( ' ' );
	  }

	  function updateBoolean () {
	  	// with two-way binding, only update if the change wasn't initiated by the user
	  	// otherwise the cursor will often be sent to the wrong place
	  	if ( !this.locked ) {
	  		if ( this.useProperty ) {
	  			this.node[ this.propertyName ] = this.getValue();
	  		} else {
	  			if ( this.getValue() ) {
	  				this.node.setAttribute( this.propertyName, '' );
	  			} else {
	  				this.node.removeAttribute( this.propertyName );
	  			}
	  		}
	  	}
	  }

	  function updateAttribute () {
	  	this.node.setAttribute( this.name, safeToStringValue( this.getString() ) );
	  }

	  function updateNamespacedAttribute () {
	  	this.node.setAttributeNS( this.namespace, this.name.slice( this.name.indexOf( ':' ) + 1 ), safeToStringValue( this.getString() ) );
	  }

	  var propertyNames = {
	  	'accept-charset': 'acceptCharset',
	  	accesskey: 'accessKey',
	  	bgcolor: 'bgColor',
	  	'class': 'className',
	  	codebase: 'codeBase',
	  	colspan: 'colSpan',
	  	contenteditable: 'contentEditable',
	  	datetime: 'dateTime',
	  	dirname: 'dirName',
	  	'for': 'htmlFor',
	  	'http-equiv': 'httpEquiv',
	  	ismap: 'isMap',
	  	maxlength: 'maxLength',
	  	novalidate: 'noValidate',
	  	pubdate: 'pubDate',
	  	readonly: 'readOnly',
	  	rowspan: 'rowSpan',
	  	tabindex: 'tabIndex',
	  	usemap: 'useMap'
	  };

	  function lookupNamespace ( node, prefix ) {
	  	var qualified = "xmlns:" + prefix;

	  	while ( node ) {
	  		if ( node.hasAttribute( qualified ) ) return node.getAttribute( qualified );
	  		node = node.parentNode;
	  	}

	  	return namespaces[ prefix ];
	  }

	  var Attribute = (function (Item) {
	  	function Attribute ( options ) {
	  		Item.call( this, options );

	  		this.name = options.name;
	  		this.namespace = null;
	  		this.element = options.element;
	  		this.parentFragment = options.element.parentFragment; // shared
	  		this.ractive = this.parentFragment.ractive;

	  		this.rendered = false;
	  		this.updateDelegate = null;
	  		this.fragment = null;
	  		this.value = null;

	  		if ( !isArray( options.template ) ) {
	  			this.value = options.template;
	  			if ( this.value === 0 ) {
	  				this.value = '';
	  			}
	  		} else {
	  			this.fragment = new Fragment({
	  				owner: this,
	  				template: options.template
	  			});
	  		}

	  		this.interpolator = this.fragment &&
	  		                    this.fragment.items.length === 1 &&
	  		                    this.fragment.items[0].type === INTERPOLATOR &&
	  		                    this.fragment.items[0];
	  	}

	  	Attribute.prototype = Object.create( Item && Item.prototype );
	  	Attribute.prototype.constructor = Attribute;

	  	Attribute.prototype.bind = function bind () {
	  		if ( this.fragment ) {
	  			this.fragment.bind();
	  		}
	  	};

	  	Attribute.prototype.bubble = function bubble () {
	  		if ( !this.dirty ) {
	  			this.element.bubble();
	  			this.dirty = true;
	  		}
	  	};

	  	Attribute.prototype.getString = function getString () {
	  		return this.fragment ?
	  			this.fragment.toString() :
	  			this.value != null ? '' + this.value : '';
	  	};

	  	// TODO could getValue ever be called for a static attribute,
	  	// or can we assume that this.fragment exists?
	  	Attribute.prototype.getValue = function getValue () {
	  		return this.fragment ? this.fragment.valueOf() : booleanAttributes.test( this.name ) ? true : this.value;
	  	};

	  	Attribute.prototype.rebind = function rebind () {
	  		if (this.fragment) this.fragment.rebind();
	  	};

	  	Attribute.prototype.render = function render () {
	  		var node = this.element.node;
	  		this.node = node;

	  		// should we use direct property access, or setAttribute?
	  		if ( !node.namespaceURI || node.namespaceURI === namespaces.html ) {
	  			this.propertyName = propertyNames[ this.name ] || this.name;

	  			if ( node[ this.propertyName ] !== undefined ) {
	  				this.useProperty = true;
	  			}

	  			// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.
	  			// node.selected = true rather than node.setAttribute( 'selected', '' )
	  			if ( booleanAttributes.test( this.name ) || this.isTwoway ) {
	  				this.isBoolean = true;
	  			}

	  			if ( this.propertyName === 'value' ) {
	  				node._ractive.value = this.value;
	  			}
	  		}

	  		if ( node.namespaceURI ) {
	  			var index = this.name.indexOf( ':' );
	  			if ( index !== -1 ) {
	  				this.namespace = lookupNamespace( node, this.name.slice( 0, index ) );
	  			} else {
	  				this.namespace = node.namespaceURI;
	  			}
	  		}

	  		this.rendered = true;
	  		this.updateDelegate = getUpdateDelegate( this );
	  		this.updateDelegate();
	  	};

	  	Attribute.prototype.toString = function toString () {
	  		var value = this.getValue();

	  		// Special case - select and textarea values (should not be stringified)
	  		if ( this.name === 'value' && ( this.element.getAttribute( 'contenteditable' ) !== undefined || ( this.element.name === 'select' || this.element.name === 'textarea' ) ) ) {
	  			return;
	  		}

	  		// Special case – bound radio `name` attributes
	  		if ( this.name === 'name' && this.element.name === 'input' && this.interpolator && this.element.getAttribute( 'type' ) === 'radio' ) {
	  			return ("name=\"{{" + (this.interpolator.model.getKeypath()) + "}}\"");
	  		}

	  		if ( booleanAttributes.test( this.name ) ) return value ? this.name : '';
	  		if ( value == null ) return '';

	  		var str = safeToStringValue( this.getString() )
	  			.replace( /&/g, '&amp;' )
	  			.replace( /"/g, '&quot;' )
	  			.replace( /'/g, '&#39;' );

	  		return str ?
	  			("" + (this.name) + "=\"" + str + "\"") :
	  			this.name;
	  	};

	  	Attribute.prototype.unbind = function unbind () {
	  		if ( this.fragment ) this.fragment.unbind();
	  	};

	  	Attribute.prototype.update = function update () {
	  		if ( this.dirty ) {
	  			this.dirty = false;
	  			if ( this.fragment ) this.fragment.update();
	  			if ( this.rendered ) this.updateDelegate();
	  		}
	  	};

	  	return Attribute;
	  }(Item));

	  var div$1 = doc ? createElement( 'div' ) : null;

	  var ConditionalAttribute = (function (Item) {
	  	function ConditionalAttribute ( options ) {
	  		Item.call( this, options );

	  		this.attributes = [];

	  		this.owner = options.owner;

	  		this.fragment = new Fragment({
	  			ractive: this.ractive,
	  			owner: this,
	  			template: [ this.template ]
	  		});

	  		this.dirty = false;
	  	}

	  	ConditionalAttribute.prototype = Object.create( Item && Item.prototype );
	  	ConditionalAttribute.prototype.constructor = ConditionalAttribute;

	  	ConditionalAttribute.prototype.bind = function bind () {
	  		this.fragment.bind();
	  	};

	  	ConditionalAttribute.prototype.bubble = function bubble () {
	  		if ( !this.dirty ) {
	  			this.dirty = true;
	  			this.owner.bubble();
	  		}
	  	};

	  	ConditionalAttribute.prototype.rebind = function rebind () {
	  		this.fragment.rebind();
	  	};

	  	ConditionalAttribute.prototype.render = function render () {
	  		this.node = this.owner.node;
	  		this.isSvg = this.node.namespaceURI === svg$1;

	  		this.rendered = true;
	  		this.dirty = true; // TODO this seems hacky, but necessary for tests to pass in browser AND node.js
	  		this.update();
	  	};

	  	ConditionalAttribute.prototype.toString = function toString () {
	  		return this.fragment.toString();
	  	};

	  	ConditionalAttribute.prototype.unbind = function unbind () {
	  		this.fragment.unbind();
	  	};

	  	ConditionalAttribute.prototype.unrender = function unrender () {
	  		this.rendered = false;
	  	};

	  	ConditionalAttribute.prototype.update = function update () {
	  		var this$1 = this;

	  		var str;
	  		var attrs;

	  		if ( this.dirty ) {
	  			this.dirty = false;

	  			this.fragment.update();

	  			if ( this.rendered ) {
	  				str = this.fragment.toString();
	  				attrs = parseAttributes( str, this.isSvg );

	  				// any attributes that previously existed but no longer do
	  				// must be removed
	  				this.attributes.filter( function ( a ) { return notIn( attrs, a ); } ).forEach( function ( a ) {
	  					this$1.node.removeAttribute( a.name );
	  				});

	  				attrs.forEach( function ( a ) {
	  					this$1.node.setAttribute( a.name, a.value );
	  				});

	  				this.attributes = attrs;
	  			}
	  		}
	  	};

	  	return ConditionalAttribute;
	  }(Item));

	  function parseAttributes ( str, isSvg ) {
	  	var tagName = isSvg ? 'svg' : 'div';
	  	return str
	  		? (div$1.innerHTML = "<" + tagName + " " + str + "></" + tagName + ">") &&
	  			toArray(div$1.childNodes[0].attributes)
	  		: [];
	  }

	  function notIn ( haystack, needle ) {
	  	var i = haystack.length;

	  	while ( i-- ) {
	  		if ( haystack[i].name === needle.name ) {
	  			return false;
	  		}
	  	}

	  	return true;
	  }

	  var missingDecorator = {
	  	update: noop,
	  	teardown: noop
	  };

	  var Decorator = function Decorator ( owner, template ) {
	  	this.owner = owner;
	  	this.template = template;

	  	this.parentFragment = owner.parentFragment;
	  	this.ractive = owner.ractive;

	  	this.dynamicName = typeof template.n === 'object';
	  	this.dynamicArgs = !!template.d;

	  	if ( this.dynamicName ) {
	  		this.nameFragment = new Fragment({
	  			owner: this,
	  			template: template.n
	  		});
	  	} else {
	  		this.name = template.n || template;
	  	}

	  	if ( this.dynamicArgs ) {
	  		this.argsFragment = new Fragment({
	  			owner: this,
	  			template: template.d
	  		});
	  	} else {
	  		this.args = template.a || [];
	  	}

	  	this.node = null;
	  	this.intermediary = null;
	  };

	  Decorator.prototype.bind = function bind () {
	  	if ( this.dynamicName ) {
	  		this.nameFragment.bind();
	  		this.name = this.nameFragment.toString();
	  	}

	  	if ( this.dynamicArgs ) this.argsFragment.bind();
	  };

	  Decorator.prototype.bubble = function bubble () {
	  	if ( !this.dirty ) {
	  		this.dirty = true;
	  		this.owner.bubble();
	  	}
	  };

	  Decorator.prototype.rebind = function rebind () {
	  	if ( this.dynamicName ) this.nameFragment.rebind();
	  	if ( this.dynamicArgs ) this.argsFragment.rebind();
	  };

	  Decorator.prototype.render = function render () {
	  	var fn = findInViewHierarchy( 'decorators', this.ractive, this.name );

	  	if ( !fn ) {
	  		warnOnce( missingPlugin( this.name, 'decorator' ) );
	  		this.intermediary = missingDecorator;
	  		return;
	  	}

	  	this.node = this.owner.node;

	  	var args = this.dynamicArgs ? this.argsFragment.getArgsList() : this.args;
	  	this.intermediary = fn.apply( this.ractive, [ this.node ].concat( args ) );

	  	if ( !this.intermediary || !this.intermediary.teardown ) {
	  		throw new Error( ("The '" + (this.name) + "' decorator must return an object with a teardown method") );
	  	}
	  };

	  Decorator.prototype.unbind = function unbind () {
	  	if ( this.dynamicName ) this.nameFragment.unbind();
	  	if ( this.dynamicArgs ) this.argsFragment.unbind();
	  };

	  Decorator.prototype.unrender = function unrender () {
	  	if ( this.intermediary ) this.intermediary.teardown();
	  };

	  Decorator.prototype.update = function update () {
	  	if ( !this.dirty ) return;

	  	this.dirty = false;

	  	var nameChanged = false;

	  	if ( this.dynamicName && this.nameFragment.dirty ) {
	  		var name = this.nameFragment.toString();
	  		nameChanged = name !== this.name;
	  		this.name = name;
	  	}

	  	if ( this.intermediary ) {
	  		if ( nameChanged || !this.intermediary.update ) {
	  			this.unrender();
	  			this.render();
	  		}
	  		else {
	  			if ( this.dynamicArgs ) {
	  				if ( this.argsFragment.dirty ) {
	  					var args = this.argsFragment.getArgsList();
	  					this.intermediary.update.apply( this.ractive, args );
	  				}
	  			}
	  			else {
	  				this.intermediary.update.apply( this.ractive, this.args );
	  			}
	  		}
	  	}

	  	// need to run these for unrender/render cases
	  	// so can't just be in conditional if above

	  	if ( this.dynamicName && this.nameFragment.dirty ) {
	  		this.nameFragment.update();
	  	}

	  	if ( this.dynamicArgs && this.argsFragment.dirty ) {
	  		this.argsFragment.update();
	  	}
	  };

	  var DOMEvent = function DOMEvent ( name, owner ) {
	  	if ( name.indexOf( '*' ) !== -1 ) {
	  		fatal( ("Only component proxy-events may contain \"*\" wildcards, <" + (owner.name) + " on-" + name + "=\"...\"/> is not valid") );
	  	}

	  	this.name = name;
	  	this.owner = owner;
	  	this.node = null;
	  	this.handler = null;
	  };

	  DOMEvent.prototype.listen = function listen ( directive ) {
	  	var node = this.node = this.owner.node;
	  	var name = this.name;

	  	if ( !( ("on" + name) in node ) ) {
	  		warnOnce( missingPlugin( name, 'events' ) );
	  		}

	  		node.addEventListener( name, this.handler = function( event ) {
	  		directive.fire({
	  				node: node,
	  			original: event
	  			});
	  		}, false );
	  };

	  DOMEvent.prototype.unlisten = function unlisten () {
	  	this.node.removeEventListener( this.name, this.handler, false );
	  };

	  var CustomEvent = function CustomEvent ( eventPlugin, owner ) {
	  	this.eventPlugin = eventPlugin;
	  	this.owner = owner;
	  	this.handler = null;
	  };

	  CustomEvent.prototype.listen = function listen ( directive ) {
	  	var node = this.owner.node;

	  	this.handler = this.eventPlugin( node, function ( event ) {
	  		if ( event === void 0 ) event = {};

	  			event.node = event.node || node;
	  		directive.fire( event );
	  	});
	  };

	  CustomEvent.prototype.unlisten = function unlisten () {
	  	this.handler.teardown();
	  };

	  var prefix;

	  if ( !isClient ) {
	  	prefix = null;
	  } else {
	  	var prefixCache = {};
	  	var testStyle = createElement( 'div' ).style;

	  	prefix = function ( prop ) {
	  		prop = camelCase( prop );

	  		if ( !prefixCache[ prop ] ) {
	  			if ( testStyle[ prop ] !== undefined ) {
	  				prefixCache[ prop ] = prop;
	  			}

	  			else {
	  				// test vendors...
	  				var capped = prop.charAt( 0 ).toUpperCase() + prop.substring( 1 );

	  				var i = vendors.length;
	  				while ( i-- ) {
	  					var vendor = vendors[i];
	  					if ( testStyle[ vendor + capped ] !== undefined ) {
	  						prefixCache[ prop ] = vendor + capped;
	  						break;
	  					}
	  				}
	  			}
	  		}

	  		return prefixCache[ prop ];
	  	};
	  }

	  var prefix$1 = prefix;

	  var visible;
	  var hidden = 'hidden';

	  if ( doc ) {
	  	var prefix$2;

	  	if ( hidden in doc ) {
	  		prefix$2 = '';
	  	} else {
	  		var i$1 = vendors.length;
	  		while ( i$1-- ) {
	  			var vendor = vendors[i$1];
	  			hidden = vendor + 'Hidden';

	  			if ( hidden in doc ) {
	  				prefix$2 = vendor;
	  				break;
	  			}
	  		}
	  	}

	  	if ( prefix$2 !== undefined ) {
	  		doc.addEventListener( prefix$2 + 'visibilitychange', onChange );
	  		onChange();
	  	} else {
	  		// gah, we're in an old browser
	  		if ( 'onfocusout' in doc ) {
	  			doc.addEventListener( 'focusout', onHide );
	  			doc.addEventListener( 'focusin', onShow );
	  		}

	  		else {
	  			win.addEventListener( 'pagehide', onHide );
	  			win.addEventListener( 'blur', onHide );

	  			win.addEventListener( 'pageshow', onShow );
	  			win.addEventListener( 'focus', onShow );
	  		}

	  		visible = true; // until proven otherwise. Not ideal but hey
	  	}
	  }

	  function onChange () {
	  	visible = !doc[ hidden ];
	  }

	  function onHide () {
	  	visible = false;
	  }

	  function onShow () {
	  	visible = true;
	  }

	  var unprefixPattern = new RegExp( '^-(?:' + vendors.join( '|' ) + ')-' );

	  function unprefix ( prop ) {
	  	return prop.replace( unprefixPattern, '' );
	  }

	  var vendorPattern = new RegExp( '^(?:' + vendors.join( '|' ) + ')([A-Z])' );

	  function hyphenate ( str ) {
	  	if ( !str ) return ''; // edge case

	  	if ( vendorPattern.test( str ) ) str = '-' + str;

	  	return str.replace( /[A-Z]/g, function ( match ) { return '-' + match.toLowerCase(); } );
	  }

	  var createTransitions;

	  if ( !isClient ) {
	  	createTransitions = null;
	  } else {
	  	var testStyle$1 = createElement( 'div' ).style;
	  	var linear$1 = function ( x ) { return x; };

	  	var canUseCssTransitions = {};
	  	var cannotUseCssTransitions = {};

	  	// determine some facts about our environment
	  	var TRANSITION;
	  	var TRANSITIONEND;
	  	var CSS_TRANSITIONS_ENABLED;
	  	var TRANSITION_DURATION;
	  	var TRANSITION_PROPERTY;
	  	var TRANSITION_TIMING_FUNCTION;

	  	if ( testStyle$1.transition !== undefined ) {
	  		TRANSITION = 'transition';
	  		TRANSITIONEND = 'transitionend';
	  		CSS_TRANSITIONS_ENABLED = true;
	  	} else if ( testStyle$1.webkitTransition !== undefined ) {
	  		TRANSITION = 'webkitTransition';
	  		TRANSITIONEND = 'webkitTransitionEnd';
	  		CSS_TRANSITIONS_ENABLED = true;
	  	} else {
	  		CSS_TRANSITIONS_ENABLED = false;
	  	}

	  	if ( TRANSITION ) {
	  		TRANSITION_DURATION = TRANSITION + 'Duration';
	  		TRANSITION_PROPERTY = TRANSITION + 'Property';
	  		TRANSITION_TIMING_FUNCTION = TRANSITION + 'TimingFunction';
	  	}

	  	createTransitions = function ( t, to, options, changedProperties, resolve ) {

	  		// Wait a beat (otherwise the target styles will be applied immediately)
	  		// TODO use a fastdom-style mechanism?
	  		setTimeout( function () {
	  			var jsTransitionsComplete;
	  			var cssTransitionsComplete;

	  			function checkComplete () {
	  				if ( jsTransitionsComplete && cssTransitionsComplete ) {
	  					// will changes to events and fire have an unexpected consequence here?
	  					t.ractive.fire( t.name + ':end', t.node, t.isIntro );
	  					resolve();
	  				}
	  			}

	  			// this is used to keep track of which elements can use CSS to animate
	  			// which properties
	  			var hashPrefix = ( t.node.namespaceURI || '' ) + t.node.tagName;

	  			// need to reset transition properties
	  			var style = t.node.style;
	  			var previous = {
	  				property: style[ TRANSITION_PROPERTY ],
	  				timing: style[ TRANSITION_TIMING_FUNCTION ],
	  				duration: style[ TRANSITION_DURATION ]
	  			};

	  			style[ TRANSITION_PROPERTY ] = changedProperties.map( prefix$1 ).map( hyphenate ).join( ',' );
	  			style[ TRANSITION_TIMING_FUNCTION ] = hyphenate( options.easing || 'linear' );
	  			style[ TRANSITION_DURATION ] = ( options.duration / 1000 ) + 's';

	  			function transitionEndHandler ( event ) {
	  				var index = changedProperties.indexOf( camelCase( unprefix( event.propertyName ) ) );

	  				if ( index !== -1 ) {
	  					changedProperties.splice( index, 1 );
	  				}

	  				if ( changedProperties.length ) {
	  					// still transitioning...
	  					return;
	  				}

	  				style[ TRANSITION_PROPERTY ] = previous.property;
	  				style[ TRANSITION_TIMING_FUNCTION ] = previous.duration;
	  				style[ TRANSITION_DURATION ] = previous.timing;

	  				t.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );

	  				cssTransitionsComplete = true;
	  				checkComplete();
	  			}

	  			t.node.addEventListener( TRANSITIONEND, transitionEndHandler, false );

	  			setTimeout( function () {
	  				var i = changedProperties.length;
	  				var hash;
	  				var originalValue;
	  				var index;
	  				var propertiesToTransitionInJs = [];
	  				var prop;
	  				var suffix;
	  				var interpolator;

	  				while ( i-- ) {
	  					prop = changedProperties[i];
	  					hash = hashPrefix + prop;

	  					if ( CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[ hash ] ) {
	  						style[ prefix$1( prop ) ] = to[ prop ];

	  						// If we're not sure if CSS transitions are supported for
	  						// this tag/property combo, find out now
	  						if ( !canUseCssTransitions[ hash ] ) {
	  							originalValue = t.getStyle( prop );

	  							// if this property is transitionable in this browser,
	  							// the current style will be different from the target style
	  							canUseCssTransitions[ hash ] = ( t.getStyle( prop ) != to[ prop ] );
	  							cannotUseCssTransitions[ hash ] = !canUseCssTransitions[ hash ];

	  							// Reset, if we're going to use timers after all
	  							if ( cannotUseCssTransitions[ hash ] ) {
	  								style[ prefix$1( prop ) ] = originalValue;
	  							}
	  						}
	  					}

	  					if ( !CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[ hash ] ) {
	  						// we need to fall back to timer-based stuff
	  						if ( originalValue === undefined ) {
	  							originalValue = t.getStyle( prop );
	  						}

	  						// need to remove this from changedProperties, otherwise transitionEndHandler
	  						// will get confused
	  						index = changedProperties.indexOf( prop );
	  						if ( index === -1 ) {
	  							warnIfDebug( 'Something very strange happened with transitions. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!', { node: t.node });
	  						} else {
	  							changedProperties.splice( index, 1 );
	  						}

	  						// TODO Determine whether this property is animatable at all

	  						suffix = /[^\d]*$/.exec( to[ prop ] )[0];
	  						interpolator = interpolate( parseFloat( originalValue ), parseFloat( to[ prop ] ) ) || ( function () { return to[ prop ]; } );

	  						// ...then kick off a timer-based transition
	  						propertiesToTransitionInJs.push({
	  							name: prefix$1( prop ),
	  							interpolator: interpolator,
	  							suffix: suffix
	  						});
	  					}
	  				}

	  				// javascript transitions
	  				if ( propertiesToTransitionInJs.length ) {
	  					var easing;

	  					if ( typeof options.easing === 'string' ) {
	  						easing = t.ractive.easing[ options.easing ];

	  						if ( !easing ) {
	  							warnOnceIfDebug( missingPlugin( options.easing, 'easing' ) );
	  							easing = linear$1;
	  						}
	  					} else if ( typeof options.easing === 'function' ) {
	  						easing = options.easing;
	  					} else {
	  						easing = linear$1;
	  					}

	  					new Ticker({
	  						duration: options.duration,
	  						easing: easing,
	  						step: function ( pos ) {
	  							var i = propertiesToTransitionInJs.length;
	  							while ( i-- ) {
	  								var prop = propertiesToTransitionInJs[i];
	  								t.node.style[ prop.name ] = prop.interpolator( pos ) + prop.suffix;
	  							}
	  						},
	  						complete: function () {
	  							jsTransitionsComplete = true;
	  							checkComplete();
	  						}
	  					});
	  				} else {
	  					jsTransitionsComplete = true;
	  				}

	  				if ( !changedProperties.length ) {
	  					// We need to cancel the transitionEndHandler, and deal with
	  					// the fact that it will never fire
	  					t.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );
	  					cssTransitionsComplete = true;
	  					checkComplete();
	  				}
	  			}, 0 );
	  		}, options.delay || 0 );
	  	};
	  }

	  var createTransitions$1 = createTransitions;

	  function resetStyle ( node, style ) {
	  	if ( style ) {
	  		node.setAttribute( 'style', style );
	  	} else {
	  		// Next line is necessary, to remove empty style attribute!
	  		// See http://stackoverflow.com/a/7167553
	  		node.getAttribute( 'style' );
	  		node.removeAttribute( 'style' );
	  	}
	  }

	  var getComputedStyle = win && ( win.getComputedStyle || legacy.getComputedStyle );
	  var resolved = Promise$1.resolve();

	  var Transition = function Transition ( ractive, node, name, params, eventName ) {
	  	this.ractive = ractive;
	  	this.node = node;
	  	this.name = name;
	  	this.params = params;

	  	// TODO this will need to change...
	  	this.eventName = eventName;
	  	this.isIntro = eventName !== 'outro';

	  	if ( typeof name === 'function' ) {
	  		this._fn = name;
	  	}
	  	else {
	  		this._fn = findInViewHierarchy( 'transitions', ractive, name );

	  		if ( !this._fn ) {
	  			warnOnceIfDebug( missingPlugin( name, 'transition' ), { ractive: ractive });
	  		}
	  	}
	  };

	  Transition.prototype.animateStyle = function animateStyle ( style, value, options ) {
	  	var this$1 = this;

	  		if ( arguments.length === 4 ) {
	  		throw new Error( 't.animateStyle() returns a promise - use .then() instead of passing a callback' );
	  	}

	  	// Special case - page isn't visible. Don't animate anything, because
	  	// that way you'll never get CSS transitionend events
	  	if ( !visible ) {
	  		this.setStyle( style, value );
	  		return resolved;
	  	}

	  	var to;

	  	if ( typeof style === 'string' ) {
	  		to = {};
	  		to[ style ] = value;
	  	} else {
	  		to = style;

	  		// shuffle arguments
	  		options = value;
	  	}

	  	// As of 0.3.9, transition authors should supply an `option` object with
	  	// `duration` and `easing` properties (and optional `delay`), plus a
	  	// callback function that gets called after the animation completes

	  	// TODO remove this check in a future version
	  	if ( !options ) {
	  		warnOnceIfDebug( 'The "%s" transition does not supply an options object to `t.animateStyle()`. This will break in a future version of Ractive. For more info see https://github.com/RactiveJS/Ractive/issues/340', this.name );
	  		options = this;
	  	}

	  	return new Promise$1( function ( fulfil ) {
	  		// Edge case - if duration is zero, set style synchronously and complete
	  		if ( !options.duration ) {
	  			this$1.setStyle( to );
	  			fulfil();
	  			return;
	  		}

	  		// Get a list of the properties we're animating
	  		var propertyNames = Object.keys( to );
	  		var changedProperties = [];

	  		// Store the current styles
	  		var computedStyle = getComputedStyle( this$1.node );

	  		var i = propertyNames.length;
	  		while ( i-- ) {
	  			var prop = propertyNames[i];
	  			var current = computedStyle[ prefix$1( prop ) ];

	  			if ( current === '0px' ) current = 0;

	  			// we need to know if we're actually changing anything
	  			if ( current != to[ prop ] ) { // use != instead of !==, so we can compare strings with numbers
	  				changedProperties.push( prop );

	  				// make the computed style explicit, so we can animate where
	  				// e.g. height='auto'
	  				this$1.node.style[ prefix$1( prop ) ] = current;
	  			}
	  		}

	  		// If we're not actually changing anything, the transitionend event
	  		// will never fire! So we complete early
	  		if ( !changedProperties.length ) {
	  			fulfil();
	  			return;
	  		}

	  		createTransitions$1( this$1, to, options, changedProperties, fulfil );
	  	});
	  };

	  Transition.prototype.getStyle = function getStyle ( props ) {
	  	var computedStyle = getComputedStyle( this.node );

	  	if ( typeof props === 'string' ) {
	  		var value = computedStyle[ prefix$1( props ) ];
	  		return value === '0px' ? 0 : value;
	  	}

	  	if ( !isArray( props ) ) {
	  		throw new Error( 'Transition$getStyle must be passed a string, or an array of strings representing CSS properties' );
	  	}

	  	var styles = {};

	  	var i = props.length;
	  	while ( i-- ) {
	  		var prop = props[i];
	  		var value$1 = computedStyle[ prefix$1( prop ) ];

	  		if ( value$1 === '0px' ) value$1 = 0;
	  		styles[ prop ] = value$1;
	  	}

	  	return styles;
	  };

	  Transition.prototype.processParams = function processParams ( params, defaults ) {
	  	if ( typeof params === 'number' ) {
	  		params = { duration: params };
	  	}

	  	else if ( typeof params === 'string' ) {
	  		if ( params === 'slow' ) {
	  			params = { duration: 600 };
	  		} else if ( params === 'fast' ) {
	  			params = { duration: 200 };
	  		} else {
	  			params = { duration: 400 };
	  		}
	  	} else if ( !params ) {
	  		params = {};
	  	}

	  	return extendObj( {}, defaults, params );
	  };

	  Transition.prototype.setStyle = function setStyle ( style, value ) {
	  	if ( typeof style === 'string' ) {
	  		this.node.style[ prefix$1( style ) ] = value;
	  	}

	  	else {
	  		var prop;
	  		for ( prop in style ) {
	  			if ( style.hasOwnProperty( prop ) ) {
	  				this.node.style[ prefix$1( prop ) ] = style[ prop ];
	  			}
	  		}
	  	}

	  	return this;
	  };

	  Transition.prototype.start = function start () {
	  	var this$1 = this;

	  		var node = this.node;
	  	var originalStyle = node.getAttribute( 'style' );

	  	var completed;

	  	// create t.complete() - we don't want this on the prototype,
	  	// because we don't want `this` silliness when passing it as
	  	// an argument
	  	this.complete = function ( noReset ) {
	  		if ( completed ) {
	  			return;
	  		}

	  		if ( !noReset && this$1.eventName === 'intro' ) {
	  			resetStyle( node, originalStyle);
	  		}

	  		this$1._manager.remove( this$1 );

	  		completed = true;
	  	};

	  	// If the transition function doesn't exist, abort
	  	if ( !this._fn ) {
	  		this.complete();
	  		return;
	  	}

	  	var promise = this._fn.apply( this.ractive, [ this ].concat( this.params ) );
	  	if ( promise ) promise.then( this.complete );
	  };

	  function updateLiveQueries$1 ( element ) {
	  	// Does this need to be added to any live queries?
	  	var node = element.node;
	  	var instance = element.ractive;

	  	do {
	  		var liveQueries = instance._liveQueries;

	  		var i = liveQueries.length;
	  		while ( i-- ) {
	  			var selector = liveQueries[i];
	  			var query = liveQueries[ ("_" + selector) ];

	  			if ( query.test( node ) ) {
	  				query.add( node );
	  				// keep register of applicable selectors, for when we teardown
	  				element.liveQueries.push( query );
	  			}
	  		}
	  	} while ( instance = instance.parent );
	  }

	  // TODO element.parent currently undefined
	  function findParentForm ( element ) {
	  	while ( element = element.parent ) {
	  		if ( element.name === 'form' ) {
	  			return element;
	  		}
	  	}
	  }

	  function warnAboutAmbiguity ( description, ractive ) {
	  	warnOnceIfDebug( ("The " + description + " being used for two-way binding is ambiguous, and may cause unexpected results. Consider initialising your data to eliminate the ambiguity"), { ractive: ractive });
	  }

	  var Binding = function Binding ( element, name ) {
	  	if ( name === void 0 ) name = 'value';

	  		this.element = element;
	  	this.ractive = element.ractive;
	  	this.attribute = element.attributeByName[ name ];

	  	var interpolator = this.attribute.interpolator;
	  	interpolator.twowayBinding = this;

	  	var model = interpolator.model;

	  	// not bound?
	  	if ( !model ) {
	  		// try to force resolution
	  		interpolator.resolver.forceResolution();
	  		model = interpolator.model;

	  		warnAboutAmbiguity( ("'" + (interpolator.template.r) + "' reference"), this.ractive );
	  	}

	  	else if ( model.isUnresolved ) {
	  		// reference expressions (e.g. foo[bar])
	  		model.forceResolution();
	  		warnAboutAmbiguity( 'expression', this.ractive );
	  	}

	  	// TODO include index/key/keypath refs as read-only
	  	else if ( model.isReadonly ) {
	  		var keypath = model.getKeypath().replace( /^@/, '' );
	  			warnOnceIfDebug( ("Cannot use two-way binding on <" + (element.name) + "> element: " + keypath + " is read-only. To suppress this warning use <" + (element.name) + " twoway='false'...>"), { ractive: this.ractive });
	  		return false;
	  	}

	  	this.attribute.isTwoway = true;
	  	this.model = model;

	  	// initialise value, if it's undefined
	  	var value = model.get();
	  	this.wasUndefined = value === undefined;

	  	if ( value === undefined && this.getInitialValue ) {
	  		value = this.getInitialValue();
	  		model.set( value );
	  	}

	  	var parentForm = findParentForm( element );
	  	if ( parentForm ) {
	  		this.resetValue = value;
	  		parentForm.formBindings.push( this );
	  	}
	  };

	  Binding.prototype.bind = function bind () {
	  	this.model.registerTwowayBinding( this );
	  };

	  Binding.prototype.handleChange = function handleChange () {
	  	var this$1 = this;

	  		runloop.start( this.root );
	  	this.attribute.locked = true;
	  	this.model.set( this.getValue() );
	  	runloop.scheduleTask( function () { return this$1.attribute.locked = false; } );
	  	runloop.end();
	  };

	  Binding.prototype.rebind = function rebind () {
	  	// TODO what does this work with CheckboxNameBinding et al?
	  	this.unbind();
	  	this.model = this.attribute.interpolator.model;
	  	this.bind();
	  };

	  Binding.prototype.render = function render () {
	  	this.node = this.element.node;
	  	this.node._ractive.binding = this;
	  	this.rendered = true; // TODO is this used anywhere?
	  	};

	  Binding.prototype.setFromNode = function setFromNode ( node ) {
	  	this.model.set( node.value );
	  	};

	  	Binding.prototype.unbind = function unbind () {
	  	this.model.unregisterTwowayBinding( this );
	  };

	  Binding.prototype.unrender = function unrender () {
	  	// noop?
	  };

	  // This is the handler for DOM events that would lead to a change in the model
	  // (i.e. change, sometimes, input, and occasionally click and keyup)
	  function handleDomEvent () {
	  	this._ractive.binding.handleChange();
	  }

	  var CheckboxBinding = (function (Binding) {
	  	function CheckboxBinding ( element ) {
	  		Binding.call( this, element, 'checked' );
	  	}

	  	CheckboxBinding.prototype = Object.create( Binding && Binding.prototype );
	  	CheckboxBinding.prototype.constructor = CheckboxBinding;

	  	CheckboxBinding.prototype.render = function render () {
	  		Binding.prototype.render.call(this);

	  		this.node.addEventListener( 'change', handleDomEvent, false );

	  		if ( this.node.attachEvent ) {
	  			this.node.addEventListener( 'click', handleDomEvent, false );
	  		}
	  	};

	  	CheckboxBinding.prototype.unrender = function unrender () {
	  		this.node.removeEventListener( 'change', handleDomEvent, false );
	  		this.node.removeEventListener( 'click', handleDomEvent, false );
	  	};

	  	CheckboxBinding.prototype.getInitialValue = function getInitialValue () {
	  		return !!this.element.getAttribute( 'checked' );
	  	};

	  	CheckboxBinding.prototype.getValue = function getValue () {
	  		return this.node.checked;
	  	};

	  	CheckboxBinding.prototype.setFromNode = function setFromNode ( node ) {
	  		this.model.set( node.checked );
	  	};

	  	return CheckboxBinding;
	  }(Binding));

	  function getBindingGroup ( group, model, getValue ) {
	  	var hash = "" + group + "-bindingGroup";
	  	return model[hash] || ( model[ hash ] = new BindingGroup( hash, model, getValue ) );
	  }

	  var BindingGroup = function BindingGroup ( hash, model, getValue ) {
	  	var this$1 = this;

	  		this.model = model;
	  	this.hash = hash;
	  	this.getValue = function () {
	  		this$1.value = getValue.call(this$1);
	  		return this$1.value;
	  	};

	  	this.bindings = [];
	  };

	  BindingGroup.prototype.add = function add ( binding ) {
	  	this.bindings.push( binding );
	  };

	  BindingGroup.prototype.bind = function bind () {
	  	this.value = this.model.get();
	  	this.model.registerTwowayBinding( this );
	  	this.bound = true;
	  };

	  BindingGroup.prototype.remove = function remove ( binding ) {
	  	removeFromArray( this.bindings, binding );
	  	if ( !this.bindings.length ) {
	  		this.unbind();
	  	}
	  };

	  BindingGroup.prototype.unbind = function unbind () {
	  	this.model.unregisterTwowayBinding( this );
	  	this.bound = false;
	  	delete this.model[this.hash];
	  };

	  var push$1 = [].push;

	  function getValue$1() {
	  	var all = this.bindings.filter(function ( b ) { return b.node && b.node.checked; }).map(function ( b ) { return b.element.getAttribute( 'value' ); });
	  	var res = [];
	  	all.forEach(function ( v ) { if ( !arrayContains( res, v ) ) res.push( v ); });
	  	return res;
	  }

	  var CheckboxNameBinding = (function (Binding) {
	  	function CheckboxNameBinding ( element ) {
	  		Binding.call( this, element, 'name' );

	  		this.checkboxName = true; // so that ractive.updateModel() knows what to do with this

	  		// Each input has a reference to an array containing it and its
	  		// group, as two-way binding depends on being able to ascertain
	  		// the status of all inputs within the group
	  		this.group = getBindingGroup( 'checkboxes', this.model, getValue$1 );
	  		this.group.add( this );

	  		if ( this.noInitialValue ) {
	  			this.group.noInitialValue = true;
	  		}

	  		// If no initial value was set, and this input is checked, we
	  		// update the model
	  		if ( this.group.noInitialValue && this.element.getAttribute( 'checked' ) ) {
	  			var existingValue = this.model.get();
	  			var bindingValue = this.element.getAttribute( 'value' );

	  			if ( !arrayContains( existingValue, bindingValue ) ) {
	  				push$1.call( existingValue, bindingValue ); // to avoid triggering runloop with array adaptor
	  			}
	  		}
	  	}

	  	CheckboxNameBinding.prototype = Object.create( Binding && Binding.prototype );
	  	CheckboxNameBinding.prototype.constructor = CheckboxNameBinding;

	  	CheckboxNameBinding.prototype.bind = function bind () {
	  		if ( !this.group.bound ) {
	  			this.group.bind();
	  		}
	  	};

	  	CheckboxNameBinding.prototype.changed = function changed () {
	  		var wasChecked = !!this.isChecked;
	  		this.isChecked = this.node.checked;
	  		return this.isChecked === wasChecked;
	  	};

	  	CheckboxNameBinding.prototype.getInitialValue = function getInitialValue () {
	  		// This only gets called once per group (of inputs that
	  		// share a name), because it only gets called if there
	  		// isn't an initial value. By the same token, we can make
	  		// a note of that fact that there was no initial value,
	  		// and populate it using any `checked` attributes that
	  		// exist (which users should avoid, but which we should
	  		// support anyway to avoid breaking expectations)
	  		this.noInitialValue = true; // TODO are noInitialValue and wasUndefined the same thing?
	  		return [];
	  	};

	  	CheckboxNameBinding.prototype.getValue = function getValue$1 () {
	  		return this.group.value;
	  	};

	  	CheckboxNameBinding.prototype.handleChange = function handleChange () {
	  		this.isChecked = this.element.node.checked;
	  		this.group.value = this.model.get();
	  		var value = this.element.getAttribute( 'value' );
	  		if ( this.isChecked && !arrayContains( this.group.value, value ) ) {
	  			this.group.value.push( value );
	  		} else if ( !this.isChecked && arrayContains( this.group.value, value ) ) {
	  			removeFromArray( this.group.value, value );
	  		}
	  		Binding.prototype.handleChange.call(this);
	  	};

	  	CheckboxNameBinding.prototype.render = function render () {
	  		Binding.prototype.render.call(this);

	  		var node = this.node;

	  		var existingValue = this.model.get();
	  		var bindingValue = this.element.getAttribute( 'value' );

	  		if ( isArray( existingValue ) ) {
	  			this.isChecked = arrayContains( existingValue, bindingValue );
	  		} else {
	  			this.isChecked = existingValue == bindingValue;
	  		}

	  		node.name = '{{' + this.model.getKeypath() + '}}';
	  		node.checked = this.isChecked;

	  		node.addEventListener( 'change', handleDomEvent, false );

	  		// in case of IE emergency, bind to click event as well
	  		if ( node.attachEvent ) {
	  			node.addEventListener( 'click', handleDomEvent, false );
	  		}
	  	};

	  	CheckboxNameBinding.prototype.setFromNode = function setFromNode ( node ) {
	  		this.group.bindings.forEach( function ( binding ) { return binding.wasUndefined = true; } );

	  		if ( node.checked ) {
	  			var valueSoFar = this.group.getValue();
	  			valueSoFar.push( this.element.getAttribute( 'value' ) );

	  			this.group.model.set( valueSoFar );
	  		}
	  	};

	  	CheckboxNameBinding.prototype.unbind = function unbind () {
	  		this.group.remove( this );
	  	};

	  	CheckboxNameBinding.prototype.unrender = function unrender () {
	  		var node = this.element.node;

	  		node.removeEventListener( 'change', handleDomEvent, false );
	  		node.removeEventListener( 'click', handleDomEvent, false );
	  	};

	  	return CheckboxNameBinding;
	  }(Binding));

	  var ContentEditableBinding = (function (Binding) {
	  	function ContentEditableBinding () {
	  		Binding.apply(this, arguments);
	  	}

	  	ContentEditableBinding.prototype = Object.create( Binding && Binding.prototype );
	  	ContentEditableBinding.prototype.constructor = ContentEditableBinding;

	  	ContentEditableBinding.prototype.getInitialValue = function getInitialValue () {
	  		return this.element.fragment ? this.element.fragment.toString() : '';
	  	};

	  	ContentEditableBinding.prototype.getValue = function getValue () {
	  		return this.element.node.innerHTML;
	  	};

	  	ContentEditableBinding.prototype.render = function render () {
	  		Binding.prototype.render.call(this);

	  		var node = this.node;

	  		node.addEventListener( 'change', handleDomEvent, false );
	  		node.addEventListener( 'blur', handleDomEvent, false );

	  		if ( !this.ractive.lazy ) {
	  			node.addEventListener( 'input', handleDomEvent, false );

	  			if ( node.attachEvent ) {
	  				node.addEventListener( 'keyup', handleDomEvent, false );
	  			}
	  		}
	  	};

	  	ContentEditableBinding.prototype.setFromNode = function setFromNode ( node ) {
	  		this.model.set( node.innerHTML );
	  	};

	  	ContentEditableBinding.prototype.unrender = function unrender () {
	  		var node = this.node;

	  		node.removeEventListener( 'blur', handleDomEvent, false );
	  		node.removeEventListener( 'change', handleDomEvent, false );
	  		node.removeEventListener( 'input', handleDomEvent, false );
	  		node.removeEventListener( 'keyup', handleDomEvent, false );
	  	};

	  	return ContentEditableBinding;
	  }(Binding));

	  function handleBlur () {
	  	handleDomEvent.call( this );

	  	var value = this._ractive.binding.model.get();
	  	this.value = value == undefined ? '' : value;
	  }

	  function handleDelay ( delay ) {
	  	var timeout;

	  	return function () {
	  		var this$1 = this;

	  		if ( timeout ) clearTimeout( timeout );

	  		timeout = setTimeout( function () {
	  			var binding = this$1._ractive.binding;
	  			if ( binding.rendered ) handleDomEvent.call( this$1 );
	  			timeout = null;
	  		}, delay );
	  	};
	  }

	  var GenericBinding = (function (Binding) {
	  	function GenericBinding () {
	  		Binding.apply(this, arguments);
	  	}

	  	GenericBinding.prototype = Object.create( Binding && Binding.prototype );
	  	GenericBinding.prototype.constructor = GenericBinding;

	  	GenericBinding.prototype.getInitialValue = function getInitialValue () {
	  		return '';
	  	};

	  	GenericBinding.prototype.getValue = function getValue () {
	  		return this.node.value;
	  	};

	  	GenericBinding.prototype.render = function render () {
	  		Binding.prototype.render.call(this);

	  		// any lazy setting for this element overrides the root
	  		// if the value is a number, it's a timeout
	  		var lazy = this.ractive.lazy;
	  		var timeout = false;

	  		// TODO handle at parse time
	  		if ( this.element.template.a && ( 'lazy' in this.element.template.a ) ) {
	  			lazy = this.element.template.a.lazy;
	  			if ( lazy === 0 ) lazy = true; // empty attribute
	  		}

	  		// TODO handle this at parse time as well?
	  		if ( lazy === 'false' ) lazy = false;

	  		if ( isNumeric( lazy ) ) {
	  			timeout = +lazy;
	  			lazy = false;
	  		}

	  		this.handler = timeout ? handleDelay( timeout ) : handleDomEvent;

	  		var node = this.node;

	  		node.addEventListener( 'change', handleDomEvent, false );

	  		if ( !lazy ) {
	  			node.addEventListener( 'input', this.handler, false );

	  			if ( node.attachEvent ) {
	  				node.addEventListener( 'keyup', this.handler, false );
	  			}
	  		}

	  		node.addEventListener( 'blur', handleBlur, false );
	  	};

	  	GenericBinding.prototype.unrender = function unrender () {
	  		var node = this.element.node;
	  		this.rendered = false;

	  		node.removeEventListener( 'change', handleDomEvent, false );
	  		node.removeEventListener( 'input', this.handler, false );
	  		node.removeEventListener( 'keyup', this.handler, false );
	  		node.removeEventListener( 'blur', handleBlur, false );
	  	};

	  	return GenericBinding;
	  }(Binding));

	  function getSelectedOptions ( select ) {
	      return select.selectedOptions
	  		? toArray( select.selectedOptions )
	  		: select.options
	  			? toArray( select.options ).filter( function ( option ) { return option.selected; } )
	  			: [];
	  }

	  var MultipleSelectBinding = (function (Binding) {
	  	function MultipleSelectBinding () {
	  		Binding.apply(this, arguments);
	  	}

	  	MultipleSelectBinding.prototype = Object.create( Binding && Binding.prototype );
	  	MultipleSelectBinding.prototype.constructor = MultipleSelectBinding;

	  	MultipleSelectBinding.prototype.forceUpdate = function forceUpdate () {
	  		var this$1 = this;

	  		var value = this.getValue();

	  		if ( value !== undefined ) {
	  			this.attribute.locked = true;
	  			runloop.scheduleTask( function () { return this$1.attribute.locked = false; } );
	  			this.model.set( value );
	  		}
	  	};

	  	MultipleSelectBinding.prototype.getInitialValue = function getInitialValue () {
	  		return this.element.options
	  			.filter( function ( option ) { return option.getAttribute( 'selected' ); } )
	  			.map( function ( option ) { return option.getAttribute( 'value' ); } );
	  	};

	  	MultipleSelectBinding.prototype.getValue = function getValue () {
	  		var options = this.element.node.options;
	  		var len = options.length;

	  		var selectedValues = [];

	  		for ( var i = 0; i < len; i += 1 ) {
	  			var option = options[i];

	  			if ( option.selected ) {
	  				var optionValue = option._ractive ? option._ractive.value : option.value;
	  				selectedValues.push( optionValue );
	  			}
	  		}

	  		return selectedValues;
	  	};

	  	MultipleSelectBinding.prototype.handleChange = function handleChange () {
	  		var attribute = this.attribute;
	  		var previousValue = attribute.getValue();

	  		var value = this.getValue();

	  		if ( previousValue === undefined || !arrayContentsMatch( value, previousValue ) ) {
	  			Binding.prototype.handleChange.call(this);
	  		}

	  		return this;
	  	};

	  	MultipleSelectBinding.prototype.render = function render () {
	  		Binding.prototype.render.call(this);

	  		this.node.addEventListener( 'change', handleDomEvent, false );

	  		if ( this.model.get() === undefined ) {
	  			// get value from DOM, if possible
	  			this.handleChange();
	  		}
	  	};

	  	MultipleSelectBinding.prototype.setFromNode = function setFromNode ( node ) {
	  		var selectedOptions = getSelectedOptions( node );
	  		var i = selectedOptions.length;
	  		var result = new Array( i );

	  		while ( i-- ) {
	  			var option = selectedOptions[i];
	  			result[i] = option._ractive ? option._ractive.value : option.value;
	  		}

	  		this.model.set( result );
	  	};

	  	MultipleSelectBinding.prototype.setValue = function setValue () {
	  		throw new Error( 'TODO not implemented yet' );
	  	};

	  	MultipleSelectBinding.prototype.unrender = function unrender () {
	  		this.node.removeEventListener( 'change', handleDomEvent, false );
	  	};

	  	MultipleSelectBinding.prototype.updateModel = function updateModel () {
	  		if ( this.attribute.value === undefined || !this.attribute.value.length ) {
	  			this.keypath.set( this.initialValue );
	  		}
	  	};

	  	return MultipleSelectBinding;
	  }(Binding));

	  var NumericBinding = (function (GenericBinding) {
	  	function NumericBinding () {
	  		GenericBinding.apply(this, arguments);
	  	}

	  	NumericBinding.prototype = Object.create( GenericBinding && GenericBinding.prototype );
	  	NumericBinding.prototype.constructor = NumericBinding;

	  	NumericBinding.prototype.getInitialValue = function getInitialValue () {
	  		return undefined;
	  	};

	  	NumericBinding.prototype.getValue = function getValue () {
	  		var value = parseFloat( this.node.value );
	  		return isNaN( value ) ? undefined : value;
	  	};

	  	NumericBinding.prototype.setFromNode = function setFromNode( node ) {
	  		var value = parseFloat( node.value );
	  		if ( !isNaN( value ) ) this.model.set( value );
	  	};

	  	return NumericBinding;
	  }(GenericBinding));

	  var siblings = {};

	  function getSiblings ( hash ) {
	  	return siblings[ hash ] || ( siblings[ hash ] = [] );
	  }

	  var RadioBinding = (function (Binding) {
	  	function RadioBinding ( element ) {
	  		Binding.call( this, element, 'checked' );

	  		this.siblings = getSiblings( this.ractive._guid + this.element.getAttribute( 'name' ) );
	  		this.siblings.push( this );
	  	}

	  	RadioBinding.prototype = Object.create( Binding && Binding.prototype );
	  	RadioBinding.prototype.constructor = RadioBinding;

	  	RadioBinding.prototype.getValue = function getValue () {
	  		return this.node.checked;
	  	};

	  	RadioBinding.prototype.handleChange = function handleChange () {
	  		runloop.start( this.root );

	  		this.siblings.forEach( function ( binding ) {
	  			binding.model.set( binding.getValue() );
	  		});

	  		runloop.end();
	  	};

	  	RadioBinding.prototype.render = function render () {
	  		Binding.prototype.render.call(this);

	  		this.node.addEventListener( 'change', handleDomEvent, false );

	  		if ( this.node.attachEvent ) {
	  			this.node.addEventListener( 'click', handleDomEvent, false );
	  		}
	  	};

	  	RadioBinding.prototype.setFromNode = function setFromNode ( node ) {
	  		this.model.set( node.checked );
	  	};

	  	RadioBinding.prototype.unbind = function unbind () {
	  		removeFromArray( this.siblings, this );
	  	};

	  	RadioBinding.prototype.unrender = function unrender () {
	  		this.node.removeEventListener( 'change', handleDomEvent, false );
	  		this.node.removeEventListener( 'click', handleDomEvent, false );
	  	};

	  	return RadioBinding;
	  }(Binding));

	  function getValue$2() {
	  	var checked = this.bindings.filter( function ( b ) { return b.node.checked; } );
	  	if ( checked.length > 0 ) {
	  		return checked[0].element.getAttribute( 'value' );
	  	}
	  }

	  var RadioNameBinding = (function (Binding) {
	  	function RadioNameBinding ( element ) {
	  		Binding.call( this, element, 'name' );

	  		this.group = getBindingGroup( 'radioname', this.model, getValue$2 );
	  		this.group.add( this );

	  		if ( element.checked ) {
	  			this.group.value = this.getValue();
	  		}
	  	}

	  	RadioNameBinding.prototype = Object.create( Binding && Binding.prototype );
	  	RadioNameBinding.prototype.constructor = RadioNameBinding;

	  	RadioNameBinding.prototype.bind = function bind () {
	  		var this$1 = this;

	  		if ( !this.group.bound ) {
	  			this.group.bind();
	  		}

	  		// update name keypath when necessary
	  		this.nameAttributeBinding = {
	  			handleChange: function () { return this$1.node.name = "{{" + (this$1.model.getKeypath()) + "}}"; }
	  		};

	  		this.model.getKeypathModel().register( this.nameAttributeBinding );
	  	};

	  	RadioNameBinding.prototype.getInitialValue = function getInitialValue () {
	  		if ( this.element.getAttribute( 'checked' ) ) {
	  			return this.element.getAttribute( 'value' );
	  		}
	  	};

	  	RadioNameBinding.prototype.getValue = function getValue$1 () {
	  		return this.element.getAttribute( 'value' );
	  	};

	  	RadioNameBinding.prototype.handleChange = function handleChange () {
	  		// If this <input> is the one that's checked, then the value of its
	  		// `name` model gets set to its value
	  		if ( this.node.checked ) {
	  			this.group.value = this.getValue();
	  			Binding.prototype.handleChange.call(this);
	  		}
	  	};

	  	RadioNameBinding.prototype.render = function render () {
	  		Binding.prototype.render.call(this);

	  		var node = this.node;

	  		node.name = "{{" + (this.model.getKeypath()) + "}}";
	  		node.checked = this.model.get() == this.element.getAttribute( 'value' );

	  		node.addEventListener( 'change', handleDomEvent, false );

	  		if ( node.attachEvent ) {
	  			node.addEventListener( 'click', handleDomEvent, false );
	  		}
	  	};

	  	RadioNameBinding.prototype.setFromNode = function setFromNode ( node ) {
	  		if ( node.checked ) {
	  			this.group.model.set( this.element.getAttribute( 'value' ) );
	  		}
	  	};

	  	RadioNameBinding.prototype.unbind = function unbind () {
	  		this.group.remove( this );

	  		this.model.getKeypathModel().unregister( this.nameAttributeBinding );
	  	};

	  	RadioNameBinding.prototype.unrender = function unrender () {
	  		var node = this.node;

	  		node.removeEventListener( 'change', handleDomEvent, false );
	  		node.removeEventListener( 'click', handleDomEvent, false );
	  	};

	  	return RadioNameBinding;
	  }(Binding));

	  var SingleSelectBinding = (function (Binding) {
	  	function SingleSelectBinding () {
	  		Binding.apply(this, arguments);
	  	}

	  	SingleSelectBinding.prototype = Object.create( Binding && Binding.prototype );
	  	SingleSelectBinding.prototype.constructor = SingleSelectBinding;

	  	SingleSelectBinding.prototype.forceUpdate = function forceUpdate () {
	  		var this$1 = this;

	  		var value = this.getValue();

	  		if ( value !== undefined ) {
	  			this.attribute.locked = true;
	  			runloop.scheduleTask( function () { return this$1.attribute.locked = false; } );
	  			this.model.set( value );
	  		}
	  	};

	  	SingleSelectBinding.prototype.getInitialValue = function getInitialValue () {
	  		if ( this.element.getAttribute( 'value' ) !== undefined ) {
	  			return;
	  		}

	  		var options = this.element.options;
	  		var len = options.length;

	  		if ( !len ) return;

	  		var value;
	  		var optionWasSelected;
	  		var i = len;

	  		// take the final selected option...
	  		while ( i-- ) {
	  			var option = options[i];

	  			if ( option.getAttribute( 'selected' ) ) {
	  				if ( !option.getAttribute( 'disabled' ) ) {
	  					value = option.getAttribute( 'value' );
	  				}

	  				optionWasSelected = true;
	  				break;
	  			}
	  		}

	  		// or the first non-disabled option, if none are selected
	  		if ( !optionWasSelected ) {
	  			while ( ++i < len ) {
	  				if ( !options[i].getAttribute( 'disabled' ) ) {
	  					value = options[i].getAttribute( 'value' );
	  					break;
	  				}
	  			}
	  		}

	  		// This is an optimisation (aka hack) that allows us to forgo some
	  		// other more expensive work
	  		// TODO does it still work? seems at odds with new architecture
	  		if ( value !== undefined ) {
	  			this.element.attributeByName.value.value = value;
	  		}

	  		return value;
	  	};

	  	SingleSelectBinding.prototype.getValue = function getValue () {
	  		var options = this.node.options;
	  		var len = options.length;

	  		var i;
	  		for ( i = 0; i < len; i += 1 ) {
	  			var option = options[i];

	  			if ( options[i].selected && !options[i].disabled ) {
	  				return option._ractive ? option._ractive.value : option.value;
	  			}
	  		}
	  	};

	  	SingleSelectBinding.prototype.render = function render () {
	  		Binding.prototype.render.call(this);
	  		this.node.addEventListener( 'change', handleDomEvent, false );
	  	};

	  	SingleSelectBinding.prototype.setFromNode = function setFromNode ( node ) {
	  		var option = getSelectedOptions( node )[0];
	  		this.model.set( option._ractive ? option._ractive.value : option.value );
	  	};

	  	// TODO this method is an anomaly... is it necessary?
	  	SingleSelectBinding.prototype.setValue = function setValue ( value ) {
	  		this.model.set( value );
	  	};

	  	SingleSelectBinding.prototype.unrender = function unrender () {
	  		this.node.removeEventListener( 'change', handleDomEvent, false );
	  	};

	  	return SingleSelectBinding;
	  }(Binding));

	  function isBindable ( attribute ) {
	  	return attribute &&
	  	       attribute.template.length === 1 &&
	  	       attribute.template[0].t === INTERPOLATOR &&
	  	       !attribute.template[0].s;
	  }

	  function selectBinding ( element ) {
	  	var attributes = element.attributeByName;

	  	// contenteditable - bind if the contenteditable attribute is true
	  	// or is bindable and may thus become true...
	  	if ( element.getAttribute( 'contenteditable' ) || isBindable( attributes.contenteditable ) ) {
	  		// ...and this element also has a value attribute to bind
	  		return isBindable( attributes.value ) ? ContentEditableBinding : null;
	  	}

	  	// <input>
	  	if ( element.name === 'input' ) {
	  		var type = element.getAttribute( 'type' );

	  		if ( type === 'radio' || type === 'checkbox' ) {
	  			var bindName = isBindable( attributes.name );
	  			var bindChecked = isBindable( attributes.checked );

	  			// for radios we can either bind the name attribute, or the checked attribute - not both
	  			if ( bindName && bindChecked ) {
	  				if ( type === 'radio' ) {
	  					warnIfDebug( 'A radio input can have two-way binding on its name attribute, or its checked attribute - not both', { ractive: element.root });
	  				} else {
	  					// A checkbox with bindings for both name and checked - see https://github.com/ractivejs/ractive/issues/1749
	  					return CheckboxBinding;
	  				}
	  			}

	  			if ( bindName ) {
	  				return type === 'radio' ? RadioNameBinding : CheckboxNameBinding;
	  			}

	  			if ( bindChecked ) {
	  				return type === 'radio' ? RadioBinding : CheckboxBinding;
	  			}
	  		}

	  		if ( type === 'file' && isBindable( attributes.value ) ) {
	  			return Binding;
	  		}

	  		if ( isBindable( attributes.value ) ) {
	  			return ( type === 'number' || type === 'range' ) ? NumericBinding : GenericBinding;
	  		}

	  		return null;
	  	}

	  	// <select>
	  	if ( element.name === 'select' && isBindable( attributes.value ) ) {
	  		return element.getAttribute( 'multiple' ) ? MultipleSelectBinding : SingleSelectBinding;
	  	}

	  	// <textarea>
	  	if ( element.name === 'textarea' && isBindable( attributes.value ) ) {
	  		return GenericBinding;
	  	}
	  }

	  function makeDirty$1 ( query ) {
	  	query.makeDirty();
	  }

	  var Element = (function (Item) {
	  	function Element ( options ) {
	  		var this$1 = this;

	  		Item.call( this, options );

	  		this.liveQueries = []; // TODO rare case. can we handle differently?

	  		this.name = options.template.e.toLowerCase();
	  		this.isVoid = voidElementNames.test( this.name );

	  		// find parent element
	  		var fragment = this.parentFragment;
	  		while ( fragment ) {
	  			if ( fragment.owner.type === ELEMENT ) {
	  				this$1.parent = fragment.owner;
	  				break;
	  			}
	  			fragment = fragment.parent;
	  		}

	  		if ( this.parent && this.parent.name === 'option' ) {
	  			throw new Error( ("An <option> element cannot contain other elements (encountered <" + (this.name) + ">)") );
	  		}

	  		// create attributes
	  		this.attributeByName = {};
	  		this.attributes = [];

	  		if ( this.template.a ) {
	  			Object.keys( this.template.a ).forEach( function ( name ) {
	  				// TODO process this at parse time
	  				if ( name === 'twoway' || name === 'lazy' ) return;

	  				var attribute = new Attribute({
	  					name: name,
	  					element: this$1,
	  					parentFragment: this$1.parentFragment,
	  					template: this$1.template.a[ name ]
	  				});

	  				this$1.attributeByName[ name ] = attribute;

	  				if ( name !== 'value' && name !== 'type' ) this$1.attributes.push( attribute );
	  			});

	  			if ( this.attributeByName.type ) this.attributes.unshift( this.attributeByName.type );
	  			if ( this.attributeByName.value ) this.attributes.push( this.attributeByName.value );
	  		}

	  		// create conditional attributes
	  		this.conditionalAttributes = ( this.template.m || [] ).map( function ( template ) {
	  			return new ConditionalAttribute({
	  				owner: this$1,
	  				parentFragment: this$1.parentFragment,
	  				template: template
	  			});
	  		});

	  		// create decorator
	  		if ( this.template.o ) {
	  			this.decorator = new Decorator( this, this.template.o );
	  		}

	  		// attach event handlers
	  		this.eventHandlers = [];
	  		if ( this.template.v ) {
	  			Object.keys( this.template.v ).forEach( function ( key ) {
	  				var eventNames = key.split( '-' );
	  				var template = this$1.template.v[ key ];

	  				eventNames.forEach( function ( eventName ) {
	  					var fn = findInViewHierarchy( 'events', this$1.ractive, eventName );
	  					// we need to pass in "this" in order to get
	  					// access to node when it is created.
	  					var event = fn ? new CustomEvent( fn, this$1 ) : new DOMEvent( eventName, this$1 );
	  					this$1.eventHandlers.push( new EventDirective( this$1, event, template ) );
	  				});
	  			});
	  		}

	  		// create children
	  		if ( options.template.f && !options.noContent ) {
	  			this.fragment = new Fragment({
	  				template: options.template.f,
	  				owner: this,
	  				cssIds: null
	  			});
	  		}

	  		this.binding = null; // filled in later
	  	}

	  	Element.prototype = Object.create( Item && Item.prototype );
	  	Element.prototype.constructor = Element;

	  	Element.prototype.bind = function bind$1 () {
	  		this.attributes.forEach( bind );
	  		this.conditionalAttributes.forEach( bind );
	  		this.eventHandlers.forEach( bind );

	  		if ( this.decorator ) this.decorator.bind();
	  		if ( this.fragment ) this.fragment.bind();

	  		// create two-way binding if necessary
	  		if ( this.binding = this.createTwowayBinding() ) this.binding.bind();
	  	};

	  	Element.prototype.createTwowayBinding = function createTwowayBinding () {
	  		var attributes = this.template.a;

	  		if ( !attributes ) return null;

	  		var shouldBind = 'twoway' in attributes ?
	  			attributes.twoway === 0 || attributes.twoway === 'true' : // covers `twoway` and `twoway='true'`
	  			this.ractive.twoway;

	  		if ( !shouldBind ) return null;

	  		var Binding = selectBinding( this );

	  		if ( !Binding ) return null;

	  		var binding = new Binding( this );

	  		return binding && binding.model ?
	  			binding :
	  			null;
	  	};

	  	Element.prototype.detach = function detach () {
	  		if ( this.decorator ) this.decorator.unrender();
	  		return detachNode( this.node );
	  	};

	  	Element.prototype.find = function find ( selector ) {
	  		if ( matches( this.node, selector ) ) return this.node;
	  		if ( this.fragment ) {
	  			return this.fragment.find( selector );
	  		}
	  	};

	  	Element.prototype.findAll = function findAll ( selector, query ) {
	  		// Add this node to the query, if applicable, and register the
	  		// query on this element
	  		var matches = query.test( this.node );
	  		if ( matches ) {
	  			query.add( this.node );
	  			if ( query.live ) this.liveQueries.push( query );
	  		}

	  		if ( this.fragment ) {
	  			this.fragment.findAll( selector, query );
	  		}
	  	};

	  	Element.prototype.findComponent = function findComponent ( name ) {
	  		if ( this.fragment ) {
	  			return this.fragment.findComponent( name );
	  		}
	  	};

	  	Element.prototype.findAllComponents = function findAllComponents ( name, query ) {
	  		if ( this.fragment ) {
	  			this.fragment.findAllComponents( name, query );
	  		}
	  	};

	  	Element.prototype.findNextNode = function findNextNode () {
	  		return null;
	  	};

	  	Element.prototype.firstNode = function firstNode () {
	  		return this.node;
	  	};

	  	Element.prototype.getAttribute = function getAttribute ( name ) {
	  		var attribute = this.attributeByName[ name ];
	  		return attribute ? attribute.getValue() : undefined;
	  	};

	  	Element.prototype.rebind = function rebind$1 () {
	  		this.attributes.forEach( rebind );
	  		this.conditionalAttributes.forEach( rebind );
	  		this.eventHandlers.forEach( rebind );
	  		if ( this.decorator ) this.decorator.rebind();
	  		if ( this.fragment ) this.fragment.rebind();
	  		if ( this.binding ) this.binding.rebind();

	  		this.liveQueries.forEach( makeDirty$1 );
	  	};

	  	Element.prototype.render = function render$1 ( target, occupants ) {
	  		// TODO determine correct namespace
	  		var this$1 = this;

	  		this.namespace = getNamespace( this );

	  		var node;
	  		var existing = false;

	  		if ( occupants ) {
	  			var n;
	  			while ( ( n = occupants.shift() ) ) {
	  				if ( n.nodeName === this$1.template.e.toUpperCase() && n.namespaceURI === this$1.namespace ) {
	  					this$1.node = node = n;
	  					existing = true;
	  					break;
	  				} else {
	  					detachNode( n );
	  				}
	  			}
	  		}

	  		if ( !node ) {
	  			node = createElement( this.template.e, this.namespace, this.getAttribute( 'is' ) );
	  			this.node = node;
	  		}

	  		defineProperty( node, '_ractive', {
	  			value: {
	  				proxy: this,
	  				fragment: this.parentFragment
	  			}
	  		});

	  		// Is this a top-level node of a component? If so, we may need to add
	  		// a data-ractive-css attribute, for CSS encapsulation
	  		if ( this.parentFragment.cssIds ) {
	  			node.setAttribute( 'data-ractive-css', this.parentFragment.cssIds.map( function ( x ) { return ("{" + x + "}"); } ).join( ' ' ) );
	  		}

	  		if ( existing && this.foundNode ) this.foundNode( node );

	  		if ( this.fragment ) {
	  			var children = existing ? toArray( node.childNodes ) : undefined;
	  			this.fragment.render( node, children );

	  			// clean up leftover children
	  			if ( children ) {
	  				children.forEach( detachNode );
	  			}
	  		}

	  		if ( existing ) {
	  			// store initial values for two-way binding
	  			if ( this.binding && this.binding.wasUndefined ) this.binding.setFromNode( node );

	  			// remove unused attributes
	  			var i = node.attributes.length;
	  			while ( i-- ) {
	  				var name = node.attributes[i].name;
	  				if ( !this$1.template.a || !( name in this$1.template.a ) ) node.removeAttribute( name );
	  			}
	  		}

	  		this.attributes.forEach( render );
	  		this.conditionalAttributes.forEach( render );

	  		if ( this.decorator ) runloop.scheduleTask( function () { return this$1.decorator.render(); }, true );
	  		if ( this.binding ) this.binding.render();

	  		this.eventHandlers.forEach( render );

	  		updateLiveQueries$1( this );

	  		// store so we can abort if it gets removed
	  		this._introTransition = getTransition( this, this.template.t0 || this.template.t1, 'intro' );

	  		if ( !existing ) {
	  			target.appendChild( node );
	  		}

	  		this.rendered = true;
	  	};

	  	Element.prototype.toString = function toString () {
	  		var tagName = this.template.e;

	  		var attrs = this.attributes.map( stringifyAttribute ).join( '' ) +
	  		            this.conditionalAttributes.map( stringifyAttribute ).join( '' );

	  		// Special case - selected options
	  		if ( this.name === 'option' && this.isSelected() ) {
	  			attrs += ' selected';
	  		}

	  		// Special case - two-way radio name bindings
	  		if ( this.name === 'input' && inputIsCheckedRadio( this ) ) {
	  			attrs += ' checked';
	  		}

	  		var str = "<" + tagName + "" + attrs + ">";

	  		if ( this.isVoid ) return str;

	  		// Special case - textarea
	  		if ( this.name === 'textarea' && this.getAttribute( 'value' ) !== undefined ) {
	  			str += escapeHtml( this.getAttribute( 'value' ) );
	  		}

	  		// Special case - contenteditable
	  		else if ( this.getAttribute( 'contenteditable' ) !== undefined ) {
	  			str += ( this.getAttribute( 'value' ) || '' );
	  		}

	  		if ( this.fragment ) {
	  			str += this.fragment.toString( !/^(?:script|style)$/i.test( this.template.e ) ); // escape text unless script/style
	  		}

	  		str += "</" + tagName + ">";
	  		return str;
	  	};

	  	Element.prototype.unbind = function unbind$1 () {
	  		this.attributes.forEach( unbind );
	  		this.conditionalAttributes.forEach( unbind );

	  		if ( this.decorator ) this.decorator.unbind();
	  		if ( this.fragment ) this.fragment.unbind();
	  	};

	  	Element.prototype.unrender = function unrender$1 ( shouldDestroy ) {
	  		if ( !this.rendered ) return;
	  		this.rendered = false;

	  		// unrendering before intro completed? complete it now
	  		// TODO should be an API for aborting transitions
	  		var transition = this._introTransition;
	  		if ( transition ) transition.complete();

	  		// Detach as soon as we can
	  		if ( this.name === 'option' ) {
	  			// <option> elements detach immediately, so that
	  			// their parent <select> element syncs correctly, and
	  			// since option elements can't have transitions anyway
	  			this.detach();
	  		} else if ( shouldDestroy ) {
	  			runloop.detachWhenReady( this );
	  		}

	  		if ( this.fragment ) this.fragment.unrender();

	  		this.eventHandlers.forEach( unrender );

	  		if ( this.binding ) this.binding.unrender();
	  		if ( !shouldDestroy && this.decorator ) this.decorator.unrender();

	  		// outro transition
	  		getTransition( this, this.template.t0 || this.template.t2, 'outro' );

	  		// special case
	  		var id = this.attributeByName.id;
	  		if ( id  ) {
	  			delete this.ractive.nodes[ id.getValue() ];
	  		}

	  		removeFromLiveQueries( this );
	  		// TODO forms are a special case
	  	};

	  	Element.prototype.update = function update$1 () {
	  		if ( this.dirty ) {
	  			this.dirty = false;

	  			this.attributes.forEach( update );
	  			this.conditionalAttributes.forEach( update );
	  			this.eventHandlers.forEach( update );

	  			if ( this.decorator ) this.decorator.update();
	  			if ( this.fragment ) this.fragment.update();
	  		}
	  	};

	  	return Element;
	  }(Item));

	  function getTransition( owner, template, eventName ) {
	  	if ( !template || !owner.ractive.transitionsEnabled ) return;

	  	var name = getTransitionName( owner, template );
	  	if ( !name ) return;

	  	var params = getTransitionParams( owner, template );
	  	var transition = new Transition( owner.ractive, owner.node, name, params, eventName );
	  	runloop.registerTransition( transition );
	  	return transition;
	  }

	  function getTransitionName ( owner, template ) {
	  	var name = template.n || template;

	  	if ( typeof name === 'string' ) return name;

	  	var fragment = new Fragment({
	  		owner: owner,
	  		template: name
	  	}).bind(); // TODO need a way to capture values without bind()

	  	name = fragment.toString();
	  	fragment.unbind();

	  	return name;
	  }

	  function getTransitionParams ( owner, template ) {
	  	if ( template.a ) return template.a;
	  	if ( !template.d )  return;

	  	// TODO is there a way to interpret dynamic arguments without all the
	  	// 'dependency thrashing'?
	  	var fragment = new Fragment({
	  		owner: owner,
	  		template: template.d
	  	}).bind();

	  	var params = fragment.getArgsList();
	  	fragment.unbind();

	  	return params;
	  }

	  function inputIsCheckedRadio ( element ) {
	  	var attributes = element.attributeByName;

	  	var typeAttribute  = attributes.type;
	  	var valueAttribute = attributes.value;
	  	var nameAttribute  = attributes.name;

	  	if ( !typeAttribute || ( typeAttribute.value !== 'radio' ) || !valueAttribute || !nameAttribute.interpolator ) {
	  		return;
	  	}

	  	if ( valueAttribute.getValue() === nameAttribute.interpolator.model.get() ) {
	  		return true;
	  	}
	  }

	  function stringifyAttribute ( attribute ) {
	  	var str = attribute.toString();
	  	return str ? ' ' + str : '';
	  }

	  function removeFromLiveQueries ( element ) {
	  	var i = element.liveQueries.length;
	  	while ( i-- ) {
	  		var query = element.liveQueries[i];
	  		query.remove( element.node );
	  	}
	  }

	  function getNamespace ( element ) {
	  	// Use specified namespace...
	  	var xmlns = element.getAttribute( 'xmlns' );
	  	if ( xmlns ) return xmlns;

	  	// ...or SVG namespace, if this is an <svg> element
	  	if ( element.name === 'svg' ) return svg$1;

	  	var parent = element.parent;

	  	if ( parent ) {
	  		// ...or HTML, if the parent is a <foreignObject>
	  		if ( parent.name === 'foreignobject' ) return html;

	  		// ...or inherit from the parent node
	  		return parent.node.namespaceURI;
	  	}

	  	return element.ractive.el.namespaceURI;
	  }

	  var Form = (function (Element) {
	  	function Form ( options ) {
	  		Element.call( this, options );
	  		this.formBindings = [];
	  	}

	  	Form.prototype = Object.create( Element && Element.prototype );
	  	Form.prototype.constructor = Form;

	  	Form.prototype.render = function render ( target, occupants ) {
	  		Element.prototype.render.call( this, target, occupants );
	  		this.node.addEventListener( 'reset', handleReset, false );
	  	};

	  	Form.prototype.unrender = function unrender ( shouldDestroy ) {
	  		this.node.removeEventListener( 'reset', handleReset, false );
	  		Element.prototype.unrender.call( this, shouldDestroy );
	  	};

	  	return Form;
	  }(Element));

	  function handleReset () {
	  	var element = this._ractive.proxy;

	  	runloop.start();
	  	element.formBindings.forEach( updateModel );
	  	runloop.end();
	  }

	  function updateModel ( binding ) {
	  	binding.model.set( binding.resetValue );
	  }

	  var Mustache = (function (Item) {
	  	function Mustache ( options ) {
	  		Item.call( this, options );

	  		this.parentFragment = options.parentFragment;
	  		this.template = options.template;
	  		this.index = options.index;

	  		this.isStatic = !!options.template.s;

	  		this.model = null;
	  		this.dirty = false;
	  	}

	  	Mustache.prototype = Object.create( Item && Item.prototype );
	  	Mustache.prototype.constructor = Mustache;

	  	Mustache.prototype.bind = function bind () {
	  		// try to find a model for this view
	  		var this$1 = this;

	  		var model = resolve$1( this.parentFragment, this.template );
	  		var value = model ? model.get() : undefined;

	  		if ( this.isStatic ) {
	  			this.model = { get: function () { return value; } };
	  			return;
	  		}

	  		if ( model ) {
	  			model.register( this );
	  			this.model = model;
	  		} else {
	  			this.resolver = this.parentFragment.resolve( this.template.r, function ( model ) {
	  				this$1.model = model;
	  				model.register( this$1 );

	  				this$1.handleChange();
	  				this$1.resolver = null;
	  			});
	  		}
	  	};

	  	Mustache.prototype.handleChange = function handleChange () {
	  		this.bubble();
	  	};

	  	Mustache.prototype.rebind = function rebind () {
	  		if ( this.isStatic || !this.model ) return;

	  		var model = resolve$1( this.parentFragment, this.template );

	  		if ( model === this.model ) return;

	  		this.model.unregister( this );

	  		this.model = model;

	  		if ( model ) {
	  			model.register( this );
	  			this.handleChange();
	  		}
	  	};

	  	Mustache.prototype.unbind = function unbind () {
	  		if ( !this.isStatic ) {
	  			this.model && this.model.unregister( this );
	  			this.model = undefined;
	  			this.resolver && this.resolver.unbind();
	  		}
	  	};

	  	return Mustache;
	  }(Item));

	  var Interpolator = (function (Mustache) {
	  	function Interpolator () {
	  		Mustache.apply(this, arguments);
	  	}

	  	Interpolator.prototype = Object.create( Mustache && Mustache.prototype );
	  	Interpolator.prototype.constructor = Interpolator;

	  	Interpolator.prototype.detach = function detach () {
	  		return detachNode( this.node );
	  	};

	  	Interpolator.prototype.firstNode = function firstNode () {
	  		return this.node;
	  	};

	  	Interpolator.prototype.getString = function getString () {
	  		return this.model ? safeToStringValue( this.model.get() ) : '';
	  	};

	  	Interpolator.prototype.render = function render ( target, occupants ) {
	  		var value = this.getString();

	  		this.rendered = true;

	  		if ( occupants ) {
	  			var n = occupants[0];
	  			if ( n && n.nodeType === 3 ) {
	  				occupants.shift();
	  				if ( n.nodeValue !== value ) {
	  					n.nodeValue = value;
	  				}
	  			} else {
	  				n = this.node = doc.createTextNode( value );
	  				if ( occupants[0] ) {
	  					target.insertBefore( n, occupants[0] );
	  				} else {
	  					target.appendChild( n );
	  				}
	  			}

	  			this.node = n;
	  		} else {
	  			this.node = doc.createTextNode( value );
	  			target.appendChild( this.node );
	  		}
	  	};

	  	Interpolator.prototype.toString = function toString ( escape ) {
	  		var string = this.getString();
	  		return escape ? escapeHtml( string ) : string;
	  	};

	  	Interpolator.prototype.unrender = function unrender ( shouldDestroy ) {
	  		if ( shouldDestroy ) this.detach();
	  		this.rendered = false;
	  	};

	  	Interpolator.prototype.update = function update () {
	  		if ( this.dirty ) {
	  			this.dirty = false;
	  			if ( this.rendered ) {
	  				this.node.data = this.getString();
	  			}
	  		}
	  	};

	  	Interpolator.prototype.valueOf = function valueOf () {
	  		return this.model ? this.model.get() : undefined;
	  	};

	  	return Interpolator;
	  }(Mustache));

	  var Input = (function (Element) {
	  	function Input () {
	  		Element.apply(this, arguments);
	  	}

	  	Input.prototype = Object.create( Element && Element.prototype );
	  	Input.prototype.constructor = Input;

	  	Input.prototype.render = function render ( target, occupants ) {
	  		Element.prototype.render.call( this, target, occupants );
	  		this.node.defaultValue = this.node.value;
	  	};

	  	return Input;
	  }(Element));

	  function findParentSelect ( element ) {
	  	while ( element ) {
	  		if ( element.name === 'select' ) return element;
	  		element = element.parent;
	  	}
	  }

	  var Option = (function (Element) {
	  	function Option ( options ) {
	  		var template = options.template;
	  		if ( !template.a ) template.a = {};

	  		// If the value attribute is missing, use the element's content,
	  		// as long as it isn't disabled
	  		if ( template.a.value === undefined && !( 'disabled' in template.a ) ) {
	  			template.a.value = template.f || '';
	  		}

	  		Element.call( this, options );

	  		this.select = findParentSelect( this.parent );
	  	}

	  	Option.prototype = Object.create( Element && Element.prototype );
	  	Option.prototype.constructor = Option;

	  	Option.prototype.bind = function bind () {
	  		if ( !this.select ) {
	  			Element.prototype.bind.call(this);
	  			return;
	  		}

	  		// If the select has a value, it overrides the `selected` attribute on
	  		// this option - so we delete the attribute
	  		var selectedAttribute = this.attributeByName.selected;
	  		if ( selectedAttribute && this.select.getAttribute( 'value' ) !== undefined ) {
	  			var index = this.attributes.indexOf( selectedAttribute );
	  			this.attributes.splice( index, 1 );
	  			delete this.attributeByName.selected;
	  		}

	  		Element.prototype.bind.call(this);
	  		this.select.options.push( this );
	  	};

	  	Option.prototype.isSelected = function isSelected () {
	  		var optionValue = this.getAttribute( 'value' );

	  		if ( optionValue === undefined || !this.select ) {
	  			return false;
	  		}

	  		var selectValue = this.select.getAttribute( 'value' );

	  		if ( selectValue == optionValue ) {
	  			return true;
	  		}

	  		if ( this.select.getAttribute( 'multiple' ) && isArray( selectValue ) ) {
	  			var i = selectValue.length;
	  			while ( i-- ) {
	  				if ( selectValue[i] == optionValue ) {
	  					return true;
	  				}
	  			}
	  		}
	  	};

	  	Option.prototype.unbind = function unbind () {
	  		Element.prototype.unbind.call(this);

	  		if ( this.select ) {
	  			removeFromArray( this.select.options, this );
	  		}
	  	};

	  	return Option;
	  }(Element));

	  function getPartialTemplate ( ractive, name, parentFragment ) {
	  	// If the partial in instance or view heirarchy instances, great
	  	var partial = getPartialFromRegistry( ractive, name, parentFragment || {} );
	  	if ( partial ) return partial;

	  	// Does it exist on the page as a script tag?
	  	partial = parser.fromId( name, { noThrow: true } );
	  	if ( partial ) {
	  		// parse and register to this ractive instance
	  		var parsed = parser.parseFor( partial, ractive );

	  		// register extra partials on the ractive instance if they don't already exist
	  		if ( parsed.p ) fillGaps( ractive.partials, parsed.p );

	  		// register (and return main partial if there are others in the template)
	  		return ractive.partials[ name ] = parsed.t;
	  	}
	  }

	  function getPartialFromRegistry ( ractive, name, parentFragment ) {
	  	// if there was an instance up-hierarchy, cool
	  	var partial = findParentPartial( name, parentFragment.owner );
	  	if ( partial ) return partial;

	  	// find first instance in the ractive or view hierarchy that has this partial
	  	var instance = findInstance( 'partials', ractive, name );

	  	if ( !instance ) { return; }

	  	partial = instance.partials[ name ];

	  	// partial is a function?
	  	var fn;
	  	if ( typeof partial === 'function' ) {
	  		fn = partial.bind( instance );
	  		fn.isOwner = instance.partials.hasOwnProperty(name);
	  		partial = fn.call( ractive, parser );
	  	}

	  	if ( !partial && partial !== '' ) {
	  		warnIfDebug( noRegistryFunctionReturn, name, 'partial', 'partial', { ractive: ractive });
	  		return;
	  	}

	  	// If this was added manually to the registry,
	  	// but hasn't been parsed, parse it now
	  	if ( !parser.isParsed( partial ) ) {
	  		// use the parseOptions of the ractive instance on which it was found
	  		var parsed = parser.parseFor( partial, instance );

	  		// Partials cannot contain nested partials!
	  		// TODO add a test for this
	  		if ( parsed.p ) {
	  			warnIfDebug( 'Partials ({{>%s}}) cannot contain nested inline partials', name, { ractive: ractive });
	  		}

	  		// if fn, use instance to store result, otherwise needs to go
	  		// in the correct point in prototype chain on instance or constructor
	  		var target = fn ? instance : findOwner( instance, name );

	  		// may be a template with partials, which need to be registered and main template extracted
	  		target.partials[ name ] = partial = parsed.t;
	  	}

	  	// store for reset
	  	if ( fn ) partial._fn = fn;

	  	return partial.v ? partial.t : partial;
	  }

	  function findOwner ( ractive, key ) {
	  	return ractive.partials.hasOwnProperty( key )
	  		? ractive
	  		: findConstructor( ractive.constructor, key);
	  }

	  function findConstructor ( constructor, key ) {
	  	if ( !constructor ) { return; }
	  	return constructor.partials.hasOwnProperty( key )
	  		? constructor
	  		: findConstructor( constructor._Parent, key );
	  }

	  function findParentPartial( name, parent ) {
	  	if ( parent ) {
	  		if ( parent.template && parent.template.p && parent.template.p[name] ) {
	  			return parent.template.p[name];
	  		} else if ( parent.parentFragment && parent.parentFragment.owner ) {
	  			return findParentPartial( name, parent.parentFragment.owner );
	  		}
	  	}
	  }

	  var Partial = (function (Mustache) {
	  	function Partial () {
	  		Mustache.apply(this, arguments);
	  	}

	  	Partial.prototype = Object.create( Mustache && Mustache.prototype );
	  	Partial.prototype.constructor = Partial;

	  	Partial.prototype.bind = function bind () {
	  		// keep track of the reference name for future resets
	  		this.refName = this.template.r;

	  		// name matches take priority over expressions
	  		var template = this.refName ? getPartialTemplate( this.ractive, this.refName, this.parentFragment ) || null : null;
	  		var templateObj;

	  		if ( template ) {
	  			this.named = true;
	  			this.setTemplate( this.template.r, template );
	  		}

	  		if ( !template ) {
	  			Mustache.prototype.bind.call(this);
	  			if ( this.model && ( templateObj = this.model.get() ) && typeof templateObj === 'object' && ( typeof templateObj.template === 'string' || isArray( templateObj.t ) ) ) {
	  				if ( templateObj.template ) {
	  					templateObj = parsePartial( this.template.r, templateObj.template, this.ractive );
	  				}
	  				this.setTemplate( this.template.r, templateObj.t );
	  			} else if ( ( !this.model || typeof this.model.get() !== 'string' ) && this.refName ) {
	  				this.setTemplate( this.refName, template );
	  			} else {
	  				this.setTemplate( this.model.get() );
	  			}
	  		}

	  		this.fragment = new Fragment({
	  			owner: this,
	  			template: this.partialTemplate
	  		}).bind();
	  	};

	  	Partial.prototype.detach = function detach () {
	  		return this.fragment.detach();
	  	};

	  	Partial.prototype.find = function find ( selector ) {
	  		return this.fragment.find( selector );
	  	};

	  	Partial.prototype.findAll = function findAll ( selector, query ) {
	  		this.fragment.findAll( selector, query );
	  	};

	  	Partial.prototype.findComponent = function findComponent ( name ) {
	  		return this.fragment.findComponent( name );
	  	};

	  	Partial.prototype.findAllComponents = function findAllComponents ( name, query ) {
	  		this.fragment.findAllComponents( name, query );
	  	};

	  	Partial.prototype.firstNode = function firstNode ( skipParent ) {
	  		return this.fragment.firstNode( skipParent );
	  	};

	  	Partial.prototype.forceResetTemplate = function forceResetTemplate () {
	  		this.partialTemplate = undefined;

	  		// on reset, check for the reference name first
	  		if ( this.refName ) {
	  			this.partialTemplate = getPartialTemplate( this.ractive, this.refName, this.parentFragment );
	  		}

	  		// then look for the resolved name
	  		if ( !this.partialTemplate ) {
	  			this.partialTemplate = getPartialTemplate( this.ractive, this.name, this.parentFragment );
	  		}

	  		if ( !this.partialTemplate ) {
	  			warnOnceIfDebug( ("Could not find template for partial '" + (this.name) + "'") );
	  			this.partialTemplate = [];
	  		}

	  		this.fragment.resetTemplate( this.partialTemplate );
	  		this.bubble();
	  	};

	  	Partial.prototype.rebind = function rebind () {
	  		Mustache.prototype.unbind.call(this);
	  		Mustache.prototype.bind.call(this);
	  		this.fragment.rebind();
	  	};

	  	Partial.prototype.render = function render ( target, occupants ) {
	  		this.fragment.render( target, occupants );
	  	};

	  	Partial.prototype.setTemplate = function setTemplate ( name, template ) {
	  		this.name = name;

	  		if ( !template && template !== null ) template = getPartialTemplate( this.ractive, name, this.parentFragment );

	  		if ( !template ) {
	  			warnOnceIfDebug( ("Could not find template for partial '" + name + "'") );
	  		}

	  		this.partialTemplate = template || [];
	  	};

	  	Partial.prototype.toString = function toString ( escape ) {
	  		return this.fragment.toString( escape );
	  	};

	  	Partial.prototype.unbind = function unbind () {
	  		Mustache.prototype.unbind.call(this);
	  		this.fragment.unbind();
	  	};

	  	Partial.prototype.unrender = function unrender ( shouldDestroy ) {
	  		this.fragment.unrender( shouldDestroy );
	  	};

	  	Partial.prototype.update = function update () {
	  		var template;

	  		if ( this.dirty ) {
	  			this.dirty = false;

	  			if ( !this.named ) {
	  				if ( this.model ) {
	  					template = this.model.get();
	  				}

	  				if ( template && typeof template === 'string' && template !== this.name ) {
	  					this.setTemplate( template );
	  					this.fragment.resetTemplate( this.partialTemplate );
	  				} else if ( template && typeof template === 'object' && ( typeof template.template === 'string' || isArray( template.t ) ) ) {
	  					if ( template.template ) {
	  						template = parsePartial( this.name, template.template, this.ractive );
	  					}
	  					this.setTemplate( this.name, template.t );
	  					this.fragment.resetTemplate( this.partialTemplate );
	  				}
	  			}

	  			this.fragment.update();
	  		}
	  	};

	  	return Partial;
	  }(Mustache));

	  function parsePartial( name, partial, ractive ) {
	  	var parsed;

	  	try {
	  		parsed = parser.parse( partial, parser.getParseOptions( ractive ) );
	  	} catch (e) {
	  		warnIfDebug( ("Could not parse partial from expression '" + name + "'\n" + (e.message)) );
	  	}

	  	return parsed || { t: [] };
	  }

	  var RepeatedFragment = function RepeatedFragment ( options ) {
	  	this.parent = options.owner.parentFragment;

	  	// bit of a hack, so reference resolution works without another
	  	// layer of indirection
	  	this.parentFragment = this;
	  	this.owner = options.owner;
	  	this.ractive = this.parent.ractive;

	  	// encapsulated styles should be inherited until they get applied by an element
	  	this.cssIds = 'cssIds' in options ? options.cssIds : ( this.parent ? this.parent.cssIds : null );

	  	this.context = null;
	  	this.rendered = false;
	  	this.iterations = [];

	  	this.template = options.template;

	  	this.indexRef = options.indexRef;
	  	this.keyRef = options.keyRef;

	  	this.pendingNewIndices = null;
	  	this.previousIterations = null;

	  	// track array versus object so updates of type rest
	  	this.isArray = false;
	  };

	  RepeatedFragment.prototype.bind = function bind ( context ) {
	  	var this$1 = this;

	  		this.context = context;
	  	var value = context.get();

	  	// {{#each array}}...
	  	if ( this.isArray = isArray( value ) ) {
	  		// we can't use map, because of sparse arrays
	  		this.iterations = [];
	  		for ( var i = 0; i < value.length; i += 1 ) {
	  			this$1.iterations[i] = this$1.createIteration( i, i );
	  		}
	  	}

	  	// {{#each object}}...
	  	else if ( isObject( value ) ) {
	  		this.isArray = false;

	  		// TODO this is a dreadful hack. There must be a neater way
	  		if ( this.indexRef ) {
	  			var refs = this.indexRef.split( ',' );
	  			this.keyRef = refs[0];
	  			this.indexRef = refs[1];
	  		}

	  		this.iterations = Object.keys( value ).map( function ( key, index ) {
	  			return this$1.createIteration( key, index );
	  		});
	  	}

	  	return this;
	  };

	  RepeatedFragment.prototype.bubble = function bubble () {
	  	this.owner.bubble();
	  };

	  RepeatedFragment.prototype.createIteration = function createIteration ( key, index ) {
	  	var fragment = new Fragment({
	  		owner: this,
	  		template: this.template
	  	});

	  	// TODO this is a bit hacky
	  	fragment.key = key;
	  	fragment.index = index;
	  	fragment.isIteration = true;

	  	var model = this.context.joinKey( key );

	  	// set up an iteration alias if there is one
	  	if ( this.owner.template.z ) {
	  		fragment.aliases = {};
	  		fragment.aliases[ this.owner.template.z[0].n ] = model;
	  	}

	  	return fragment.bind( model );
	  };

	  RepeatedFragment.prototype.detach = function detach () {
	  	var docFrag = createDocumentFragment();
	  	this.iterations.forEach( function ( fragment ) { return docFrag.appendChild( fragment.detach() ); } );
	  	return docFrag;
	  };

	  RepeatedFragment.prototype.find = function find ( selector ) {
	  	var this$1 = this;

	  		var len = this.iterations.length;
	  	var i;

	  	for ( i = 0; i < len; i += 1 ) {
	  		var found = this$1.iterations[i].find( selector );
	  		if ( found ) return found;
	  	}
	  };

	  RepeatedFragment.prototype.findAll = function findAll ( selector, query ) {
	  	var this$1 = this;

	  		var len = this.iterations.length;
	  	var i;

	  	for ( i = 0; i < len; i += 1 ) {
	  		this$1.iterations[i].findAll( selector, query );
	  	}
	  };

	  RepeatedFragment.prototype.findComponent = function findComponent ( name ) {
	  	var this$1 = this;

	  		var len = this.iterations.length;
	  	var i;

	  	for ( i = 0; i < len; i += 1 ) {
	  		var found = this$1.iterations[i].findComponent( name );
	  		if ( found ) return found;
	  	}
	  };

	  RepeatedFragment.prototype.findAllComponents = function findAllComponents ( name, query ) {
	  	var this$1 = this;

	  		var len = this.iterations.length;
	  	var i;

	  	for ( i = 0; i < len; i += 1 ) {
	  		this$1.iterations[i].findAllComponents( name, query );
	  	}
	  };

	  RepeatedFragment.prototype.findNextNode = function findNextNode ( iteration ) {
	  	var this$1 = this;

	  		if ( iteration.index < this.iterations.length - 1 ) {
	  		for ( var i = iteration.index + 1; i < this$1.iterations.length; i++ ) {
	  			var node = this$1.iterations[ i ].firstNode( true );
	  			if ( node ) return node;
	  		}
	  	}

	  	return this.owner.findNextNode();
	  };

	  RepeatedFragment.prototype.firstNode = function firstNode ( skipParent ) {
	  	return this.iterations[0] ? this.iterations[0].firstNode( skipParent ) : null;
	  };

	  RepeatedFragment.prototype.rebind = function rebind ( context ) {
	  	var this$1 = this;

	  		this.context = context;

	  	this.iterations.forEach( function ( fragment ) {
	  		var model = context.joinKey( fragment.key || fragment.index );
	  		if ( this$1.owner.template.z ) {
	  			fragment.aliases = {};
	  			fragment.aliases[ this$1.owner.template.z[0].n ] = model;
	  		}
	  		fragment.rebind( model );
	  	});
	  };

	  RepeatedFragment.prototype.render = function render ( target, occupants ) {
	  	// TODO use docFrag.cloneNode...

	  	if ( this.iterations ) {
	  		this.iterations.forEach( function ( fragment ) { return fragment.render( target, occupants ); } );
	  	}

	  	this.rendered = true;
	  };

	  RepeatedFragment.prototype.shuffle = function shuffle ( newIndices ) {
	  	var this$1 = this;

	  		if ( !this.pendingNewIndices ) this.previousIterations = this.iterations.slice();

	  	if ( !this.pendingNewIndices ) this.pendingNewIndices = [];

	  	this.pendingNewIndices.push( newIndices );

	  	var iterations = [];

	  	newIndices.forEach( function ( newIndex, oldIndex ) {
	  		if ( newIndex === -1 ) return;

	  		var fragment = this$1.iterations[ oldIndex ];
	  		iterations[ newIndex ] = fragment;

	  		if ( newIndex !== oldIndex && fragment ) fragment.dirty = true;
	  	});

	  	this.iterations = iterations;

	  	this.bubble();
	  };

	  RepeatedFragment.prototype.toString = function toString$1$$ ( escape ) {
	  	return this.iterations ?
	  		this.iterations.map( escape ? toEscapedString : toString$1 ).join( '' ) :
	  		'';
	  };

	  RepeatedFragment.prototype.unbind = function unbind$1 () {
	  	this.iterations.forEach( unbind );
	  	return this;
	  };

	  RepeatedFragment.prototype.unrender = function unrender$1 ( shouldDestroy ) {
	  	this.iterations.forEach( shouldDestroy ? unrenderAndDestroy : unrender );
	  	if ( this.pendingNewIndices && this.previousIterations ) {
	  		this.previousIterations.forEach( function ( fragment ) {
	  			if ( fragment.rendered ) shouldDestroy ? unrenderAndDestroy( fragment ) : unrender( fragment );
	  		});
	  	}
	  	this.rendered = false;
	  };

	  // TODO smart update
	  RepeatedFragment.prototype.update = function update$1 () {
	  	// skip dirty check, since this is basically just a facade

	  	var this$1 = this;

	  		if ( this.pendingNewIndices ) {
	  		this.updatePostShuffle();
	  		return;
	  	}

	  	if ( this.updating ) return;
	  	this.updating = true;

	  	var value = this.context.get(),
	  			  wasArray = this.isArray;

	  	var toRemove;
	  	var oldKeys;
	  	var reset = true;
	  	var i;

	  	if ( this.isArray = isArray( value ) ) {
	  		if ( wasArray ) {
	  			reset = false;
	  			if ( this.iterations.length > value.length ) {
	  				toRemove = this.iterations.splice( value.length );
	  			}
	  		}
	  	} else if ( isObject( value ) && !wasArray ) {
	  		reset = false;
	  		toRemove = [];
	  		oldKeys = {};
	  		i = this.iterations.length;

	  		while ( i-- ) {
	  			var fragment$1 = this$1.iterations[i];
	  			if ( fragment$1.key in value ) {
	  				oldKeys[ fragment$1.key ] = true;
	  			} else {
	  				this$1.iterations.splice( i, 1 );
	  				toRemove.push( fragment$1 );
	  			}
	  		}
	  	}

	  	if ( reset ) {
	  		toRemove = this.iterations;
	  		this.iterations = [];
	  	}

	  	if ( toRemove ) {
	  		toRemove.forEach( function ( fragment ) {
	  			fragment.unbind();
	  			fragment.unrender( true );
	  		});
	  	}

	  	// update the remaining ones
	  	this.iterations.forEach( update );

	  	// add new iterations
	  	var newLength = isArray( value ) ?
	  		value.length :
	  		isObject( value ) ?
	  			Object.keys( value ).length :
	  			0;

	  	var docFrag;
	  	var fragment;

	  	if ( newLength > this.iterations.length ) {
	  		docFrag = this.rendered ? createDocumentFragment() : null;
	  		i = this.iterations.length;

	  		if ( isArray( value ) ) {
	  			while ( i < value.length ) {
	  				fragment = this$1.createIteration( i, i );

	  				this$1.iterations.push( fragment );
	  				if ( this$1.rendered ) fragment.render( docFrag );

	  				i += 1;
	  			}
	  		}

	  		else if ( isObject( value ) ) {
	  			// TODO this is a dreadful hack. There must be a neater way
	  			if ( this.indexRef && !this.keyRef ) {
	  				var refs = this.indexRef.split( ',' );
	  				this.keyRef = refs[0];
	  				this.indexRef = refs[1];
	  			}

	  			Object.keys( value ).forEach( function ( key ) {
	  				if ( !oldKeys || !( key in oldKeys ) ) {
	  					fragment = this$1.createIteration( key, i );

	  					this$1.iterations.push( fragment );
	  					if ( this$1.rendered ) fragment.render( docFrag );

	  					i += 1;
	  				}
	  			});
	  		}

	  		if ( this.rendered ) {
	  			var parentNode = this.parent.findParentNode();
	  			var anchor = this.parent.findNextNode( this.owner );

	  			parentNode.insertBefore( docFrag, anchor );
	  		}
	  	}

	  	this.updating = false;
	  };

	  RepeatedFragment.prototype.updatePostShuffle = function updatePostShuffle () {
	  	var this$1 = this;

	  		var newIndices = this.pendingNewIndices[ 0 ];

	  	// map first shuffle through
	  	this.pendingNewIndices.slice( 1 ).forEach( function ( indices ) {
	  		newIndices.forEach( function ( newIndex, oldIndex ) {
	  			newIndices[ oldIndex ] = indices[ newIndex ];
	  		});
	  	});

	  	// This algorithm (for detaching incorrectly-ordered fragments from the DOM and
	  	// storing them in a document fragment for later reinsertion) seems a bit hokey,
	  	// but it seems to work for now
	  	var len = this.context.get().length;
	  	var i, maxIdx = 0, merged = false;

	  	newIndices.forEach( function ( newIndex, oldIndex ) {
	  		var fragment = this$1.previousIterations[ oldIndex ];

	  		// check for merged shuffles
	  		if ( !merged && newIndex !== -1 ) {
	  			if ( newIndex < maxIdx ) merged = true;
	  			if ( newIndex > maxIdx ) maxIdx = newIndex;
	  		}


	  		if ( newIndex === -1 ) {
	  			fragment.unbind().unrender( true );
	  		} else {
	  			fragment.index = newIndex;
	  			var model = this$1.context.joinKey( newIndex );
	  			if ( this$1.owner.template.z ) {
	  				fragment.aliases = {};
	  				fragment.aliases[ this$1.owner.template.z[0].n ] = model;
	  			}
	  			fragment.rebind( model );
	  		}
	  	});

	  	// create new iterations
	  	var docFrag = this.rendered ? createDocumentFragment() : null;
	  	var parentNode = this.rendered ? this.parent.findParentNode() : null;

	  	if ( merged ) {
	  		for ( i = 0; i < len; i += 1 ) {
	  			var frag = this$1.iterations[i];

	  			if ( this$1.rendered ) {
	  				if ( frag ) {
	  					docFrag.appendChild( frag.detach() );
	  				} else {
	  					this$1.iterations[i] = this$1.createIteration( i, i );
	  					this$1.iterations[i].render( docFrag );
	  				}
	  			}

	  			if ( !this$1.rendered ) {
	  				if ( !frag ) {
	  					this$1.iterations[i] = this$1.createIteration( i, i );
	  				}
	  			}
	  		}
	  	} else {
	  		for ( i = 0; i < len; i++ ) {
	  			var frag$1 = this$1.iterations[i];

	  			if ( this$1.rendered ) {
	  				if ( frag$1 && docFrag.childNodes.length ) {
	  					parentNode.insertBefore( docFrag, frag$1.firstNode() );
	  				}

	  				if ( !frag$1 ) {
	  					frag$1 = this$1.iterations[i] = this$1.createIteration( i, i );
	  					frag$1.render( docFrag );
	  				}
	  			} else if ( !frag$1 ) {
	  				this$1.iterations[i] = this$1.createIteration( i, i );
	  			}
	  		}
	  	}

	  	if ( this.rendered && docFrag.childNodes.length ) {
	  		parentNode.insertBefore( docFrag, this.owner.findNextNode() );
	  	}

	  	this.iterations.forEach( update );

	  	this.pendingNewIndices = null;
	  };

	  function isEmpty ( value ) {
	  	return !value ||
	  	       ( isArray( value ) && value.length === 0 ) ||
	  		   ( isObject( value ) && Object.keys( value ).length === 0 );
	  }

	  function getType ( value, hasIndexRef ) {
	  	if ( hasIndexRef || isArray( value ) ) return SECTION_EACH;
	  	if ( isObject( value ) || typeof value === 'function' ) return SECTION_IF_WITH;
	  	if ( value === undefined ) return null;
	  	return SECTION_IF;
	  }

	  var Section = (function (Mustache) {
	  	function Section ( options ) {
	  		Mustache.call( this, options );

	  		this.sectionType = options.template.n || null;
	  		this.templateSectionType = this.sectionType;
	  		this.fragment = null;
	  	}

	  	Section.prototype = Object.create( Mustache && Mustache.prototype );
	  	Section.prototype.constructor = Section;

	  	Section.prototype.bind = function bind () {
	  		Mustache.prototype.bind.call(this);

	  		// if we managed to bind, we need to create children
	  		if ( this.model ) {
	  			this.dirty = true;
	  			this.update();
	  		} else if (this.sectionType && this.sectionType === SECTION_UNLESS) {
	  			this.fragment = new Fragment({
	  				owner: this,
	  				template: this.template.f
	  			}).bind();
	  		}
	  	};

	  	Section.prototype.detach = function detach () {
	  		return this.fragment ? this.fragment.detach() : createDocumentFragment();
	  	};

	  	Section.prototype.find = function find ( selector ) {
	  		if ( this.fragment ) {
	  			return this.fragment.find( selector );
	  		}
	  	};

	  	Section.prototype.findAll = function findAll ( selector, query ) {
	  		if ( this.fragment ) {
	  			this.fragment.findAll( selector, query );
	  		}
	  	};

	  	Section.prototype.findComponent = function findComponent ( name ) {
	  		if ( this.fragment ) {
	  			return this.fragment.findComponent( name );
	  		}
	  	};

	  	Section.prototype.findAllComponents = function findAllComponents ( name, query ) {
	  		if ( this.fragment ) {
	  			this.fragment.findAllComponents( name, query );
	  		}
	  	};

	  	Section.prototype.firstNode = function firstNode ( skipParent ) {
	  		return this.fragment && this.fragment.firstNode( skipParent );
	  	};

	  	Section.prototype.rebind = function rebind () {
	  		Mustache.prototype.rebind.call(this);

	  		if ( this.fragment ) {
	  			this.fragment.rebind( this.sectionType === SECTION_IF || this.sectionType === SECTION_UNLESS ? null : this.model );
	  		}
	  	};

	  	Section.prototype.render = function render ( target, occupants ) {
	  		this.rendered = true;
	  		if ( this.fragment ) this.fragment.render( target, occupants );
	  	};

	  	Section.prototype.shuffle = function shuffle ( newIndices ) {
	  		if ( this.fragment && this.sectionType === SECTION_EACH ) {
	  			this.fragment.shuffle( newIndices );
	  		}
	  	};

	  	Section.prototype.toString = function toString ( escape ) {
	  		return this.fragment ? this.fragment.toString( escape ) : '';
	  	};

	  	Section.prototype.unbind = function unbind () {
	  		Mustache.prototype.unbind.call(this);
	  		if ( this.fragment ) this.fragment.unbind();
	  	};

	  	Section.prototype.unrender = function unrender ( shouldDestroy ) {
	  		if ( this.rendered && this.fragment ) this.fragment.unrender( shouldDestroy );
	  		this.rendered = false;
	  	};

	  	Section.prototype.update = function update () {
	  		if ( !this.dirty ) return;
	  		if ( !this.model && this.sectionType !== SECTION_UNLESS ) return;

	  		this.dirty = false;

	  		var value = !this.model ? undefined : this.model.isRoot ? this.model.value : this.model.get();
	  		var lastType = this.sectionType;

	  		// watch for switching section types
	  		if ( this.sectionType === null || this.templateSectionType === null ) this.sectionType = getType( value, this.template.i );
	  		if ( lastType && lastType !== this.sectionType && this.fragment ) {
	  			if ( this.rendered ) {
	  				this.fragment.unbind().unrender( true );
	  			}

	  			this.fragment = null;
	  		}

	  		var newFragment;

	  		if ( this.sectionType === SECTION_EACH ) {
	  			if ( this.fragment ) {
	  				this.fragment.update();
	  			} else {
	  				// TODO can this happen?
	  				newFragment = new RepeatedFragment({
	  					owner: this,
	  					template: this.template.f,
	  					indexRef: this.template.i
	  				}).bind( this.model );
	  			}
	  		}

	  		// WITH is now IF_WITH; WITH is only used for {{>partial context}}
	  		else if ( this.sectionType === SECTION_WITH ) {
	  			if ( this.fragment ) {
	  				this.fragment.update();
	  			} else {
	  				newFragment = new Fragment({
	  					owner: this,
	  					template: this.template.f
	  				}).bind( this.model );
	  			}
	  		}

	  		else if ( this.sectionType === SECTION_IF_WITH ) {
	  			if ( this.fragment ) {
	  				if ( isEmpty( value ) ) {
	  					if ( this.rendered ) {
	  						this.fragment.unbind().unrender( true );
	  					}

	  					this.fragment = null;
	  				} else {
	  					this.fragment.update();
	  				}
	  			} else if ( !isEmpty( value ) ) {
	  				newFragment = new Fragment({
	  					owner: this,
	  					template: this.template.f
	  				}).bind( this.model );
	  			}
	  		}

	  		else {
	  			var fragmentShouldExist = this.sectionType === SECTION_UNLESS ? isEmpty( value ) : !!value && !isEmpty( value );

	  			if ( this.fragment ) {
	  				if ( fragmentShouldExist ) {
	  					this.fragment.update();
	  				} else {
	  					if ( this.rendered ) {
	  						this.fragment.unbind().unrender( true );
	  					}

	  					this.fragment = null;
	  				}
	  			} else if ( fragmentShouldExist ) {
	  				newFragment = new Fragment({
	  					owner: this,
	  					template: this.template.f
	  				}).bind( null );
	  			}
	  		}

	  		if ( newFragment ) {
	  			if ( this.rendered ) {
	  				var parentNode = this.parentFragment.findParentNode();
	  				var anchor = this.parentFragment.findNextNode( this );

	  				if ( anchor ) {
	  					var docFrag = createDocumentFragment();
	  					newFragment.render( docFrag );

	  					// we use anchor.parentNode, not parentNode, because the sibling
	  					// may be temporarily detached as a result of a shuffle
	  					anchor.parentNode.insertBefore( docFrag, anchor );
	  				} else {
	  					newFragment.render( parentNode );
	  				}
	  			}

	  			this.fragment = newFragment;
	  		}
	  	};

	  	return Section;
	  }(Mustache));

	  function valueContains ( selectValue, optionValue ) {
	  	var i = selectValue.length;
	  	while ( i-- ) {
	  		if ( selectValue[i] == optionValue ) return true;
	  	}
	  }

	  var Select = (function (Element) {
	  	function Select ( options ) {
	  		Element.call( this, options );
	  		this.options = [];
	  	}

	  	Select.prototype = Object.create( Element && Element.prototype );
	  	Select.prototype.constructor = Select;

	  	Select.prototype.foundNode = function foundNode ( node ) {
	  		if ( this.binding ) {
	  			var selectedOptions = getSelectedOptions( node );

	  			if ( selectedOptions.length > 0 ) {
	  				this.selectedOptions = selectedOptions;
	  			}
	  		}
	  	};

	  	Select.prototype.render = function render ( target, occupants ) {
	  		Element.prototype.render.call( this, target, occupants );
	  		this.sync();

	  		var node = this.node;

	  		var i = node.options.length;
	  		while ( i-- ) {
	  			node.options[i].defaultSelected = node.options[i].selected;
	  		}

	  		this.rendered = true;
	  	};

	  	Select.prototype.sync = function sync () {
	  		var this$1 = this;

	  		var selectNode = this.node;

	  		if ( !selectNode ) return;

	  		var options = toArray( selectNode.options );

	  		if ( this.selectedOptions ) {
	  			options.forEach( function ( o ) {
	  				if ( this$1.selectedOptions.indexOf( o ) >= 0 ) o.selected = true;
	  				else o.selected = false;
	  			});
	  			this.binding.setFromNode( selectNode );
	  			delete this.selectedOptions;
	  			return;
	  		}

	  		var selectValue = this.getAttribute( 'value' );
	  		var isMultiple = this.getAttribute( 'multiple' );

	  		// If the <select> has a specified value, that should override
	  		// these options
	  		if ( selectValue !== undefined ) {
	  			var optionWasSelected;

	  			options.forEach( function ( o ) {
	  				var optionValue = o._ractive ? o._ractive.value : o.value;
	  				var shouldSelect = isMultiple ? valueContains( selectValue, optionValue ) : selectValue == optionValue;

	  				if ( shouldSelect ) {
	  					optionWasSelected = true;
	  				}

	  				o.selected = shouldSelect;
	  			});

	  			if ( !optionWasSelected && !isMultiple ) {
	  				if ( this.binding ) {
	  					this.binding.forceUpdate();
	  				}
	  			}
	  		}

	  		// Otherwise the value should be initialised according to which
	  		// <option> element is selected, if twoway binding is in effect
	  		else if ( this.binding ) {
	  			this.binding.forceUpdate();
	  		}
	  	};

	  	Select.prototype.update = function update () {
	  		Element.prototype.update.call(this);
	  		this.sync();
	  	};

	  	return Select;
	  }(Element));

	  var Textarea = (function (Input) {
	  	function Textarea( options ) {
	  		var template = options.template;

	  		// if there is a bindable value, there should be no body
	  		if ( template.a && template.a.value && isBindable( { template: template.a.value } ) ) {
	  			options.noContent = true;
	  		}

	  		// otherwise, if there is a single bindable interpolator as content, move it to the value attr
	  		else if ( template.f && (!template.a || !template.a.value) && isBindable( { template: template.f } ) ) {
	  			if ( !template.a ) template.a = {};
	  			template.a.value = template.f;
	  			options.noContent = true;
	  		}

	  		Input.call( this, options );
	  	}

	  	Textarea.prototype = Object.create( Input && Input.prototype );
	  	Textarea.prototype.constructor = Textarea;

	  	Textarea.prototype.bubble = function bubble () {
	  		var this$1 = this;

	  		if ( !this.dirty ) {
	  			this.dirty = true;

	  			if ( this.rendered && !this.binding && this.fragment ) {
	  				runloop.scheduleTask( function () {
	  					this$1.dirty = false;
	  					this$1.node.value = this$1.fragment.toString();
	  				});
	  			}

	  			this.parentFragment.bubble(); // default behaviour
	  		}
	  	};

	  	return Textarea;
	  }(Input));

	  var Text = (function (Item) {
	  	function Text ( options ) {
	  		Item.call( this, options );
	  		this.type = TEXT;
	  	}

	  	Text.prototype = Object.create( Item && Item.prototype );
	  	Text.prototype.constructor = Text;

	  	Text.prototype.bind = function bind () {
	  		// noop
	  	};

	  	Text.prototype.detach = function detach () {
	  		return detachNode( this.node );
	  	};

	  	Text.prototype.firstNode = function firstNode () {
	  		return this.node;
	  	};

	  	Text.prototype.rebind = function rebind () {
	  		// noop
	  	};

	  	Text.prototype.render = function render ( target, occupants ) {
	  		this.rendered = true;

	  		if ( occupants ) {
	  			var n = occupants[0];
	  			if ( n && n.nodeType === 3 ) {
	  				occupants.shift();
	  				if ( n.nodeValue !== this.template ) {
	  					n.nodeValue = this.template;
	  				}
	  			} else {
	  				n = this.node = doc.createTextNode( this.template );
	  				if ( occupants[0] ) {
	  					target.insertBefore( n, occupants[0] );
	  				} else {
	  					target.appendChild( n );
	  				}
	  			}

	  			this.node = n;
	  		} else {
	  			this.node = doc.createTextNode( this.template );
	  			target.appendChild( this.node );
	  		}
	  	};

	  	Text.prototype.toString = function toString ( escape ) {
	  		return escape ? escapeHtml( this.template ) : this.template;
	  	};

	  	Text.prototype.unbind = function unbind () {
	  		// noop
	  	};

	  	Text.prototype.unrender = function unrender ( shouldDestroy ) {
	  		if ( this.rendered && shouldDestroy ) this.detach();
	  		this.rendered = false;
	  	};

	  	Text.prototype.update = function update () {
	  		// noop
	  	};

	  	Text.prototype.valueOf = function valueOf () {
	  		return this.template;
	  	};

	  	return Text;
	  }(Item));

	  var elementCache = {};

	  var ieBug;
	  var ieBlacklist;

	  try {
	  	createElement( 'table' ).innerHTML = 'foo';
	  } catch ( err ) {
	  	ieBug = true;

	  	ieBlacklist = {
	  		TABLE:  [ '<table class="x">', '</table>' ],
	  		THEAD:  [ '<table><thead class="x">', '</thead></table>' ],
	  		TBODY:  [ '<table><tbody class="x">', '</tbody></table>' ],
	  		TR:     [ '<table><tr class="x">', '</tr></table>' ],
	  		SELECT: [ '<select class="x">', '</select>' ]
	  	};
	  }

	  function insertHtml ( html, node, docFrag ) {
	  	var nodes = [];

	  	// render 0 and false
	  	if ( html == null || html === '' ) return nodes;

	  	var container;
	  	var wrapper;
	  	var selectedOption;

	  	if ( ieBug && ( wrapper = ieBlacklist[ node.tagName ] ) ) {
	  		container = element( 'DIV' );
	  		container.innerHTML = wrapper[0] + html + wrapper[1];
	  		container = container.querySelector( '.x' );

	  		if ( container.tagName === 'SELECT' ) {
	  			selectedOption = container.options[ container.selectedIndex ];
	  		}
	  	}

	  	else if ( node.namespaceURI === svg$1 ) {
	  		container = element( 'DIV' );
	  		container.innerHTML = '<svg class="x">' + html + '</svg>';
	  		container = container.querySelector( '.x' );
	  	}

	  	else if ( node.tagName === 'TEXTAREA' ) {
	  		container = createElement( 'div' );

	  		if ( typeof container.textContent !== 'undefined' ) {
	  			container.textContent = html;
	  		} else {
	  			container.innerHTML = html;
	  		}
	  	}

	  	else {
	  		container = element( node.tagName );
	  		container.innerHTML = html;

	  		if ( container.tagName === 'SELECT' ) {
	  			selectedOption = container.options[ container.selectedIndex ];
	  		}
	  	}

	  	var child;
	  	while ( child = container.firstChild ) {
	  		nodes.push( child );
	  		docFrag.appendChild( child );
	  	}

	  	// This is really annoying. Extracting <option> nodes from the
	  	// temporary container <select> causes the remaining ones to
	  	// become selected. So now we have to deselect them. IE8, you
	  	// amaze me. You really do
	  	// ...and now Chrome too
	  	var i;
	  	if ( node.tagName === 'SELECT' ) {
	  		i = nodes.length;
	  		while ( i-- ) {
	  			if ( nodes[i] !== selectedOption ) {
	  				nodes[i].selected = false;
	  			}
	  		}
	  	}

	  	return nodes;
	  }

	  function element ( tagName ) {
	  	return elementCache[ tagName ] || ( elementCache[ tagName ] = createElement( tagName ) );
	  }

	  var Triple = (function (Mustache) {
	  	function Triple ( options ) {
	  		Mustache.call( this, options );
	  	}

	  	Triple.prototype = Object.create( Mustache && Mustache.prototype );
	  	Triple.prototype.constructor = Triple;

	  	Triple.prototype.detach = function detach () {
	  		var docFrag = createDocumentFragment();
	  		this.nodes.forEach( function ( node ) { return docFrag.appendChild( node ); } );
	  		return docFrag;
	  	};

	  	Triple.prototype.find = function find ( selector ) {
	  		var this$1 = this;

	  		var len = this.nodes.length;
	  		var i;

	  		for ( i = 0; i < len; i += 1 ) {
	  			var node = this$1.nodes[i];

	  			if ( node.nodeType !== 1 ) continue;

	  			if ( matches( node, selector ) ) return node;

	  			var queryResult = node.querySelector( selector );
	  			if ( queryResult ) return queryResult;
	  		}

	  		return null;
	  	};

	  	Triple.prototype.findAll = function findAll ( selector, query ) {
	  		var this$1 = this;

	  		var len = this.nodes.length;
	  		var i;

	  		for ( i = 0; i < len; i += 1 ) {
	  			var node = this$1.nodes[i];

	  			if ( node.nodeType !== 1 ) continue;

	  			if ( query.test( node ) ) query.add( node );

	  			var queryAllResult = node.querySelectorAll( selector );
	  			if ( queryAllResult ) {
	  				var numNodes = queryAllResult.length;
	  				var j;

	  				for ( j = 0; j < numNodes; j += 1 ) {
	  					query.add( queryAllResult[j] );
	  				}
	  			}
	  		}
	  	};

	  	Triple.prototype.findComponent = function findComponent () {
	  		return null;
	  	};

	  	Triple.prototype.firstNode = function firstNode () {
	  		return this.nodes[0];
	  	};

	  	Triple.prototype.render = function render ( target ) {
	  		var html = this.model ? this.model.get() : '';
	  		this.nodes = insertHtml( html, this.parentFragment.findParentNode(), target );
	  		this.rendered = true;
	  	};

	  	Triple.prototype.toString = function toString () {
	  		return this.model && this.model.get() != null ? decodeCharacterReferences( '' + this.model.get() ) : '';
	  	};

	  	Triple.prototype.unrender = function unrender () {
	  		if ( this.nodes ) this.nodes.forEach( function ( node ) { return detachNode( node ); } );
	  		this.rendered = false;
	  	};

	  	Triple.prototype.update = function update () {
	  		if ( this.rendered && this.dirty ) {
	  			this.dirty = false;

	  			this.unrender();
	  			var docFrag = createDocumentFragment();
	  			this.render( docFrag );

	  			var parentNode = this.parentFragment.findParentNode();
	  			var anchor = this.parentFragment.findNextNode( this );

	  			parentNode.insertBefore( docFrag, anchor );
	  		}
	  	};

	  	return Triple;
	  }(Mustache));

	  var Yielder = (function (Item) {
	  	function Yielder ( options ) {
	  		Item.call( this, options );

	  		this.container = options.parentFragment.ractive;
	  		this.component = this.container.component;

	  		this.containerFragment = options.parentFragment;
	  		this.parentFragment = this.component.parentFragment;

	  		// {{yield}} is equivalent to {{yield content}}
	  		this.name = options.template.n || '';
	  	}

	  	Yielder.prototype = Object.create( Item && Item.prototype );
	  	Yielder.prototype.constructor = Yielder;

	  	Yielder.prototype.bind = function bind () {
	  		var name = this.name;

	  		( this.component.yielders[ name ] || ( this.component.yielders[ name ] = [] ) ).push( this );

	  		// TODO don't parse here
	  		var template = this.container._inlinePartials[ name || 'content' ];

	  		if ( typeof template === 'string' ) {
	  			template = parse( template ).t;
	  		}

	  		if ( !template ) {
	  			warnIfDebug( ("Could not find template for partial \"" + name + "\""), { ractive: this.ractive });
	  			template = [];
	  		}

	  		this.fragment = new Fragment({
	  			owner: this,
	  			ractive: this.container.parent,
	  			template: template
	  		}).bind();
	  	};

	  	Yielder.prototype.bubble = function bubble () {
	  		if ( !this.dirty ) {
	  			this.containerFragment.bubble();
	  			this.dirty = true;
	  		}
	  	};

	  	Yielder.prototype.detach = function detach () {
	  		return this.fragment.detach();
	  	};

	  	Yielder.prototype.find = function find ( selector ) {
	  		return this.fragment.find( selector );
	  	};

	  	Yielder.prototype.findAll = function findAll ( selector, queryResult ) {
	  		this.fragment.find( selector, queryResult );
	  	};

	  	Yielder.prototype.findComponent = function findComponent ( name ) {
	  		return this.fragment.findComponent( name );
	  	};

	  	Yielder.prototype.findAllComponents = function findAllComponents ( name, queryResult ) {
	  		this.fragment.findAllComponents( name, queryResult );
	  	};

	  	Yielder.prototype.findNextNode = function findNextNode() {
	  		return this.containerFragment.findNextNode( this );
	  	};

	  	Yielder.prototype.firstNode = function firstNode ( skipParent ) {
	  		return this.fragment.firstNode( skipParent );
	  	};

	  	Yielder.prototype.rebind = function rebind () {
	  		this.fragment.rebind();
	  	};

	  	Yielder.prototype.render = function render ( target, occupants ) {
	  		return this.fragment.render( target, occupants );
	  	};

	  	Yielder.prototype.setTemplate = function setTemplate ( name ) {
	  		var template = this.parentFragment.ractive.partials[ name ];

	  		if ( typeof template === 'string' ) {
	  			template = parse( template ).t;
	  		}

	  		this.partialTemplate = template || []; // TODO warn on missing partial
	  	};

	  	Yielder.prototype.toString = function toString ( escape ) {
	  		return this.fragment.toString( escape );
	  	};

	  	Yielder.prototype.unbind = function unbind () {
	  		this.fragment.unbind();
	  		removeFromArray( this.component.yielders[ this.name ], this );
	  	};

	  	Yielder.prototype.unrender = function unrender ( shouldDestroy ) {
	  		this.fragment.unrender( shouldDestroy );
	  	};

	  	Yielder.prototype.update = function update () {
	  		this.dirty = false;
	  		this.fragment.update();
	  	};

	  	return Yielder;
	  }(Item));

	  // finds the component constructor in the registry or view hierarchy registries
	  function getComponentConstructor ( ractive, name ) {
	  	var instance = findInstance( 'components', ractive, name );
	  	var Component;

	  	if ( instance ) {
	  		Component = instance.components[ name ];

	  		// best test we have for not Ractive.extend
	  		if ( !Component._Parent ) {
	  			// function option, execute and store for reset
	  			var fn = Component.bind( instance );
	  			fn.isOwner = instance.components.hasOwnProperty( name );
	  			Component = fn();

	  			if ( !Component ) {
	  				warnIfDebug( noRegistryFunctionReturn, name, 'component', 'component', { ractive: ractive });
	  				return;
	  			}

	  			if ( typeof Component === 'string' ) {
	  				// allow string lookup
	  				Component = getComponentConstructor( ractive, Component );
	  			}

	  			Component._fn = fn;
	  			instance.components[ name ] = Component;
	  		}
	  	}

	  	return Component;
	  }

	  var constructors = {};
	  constructors[ ALIAS ] = Alias;
	  constructors[ DOCTYPE ] = Doctype;
	  constructors[ INTERPOLATOR ] = Interpolator;
	  constructors[ PARTIAL ] = Partial;
	  constructors[ SECTION ] = Section;
	  constructors[ TRIPLE ] = Triple;
	  constructors[ YIELDER ] = Yielder;

	  var specialElements = {
	  	doctype: Doctype,
	  	form: Form,
	  	input: Input,
	  	option: Option,
	  	select: Select,
	  	textarea: Textarea
	  };

	  function createItem ( options ) {
	  	if ( typeof options.template === 'string' ) {
	  		return new Text( options );
	  	}

	  	if ( options.template.t === ELEMENT ) {
	  		// could be component or element
	  		var ComponentConstructor = getComponentConstructor( options.parentFragment.ractive, options.template.e );
	  		if ( ComponentConstructor ) {
	  			return new Component( options, ComponentConstructor );
	  		}

	  		var tagName = options.template.e.toLowerCase();

	  		var ElementConstructor = specialElements[ tagName ] || Element;
	  		return new ElementConstructor( options );
	  	}

	  	var Item = constructors[ options.template.t ];

	  	if ( !Item ) throw new Error( ("Unrecognised item type " + (options.template.t)) );

	  	return new Item( options );
	  }

	  var ReferenceResolver = function ReferenceResolver ( fragment, reference, callback ) {
	  	var this$1 = this;

	  		this.fragment = fragment;
	  	this.reference = normalise( reference );
	  	this.callback = callback;

	  	this.keys = splitKeypathI( reference );
	  	this.resolved = false;

	  	// TODO the consumer should take care of addUnresolved
	  	// we attach to all the contexts between here and the root
	  	// - whenever their values change, they can quickly
	  	// check to see if we can resolve
	  	while ( fragment ) {
	  		if ( fragment.context ) {
	  			fragment.context.addUnresolved( this$1.keys[0], this$1 );
	  		}

	  		fragment = fragment.componentParent || fragment.parent;
	  	}
	  };

	  ReferenceResolver.prototype.attemptResolution = function attemptResolution () {
	  	if ( this.resolved ) return;

	  	var model = resolveAmbiguousReference( this.fragment, this.reference );

	  	if ( model ) {
	  		this.resolved = true;
	  		this.callback( model );
	  	}
	  };

	  ReferenceResolver.prototype.forceResolution = function forceResolution () {
	  	if ( this.resolved ) return;

	  	var model = this.fragment.findContext().joinAll( this.keys );
	  	this.callback( model );
	  	this.resolved = true;
	  };

	  ReferenceResolver.prototype.unbind = function unbind () {
	  	var this$1 = this;

	  		removeFromArray( this.fragment.unresolved, this );

	  	if ( this.resolved ) return;

	  	var fragment = this.fragment;
	  	while ( fragment ) {
	  		if ( fragment.context ) {
	  			fragment.context.removeUnresolved( this$1.keys[0], this$1 );
	  		}

	  		fragment = fragment.componentParent || fragment.parent;
	  	}
	  };

	  // TODO all this code needs to die
	  function processItems ( items, values, guid, counter ) {
	  	if ( counter === void 0 ) counter = 0;

	  	return items.map( function ( item ) {
	  		if ( item.type === TEXT ) {
	  			return item.template;
	  		}

	  		if ( item.fragment ) {
	  			if ( item.fragment.iterations ) {
	  				return item.fragment.iterations.map( function ( fragment ) {
	  					return processItems( fragment.items, values, guid, counter );
	  				}).join( '' );
	  			} else {
	  				return processItems( item.fragment.items, values, guid, counter );
	  			}
	  		}

	  		var placeholderId = "" + guid + "-" + (counter++);

	  		values[ placeholderId ] = item.model ?
	  			item.model.wrapper ?
	  				item.model.wrapper.value :
	  				item.model.get() :
	  			undefined;

	  		return '${' + placeholderId + '}';
	  	}).join( '' );
	  }

	  function unrenderAndDestroy$1 ( item ) {
	  	item.unrender( true );
	  }

	  var Fragment = function Fragment ( options ) {
	  	this.owner = options.owner; // The item that owns this fragment - an element, section, partial, or attribute

	  	this.isRoot = !options.owner.parentFragment;
	  	this.parent = this.isRoot ? null : this.owner.parentFragment;
	  	this.ractive = options.ractive || ( this.isRoot ? options.owner : this.parent.ractive );

	  	this.componentParent = ( this.isRoot && this.ractive.component ) ? this.ractive.component.parentFragment : null;

	  	this.context = null;
	  	this.rendered = false;

	  	// encapsulated styles should be inherited until they get applied by an element
	  	this.cssIds = 'cssIds' in options ? options.cssIds : ( this.parent ? this.parent.cssIds : null );

	  	this.resolvers = [];

	  	this.dirty = false;
	  	this.dirtyArgs = this.dirtyValue = true; // TODO getArgsList is nonsense - should deprecate legacy directives style

	  	this.template = options.template || [];
	  	this.createItems();
	  };

	  Fragment.prototype.bind = function bind$1 ( context ) {
	  	this.context = context;
	  	this.items.forEach( bind );
	  	this.bound = true;

	  	// in rare cases, a forced resolution (or similar) will cause the
	  	// fragment to be dirty before it's even finished binding. In those
	  	// cases we update immediately
	  	if ( this.dirty ) this.update();

	  	return this;
	  };

	  Fragment.prototype.bubble = function bubble () {
	  	this.dirtyArgs = this.dirtyValue = true;

	  	if ( !this.dirty ) {
	  		this.dirty = true;

	  		if ( this.isRoot ) { // TODO encapsulate 'is component root, but not overall root' check?
	  			if ( this.ractive.component ) {
	  				this.ractive.component.bubble();
	  			} else if ( this.bound ) {
	  				runloop.addFragment( this );
	  			}
	  		} else {
	  			this.owner.bubble();
	  		}
	  	}
	  };

	  Fragment.prototype.createItems = function createItems () {
	  	var this$1 = this;

	  		this.items = this.template.map( function ( template, index ) {
	  		return createItem({ parentFragment: this$1, template: template, index: index });
	  	});
	  };

	  Fragment.prototype.detach = function detach () {
	  	var docFrag = createDocumentFragment();
	  	this.items.forEach( function ( item ) { return docFrag.appendChild( item.detach() ); } );
	  	return docFrag;
	  };

	  Fragment.prototype.find = function find ( selector ) {
	  	var this$1 = this;

	  		var len = this.items.length;
	  	var i;

	  	for ( i = 0; i < len; i += 1 ) {
	  		var found = this$1.items[i].find( selector );
	  		if ( found ) return found;
	  	}
	  };

	  Fragment.prototype.findAll = function findAll ( selector, query ) {
	  	var this$1 = this;

	  		if ( this.items ) {
	  		var len = this.items.length;
	  		var i;

	  		for ( i = 0; i < len; i += 1 ) {
	  			var item = this$1.items[i];

	  			if ( item.findAll ) {
	  				item.findAll( selector, query );
	  			}
	  		}
	  	}

	  	return query;
	  };

	  Fragment.prototype.findComponent = function findComponent ( name ) {
	  	var this$1 = this;

	  		var len = this.items.length;
	  	var i;

	  	for ( i = 0; i < len; i += 1 ) {
	  		var found = this$1.items[i].findComponent( name );
	  		if ( found ) return found;
	  	}
	  };

	  Fragment.prototype.findAllComponents = function findAllComponents ( name, query ) {
	  	var this$1 = this;

	  		if ( this.items ) {
	  		var len = this.items.length;
	  		var i;

	  		for ( i = 0; i < len; i += 1 ) {
	  			var item = this$1.items[i];

	  			if ( item.findAllComponents ) {
	  				item.findAllComponents( name, query );
	  			}
	  		}
	  	}

	  	return query;
	  };

	  Fragment.prototype.findContext = function findContext () {
	  	var fragment = this;
	  	while ( !fragment.context ) fragment = fragment.parent;
	  	return fragment.context;
	  };

	  Fragment.prototype.findNextNode = function findNextNode ( item ) {
	  	// search for the next node going forward
	  	var this$1 = this;

	  		for ( var i = item.index + 1; i < this$1.items.length; i++ ) {
	  		if ( !this$1.items[ i ] ) continue;

	  		var node = this$1.items[ i ].firstNode( true );
	  		if ( node ) return node;
	  	}

	  	// if this is the root fragment, and there are no more items,
	  	// it means we're at the end...
	  	if ( this.isRoot ) {
	  		if ( this.ractive.component ) {
	  			return this.ractive.component.parentFragment.findNextNode( this.ractive.component );
	  		}

	  		// TODO possible edge case with other content
	  		// appended to this.ractive.el?
	  		return null;
	  	}

	  	return this.owner.findNextNode( this ); // the argument is in case the parent is a RepeatedFragment
	  };

	  Fragment.prototype.findParentNode = function findParentNode () {
	  	var fragment = this;

	  	do {
	  		if ( fragment.owner.type === ELEMENT ) {
	  			return fragment.owner.node;
	  		}

	  		if ( fragment.isRoot && !fragment.ractive.component ) { // TODO encapsulate check
	  			return fragment.ractive.el;
	  		}

	  		if ( fragment.owner.type === YIELDER ) {
	  			fragment = fragment.owner.containerFragment;
	  		} else {
	  			fragment = fragment.componentParent || fragment.parent; // TODO ugh
	  		}
	  	} while ( fragment );

	  	throw new Error( 'Could not find parent node' ); // TODO link to issue tracker
	  };

	  Fragment.prototype.findRepeatingFragment = function findRepeatingFragment () {
	  	var fragment = this;
	  	// TODO better check than fragment.parent.iterations
	  	while ( fragment.parent && !fragment.isIteration ) {
	  		fragment = fragment.parent || fragment.componentParent;
	  	}

	  	return fragment;
	  };

	  Fragment.prototype.firstNode = function firstNode ( skipParent ) {
	  	var this$1 = this;

	  		var node;
	  	for ( var i = 0; i < this$1.items.length; i++ ) {
	  		node = this$1.items[i].firstNode( true );

	  		if ( node ) {
	  			return node;
	  		}
	  	}

	  	if ( skipParent ) return null;

	  	return this.parent.findNextNode( this.owner );
	  };

	  // TODO ideally, this would be deprecated in favour of an
	  // expression-like approach
	  Fragment.prototype.getArgsList = function getArgsList () {
	  	if ( this.dirtyArgs ) {
	  		var values = {};
	  		var source = processItems( this.items, values, this.ractive._guid );
	  		var parsed = parseJSON( '[' + source + ']', values );

	  		this.argsList = parsed ?
	  			parsed.value :
	  			[ this.toString() ];

	  		this.dirtyArgs = false;
	  	}

	  	return this.argsList;
	  };

	  Fragment.prototype.rebind = function rebind$1 ( context ) {
	  	this.context = context;

	  	this.items.forEach( rebind );
	  };

	  Fragment.prototype.render = function render ( target, occupants ) {
	  	if ( this.rendered ) throw new Error( 'Fragment is already rendered!' );
	  	this.rendered = true;

	  	this.items.forEach( function ( item ) { return item.render( target, occupants ); } );
	  };

	  Fragment.prototype.resetTemplate = function resetTemplate ( template ) {
	  	var wasBound = this.bound;
	  	var wasRendered = this.rendered;

	  	// TODO ensure transitions are disabled globally during reset

	  	if ( wasBound ) {
	  		if ( wasRendered ) this.unrender( true );
	  		this.unbind();
	  	}

	  	this.template = template;
	  	this.createItems();

	  	if ( wasBound ) {
	  		this.bind( this.context );

	  		if ( wasRendered ) {
	  			var parentNode = this.findParentNode();
	  			var anchor = this.parent ? this.parent.findNextNode( this.owner ) : null;

	  			if ( anchor ) {
	  				var docFrag = createDocumentFragment();
	  				this.render( docFrag );
	  				parentNode.insertBefore( docFrag, anchor );
	  			} else {
	  				this.render( parentNode );
	  			}
	  		}
	  	}
	  };

	  Fragment.prototype.resolve = function resolve ( template, callback ) {
	  	if ( !this.context ) {
	  		return this.parent.resolve( template, callback );
	  	}

	  	var resolver = new ReferenceResolver( this, template, callback );
	  	this.resolvers.push( resolver );

	  	return resolver; // so we can e.g. force resolution
	  };

	  Fragment.prototype.toHtml = function toHtml () {
	  	return this.toString();
	  };

	  Fragment.prototype.toString = function toString$1$$ ( escape ) {
	  	return this.items.map( escape ? toEscapedString : toString$1 ).join( '' );
	  };

	  Fragment.prototype.unbind = function unbind$1 () {
	  	this.items.forEach( unbind );
	  	this.bound = false;

	  	return this;
	  };

	  Fragment.prototype.unrender = function unrender$1 ( shouldDestroy ) {
	  	this.items.forEach( shouldDestroy ? unrenderAndDestroy$1 : unrender );
	  	this.rendered = false;
	  };

	  Fragment.prototype.update = function update$1 () {
	  	if ( this.dirty && !this.updating ) {
	  		this.dirty = false;
	  		this.updating = true;
	  		this.items.forEach( update );
	  		this.updating = false;
	  	}
	  };

	  Fragment.prototype.valueOf = function valueOf () {
	  	if ( this.items.length === 1 ) {
	  		return this.items[0].valueOf();
	  	}

	  	if ( this.dirtyValue ) {
	  		var values = {};
	  		var source = processItems( this.items, values, this.ractive._guid );
	  		var parsed = parseJSON( source, values );

	  		this.value = parsed ?
	  			parsed.value :
	  			this.toString();

	  		this.dirtyValue = false;
	  	}

	  	return this.value;
	  };

	  // TODO should resetTemplate be asynchronous? i.e. should it be a case
	  // of outro, update template, intro? I reckon probably not, since that
	  // could be achieved with unrender-resetTemplate-render. Also, it should
	  // conceptually be similar to resetPartial, which couldn't be async

	  function Ractive$resetTemplate ( template ) {
	  	templateConfigurator.init( null, this, { template: template });

	  	var transitionsEnabled = this.transitionsEnabled;
	  	this.transitionsEnabled = false;

	  	// Is this is a component, we need to set the `shouldDestroy`
	  	// flag, otherwise it will assume by default that a parent node
	  	// will be detached, and therefore it doesn't need to bother
	  	// detaching its own nodes
	  	var component = this.component;
	  	if ( component ) component.shouldDestroy = true;
	  	this.unrender();
	  	if ( component ) component.shouldDestroy = false;

	  	// remove existing fragment and create new one
	  	this.fragment.unbind().unrender( true );

	  	this.fragment = new Fragment({
	  		template: this.template,
	  		root: this,
	  		owner: this
	  	});

	  	var docFrag = createDocumentFragment();
	  	this.fragment.bind( this.viewmodel ).render( docFrag );
	  	this.el.insertBefore( docFrag, this.anchor );

	  	this.transitionsEnabled = transitionsEnabled;
	  }

	  var reverse = makeArrayMethod( 'reverse' );

	  function Ractive$set ( keypath, value ) {
	  	var promise = runloop.start( this, true );

	  	// Set multiple keypaths in one go
	  	if ( isObject( keypath ) ) {
	  		var map = keypath;

	  		for ( var k in map ) {
	  			if ( map.hasOwnProperty( k) ) {
	  				set( this, k, map[k] );
	  			}
	  		}
	  	}
	  	// Set a single keypath
	  	else {
	  		set( this, keypath, value );
	  	}

	  	runloop.end();

	  	return promise;
	  }


	  function set ( ractive, keypath, value ) {
	  	if ( typeof value === 'function' ) value = bind$1( value, ractive );

	  	if ( /\*/.test( keypath ) ) {
	  		ractive.viewmodel.findMatches( splitKeypathI( keypath ) ).forEach( function ( model ) {
	  			model.set( value );
	  		});
	  	} else {
	  		var model = ractive.viewmodel.joinAll( splitKeypathI( keypath ) );
	  		model.set( value );
	  	}
	  }

	  var shift = makeArrayMethod( 'shift' );

	  var sort = makeArrayMethod( 'sort' );

	  var splice = makeArrayMethod( 'splice' );

	  function Ractive$subtract ( keypath, d ) {
	  	return add( this, keypath, ( d === undefined ? -1 : -d ) );
	  }

	  var teardownHook$1 = new Hook( 'teardown' );

	  // Teardown. This goes through the root fragment and all its children, removing observers
	  // and generally cleaning up after itself

	  function Ractive$teardown () {
	  	var this$1 = this;

	  	this.fragment.unbind();
	  	this.viewmodel.teardown();

	  	this._observers.forEach( cancel );

	  	if ( this.fragment.rendered && this.el.__ractive_instances__ ) {
	  		removeFromArray( this.el.__ractive_instances__, this );
	  	}

	  	this.shouldDestroy = true;
	  	var promise = ( this.fragment.rendered ? this.unrender() : Promise$1.resolve() );

	  	Object.keys( this._links ).forEach( function ( k ) { return this$1._links[k].unlink(); } );

	  	teardownHook$1.fire( this );

	  	return promise;
	  }

	  function Ractive$toggle ( keypath ) {
	  	if ( typeof keypath !== 'string' ) {
	  		throw new TypeError( badArguments );
	  	}

	  	var changes;

	  	if ( /\*/.test( keypath ) ) {
	  		changes = {};

	  		this.viewmodel.findMatches( splitKeypathI( keypath ) ).forEach( function ( model ) {
	  			changes[ model.getKeypath() ] = !model.get();
	  		});

	  		return this.set( changes );
	  	}

	  	return this.set( keypath, !this.get( keypath ) );
	  }

	  function Ractive$toCSS() {
	  	var cssIds = [ this.cssId ].concat( this.findAllComponents().map( function ( c ) { return c.cssId; } ) );
	  	var uniqueCssIds = Object.keys(cssIds.reduce( function ( ids, id ) { return (ids[id] = true, ids); }, {}));
	  	return getCSS( uniqueCssIds );
	  }

	  function Ractive$toHTML () {
	  	return this.fragment.toString( true );
	  }

	  function Ractive$transition ( name, node, params ) {

	  	if ( node instanceof HTMLElement ) {
	  		// good to go
	  	}
	  	else if ( isObject( node ) ) {
	  		// omitted, use event node
	  		params = node;
	  	}

	  	// if we allow query selector, then it won't work
	  	// simple params like "fast"

	  	// else if ( typeof node === 'string' ) {
	  	// 	// query selector
	  	// 	node = this.find( node )
	  	// }

	  	node = node || this.event.node;

	  	if ( !node ) {
	  		fatal( ("No node was supplied for transition " + name) );
	  	}

	  	var transition = new Transition( this, node, name, params );
	  	var promise = runloop.start( this, true );
	  	runloop.registerTransition( transition );
	  	runloop.end();
	  	return promise;
	  }

	  function unlink( here ) {
	  	var ln = this._links[ here ];

	  	if ( ln ) {
	  		ln.unlink();
	  		delete this._links[ here ];
	  		return this.set( here, ln.intialValue );
	  	} else {
	  		return Promise$1.resolve( true );
	  	}
	  }

	  var unrenderHook$1 = new Hook( 'unrender' );

	  function Ractive$unrender () {
	  	if ( !this.fragment.rendered ) {
	  		warnIfDebug( 'ractive.unrender() was called on a Ractive instance that was not rendered' );
	  		return Promise$1.resolve();
	  	}

	  	var promise = runloop.start( this, true );

	  	// If this is a component, and the component isn't marked for destruction,
	  	// don't detach nodes from the DOM unnecessarily
	  	var shouldDestroy = !this.component || this.component.shouldDestroy || this.shouldDestroy;
	  	this.fragment.unrender( shouldDestroy );

	  	removeFromArray( this.el.__ractive_instances__, this );

	  	unrenderHook$1.fire( this );

	  	runloop.end();
	  	return promise;
	  }

	  var unshift = makeArrayMethod( 'unshift' );

	  var updateHook = new Hook( 'update' );

	  function Ractive$update ( keypath ) {
	  	if ( keypath ) keypath = splitKeypathI( keypath );

	  	var model = keypath ?
	  		this.viewmodel.joinAll( keypath ) :
	  		this.viewmodel;

	  	if ( model.parent && model.parent.wrapper ) return this.update( model.parent.getKeypath( this ) );

	  	var promise = runloop.start( this, true );

	  	model.mark();
	  	model.registerChange( model.getKeypath(), model.get() );

	  	if ( keypath ) {
	  		// there may be unresolved refs that are now resolvable up the context tree
	  		var parent = model.parent;
	  		while ( keypath.length && parent ) {
	  			if ( parent.clearUnresolveds ) parent.clearUnresolveds( keypath.pop() );
	  			parent = parent.parent;
	  		}
	  	}

	  	// notify upstream of changes
	  	model.notifyUpstream();

	  	runloop.end();

	  	updateHook.fire( this, model );

	  	return promise;
	  }

	  function Ractive$updateModel ( keypath, cascade ) {
	  	var promise = runloop.start( this, true );

	  	if ( !keypath ) {
	  		this.viewmodel.updateFromBindings( true );
	  	} else {
	  		this.viewmodel.joinAll( splitKeypathI( keypath ) ).updateFromBindings( cascade !== false );
	  	}

	  	runloop.end();

	  	return promise;
	  }

	  var proto = {
	  	add: Ractive$add,
	  	animate: Ractive$animate,
	  	detach: Ractive$detach,
	  	find: Ractive$find,
	  	findAll: Ractive$findAll,
	  	findAllComponents: Ractive$findAllComponents,
	  	findComponent: Ractive$findComponent,
	  	findContainer: Ractive$findContainer,
	  	findParent: Ractive$findParent,
	  	fire: Ractive$fire,
	  	get: Ractive$get,
	  	insert: Ractive$insert,
	  	link: link,
	  	merge: Ractive$merge,
	  	observe: observe,
	  	observeList: observeList,
	  	observeOnce: observeOnce,
	  	// TODO reinstate these
	  	// observeListOnce,
	  	off: Ractive$off,
	  	on: Ractive$on,
	  	once: Ractive$once,
	  	pop: pop,
	  	push: push,
	  	render: Ractive$render,
	  	reset: Ractive$reset,
	  	resetPartial: resetPartial,
	  	resetTemplate: Ractive$resetTemplate,
	  	reverse: reverse,
	  	set: Ractive$set,
	  	shift: shift,
	  	sort: sort,
	  	splice: splice,
	  	subtract: Ractive$subtract,
	  	teardown: Ractive$teardown,
	  	toggle: Ractive$toggle,
	  	toCSS: Ractive$toCSS,
	  	toCss: Ractive$toCSS,
	  	toHTML: Ractive$toHTML,
	  	toHtml: Ractive$toHTML,
	  	transition: Ractive$transition,
	  	unlink: unlink,
	  	unrender: Ractive$unrender,
	  	unshift: unshift,
	  	update: Ractive$update,
	  	updateModel: Ractive$updateModel
	  };

	  function wrap$1 ( method, superMethod, force ) {

	  	if ( force || needsSuper( method, superMethod ) )  {

	  		return function () {

	  			var hasSuper = ( '_super' in this ), _super = this._super, result;

	  			this._super = superMethod;

	  			result = method.apply( this, arguments );

	  			if ( hasSuper ) {
	  				this._super = _super;
	  			}

	  			return result;
	  		};
	  	}

	  	else {
	  		return method;
	  	}
	  }

	  function needsSuper ( method, superMethod ) {
	  	return typeof superMethod === 'function' && /_super/.test( method );
	  }

	  function unwrap ( Child ) {
	  	var options = {};

	  	while ( Child ) {
	  		addRegistries( Child, options );
	  		addOtherOptions( Child, options );

	  		if ( Child._Parent !== Ractive ) {
	  			Child = Child._Parent;
	  		} else {
	  			Child = false;
	  		}
	  	}

	  	return options;
	  }

	  function addRegistries ( Child, options ) {
	  	registries.forEach( function ( r ) {
	  		addRegistry(
	  			r.useDefaults ? Child.prototype : Child,
	  			options, r.name );
	  	});
	  }

	  function addRegistry ( target, options, name ) {
	  	var registry, keys = Object.keys( target[ name ] );

	  	if ( !keys.length ) { return; }

	  	if ( !( registry = options[ name ] ) ) {
	  		registry = options[ name ] = {};
	  	}

	  	keys
	  		.filter( function ( key ) { return !( key in registry ); } )
	  		.forEach( function ( key ) { return registry[ key ] = target[ name ][ key ]; } );
	  }

	  function addOtherOptions ( Child, options ) {
	  	Object.keys( Child.prototype ).forEach( function ( key ) {
	  		if ( key === 'computed' ) { return; }

	  		var value = Child.prototype[ key ];

	  		if ( !( key in options ) ) {
	  			options[ key ] = value._method ? value._method : value;
	  		}

	  		// is it a wrapped function?
	  		else if ( typeof options[ key ] === 'function'
	  				&& typeof value === 'function'
	  				&& options[ key ]._method ) {

	  			var result, needsSuper = value._method;

	  			if ( needsSuper ) { value = value._method; }

	  			// rewrap bound directly to parent fn
	  			result = wrap$1( options[ key ]._method, value );

	  			if ( needsSuper ) { result._method = result; }

	  			options[ key ] = result;
	  		}
	  	});
	  }

	  function extend () {
	  	var options = [], len = arguments.length;
	  	while ( len-- ) options[ len ] = arguments[ len ];

	  	if( !options.length ) {
	  		return extendOne( this );
	  	} else {
	  		return options.reduce( extendOne, this );
	  	}
	  }

	  function extendOne ( Parent, options ) {
	  	if ( options === void 0 ) options = {};

	  	var Child, proto;

	  	// if we're extending with another Ractive instance...
	  	//
	  	//   var Human = Ractive.extend(...), Spider = Ractive.extend(...);
	  	//   var Spiderman = Human.extend( Spider );
	  	//
	  	// ...inherit prototype methods and default options as well
	  	if ( options.prototype instanceof Ractive ) {
	  		options = unwrap( options );
	  	}

	  	Child = function ( options ) {
	  		if ( !( this instanceof Child ) ) return new Child( options );

	  		construct( this, options || {} );
	  		initialise( this, options || {}, {} );
	  	};

	  	proto = create( Parent.prototype );
	  	proto.constructor = Child;

	  	// Static properties
	  	defineProperties( Child, {
	  		// alias prototype as defaults
	  		defaults: { value: proto },

	  		// extendable
	  		extend: { value: extend, writable: true, configurable: true },

	  		// Parent - for IE8, can't use Object.getPrototypeOf
	  		_Parent: { value: Parent }
	  	});

	  	// extend configuration
	  	config.extend( Parent, proto, options );

	  	dataConfigurator.extend( Parent, proto, options );

	  	if ( options.computed ) {
	  		proto.computed = extendObj( create( Parent.prototype.computed ), options.computed );
	  	}

	  	Child.prototype = proto;

	  	return Child;
	  }

	  function getNodeInfo( node ) {
	  	if ( !node || !node._ractive ) return {};

	  	var storage = node._ractive;
	  	var ractive = storage.fragment.ractive;
	  	var ref = gatherRefs( storage.fragment ), key = ref.key, index = ref.index;
	  	var context = storage.fragment.findContext();

	  	return {
	  		ractive: ractive,
	  		keypath: context.getKeypath( ractive ),
	  		rootpath: context.getKeypath(),
	  		index: index,
	  		key: key
	  	};
	  }

	  function joinKeys () {
	  	var keys = [], len = arguments.length;
	  	while ( len-- ) keys[ len ] = arguments[ len ];

	  	return keys.map( escapeKey ).join( '.' );
	  }

	  function splitKeypath ( keypath ) {
	  	return splitKeypathI( keypath ).map( unescapeKey );
	  }

	  // Ractive.js makes liberal use of things like Array.prototype.indexOf. In
	  // older browsers, these are made available via a shim - here, we do a quick
	  // pre-flight check to make sure that either a) we're not in a shit browser,
	  // or b) we're using a Ractive-legacy.js build
	  var FUNCTION = 'function';

	  if (
	  	typeof Date.now !== FUNCTION                 ||
	  	typeof String.prototype.trim !== FUNCTION    ||
	  	typeof Object.keys !== FUNCTION              ||
	  	typeof Array.prototype.indexOf !== FUNCTION  ||
	  	typeof Array.prototype.forEach !== FUNCTION  ||
	  	typeof Array.prototype.map !== FUNCTION      ||
	  	typeof Array.prototype.filter !== FUNCTION   ||
	  	( win && typeof win.addEventListener !== FUNCTION )
	  ) {
	  	throw new Error( 'It looks like you\'re attempting to use Ractive.js in an older browser. You\'ll need to use one of the \'legacy builds\' in order to continue - see http://docs.ractivejs.org/latest/legacy-builds for more information.' );
	  }

	  function Ractive ( options ) {
	  	if ( !( this instanceof Ractive ) ) return new Ractive( options );

	  	construct( this, options || {} );
	  	initialise( this, options || {}, {} );
	  }

	  extendObj( Ractive.prototype, proto, defaults );
	  Ractive.prototype.constructor = Ractive;

	  // alias prototype as `defaults`
	  Ractive.defaults = Ractive.prototype;

	  // static properties
	  defineProperties( Ractive, {

	  	// debug flag
	  	DEBUG:          { writable: true, value: true },
	  	DEBUG_PROMISES: { writable: true, value: true },

	  	// static methods:
	  	extend:         { value: extend },
	  	escapeKey:      { value: escapeKey },
	  	getNodeInfo:    { value: getNodeInfo },
	  	joinKeys:       { value: joinKeys },
	  	parse:          { value: parse },
	  	splitKeypath:   { value: splitKeypath },
	  	unescapeKey:    { value: unescapeKey },
	  	getCSS:         { value: getCSS },

	  	// namespaced constructors
	  	Promise:        { value: Promise$1 },

	  	// support
	  	enhance:        { writable: true, value: false },
	  	svg:            { value: svg },
	  	magic:          { value: magicSupported },

	  	// version
	  	VERSION:        { value: '0.8.0-edge' },

	  	// plugins
	  	adaptors:       { writable: true, value: {} },
	  	components:     { writable: true, value: {} },
	  	decorators:     { writable: true, value: {} },
	  	easing:         { writable: true, value: easing },
	  	events:         { writable: true, value: {} },
	  	interpolators:  { writable: true, value: interpolators },
	  	partials:       { writable: true, value: {} },
	  	transitions:    { writable: true, value: {} }
	  });

	  return Ractive;

	}));
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 1 */
/***/ function(module, exports) {

	var on = {
	    client: !!(typeof window !== "undefined" && window.document),
	    server: !(typeof window !== "undefined" && window.document)
	};

	module.exports = on;


/***/ },
/* 2 */
/***/ function(module, exports) {

	var g;

	// This works in non-strict mode
	g = (function() { return this; })();

	try {
		// This works if eval is allowed (see CSP)
		g = g || Function("return this")() || (1,eval)("this");
	} catch(e) {
		// This works if the window reference is available
		if(typeof window === "object")
			g = window;
	}

	// g can still be undefined, but nothing to do about it...
	// We return undefined, instead of nothing here, so it's
	// easier to handle this case. if(!global) { ...}

	module.exports = g;


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _ = __webpack_require__(5);
	var cls = __webpack_require__(18);
	var defaultSettings = __webpack_require__(134);
	var dom = __webpack_require__(10);
	var EventManager = __webpack_require__(131);
	var guid = __webpack_require__(132);

	var instances = {};

	function Instance(element) {
	  var i = this;

	  i.settings = _.clone(defaultSettings);
	  i.containerWidth = null;
	  i.containerHeight = null;
	  i.contentWidth = null;
	  i.contentHeight = null;

	  i.isRtl = dom.css(element, 'direction') === "rtl";
	  i.isNegativeScroll = (function () {
	    var originalScrollLeft = element.scrollLeft;
	    var result = null;
	    element.scrollLeft = -1;
	    result = element.scrollLeft < 0;
	    element.scrollLeft = originalScrollLeft;
	    return result;
	  })();
	  i.negativeScrollAdjustment = i.isNegativeScroll ? element.scrollWidth - element.clientWidth : 0;
	  i.event = new EventManager();
	  i.ownerDocument = element.ownerDocument || document;

	  function focus() {
	    cls.add(element, 'ps-focus');
	  }

	  function blur() {
	    cls.remove(element, 'ps-focus');
	  }

	  i.scrollbarXRail = dom.appendTo(dom.e('div', 'ps-scrollbar-x-rail'), element);
	  i.scrollbarX = dom.appendTo(dom.e('div', 'ps-scrollbar-x'), i.scrollbarXRail);
	  i.scrollbarX.setAttribute('tabindex', 0);
	  i.event.bind(i.scrollbarX, 'focus', focus);
	  i.event.bind(i.scrollbarX, 'blur', blur);
	  i.scrollbarXActive = null;
	  i.scrollbarXWidth = null;
	  i.scrollbarXLeft = null;
	  i.scrollbarXBottom = _.toInt(dom.css(i.scrollbarXRail, 'bottom'));
	  i.isScrollbarXUsingBottom = i.scrollbarXBottom === i.scrollbarXBottom; // !isNaN
	  i.scrollbarXTop = i.isScrollbarXUsingBottom ? null : _.toInt(dom.css(i.scrollbarXRail, 'top'));
	  i.railBorderXWidth = _.toInt(dom.css(i.scrollbarXRail, 'borderLeftWidth')) + _.toInt(dom.css(i.scrollbarXRail, 'borderRightWidth'));
	  // Set rail to display:block to calculate margins
	  dom.css(i.scrollbarXRail, 'display', 'block');
	  i.railXMarginWidth = _.toInt(dom.css(i.scrollbarXRail, 'marginLeft')) + _.toInt(dom.css(i.scrollbarXRail, 'marginRight'));
	  dom.css(i.scrollbarXRail, 'display', '');
	  i.railXWidth = null;
	  i.railXRatio = null;

	  i.scrollbarYRail = dom.appendTo(dom.e('div', 'ps-scrollbar-y-rail'), element);
	  i.scrollbarY = dom.appendTo(dom.e('div', 'ps-scrollbar-y'), i.scrollbarYRail);
	  i.scrollbarY.setAttribute('tabindex', 0);
	  i.event.bind(i.scrollbarY, 'focus', focus);
	  i.event.bind(i.scrollbarY, 'blur', blur);
	  i.scrollbarYActive = null;
	  i.scrollbarYHeight = null;
	  i.scrollbarYTop = null;
	  i.scrollbarYRight = _.toInt(dom.css(i.scrollbarYRail, 'right'));
	  i.isScrollbarYUsingRight = i.scrollbarYRight === i.scrollbarYRight; // !isNaN
	  i.scrollbarYLeft = i.isScrollbarYUsingRight ? null : _.toInt(dom.css(i.scrollbarYRail, 'left'));
	  i.scrollbarYOuterWidth = i.isRtl ? _.outerWidth(i.scrollbarY) : null;
	  i.railBorderYWidth = _.toInt(dom.css(i.scrollbarYRail, 'borderTopWidth')) + _.toInt(dom.css(i.scrollbarYRail, 'borderBottomWidth'));
	  dom.css(i.scrollbarYRail, 'display', 'block');
	  i.railYMarginHeight = _.toInt(dom.css(i.scrollbarYRail, 'marginTop')) + _.toInt(dom.css(i.scrollbarYRail, 'marginBottom'));
	  dom.css(i.scrollbarYRail, 'display', '');
	  i.railYHeight = null;
	  i.railYRatio = null;
	}

	function getId(element) {
	  return element.getAttribute('data-ps-id');
	}

	function setId(element, id) {
	  element.setAttribute('data-ps-id', id);
	}

	function removeId(element) {
	  element.removeAttribute('data-ps-id');
	}

	exports.add = function (element) {
	  var newId = guid();
	  setId(element, newId);
	  instances[newId] = new Instance(element);
	  return instances[newId];
	};

	exports.remove = function (element) {
	  delete instances[getId(element)];
	  removeId(element);
	};

	exports.get = function (element) {
	  return instances[getId(element)];
	};


/***/ },
/* 4 */
/***/ function(module, exports) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/

	(function (root, factory) {

	    if (typeof module === 'object' && module.exports) {

	        module.exports = factory();

	    } else {

	        root.U = factory();
	    }

	}(this, function () {

	    return {
	        extend: function (subO, superO, staticM) {
	            function object(obj) { function F() {} F.prototype = obj; return new F(); }
	            var prototype = object(superO.prototype);
	            prototype.constructor = subO;
	            subO.prototype = prototype;
	            if (staticM) { for (var i in superO) { subO[i] = superO[i]; }}
	        },

	        viewportWidth: function () {

	            return document.documentElement.clientWidth > window.innerWidth || navigator.userAgent.match(/Mobi/) ? window.innerWidth : document.documentElement.clientWidth;
	        },

	        viewportHeight: function () {

	            return document.documentElement.clientHeight > window.innerHeight || navigator.userAgent.match(/Mobi/) ? window.innerHeight : document.documentElement.clientHeight;
	        },

	        offset: function (elem) {

	            var rect = elem.getBoundingClientRect();

	            return {
	                top:  rect.top  + (window.pageYOffset || document.documentElement.scrollTop)  - (document.documentElement.clientTop  || 0),
	                left: rect.left + (window.pageXOffset || document.documentElement.scrollLeft) - (document.documentElement.clientLeft || 0)
	            };
	        },

	        eventData: function (event) {

	            var source = event;

	            event = event.original || event.originalEvent || event;

	            var isTouchEvent = !!event.touches,

	                hasOffset = event.offsetX !== undefined,
	                offset = hasOffset || this.offset(event.target),

	                offsetX = hasOffset ? event.offsetX : (isTouchEvent ? event.touches[0].pageX : event.pageX) - offset.left,
	                offsetY = hasOffset ? event.offsetY : (isTouchEvent ? event.touches[0].pageY : event.pageY) - offset.top,

	                clientX = isTouchEvent ? event.touches[0].clientX : event.clientX,
	                clientY = isTouchEvent ? event.touches[0].clientY : event.clientY,

	                pageX = isTouchEvent ? event.touches[0].pageX : event.pageX,
	                pageY = isTouchEvent ? event.touches[0].pageY : event.pageY;

	            return {
	                type          : event.type,
	                isTouchEvent  : isTouchEvent,

	                pointers      : isTouchEvent ? event.touches.length : 1,

	                target        : event.target,

	                offsetX       : offsetX,
	                offsetY       : offsetY,
	                clientX       : clientX,
	                clientY       : clientY,
	                pageX         : pageX,
	                pageY         : pageY,

	                preventDefault: function () {
	                    event.preventDefault();
	                },
	                stopPropagation: function () {
	                    event.stopPropagation();
	                },

	                event         : event,
	                source        : source
	            };
	        }
	    };
	}));



/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var cls = __webpack_require__(18);
	var dom = __webpack_require__(10);

	var toInt = exports.toInt = function (x) {
	  return parseInt(x, 10) || 0;
	};

	var clone = exports.clone = function (obj) {
	  if (obj === null) {
	    return null;
	  } else if (obj.constructor === Array) {
	    return obj.map(clone);
	  } else if (typeof obj === 'object') {
	    var result = {};
	    for (var key in obj) {
	      result[key] = clone(obj[key]);
	    }
	    return result;
	  } else {
	    return obj;
	  }
	};

	exports.extend = function (original, source) {
	  var result = clone(original);
	  for (var key in source) {
	    result[key] = clone(source[key]);
	  }
	  return result;
	};

	exports.isEditable = function (el) {
	  return dom.matches(el, "input,[contenteditable]") ||
	         dom.matches(el, "select,[contenteditable]") ||
	         dom.matches(el, "textarea,[contenteditable]") ||
	         dom.matches(el, "button,[contenteditable]");
	};

	exports.removePsClasses = function (element) {
	  var clsList = cls.list(element);
	  for (var i = 0; i < clsList.length; i++) {
	    var className = clsList[i];
	    if (className.indexOf('ps-') === 0) {
	      cls.remove(element, className);
	    }
	  }
	};

	exports.outerWidth = function (element) {
	  return toInt(dom.css(element, 'width')) +
	         toInt(dom.css(element, 'paddingLeft')) +
	         toInt(dom.css(element, 'paddingRight')) +
	         toInt(dom.css(element, 'borderLeftWidth')) +
	         toInt(dom.css(element, 'borderRightWidth'));
	};

	exports.startScrolling = function (element, axis) {
	  cls.add(element, 'ps-in-scrolling');
	  if (typeof axis !== 'undefined') {
	    cls.add(element, 'ps-' + axis);
	  } else {
	    cls.add(element, 'ps-x');
	    cls.add(element, 'ps-y');
	  }
	};

	exports.stopScrolling = function (element, axis) {
	  cls.remove(element, 'ps-in-scrolling');
	  if (typeof axis !== 'undefined') {
	    cls.remove(element, 'ps-' + axis);
	  } else {
	    cls.remove(element, 'ps-x');
	    cls.remove(element, 'ps-y');
	  }
	};

	exports.env = {
	  isWebKit: 'WebkitAppearance' in document.documentElement.style,
	  supportsTouch: (('ontouchstart' in window) || window.DocumentTouch && document instanceof window.DocumentTouch),
	  supportsIePointer: window.navigator.msMaxTouchPoints !== null
	};


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	/*global $*/

	var on = __webpack_require__(1);

	var EventEmitter = on.client ? $({}) : {};

	module.exports = function () {
	    return EventEmitter;
	};


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {


	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = __webpack_require__(108);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome
	               && 'undefined' != typeof chrome.storage
	                  ? chrome.storage.local
	                  : localstorage();

	/**
	 * Colors.
	 */

	exports.colors = [
	  'lightseagreen',
	  'forestgreen',
	  'goldenrod',
	  'dodgerblue',
	  'darkorchid',
	  'crimson'
	];

	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */

	function useColors() {
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  return ('WebkitAppearance' in document.documentElement.style) ||
	    // is firebug? http://stackoverflow.com/a/398120/376773
	    (window.console && (console.firebug || (console.exception && console.table))) ||
	    // is firefox >= v31?
	    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
	}

	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */

	exports.formatters.j = function(v) {
	  return JSON.stringify(v);
	};


	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */

	function formatArgs() {
	  var args = arguments;
	  var useColors = this.useColors;

	  args[0] = (useColors ? '%c' : '')
	    + this.namespace
	    + (useColors ? ' %c' : ' ')
	    + args[0]
	    + (useColors ? '%c ' : ' ')
	    + '+' + exports.humanize(this.diff);

	  if (!useColors) return args;

	  var c = 'color: ' + this.color;
	  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-z%]/g, function(match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });

	  args.splice(lastC, 0, c);
	  return args;
	}

	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */

	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === typeof console
	    && console.log
	    && Function.prototype.apply.call(console.log, console, arguments);
	}

	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */

	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch(e) {}
	}

	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */

	function load() {
	  var r;
	  try {
	    r = exports.storage.debug;
	  } catch(e) {}
	  return r;
	}

	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */

	exports.enable(load());

	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */

	function localstorage(){
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _ = __webpack_require__(5);
	var cls = __webpack_require__(18);
	var dom = __webpack_require__(10);
	var instances = __webpack_require__(3);
	var updateScroll = __webpack_require__(9);

	function getThumbSize(i, thumbSize) {
	  if (i.settings.minScrollbarLength) {
	    thumbSize = Math.max(thumbSize, i.settings.minScrollbarLength);
	  }
	  if (i.settings.maxScrollbarLength) {
	    thumbSize = Math.min(thumbSize, i.settings.maxScrollbarLength);
	  }
	  return thumbSize;
	}

	function updateCss(element, i) {
	  var xRailOffset = {width: i.railXWidth};
	  if (i.isRtl) {
	    xRailOffset.left = i.negativeScrollAdjustment + element.scrollLeft + i.containerWidth - i.contentWidth;
	  } else {
	    xRailOffset.left = element.scrollLeft;
	  }
	  if (i.isScrollbarXUsingBottom) {
	    xRailOffset.bottom = i.scrollbarXBottom - element.scrollTop;
	  } else {
	    xRailOffset.top = i.scrollbarXTop + element.scrollTop;
	  }
	  dom.css(i.scrollbarXRail, xRailOffset);

	  var yRailOffset = {top: element.scrollTop, height: i.railYHeight};
	  if (i.isScrollbarYUsingRight) {
	    if (i.isRtl) {
	      yRailOffset.right = i.contentWidth - (i.negativeScrollAdjustment + element.scrollLeft) - i.scrollbarYRight - i.scrollbarYOuterWidth;
	    } else {
	      yRailOffset.right = i.scrollbarYRight - element.scrollLeft;
	    }
	  } else {
	    if (i.isRtl) {
	      yRailOffset.left = i.negativeScrollAdjustment + element.scrollLeft + i.containerWidth * 2 - i.contentWidth - i.scrollbarYLeft - i.scrollbarYOuterWidth;
	    } else {
	      yRailOffset.left = i.scrollbarYLeft + element.scrollLeft;
	    }
	  }
	  dom.css(i.scrollbarYRail, yRailOffset);

	  dom.css(i.scrollbarX, {left: i.scrollbarXLeft, width: i.scrollbarXWidth - i.railBorderXWidth});
	  dom.css(i.scrollbarY, {top: i.scrollbarYTop, height: i.scrollbarYHeight - i.railBorderYWidth});
	}

	module.exports = function (element) {
	  var i = instances.get(element);

	  i.containerWidth = element.clientWidth;
	  i.containerHeight = element.clientHeight;
	  i.contentWidth = element.scrollWidth;
	  i.contentHeight = element.scrollHeight;

	  var existingRails;
	  if (!element.contains(i.scrollbarXRail)) {
	    existingRails = dom.queryChildren(element, '.ps-scrollbar-x-rail');
	    if (existingRails.length > 0) {
	      existingRails.forEach(function (rail) {
	        dom.remove(rail);
	      });
	    }
	    dom.appendTo(i.scrollbarXRail, element);
	  }
	  if (!element.contains(i.scrollbarYRail)) {
	    existingRails = dom.queryChildren(element, '.ps-scrollbar-y-rail');
	    if (existingRails.length > 0) {
	      existingRails.forEach(function (rail) {
	        dom.remove(rail);
	      });
	    }
	    dom.appendTo(i.scrollbarYRail, element);
	  }

	  if (!i.settings.suppressScrollX && i.containerWidth + i.settings.scrollXMarginOffset < i.contentWidth) {
	    i.scrollbarXActive = true;
	    i.railXWidth = i.containerWidth - i.railXMarginWidth;
	    i.railXRatio = i.containerWidth / i.railXWidth;
	    i.scrollbarXWidth = getThumbSize(i, _.toInt(i.railXWidth * i.containerWidth / i.contentWidth));
	    i.scrollbarXLeft = _.toInt((i.negativeScrollAdjustment + element.scrollLeft) * (i.railXWidth - i.scrollbarXWidth) / (i.contentWidth - i.containerWidth));
	  } else {
	    i.scrollbarXActive = false;
	  }

	  if (!i.settings.suppressScrollY && i.containerHeight + i.settings.scrollYMarginOffset < i.contentHeight) {
	    i.scrollbarYActive = true;
	    i.railYHeight = i.containerHeight - i.railYMarginHeight;
	    i.railYRatio = i.containerHeight / i.railYHeight;
	    i.scrollbarYHeight = getThumbSize(i, _.toInt(i.railYHeight * i.containerHeight / i.contentHeight));
	    i.scrollbarYTop = _.toInt(element.scrollTop * (i.railYHeight - i.scrollbarYHeight) / (i.contentHeight - i.containerHeight));
	  } else {
	    i.scrollbarYActive = false;
	  }

	  if (i.scrollbarXLeft >= i.railXWidth - i.scrollbarXWidth) {
	    i.scrollbarXLeft = i.railXWidth - i.scrollbarXWidth;
	  }
	  if (i.scrollbarYTop >= i.railYHeight - i.scrollbarYHeight) {
	    i.scrollbarYTop = i.railYHeight - i.scrollbarYHeight;
	  }

	  updateCss(element, i);

	  if (i.scrollbarXActive) {
	    cls.add(element, 'ps-active-x');
	  } else {
	    cls.remove(element, 'ps-active-x');
	    i.scrollbarXWidth = 0;
	    i.scrollbarXLeft = 0;
	    updateScroll(element, 'left', 0);
	  }
	  if (i.scrollbarYActive) {
	    cls.add(element, 'ps-active-y');
	  } else {
	    cls.remove(element, 'ps-active-y');
	    i.scrollbarYHeight = 0;
	    i.scrollbarYTop = 0;
	    updateScroll(element, 'top', 0);
	  }
	};


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var instances = __webpack_require__(3);

	var upEvent = document.createEvent('Event');
	var downEvent = document.createEvent('Event');
	var leftEvent = document.createEvent('Event');
	var rightEvent = document.createEvent('Event');
	var yEvent = document.createEvent('Event');
	var xEvent = document.createEvent('Event');
	var xStartEvent = document.createEvent('Event');
	var xEndEvent = document.createEvent('Event');
	var yStartEvent = document.createEvent('Event');
	var yEndEvent = document.createEvent('Event');
	var lastTop;
	var lastLeft;

	upEvent.initEvent('ps-scroll-up', true, true);
	downEvent.initEvent('ps-scroll-down', true, true);
	leftEvent.initEvent('ps-scroll-left', true, true);
	rightEvent.initEvent('ps-scroll-right', true, true);
	yEvent.initEvent('ps-scroll-y', true, true);
	xEvent.initEvent('ps-scroll-x', true, true);
	xStartEvent.initEvent('ps-x-reach-start', true, true);
	xEndEvent.initEvent('ps-x-reach-end', true, true);
	yStartEvent.initEvent('ps-y-reach-start', true, true);
	yEndEvent.initEvent('ps-y-reach-end', true, true);

	module.exports = function (element, axis, value) {
	  if (typeof element === 'undefined') {
	    throw 'You must provide an element to the update-scroll function';
	  }

	  if (typeof axis === 'undefined') {
	    throw 'You must provide an axis to the update-scroll function';
	  }

	  if (typeof value === 'undefined') {
	    throw 'You must provide a value to the update-scroll function';
	  }

	  if (axis === 'top' && value <= 0) {
	    element.scrollTop = value = 0; // don't allow negative scroll
	    element.dispatchEvent(yStartEvent);
	  }

	  if (axis === 'left' && value <= 0) {
	    element.scrollLeft = value = 0; // don't allow negative scroll
	    element.dispatchEvent(xStartEvent);
	  }

	  var i = instances.get(element);

	  if (axis === 'top' && value >= i.contentHeight - i.containerHeight) {
	    // don't allow scroll past container
	    value = i.contentHeight - i.containerHeight;
	    if (value - element.scrollTop <= 1) {
	      // mitigates rounding errors on non-subpixel scroll values
	      value = element.scrollTop;
	    } else {
	      element.scrollTop = value;
	    }
	    element.dispatchEvent(yEndEvent);
	  }

	  if (axis === 'left' && value >= i.contentWidth - i.containerWidth) {
	    // don't allow scroll past container
	    value = i.contentWidth - i.containerWidth;
	    if (value - element.scrollLeft <= 1) {
	      // mitigates rounding errors on non-subpixel scroll values
	      value = element.scrollLeft;
	    } else {
	      element.scrollLeft = value;
	    }
	    element.dispatchEvent(xEndEvent);
	  }

	  if (!lastTop) {
	    lastTop = element.scrollTop;
	  }

	  if (!lastLeft) {
	    lastLeft = element.scrollLeft;
	  }

	  if (axis === 'top' && value < lastTop) {
	    element.dispatchEvent(upEvent);
	  }

	  if (axis === 'top' && value > lastTop) {
	    element.dispatchEvent(downEvent);
	  }

	  if (axis === 'left' && value < lastLeft) {
	    element.dispatchEvent(leftEvent);
	  }

	  if (axis === 'left' && value > lastLeft) {
	    element.dispatchEvent(rightEvent);
	  }

	  if (axis === 'top') {
	    element.scrollTop = lastTop = value;
	    element.dispatchEvent(yEvent);
	  }

	  if (axis === 'left') {
	    element.scrollLeft = lastLeft = value;
	    element.dispatchEvent(xEvent);
	  }

	};


/***/ },
/* 10 */
/***/ function(module, exports) {

	"use strict";
	'use strict';

	var DOM = {};

	DOM.e = function (tagName, className) {
	  var element = document.createElement(tagName);
	  element.className = className;
	  return element;
	};

	DOM.appendTo = function (child, parent) {
	  parent.appendChild(child);
	  return child;
	};

	function cssGet(element, styleName) {
	  return window.getComputedStyle(element)[styleName];
	}

	function cssSet(element, styleName, styleValue) {
	  if (typeof styleValue === 'number') {
	    styleValue = styleValue.toString() + 'px';
	  }
	  element.style[styleName] = styleValue;
	  return element;
	}

	function cssMultiSet(element, obj) {
	  for (var key in obj) {
	    var val = obj[key];
	    if (typeof val === 'number') {
	      val = val.toString() + 'px';
	    }
	    element.style[key] = val;
	  }
	  return element;
	}

	DOM.css = function (element, styleNameOrObject, styleValue) {
	  if (typeof styleNameOrObject === 'object') {
	    // multiple set with object
	    return cssMultiSet(element, styleNameOrObject);
	  } else {
	    if (typeof styleValue === 'undefined') {
	      return cssGet(element, styleNameOrObject);
	    } else {
	      return cssSet(element, styleNameOrObject, styleValue);
	    }
	  }
	};

	DOM.matches = function (element, query) {
	  if (typeof element.matches !== 'undefined') {
	    return element.matches(query);
	  } else {
	    if (typeof element.matchesSelector !== 'undefined') {
	      return element.matchesSelector(query);
	    } else if (typeof element.webkitMatchesSelector !== 'undefined') {
	      return element.webkitMatchesSelector(query);
	    } else if (typeof element.mozMatchesSelector !== 'undefined') {
	      return element.mozMatchesSelector(query);
	    } else if (typeof element.msMatchesSelector !== 'undefined') {
	      return element.msMatchesSelector(query);
	    }
	  }
	};

	DOM.remove = function (element) {
	  if (typeof element.remove !== 'undefined') {
	    element.remove();
	  } else {
	    if (element.parentNode) {
	      element.parentNode.removeChild(element);
	    }
	  }
	};

	DOM.queryChildren = function (element, selector) {
	  return Array.prototype.filter.call(element.childNodes, function (child) {
	    return DOM.matches(child, selector);
	  });
	};

	module.exports = DOM;


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module dependencies.
	 */

	var keys = __webpack_require__(115);
	var hasBinary = __webpack_require__(116);
	var sliceBuffer = __webpack_require__(104);
	var base64encoder = __webpack_require__(106);
	var after = __webpack_require__(101);
	var utf8 = __webpack_require__(204);

	/**
	 * Check if we are running an android browser. That requires us to use
	 * ArrayBuffer with polling transports...
	 *
	 * http://ghinda.net/jpeg-blob-ajax-android/
	 */

	var isAndroid = navigator.userAgent.match(/Android/i);

	/**
	 * Check if we are running in PhantomJS.
	 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
	 * https://github.com/ariya/phantomjs/issues/11395
	 * @type boolean
	 */
	var isPhantomJS = /PhantomJS/i.test(navigator.userAgent);

	/**
	 * When true, avoids using Blobs to encode payloads.
	 * @type boolean
	 */
	var dontSendBlobs = isAndroid || isPhantomJS;

	/**
	 * Current protocol version.
	 */

	exports.protocol = 3;

	/**
	 * Packet types.
	 */

	var packets = exports.packets = {
	    open:     0    // non-ws
	  , close:    1    // non-ws
	  , ping:     2
	  , pong:     3
	  , message:  4
	  , upgrade:  5
	  , noop:     6
	};

	var packetslist = keys(packets);

	/**
	 * Premade error packet.
	 */

	var err = { type: 'error', data: 'parser error' };

	/**
	 * Create a blob api even for blob builder when vendor prefixes exist
	 */

	var Blob = __webpack_require__(107);

	/**
	 * Encodes a packet.
	 *
	 *     <packet type id> [ <data> ]
	 *
	 * Example:
	 *
	 *     5hello world
	 *     3
	 *     4
	 *
	 * Binary is encoded in an identical principle
	 *
	 * @api private
	 */

	exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
	  if ('function' == typeof supportsBinary) {
	    callback = supportsBinary;
	    supportsBinary = false;
	  }

	  if ('function' == typeof utf8encode) {
	    callback = utf8encode;
	    utf8encode = null;
	  }

	  var data = (packet.data === undefined)
	    ? undefined
	    : packet.data.buffer || packet.data;

	  if (global.ArrayBuffer && data instanceof ArrayBuffer) {
	    return encodeArrayBuffer(packet, supportsBinary, callback);
	  } else if (Blob && data instanceof global.Blob) {
	    return encodeBlob(packet, supportsBinary, callback);
	  }

	  // might be an object with { base64: true, data: dataAsBase64String }
	  if (data && data.base64) {
	    return encodeBase64Object(packet, callback);
	  }

	  // Sending data as a utf-8 string
	  var encoded = packets[packet.type];

	  // data fragment is optional
	  if (undefined !== packet.data) {
	    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
	  }

	  return callback('' + encoded);

	};

	function encodeBase64Object(packet, callback) {
	  // packet data is an object { base64: true, data: dataAsBase64String }
	  var message = 'b' + exports.packets[packet.type] + packet.data.data;
	  return callback(message);
	}

	/**
	 * Encode packet helpers for binary types
	 */

	function encodeArrayBuffer(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }

	  var data = packet.data;
	  var contentArray = new Uint8Array(data);
	  var resultBuffer = new Uint8Array(1 + data.byteLength);

	  resultBuffer[0] = packets[packet.type];
	  for (var i = 0; i < contentArray.length; i++) {
	    resultBuffer[i+1] = contentArray[i];
	  }

	  return callback(resultBuffer.buffer);
	}

	function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }

	  var fr = new FileReader();
	  fr.onload = function() {
	    packet.data = fr.result;
	    exports.encodePacket(packet, supportsBinary, true, callback);
	  };
	  return fr.readAsArrayBuffer(packet.data);
	}

	function encodeBlob(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }

	  if (dontSendBlobs) {
	    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
	  }

	  var length = new Uint8Array(1);
	  length[0] = packets[packet.type];
	  var blob = new Blob([length.buffer, packet.data]);

	  return callback(blob);
	}

	/**
	 * Encodes a packet with binary data in a base64 string
	 *
	 * @param {Object} packet, has `type` and `data`
	 * @return {String} base64 encoded message
	 */

	exports.encodeBase64Packet = function(packet, callback) {
	  var message = 'b' + exports.packets[packet.type];
	  if (Blob && packet.data instanceof global.Blob) {
	    var fr = new FileReader();
	    fr.onload = function() {
	      var b64 = fr.result.split(',')[1];
	      callback(message + b64);
	    };
	    return fr.readAsDataURL(packet.data);
	  }

	  var b64data;
	  try {
	    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
	  } catch (e) {
	    // iPhone Safari doesn't let you apply with typed arrays
	    var typed = new Uint8Array(packet.data);
	    var basic = new Array(typed.length);
	    for (var i = 0; i < typed.length; i++) {
	      basic[i] = typed[i];
	    }
	    b64data = String.fromCharCode.apply(null, basic);
	  }
	  message += global.btoa(b64data);
	  return callback(message);
	};

	/**
	 * Decodes a packet. Changes format to Blob if requested.
	 *
	 * @return {Object} with `type` and `data` (if any)
	 * @api private
	 */

	exports.decodePacket = function (data, binaryType, utf8decode) {
	  // String data
	  if (typeof data == 'string' || data === undefined) {
	    if (data.charAt(0) == 'b') {
	      return exports.decodeBase64Packet(data.substr(1), binaryType);
	    }

	    if (utf8decode) {
	      try {
	        data = utf8.decode(data);
	      } catch (e) {
	        return err;
	      }
	    }
	    var type = data.charAt(0);

	    if (Number(type) != type || !packetslist[type]) {
	      return err;
	    }

	    if (data.length > 1) {
	      return { type: packetslist[type], data: data.substring(1) };
	    } else {
	      return { type: packetslist[type] };
	    }
	  }

	  var asArray = new Uint8Array(data);
	  var type = asArray[0];
	  var rest = sliceBuffer(data, 1);
	  if (Blob && binaryType === 'blob') {
	    rest = new Blob([rest]);
	  }
	  return { type: packetslist[type], data: rest };
	};

	/**
	 * Decodes a packet encoded in a base64 string
	 *
	 * @param {String} base64 encoded message
	 * @return {Object} with `type` and `data` (if any)
	 */

	exports.decodeBase64Packet = function(msg, binaryType) {
	  var type = packetslist[msg.charAt(0)];
	  if (!global.ArrayBuffer) {
	    return { type: type, data: { base64: true, data: msg.substr(1) } };
	  }

	  var data = base64encoder.decode(msg.substr(1));

	  if (binaryType === 'blob' && Blob) {
	    data = new Blob([data]);
	  }

	  return { type: type, data: data };
	};

	/**
	 * Encodes multiple messages (payload).
	 *
	 *     <length>:data
	 *
	 * Example:
	 *
	 *     11:hello world2:hi
	 *
	 * If any contents are binary, they will be encoded as base64 strings. Base64
	 * encoded strings are marked with a b before the length specifier
	 *
	 * @param {Array} packets
	 * @api private
	 */

	exports.encodePayload = function (packets, supportsBinary, callback) {
	  if (typeof supportsBinary == 'function') {
	    callback = supportsBinary;
	    supportsBinary = null;
	  }

	  var isBinary = hasBinary(packets);

	  if (supportsBinary && isBinary) {
	    if (Blob && !dontSendBlobs) {
	      return exports.encodePayloadAsBlob(packets, callback);
	    }

	    return exports.encodePayloadAsArrayBuffer(packets, callback);
	  }

	  if (!packets.length) {
	    return callback('0:');
	  }

	  function setLengthHeader(message) {
	    return message.length + ':' + message;
	  }

	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {
	      doneCallback(null, setLengthHeader(message));
	    });
	  }

	  map(packets, encodeOne, function(err, results) {
	    return callback(results.join(''));
	  });
	};

	/**
	 * Async array map using after
	 */

	function map(ary, each, done) {
	  var result = new Array(ary.length);
	  var next = after(ary.length, done);

	  var eachWithIndex = function(i, el, cb) {
	    each(el, function(error, msg) {
	      result[i] = msg;
	      cb(error, result);
	    });
	  };

	  for (var i = 0; i < ary.length; i++) {
	    eachWithIndex(i, ary[i], next);
	  }
	}

	/*
	 * Decodes data when a payload is maybe expected. Possible binary contents are
	 * decoded from their base64 representation
	 *
	 * @param {String} data, callback method
	 * @api public
	 */

	exports.decodePayload = function (data, binaryType, callback) {
	  if (typeof data != 'string') {
	    return exports.decodePayloadAsBinary(data, binaryType, callback);
	  }

	  if (typeof binaryType === 'function') {
	    callback = binaryType;
	    binaryType = null;
	  }

	  var packet;
	  if (data == '') {
	    // parser error - ignoring payload
	    return callback(err, 0, 1);
	  }

	  var length = ''
	    , n, msg;

	  for (var i = 0, l = data.length; i < l; i++) {
	    var chr = data.charAt(i);

	    if (':' != chr) {
	      length += chr;
	    } else {
	      if ('' == length || (length != (n = Number(length)))) {
	        // parser error - ignoring payload
	        return callback(err, 0, 1);
	      }

	      msg = data.substr(i + 1, n);

	      if (length != msg.length) {
	        // parser error - ignoring payload
	        return callback(err, 0, 1);
	      }

	      if (msg.length) {
	        packet = exports.decodePacket(msg, binaryType, true);

	        if (err.type == packet.type && err.data == packet.data) {
	          // parser error in individual packet - ignoring payload
	          return callback(err, 0, 1);
	        }

	        var ret = callback(packet, i + n, l);
	        if (false === ret) return;
	      }

	      // advance cursor
	      i += n;
	      length = '';
	    }
	  }

	  if (length != '') {
	    // parser error - ignoring payload
	    return callback(err, 0, 1);
	  }

	};

	/**
	 * Encodes multiple messages (payload) as binary.
	 *
	 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
	 * 255><data>
	 *
	 * Example:
	 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
	 *
	 * @param {Array} packets
	 * @return {ArrayBuffer} encoded payload
	 * @api private
	 */

	exports.encodePayloadAsArrayBuffer = function(packets, callback) {
	  if (!packets.length) {
	    return callback(new ArrayBuffer(0));
	  }

	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, true, true, function(data) {
	      return doneCallback(null, data);
	    });
	  }

	  map(packets, encodeOne, function(err, encodedPackets) {
	    var totalLength = encodedPackets.reduce(function(acc, p) {
	      var len;
	      if (typeof p === 'string'){
	        len = p.length;
	      } else {
	        len = p.byteLength;
	      }
	      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
	    }, 0);

	    var resultArray = new Uint8Array(totalLength);

	    var bufferIndex = 0;
	    encodedPackets.forEach(function(p) {
	      var isString = typeof p === 'string';
	      var ab = p;
	      if (isString) {
	        var view = new Uint8Array(p.length);
	        for (var i = 0; i < p.length; i++) {
	          view[i] = p.charCodeAt(i);
	        }
	        ab = view.buffer;
	      }

	      if (isString) { // not true binary
	        resultArray[bufferIndex++] = 0;
	      } else { // true binary
	        resultArray[bufferIndex++] = 1;
	      }

	      var lenStr = ab.byteLength.toString();
	      for (var i = 0; i < lenStr.length; i++) {
	        resultArray[bufferIndex++] = parseInt(lenStr[i]);
	      }
	      resultArray[bufferIndex++] = 255;

	      var view = new Uint8Array(ab);
	      for (var i = 0; i < view.length; i++) {
	        resultArray[bufferIndex++] = view[i];
	      }
	    });

	    return callback(resultArray.buffer);
	  });
	};

	/**
	 * Encode as Blob
	 */

	exports.encodePayloadAsBlob = function(packets, callback) {
	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, true, true, function(encoded) {
	      var binaryIdentifier = new Uint8Array(1);
	      binaryIdentifier[0] = 1;
	      if (typeof encoded === 'string') {
	        var view = new Uint8Array(encoded.length);
	        for (var i = 0; i < encoded.length; i++) {
	          view[i] = encoded.charCodeAt(i);
	        }
	        encoded = view.buffer;
	        binaryIdentifier[0] = 0;
	      }

	      var len = (encoded instanceof ArrayBuffer)
	        ? encoded.byteLength
	        : encoded.size;

	      var lenStr = len.toString();
	      var lengthAry = new Uint8Array(lenStr.length + 1);
	      for (var i = 0; i < lenStr.length; i++) {
	        lengthAry[i] = parseInt(lenStr[i]);
	      }
	      lengthAry[lenStr.length] = 255;

	      if (Blob) {
	        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
	        doneCallback(null, blob);
	      }
	    });
	  }

	  map(packets, encodeOne, function(err, results) {
	    return callback(new Blob(results));
	  });
	};

	/*
	 * Decodes data when a payload is maybe expected. Strings are decoded by
	 * interpreting each byte as a key code for entries marked to start with 0. See
	 * description of encodePayloadAsBinary
	 *
	 * @param {ArrayBuffer} data, callback method
	 * @api public
	 */

	exports.decodePayloadAsBinary = function (data, binaryType, callback) {
	  if (typeof binaryType === 'function') {
	    callback = binaryType;
	    binaryType = null;
	  }

	  var bufferTail = data;
	  var buffers = [];

	  var numberTooLong = false;
	  while (bufferTail.byteLength > 0) {
	    var tailArray = new Uint8Array(bufferTail);
	    var isString = tailArray[0] === 0;
	    var msgLength = '';

	    for (var i = 1; ; i++) {
	      if (tailArray[i] == 255) break;

	      if (msgLength.length > 310) {
	        numberTooLong = true;
	        break;
	      }

	      msgLength += tailArray[i];
	    }

	    if(numberTooLong) return callback(err, 0, 1);

	    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
	    msgLength = parseInt(msgLength);

	    var msg = sliceBuffer(bufferTail, 0, msgLength);
	    if (isString) {
	      try {
	        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
	      } catch (e) {
	        // iPhone Safari doesn't let you apply to typed arrays
	        var typed = new Uint8Array(msg);
	        msg = '';
	        for (var i = 0; i < typed.length; i++) {
	          msg += String.fromCharCode(typed[i]);
	        }
	      }
	    }

	    buffers.push(msg);
	    bufferTail = sliceBuffer(bufferTail, msgLength);
	  }

	  var total = buffers.length;
	  buffers.forEach(function(buffer, i) {
	    callback(exports.decodePacket(buffer, binaryType, true), i, total);
	  });
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	/*global $, MutationObserver*/
	(function (root, factory) {

	    if (typeof module === 'object' && module.exports) {

	        var Ractive = __webpack_require__(0),

	            U = __webpack_require__(4),
	            on = __webpack_require__(1);

	        module.exports = factory(
	            Ractive,
	            U,
	            __webpack_require__(172),
	            on
	        );

	    } else {

	        root.PageSectionSettings = factory(
	            root.Ractive,
	            root.U,
	            "",
	            {client: true}
	        );
	    }

	}(this, function (Ractive, U, template, on) {

	    var instanceCounter = 0;

	    /*
	     * Komponent nastavení sekce. Komponent by měl obsahovat konkrétní komponenty (jako "partial" - "content")
	     * s nastavením. Tyto komponenty se registrují zde (a nachází se ve složce "/Types").
	     *
	     * Komponenty uvnitř "PageSectionSettings" by měli být element s dekorátorem "PageSectionSettingsBox",
	     * který zajistí správné zvětšovaní/zmenšování nastavení a přidá posuvníky.
	     */

	    return Ractive.extend({

	        template: template,

	        CLASS: {
	            self: "E_PageSectionSettings",
	            multipleTabs: "E_PageSectionSettings__multiple-tabs",

	            wrapper: "E_PageSectionSettings--wrapper",
	            scrollingContent: "E_PageSectionSettings--scrolling-content",
	            scrollingContentHideOverlay: "E_PageSectionSettings--scrolling-content__hide-overlay",

	            resizer: "E_PageSectionSettings--resizer",
	            resizerActive: "E_PageSectionSettings--resizer__active",
	            resizableBox: "E_PageSectionSettings--resizable-box",

	            minmax: "E_PageSectionSettings--min-max",
	            minmaxMax: "E_PageSectionSettings--min-max__max",
	            minmaxMin: "E_PageSectionSettings--min-max__min"
	        },

	        OPTIONS: {
	            SCROLL_EASING: on.client ? $.bez([0.1, 0.4, 0.4, 1]) : "",
	            SCROLL_DURATION: 300
	        },

	        components: {
	            ProgressBar: __webpack_require__(36)
	        },

	        partials: {
	            Text: __webpack_require__(48)
	        },

	        decorators: {
	            ResizableBox: __webpack_require__(23)
	        },

	        data: function () {

	            return {
	            };
	        },

	        superOnconfig: function () {

	            this.EVENT_NS = "PageSectionSettings-" + (++instanceCounter);

	            if (on.client) {

	                Ractive.$win = Ractive.$win || $(window);

	                Ractive.$scrollElement = Ractive.$scrollElement || $("html, body");
	            }

	            this.onresizableboxinit = this.scrollToView;
	            this.onresizableboxend = this.scrollToView;

	            //Počkat až se zavře jiné nastavení ve stejné sekci?
	            this.set("delayOpening", this.parent.get("anotherSettingsOpened"));
	        },

	        superOnrender: function () {

	            if (on.client) {

	                this.self = this.find("." + this.CLASS.self);
	                this.$self = $(this.self);
	            }
	        },

	        superOncomplete: function () {

	            if (on.client) {

	            }
	        },

	        superOnteardown: function () {

	            Ractive.$win.off("." + this.EVENT_NS);
	        },

	        onconfig: function () {
	            this.superOnconfig();
	        },

	        onrender: function () {
	            this.superOnrender();
	        },

	        oncomplete: function () {
	            this.superOncomplete();
	        },

	        onteardown: function () {
	            this.superOnteardown();
	        },

	        scrollToView: function (expectedRect, isMaximized) {

	            var height = (expectedRect && expectedRect.height) || parseFloat(this.$resizableElement.css("height")),
	                prevSettingsHeight = 0,

	                top = this.$self[0].getBoundingClientRect().top,

	                pageSection = !isMaximized && this.getPageSection(),

	                $prevSettings = !isMaximized && this.$self.prevAll("." + this.CLASS.self),
	                $prevSections = pageSection && pageSection.get$SectionElement().prevAll("." + pageSection.CLASS.self),

	                $temp = $([null]);

	            //pokud je otevřeno nastavení v předchozí sekci, pak bude zavřeno,
	            //takže je potřeba jeho výšku odečíst
	            if ($prevSections && $prevSections.length) {

	                var instance = this;

	                $prevSections.each(function () {

	                    $temp[0] = this;

	                    var $settings = $temp.find("." + instance.CLASS.self);

	                    if ($settings.length) {

	                        prevSettingsHeight += parseFloat($settings.css("height"));
	                    }
	                });
	            }

	            //pokud je otevřeno jiné nastavení ve stejné sekci, pak bude zavřeno,
	            //takže je potřeba jeho výšku odečíst
	            if ($prevSettings && $prevSettings.length) {

	                $prevSettings.each(function () {

	                    $temp[0] = this;

	                    prevSettingsHeight += parseFloat($temp.css("height"));
	                });
	            }

	            //pokud by bylo nastavení pod dolním okrajem okna -> seskrolovat dolu
	            if (top + height - prevSettingsHeight > window.innerHeight) {

	                var scrollTop = this.$self.offset().top + (height > window.innerHeight ? window.innerHeight : height) - prevSettingsHeight - window.innerHeight;

	                Ractive.$scrollElement
	                    .stop()
	                    //zdržet, pokud je potřeba počkat na zavření jiného nastavení
	                    .delay(this.get("delayOpening") && !isMaximized ? 300 : 0)
	                    .animate({
	                        scrollTop: scrollTop
	                    }, this.OPTIONS.SCROLL_DURATION, this.OPTIONS.SCROLL_EASING);
	            }
	        }

	    });

	}));



/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	/*global $*/

	(function (root, factory) {

	    if (typeof module === 'object' && module.exports) {

	        var on = __webpack_require__(1);
	        var EventEmitter = __webpack_require__(6)();

	        var Ractive = __webpack_require__(0);

	        var components = {
	                PageSectionMessage: Ractive.EDIT_MODE ? __webpack_require__(64) : null,
	                ProgressBar: Ractive.EDIT_MODE ? __webpack_require__(36) : null,

	                PageSectionSettings: Ractive.EDIT_MODE ? __webpack_require__(12) : null,
	                ColorSettings: Ractive.EDIT_MODE ? __webpack_require__(66) : null,
	                BackgroundImageSettings: Ractive.EDIT_MODE ? __webpack_require__(65) : null,
	                SectionSettings: Ractive.EDIT_MODE ? __webpack_require__(67) : null,

	                PageElementSettings: Ractive.EDIT_MODE ? __webpack_require__(31) : null,

	                PageElement: __webpack_require__(20),
	                PageElementTitle: __webpack_require__(61),
	                PageElementTextContent: __webpack_require__(60),

	                BackgroundImage: __webpack_require__(63)
	            },

	            template = __webpack_require__(179);

	        module.exports = factory(Ractive, template, components, EventEmitter, on);

	    } else {

	        root.PageSection = factory(root.Ractive, null, $({}), {client: true});
	    }

	}(this, function (Ractive, template, components, EventEmitter, on) {

	    /*
	     * Abstraktní komponent pro vytváření sekcí.
	     *
	     * Konkrétný typ sekce musí v partials zaregistrovat v "pageSectionContent" obsah sekce,
	     * v "pageSectionEditUI" ovládací prvky sekce (komponent rozšiřující PageSectionEditUI - registruje
	     * se u konkrtétní sekce) a v "pageSectionSettings" šablona obsahující všechny PageSectionSettings.
	     **/

	    return Ractive.extend({

	        PAGE_SECTION: true,

	        template: template || "",

	        CLASS: {
	            self: "P_PageSection",
	            hasSettings: "P_PageSection__has-settings",
	            hasOutline: "P_PageSection__has-outline",

	            innerWrapper: "P_PageSection--inner-wrapper",

	            stopColorTransitions: "E_PageSection__stop-color-transitions",

	            //Seřazování sekcí
	            parentOfSortable: "P_sortable-sections",
	            parentOfNonSortable: "P_nonsortable-sections",
	            sortHandle: "P_PageSection--sort-handle",
	            draggedSection: "P_PageSection__dragged",
	            placedSection: "P_PageSection__placed",
	            newSection: "P_PageSection__new",
	            insertedByTap: "P_PageSection__inserted-by-tap",
	            removedSection: "P_PageSection__removed",

	            placeholderTransitions: "P_PageSection--placeholder__transitions",
	            placeholderFake: "P_PageSection--fake-placeholder",
	            placeholder: "P_PageSection--placeholder"
	        },

	        components: components || {},

	        partials: {
	            pageSectionEditUI: "",
	            pageSectionContent: "",
	            pageSectionSettings: "",

	            ColorSettings: Ractive.EDIT_MODE ? __webpack_require__(180) : null
	        },

	        data: function () {

	            return {
	                editMode: Ractive.EDIT_MODE,
	                stopColorTransitions: false
	            };
	        },

	        superOnconfig: function () {

	            if (Ractive.EDIT_MODE) {

	                //při změně jména sekce změnit id
	                this.observe("section.name", this.regenerateId, {init: false, defer: true});

	                this.initPageElementSettings();
	                this.initPageSectionSettings();

	                //pokud je nastaven obrázek na pozadí, ale uživatel nevybral žádnou barvu pozadí,
	                //nastavit jako pozadí výchozí, aby při změně výchozí palety nedošlo ke změně barvy
	                //(barva bude vidět, než se načte obrázek)
	                this.observe("section.backgroundImage.src", function (value) {

	                    if (value && !this.get("section.backgroundColor")) {

	                        this.set("section.backgroundColor", this.get("section.defaultColors.backgroundColor"));

	                        this.set("section.defaultColors.backgroundColorRefByUser", false);
	                    }
	                }, {init: false});

	                this.on("ColorPicker.*", function (data) {

	                    if (data && typeof data === "object" && data.key === "current") {

	                        this.set("stopColorTransitions", !data.context.get("animate"));
	                    }

	                }.bind(this));

	                if (on.client) {

	                    /************************************/
	                    /*ZMĚNA BAREV*/
	                    this.on("*.generateRandomColors", this.generateRandomColors.bind(this));

	                    this.on("ColorPickerPalette.setColor", function (event) {

	                        var pathName = (event.component.container || event.component.parent).get("pathName");

	                        if (!pathName) {

	                            return;
	                        }

	                        //uživatel nastavuje vlastní barvu z výchozích -> uložit odkaz na barvu, aby se měnila v případě změny v paletě
	                        if (event.component.get("id") === "defaultColors") {

	                            this.set("section.defaultColors." + pathName + "Ref", event.index.i);

	                            //(1) odkaz na pozadí se používá pro získání všech ostatních barev,
	                            //(1) proto je potřeba zachovávát odkaz neustále, že je nutné zjistit nastavení uživatelem jiným způsobem
	                            if (pathName === "backgroundColor") {

	                                this.set("section.defaultColors.backgroundColorRefByUser", true);
	                            }

	                        //(2) uživatel nastavuje vlastní barvu, které nepatří k výchozí paletě -> odstranit odkaz na barvu -> výchozí barva pak bude opět dynamická
	                        //(2) pozadí je nutné řešit zvlášť -> viz (1)
	                        } else if (pathName !== "backgroundColor") {

	                            this.set("section.defaultColors." + pathName + "Ref", undefined);

	                            //odkaz na barvu odstraněn -> najít výchozí barvu, která patří k výchozímu pozadí
	                            var colorGenerator = this.findParent("Page").defaultColorsGenerator;

	                            if (typeof this.get("section.defaultColors.backgroundColorRef") === "number") {

	                                var method = "get" + pathName.charAt(0).toUpperCase() + pathName.slice(1);

	                                if (colorGenerator[method]) {

	                                    this.set("section.defaultColors." + pathName, colorGenerator[method](this.get("section.defaultColors.backgroundColorRef")));
	                                }
	                            }

	                        //(3) uživatel mění barvu pozadí na nevýchozí barvu; viz také (1)
	                        } else {

	                            this.set("section.defaultColors.backgroundColorRefByUser", false);
	                        }

	                    }.bind(this));

	                    //"ruční" nastavení barvy
	                    this.on("ColorPicker.activated", function (colorPicker) {

	                        var pathName = colorPicker.get("pathName");

	                        if (!pathName) {

	                            return;
	                        }

	                        //uživatel mění barvu na nevýchozí -> odstranit odkazy
	                        //viz (2)
	                        if (pathName !== "backgroundColor") {

	                            this.set("section.defaultColors." + pathName + "Ref", undefined);

	                            var colorGenerator = this.findParent("Page").defaultColorsGenerator;

	                            if (typeof this.get("section.defaultColors.backgroundColorRef") === "number") {

	                                var method = "get" + pathName.charAt(0).toUpperCase() + pathName.slice(1);

	                                if (colorGenerator[method]) {

	                                    this.set("section.defaultColors." + pathName, colorGenerator[method](this.get("section.defaultColors.backgroundColorRef")));
	                                }
	                            }
	                        //(3)
	                        } else {

	                            this.set("section.defaultColors.backgroundColorRefByUser", false);
	                        }

	                    }.bind(this));
	                }
	                /************************************/
	            }
	        },

	        superOnrender: function () {

	            if (Ractive.EDIT_MODE) {

	                this.initEditUI();
	            }
	        },

	        superOncomplete: function () {
	        },

	        initEditUI: function () {

	            var EditUI,

	                components = this.findAllComponents(),
	                c = components.length - 1;

	            for (c; c >= 0; c--) {

	                if (components[c].EDIT_UI) {

	                    EditUI = components[c];

	                    break;
	                }
	            }

	            this.EditUI = EditUI;
	        },

	        initPageElementSettings: function () {

	            if (on.client) {

	                //otevírá se nastavení elementu v sekci
	                EventEmitter.on("openPageElementSettings.PageElement sortPageSection.PageSectionManager", function (e, state, pageElement) {

	                    this.updateHasSettingsState(pageElement);

	                }.bind(this));
	            }

	            this.on("*.sectionHasOutline", this.updateHasOutlineState.bind(this), {context: this});
	        },

	        initPageSectionSettings: function () {

	            if (on.client) {

	                //otevírá se nastavení sekce -> zavřít ostatní sekce
	                EventEmitter.on("openPageSectionSettings.PageSection", function (e, pageSectionType) {

	                    if (pageSectionType !== this) {

	                        this.togglePageSectionSettings(false);
	                    }
	                }.bind(this));
	            }

	            //Zjišťuje, jestli je jiné nastavení této sekce otevřené.
	            //Pokud se otevírá nastavení sekce a jiné nastavení té samé sekce je už otevřené, nastavení se otevře až po zavření již otevřeného.
	            this.observe("openPageSectionSettings", function (now, before) {

	                this.set("anotherSettingsOpened", !!before);

	            }, {init: false});

	            //uživatel chce otevřít nastavení sekce
	            this.on("*.openPageSectionSettings", function (event, type) {

	                type = type === this.get("openPageSectionSettings") ? false : type;

	                this.togglePageSectionSettings(type);

	                if (type) {

	                    EventEmitter.trigger("openPageSectionSettings.PageSection", this);
	                }
	            });

	            //Uživatel kliknul na "zavřít" v nastavení.
	            this.on("PageSectionSettings.closeThisSettings", this.togglePageSectionSettings.bind(this, false));
	        },

	        superOnteardown: function () {

	            this.off("PageSectionSettings.closeThisSettings");
	            this.off("PageSectionEditUI.openPageSectionSettings");
	            this.off("*.sectionHasOutline");

	            EventEmitter.off("change.DefaultColorsGenerator." + this.get("section.internalId"));

	        },

	        updateHasSettingsState: function (pageElement) {

	            var state  = this.get("openPageSectionSettings") || (pageElement && pageElement.get("openPageElementSettings") && pageElement.getPageSection() === this);

	            this.set("hasSettings", state);

	            this.getSectionElement().classList[state ? "add" : "remove"](this.CLASS.hasSettings);
	        },

	        updateHasOutlineState: function (state) {

	            if (Boolean(this.currentOutlineState) === Boolean(state)) {

	                return;
	            }

	            this.currentOutlineState = this.find("." + this.components.PageElement.prototype.CLASS.outlineActive);

	            this.set("hasOutline", this.currentOutlineState);

	            EventEmitter.trigger("hasOutline.PageSection", [state, this.EditUI]);

	            this.getSectionElement().classList[this.currentOutlineState ? "add" : "remove"](this.CLASS.hasOutline);
	        },

	        togglePageSectionSettings: function (state) {

	            this.set("openPageSectionSettings", state);

	            this.updateHasSettingsState();
	        },

	        regenerateId: function (newName) {

	            if (typeof newName === "undefined") {

	                return;
	            }

	            var builder = this.findParent("Page").pageSectionBuilder;

	            if (!newName) {

	                this.set("section.name", builder.getDefaultName(this.get("section.type")));

	                return;
	            }

	            this.set("section.id", builder.generateId(newName));

	            this.rewriteNameReferences(newName);
	        },

	        rewriteNameReferences: function (name) {

	            var id = this.get("section.internalId");

	            $("[value='#" + id + "'], [data-value='#" + id + "']").text(name);
	        },

	        /**
	         * Logika změny barvy:
	         * Nastaví-li uživatel novou paletu, jsou výchozí barvy kompletně přepsány náhodnou barvou z výchozích,
	         * Odkaz na tuto barvu se udržuje v "section.defaultColors.backgroundColorRef" - z barvy pozadí se odvozují ostatní.
	         * Pokud uživatel nastavil vlastní výchozí barvy, jsou tyto barvy přepsány novou paletou (resp. nastavení barev je odstraněno, aby se použily barvy výchozí).
	         *
	         * Pokud se mění pouze jedna barva, tak v případě, že existuje odkaz na výchozí barvu (uživatel vybral vlastní výchozí barvu),
	         * se tato barva změní, pokud je změněna ve výchozí paletě, ale není dynamická (nemění se např. při změně pozadí na jinou).
	         * Pokud odkaz neexistuje použije se dynamická barva patřící k pozadí.
	         *
	         * Vlastní barvy zůstavají vždy zachovány.
	         */
	        handleDefaultColorsChanged: function (colorGenerator, singleColorChanged, prevSection) {

	            if (singleColorChanged) {

	                this.handleSingleDefaultColorChanged(colorGenerator);

	                return;
	            }

	            this.handleColorPaletteChanged(colorGenerator, prevSection);
	        },

	        handleSingleDefaultColorChanged: function (colorGenerator) {

	            var defaultColors = this.get("section.defaultColors");

	            if (defaultColors && typeof defaultColors.backgroundColorRef === "number") {

	                //uživatel změnil barvu pozadí z výchozích barev -> použít výchozí a odstranit nastaveno barvu
	                if (defaultColors && defaultColors.backgroundColorRefByUser) {

	                    this.set("section.backgroundColor", "");
	                }

	                //výchozí barvy podle odkazu
	                this.set("section.defaultColors.backgroundColor", colorGenerator.getColor(defaultColors.backgroundColorRef));

	                //(1) uživatel změnil barvu textu (speciální) z výchozích -> použít výchozí z odkazu na tuto barvu a odstranit nastavenou
	                //(1) pokud uživatel mění tuto barvu (v paletě) -> barva se bude měnit také, ale nebude se přizůsovovat
	                if (defaultColors && typeof defaultColors.textColorRef === "number") {

	                    this.set("section.textColor", "");
	                    this.set("section.defaultColors.textColor", colorGenerator.getColor(defaultColors.textColorRef));

	                    //(2) jestiže odkaz neexistuje, použije se dynamická barva patřící k pozadí
	                } else {

	                    this.set("section.defaultColors.textColor", colorGenerator.getTextColor(defaultColors.backgroundColorRef));
	                }

	                //viz (1)
	                if (defaultColors && typeof defaultColors.specialColorRef === "number") {

	                    this.set("section.specialColor", "");
	                    this.set("section.defaultColors.specialColor", colorGenerator.getColor(defaultColors.specialColorRef));

	                //viz (2)
	                } else {

	                    this.set("section.defaultColors.specialColor", colorGenerator.getSpecialColor(defaultColors.backgroundColorRef));
	                }
	            }
	        },

	        handleColorPaletteChanged: function (colorGenerator, prevSection) {

	            var defaultColors = this.get("section.defaultColors");

	            //v případě, že na jednotlivé barvy byly nastaveny odkazy (uživatel vybral barvu z výchozích),
	            //tak se tyto barvy změní s paletou (odstraní se nastavené barvy)
	            if (defaultColors && typeof defaultColors.textColorRef === "number") {

	                this.set("section.textColor", "");
	            }

	            if (defaultColors && typeof defaultColors.specialColorRef === "number") {

	                this.set("section.specialColor", "");
	            }

	            if (defaultColors && defaultColors.backgroundColorRefByUser) {

	                this.set("section.backgroundColor", "");
	            }

	            /**************************************/
	            //pokud má předcházející sekce stejnou barvu pozadí, vybrat jinou
	            var colors, thisRef,

	                prevRef = prevSection ? prevSection.get("section.defaultColors.backgroundColorRef") : null;

	            do {

	                colors = colorGenerator.getColors();

	                thisRef = colors.backgroundColorRef;

	            } while (thisRef === prevRef);
	            /**************************************/

	            this.set("section.defaultColors", colors);
	        },

	        generateRandomColors: function (checkAfterAndBefore, stopTransitions) {

	            if (typeof checkAfterAndBefore === "object") {

	                checkAfterAndBefore = false;
	            }

	            var colorPaths = this.getColorPaths(),
	                p = colorPaths .length - 1;

	            for (p; p >= 0; p--) {

	                this.set("section." + colorPaths[p], "");
	            }

	            var allSections, afterRef, beforeRef, s;

	            if (checkAfterAndBefore) {

	                allSections = this.findParent("Page").pageSectionsManager.getSectionsSortedByIndex(true);

	                s = allSections.length - 1;

	                for (s; s >= 0; s--) {

	                    if (allSections[s] === this) {

	                        //předchozí sekce
	                        if (allSections[s - 1]) {

	                            beforeRef = allSections[s - 1].get("section.defaultColors.backgroundColorRef");

	                        }
	                        //následující sekce
	                        if (allSections[s + 1]) {

	                            afterRef = allSections[s + 1].get("section.defaultColors.backgroundColorRef");
	                        }
	                    }
	                }
	            }

	            var colorGenerator = this.findParent("Page").defaultColorsGenerator,

	                colors,

	                lastRef = this.get("section.defaultColors.backgroundColorRef"),
	                thisRef;

	            do {

	                colors = colorGenerator.getColors();

	                thisRef = colors.backgroundColorRef;

	            } while ((thisRef === lastRef) || (checkAfterAndBefore && (thisRef === afterRef || thisRef === beforeRef)));

	            this.set("stopColorTransitions", !!stopTransitions);

	            this.set("section.defaultColors", colors);
	        },

	        handleHover: function (event) {

	            if (this.EditUI) {

	                this.EditUI.fire("hover", event, this);
	            }
	        },

	        //uživatel se dotknul sekce -> zobrazit EditUI? -> handleTouchend
	        handleTouchstart: function (event) {

	            if (event.original.touches.length > 1 || this.EditUI.get("hover")) {

	                return;
	            }

	            this.cancelTouchend = false;

	            this.wasTouchstart = true;

	            var initX = event.original.touches[0].pageX,
	                initY = event.original.touches[0].pageY;

	            Ractive.$win.on("touchmove.hover-PageSection", function (event) {

	                this.cancelTouchend = Math.abs(initX - event.originalEvent.touches[0].pageX) > 5 ||
	                    Math.abs(initY - event.originalEvent.touches[0].pageY) > 5;

	            }.bind(this));
	        },

	        //předává informaci EditUI, že uživatel chce zobrazit UI
	        handleTouchend: function (event) {

	            Ractive.$win.off("touchmove.hover-PageSection");

	            if (event.original.touches.length > 1) {

	                return;
	            }

	            if (this.wasTouchstart && this.EditUI) {

	                this.EditUI.fire("pageSectionTouchend", event, this, this.cancelTouchend);
	            }

	            this.wasTouchstart = false;
	        },

	        //Vrátí současnou pozici sekce na stránce.
	        getCurrentIndex: function () {

	            return this.get$SectionElement().index();
	        },

	        getSectionElement: function () {

	            this.sectionElement = this.sectionElement || this.find("." + this.CLASS.self);

	            return this.sectionElement;
	        },

	        get$SectionElement: function () {

	            this.$sectionElement = this.$sectionElement || $(this.getSectionElement());

	            return this.$sectionElement;
	        },

	        findPageElements: function () {

	            var elements = [],

	                components = this.findAllComponents(),
	                c = components.length - 1;

	            for (c; c >= 0; c--) {

	                if (components[c].PAGE_ELEMENT) {

	                    elements.unshift(components[c]);
	                }
	            }

	            return elements;
	        },

	        forEachPageElement: function (fn/*, args...*/) {

	            var elements = this.findPageElements(),
	                e = elements.length - 1,

	                args = Array.prototype.slice.call(arguments);

	            args.shift();

	            for (e; e >= 0; e--) {

	                if (typeof fn === "string" && elements[e][fn]) {

	                    elements[e][fn].apply(elements[e], args);

	                } else if (typeof fn === "function") {

	                    fn.apply(elements[e], elements[e]);
	                }
	            }
	        },

	        getColorPaths: function () {

	            var paths = ["backgroundColor", "textColor"];

	            //pokud je barva v poli -> přidat, každou cestu zvlášť ???

	            return paths;
	        },

	        getColors: function () {

	            var colorPaths = this.getColorPaths(),
	                cP = colorPaths.length - 1,
	                tempColor,

	                colors = [];

	            for (cP; cP >= 0; cP--) {

	                tempColor = this.get(colorPaths[cP]);

	                if (tempColor && !~colors.indexOf(tempColor)) {

	                    colors.unshift(tempColor);
	                }
	            }

	            return colors;
	        }

	    });

	}));



/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/

	(function (root, factory) {

	    if (typeof module === 'object' && module.exports) {

	        var Ractive = __webpack_require__(0),
	            Spectra = __webpack_require__(29),
	            Vibrant = __webpack_require__(95),
	            template = __webpack_require__(183),
	            on = __webpack_require__(1);

	        module.exports = factory(Ractive, Spectra, Vibrant, template, on);

	    } else {

	        root.ColorPickerPalette = factory(root.Ractive, root.Spectra, root.Vibrant, "", {client: true});
	    }

	}(this, function (Ractive, Spectra, Vibrant, template, on) {

	    return Ractive.extend({

	        template: template,

	        noIntro: true,

	        data: function () {

	            return {
	                TYPE_DEFAULT: "default",

	                delay: 0,

	                colors: [],
	                image: "",

	                formatColor: function (color, format) {

	                    var colorPicker = this.parent.COLOR_PICKER ? this.parent: this.container;

	                    if (format === colorPicker.get("TYPE_HEX")) {

	                        if (colorPicker.validateHEX(color)) {

	                            return color;
	                        }

	                        return Spectra(color).hex();

	                    } else if (format === colorPicker.get("TYPE_RGB")) {

	                        if (colorPicker.validateRGB(color)) {

	                            return color;
	                        }

	                        var spectra = Spectra(color);

	                        return "rgb(" + spectra.red() + ", " + spectra.green() + ", " + spectra.blue() + ")";
	                    }

	                    return color;
	                }
	            };
	        },

	        computed: {

	            nearToBlack: function () {

	                var color = Spectra(this.parent.get("current"));

	                return color.near(Spectra("black"), 50);
	            }
	        },

	        onconfig: function () {

	            if (on.client) {

	                this[this.parent.COLOR_PICKER ? "parent" : "container"].observe("inputType", function (value) {

	                    this.set("inputType", value);

	                }.bind(this));
	            }
	        },

	        oncomplete: function () {

	            var image = this.get("image");

	            if (on.client && image && image !== "none") {

	                //cross-origin
	                if (image.match(/^http/) && !image.match(new RegExp("^" + window.location.origin))) {

	                    return;
	                }

	                this.loadImageTimeout = setTimeout(function() {

	                    this.getPaletteFromImage();

	                }.bind(this), this.get("delay"));
	            }
	        },

	        onteardown: function () {

	            clearTimeout(this.loadImageTimeout);
	            clearTimeout(this.stopVibrantTimeout);
	            clearTimeout(this.stopVibrant2Timeout);

	            if (this.stopVibrant) {

	                this.stopVibrant();
	            }

	            if (this.stopVibrant2) {

	                this.stopVibrant2();
	            }
	        },

	        getUniqueRgbs: function (vibrantPalette) {

	            var keys = Object.keys(vibrantPalette),
	                c = keys.length - 1,
	                rgbs = [];

	            for (c; c >= 0; c--) {

	                if (vibrantPalette[keys[c]]) {

	                    vibrantPalette[keys[c]].rgb[0] = Math.round(vibrantPalette[keys[c]].rgb[0]);
	                    vibrantPalette[keys[c]].rgb[1] = Math.round(vibrantPalette[keys[c]].rgb[1]);
	                    vibrantPalette[keys[c]].rgb[2] = Math.round(vibrantPalette[keys[c]].rgb[2]);

	                    var rgbString = "rgb(" + vibrantPalette[keys[c]].rgb.join(",") + ")";

	                    if (!~rgbs.indexOf(rgbString)) {

	                        rgbs.push(rgbString);
	                    }
	                }
	            }

	            return rgbs;
	        },

	        findTheLeastSimilarColors: function (rgbs, compareWithRgbs, count) {

	            var similarity = {},
	                spectraCache = {},

	                r = rgbs.length - 1,
	                c = compareWithRgbs.length - 1;

	            for (r; r >= 0; r--) {

	                var spectra = Spectra(rgbs[r]);

	                similarity[rgbs[r]] = 0;

	                for (c; c >= 0; c--) {

	                    var spectra2 = spectraCache[compareWithRgbs[c]] || Spectra(compareWithRgbs[c]);

	                    if (!spectraCache[compareWithRgbs[c]]) {

	                        spectraCache[compareWithRgbs[c]] = spectra2;
	                    }

	                    if (spectra.near(spectra2, 5)) {

	                        similarity[rgbs[r]] = -100;

	                    } else if (spectra.near(spectra2, 10)) {

	                        similarity[rgbs[r]] += 3;

	                    } else if (spectra.near(spectra2, 20)) {

	                        similarity[rgbs[r]] += 2;

	                    } else if (spectra.near(spectra2, 30)) {

	                        similarity[rgbs[r]] += 1;
	                    }
	                }

	                c = compareWithRgbs.length - 1;
	            }

	            var sorted = Object.keys(similarity)
	                .filter(function (color) {

	                    return similarity[color] < 0 ? false : color;

	                }).sort(function (a, b) {

	                    return similarity[a] - similarity[b];
	                });

	            return sorted.splice(0, count);
	        },

	        getPaletteFromImage: function () {

	            this.image = new Image();

	            this.image.onload = function () {

	                var vibrant = new Vibrant(this.image, 32, 7);

	                this.stopVibrant = vibrant.stop;

	                this.stopVibrantTimeout = setTimeout(vibrant.stop, 3000);

	                vibrant.promise.then(function (vibrant) {

	                    clearTimeout(this.stopVibrantTimeout);

	                    var palette = vibrant.swatches(),

	                        rgbs = this.getUniqueRgbs(palette);

	                    if (rgbs.length < 5) {

	                        var vibrant2 = new Vibrant(this.image, 5, 10, true);

	                        this.stopVibrant2 = vibrant2.stop;

	                        this.stopVibrant2Timeout = setTimeout(vibrant2.stop, 3000);

	                        vibrant2.promise.then(function (palette) {

	                            clearTimeout(this.stopVibrant2Timeout);

	                            var rgbs2 = this.getUniqueRgbs(palette),

	                                leastSimilar = this.findTheLeastSimilarColors(rgbs2, rgbs, 5 - rgbs.length);

	                            this.merge("colors", this.get("colors").concat(leastSimilar));

	                            this.image = null;

	                        }.bind(this));

	                    } else {

	                        this.image = null;
	                    }

	                    this.set("colors", rgbs);

	                }.bind(this));

	            }.bind(this);

	            this.image.src = this.get("image");
	        }
	    });

	}));


/***/ },
/* 15 */
/***/ function(module, exports) {


	/**
	 * Expose `Emitter`.
	 */

	module.exports = Emitter;

	/**
	 * Initialize a new `Emitter`.
	 *
	 * @api public
	 */

	function Emitter(obj) {
	  if (obj) return mixin(obj);
	};

	/**
	 * Mixin the emitter properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */

	function mixin(obj) {
	  for (var key in Emitter.prototype) {
	    obj[key] = Emitter.prototype[key];
	  }
	  return obj;
	}

	/**
	 * Listen on the given `event` with `fn`.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.on =
	Emitter.prototype.addEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	  (this._callbacks[event] = this._callbacks[event] || [])
	    .push(fn);
	  return this;
	};

	/**
	 * Adds an `event` listener that will be invoked a single
	 * time then automatically removed.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.once = function(event, fn){
	  var self = this;
	  this._callbacks = this._callbacks || {};

	  function on() {
	    self.off(event, on);
	    fn.apply(this, arguments);
	  }

	  on.fn = fn;
	  this.on(event, on);
	  return this;
	};

	/**
	 * Remove the given callback for `event` or all
	 * registered callbacks.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.off =
	Emitter.prototype.removeListener =
	Emitter.prototype.removeAllListeners =
	Emitter.prototype.removeEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};

	  // all
	  if (0 == arguments.length) {
	    this._callbacks = {};
	    return this;
	  }

	  // specific event
	  var callbacks = this._callbacks[event];
	  if (!callbacks) return this;

	  // remove all handlers
	  if (1 == arguments.length) {
	    delete this._callbacks[event];
	    return this;
	  }

	  // remove specific handler
	  var cb;
	  for (var i = 0; i < callbacks.length; i++) {
	    cb = callbacks[i];
	    if (cb === fn || cb.fn === fn) {
	      callbacks.splice(i, 1);
	      break;
	    }
	  }
	  return this;
	};

	/**
	 * Emit `event` with the given args.
	 *
	 * @param {String} event
	 * @param {Mixed} ...
	 * @return {Emitter}
	 */

	Emitter.prototype.emit = function(event){
	  this._callbacks = this._callbacks || {};
	  var args = [].slice.call(arguments, 1)
	    , callbacks = this._callbacks[event];

	  if (callbacks) {
	    callbacks = callbacks.slice(0);
	    for (var i = 0, len = callbacks.length; i < len; ++i) {
	      callbacks[i].apply(this, args);
	    }
	  }

	  return this;
	};

	/**
	 * Return array of callbacks for `event`.
	 *
	 * @param {String} event
	 * @return {Array}
	 * @api public
	 */

	Emitter.prototype.listeners = function(event){
	  this._callbacks = this._callbacks || {};
	  return this._callbacks[event] || [];
	};

	/**
	 * Check if this emitter has `event` handlers.
	 *
	 * @param {String} event
	 * @return {Boolean}
	 * @api public
	 */

	Emitter.prototype.hasListeners = function(event){
	  return !! this.listeners(event).length;
	};


/***/ },
/* 16 */
/***/ function(module, exports) {


	module.exports = function(a, b){
	  var fn = function(){};
	  fn.prototype = b.prototype;
	  a.prototype = new fn;
	  a.prototype.constructor = a;
	};

/***/ },
/* 17 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 18 */
/***/ function(module, exports) {

	"use strict";
	'use strict';

	function oldAdd(element, className) {
	  var classes = element.className.split(' ');
	  if (classes.indexOf(className) < 0) {
	    classes.push(className);
	  }
	  element.className = classes.join(' ');
	}

	function oldRemove(element, className) {
	  var classes = element.className.split(' ');
	  var idx = classes.indexOf(className);
	  if (idx >= 0) {
	    classes.splice(idx, 1);
	  }
	  element.className = classes.join(' ');
	}

	exports.add = function (element, className) {
	  if (element.classList) {
	    element.classList.add(className);
	  } else {
	    oldAdd(element, className);
	  }
	};

	exports.remove = function (element, className) {
	  if (element.classList) {
	    element.classList.remove(className);
	  } else {
	    oldRemove(element, className);
	  }
	};

	exports.list = function (element) {
	  if (element.classList) {
	    return Array.prototype.slice.apply(element.classList);
	  } else {
	    return element.className.split(' ');
	  }
	};


/***/ },
/* 19 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			Object.defineProperty(module, "loaded", {
				enumerable: true,
				configurable: false,
				get: function() { return module.l; }
			});
			Object.defineProperty(module, "id", {
				enumerable: true,
				configurable: false,
				get: function() { return module.i; }
			});
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	/*global $*/
	(function (root, factory) {

	    if (typeof module === 'object' && module.exports) {

	        var Ractive = __webpack_require__(0),

	            PageElementSettings = __webpack_require__(31),

	            U = __webpack_require__(4),
	            EventEmitter = __webpack_require__(6)(),
	            on = __webpack_require__(1);

	        module.exports = factory(
	            Ractive,
	            PageElementSettings,
	            U,
	            __webpack_require__(158),
	            EventEmitter,
	            on
	        );

	    } else {

	        root.PageElement = factory(
	            root.Ractive,
	            root.PageElementSettings,
	            root.U,
	            "",
	            $([]),
	            {client: true}
	        );
	    }

	}(this, function (Ractive, PageElementSettings, U, template, EventEmitter, on) {

	    /*
	     * Abstraktní (!) component pro vytváření editovatelných prvků na stránce.
	     * Přídá outline a nastavovací tlačítka -> řízeno konkrétními komponenty.
	     *
	     * Konkrétní typ musí obsahovat data "type" označující typ PageElementu,
	     * data "hasEditUI" označující, jestli má ovládací prvky a může obsahovat
	     * "settingsTitle" nastavující titulek PageElementSettings.
	     *
	     * Konkrétní typ může obsahovat metodu isEmpty, která zjistí, jestli je element prázdný (Přidá se třída E_PageElement__empty).
	     *
	     * Konkrétní typ může nastavovat stav PageElementu nastavením vlastnosti "state", která by měla vycházet z
	     * události "stateChange".
	     */

	    var instanceCounter = 0,

	        hasMouseTouchStyles = false,

	        //nastaví chování outlinu
	        //Outline se zobrazuje nad obsahem, proto je potřeba mu přidat pointer-events: none.
	        //Na dotykových zařízeních se nastaví po touchstart na konkrétním elementu (v styles.css),
	        //při použití myši se nastaví pro všechny.
	        setMouseTouchStyles = function (isMouseUsed) {

	            if (isMouseUsed) {

	                if (hasMouseTouchStyles) {

	                    return;
	                }

	                var cssText = [
	                    ".E_PageElement--outline { ",
	                        "pointer-events: none;",
	                    "}"
	                ].join("");

	                $("<style />")
	                    .attr("id", "PageElement--mouse-touch")
	                    .html(cssText)
	                    .appendTo("head");

	                hasMouseTouchStyles = true;

	                return;
	            }

	            if (hasMouseTouchStyles) {

	                $("#PageElement--mouse-touch").remove();

	                hasMouseTouchStyles = false;
	            }
	        },

	        hoverByTouch = false,
	        hoverByTouchTimeout = null,

	        throttleHoverByTouch = function () {

	            hoverByTouch = true;

	            clearTimeout(hoverByTouchTimeout);

	            hoverByTouchTimeout = setTimeout(function() {

	                hoverByTouch = false;

	                setMouseTouchStyles(false);

	                //Pokud se opět použije touchstart -> použít stylování pro dotyk. z.
	                Ractive.$win
	                    .off("touchstart.PageElement")
	                    .one("touchstart.PageElement", function () {

	                    setMouseTouchStyles(false);

	                    hoverByTouch = true;

	                }.bind(this));

	            }, 5000);
	        };

	    return Ractive.extend({

	        PAGE_ELEMENT: true,

	        template: template,

	        CLASS: {
	            self: "P_PageElement",

	            outline: "E_PageElement--outline", //při změně změnit i výše v "setMouseTouchStyles()"
	            outlineActive: "E_PageElement--outline__active"
	        },

	        components: {
	            PageElementSettings: Ractive.EDIT_MODE ? PageElementSettings : null
	        },

	        partials: {
	            pageElementEditUI: "",
	            pageElementContent: ""
	        },

	        data: function () {

	            return {
	                hover: false,
	                editMode: Ractive.EDIT_MODE
	            };
	        },

	        superOnconfig: function () {

	            this.EVENT_NS = "PageElement-" + (++instanceCounter);

	            if (on.client) {

	                Ractive.$win = Ractive.$win || $(window);

	                this.$temp = $([null]);

	                if (Ractive.EDIT_MODE) {

	                    //umožnit otevřít nastavení elementu
	                    this.initPageElementSettings();
	                }
	            }
	        },

	        initPageElementSettings: function () {

	            if (on.client) {

	                //otevírá se nastavení elementu v sekci -> zavřít nastavení v ostatních sekcích
	                EventEmitter.on("openPageElementSettings.PageElement sortPageSection.PageSectionManager", function (e, state, pageSectionType) {

	                    if (pageSectionType !== this) {

	                        this.togglePageElementSettings(false);
	                    }
	                }.bind(this));
	            }

	            //uživatel otevírá nastavení elementu v sekci
	            this.on("openPageElementSettings", function (event, type) {

	                //element pro určení pozice nastavení
	                this.set("pageElementSettingsPositionElement", event.node);

	                type = type === this.get("openPageElementSettings") ? false : type;

	                this.togglePageElementSettings(type);

	                EventEmitter.trigger("openPageElementSettings.PageElement", [type, this]);
	            });

	            //Uživatel kliknul na "zavřít" v nastavení.
	            this.on("PageElementSettings.closeThisSettings", function () {

	                this.togglePageElementSettings(false);

	                EventEmitter.trigger("openPageElementSettings.PageElement", [false, this]);

	            }.bind(this));
	        },

	        superOnrender: function () {

	            if (on.client) {

	                this.self = this.find("." + this.CLASS.self);
	                this.$self = $(this.self);

	                if (Ractive.EDIT_MODE) {

	                    this.initOutline();
	                }
	            }
	        },

	        //spustí zobrazování ui při najetí myší
	        initOutline: function () {

	            this.outlineElement = this.find("." + this.CLASS.outline);

	            this.$self
	                //pokud uživatel přestane editovat text, je nutné zjistit, jestli má outline zmizet
	                .on("focusout." + this.EVENT_NS, function () {

	                    this.set("hover", false);

	                    this.fire("stateChange", this.get("showOutline"));

	                    clearTimeout(this.focusoutTimeout);

	                    this.focusoutTimeout = setTimeout(this.updateOutlineState.bind(this), 100);

	                }.bind(this))
	                //zobrazit outline např při tabu nebo označení
	                .on("focusin." + this.EVENT_NS, function (e) {

	                    //pouze nejvnitřnější elmenet
	                    var children = this.findAllComponents(),

	                        i = children.length - 1;

	                    for (i; i >= 0; i--) {

	                        if (children[i].PAGE_ELEMENT && children[i].focusin) {

	                            return;
	                        }
	                    }

	                    this.set("hover", true);

	                    this.focusin = true;

	                    this.fire("stateChange", this.get("showOutline"));

	//                    e.stopPropagation();

	                }.bind(this));

	            //při najetí myší zbrazit outline
	            this.observe("hover", function (state) {

	                if (!hoverByTouch) {

	                    //pro případné odstranění vnějších hover stavů
	                    this.fire("pageElementHover", state);
	                }

	                this.updateOutlineState();

	                if (!state) {

	                    this.focusin = false;

	                    this.set("restoreHover", false);

	                    if (hoverByTouch) {

	                        Ractive.$win.off("touchstart.hover-" + this.EVENT_NS);
	                    }
	                }
	            }, {init: false});

	            //při najetí na vnitřní outline je potřeba ostatní odstranit
	            this.on("*.pageElementHover", function (state) {

	                if (state) {

	                    this.set("hover", false);

	                    this.fire("stateChange", this.get("showOutline"));

	                    //je potřeba uložit stav - až uživatel odjede z vnitřního elementu, outline se vrátí
	                    this.set("restoreHover", true);

	                } else {

	                    if (!this.hasChildPageElementHoverState()) {

	                        var restore = this.get("restoreHover");

	                        this.set("hover", restore);

	                        this.fire("stateChange", this.get("showOutline"));
	                    }
	                }
	            });
	        },

	        superOncomplete: function () {

	        },

	        superOnteardown: function () {

	            clearTimeout(this.focusoutTimeout);

	            this.$self.off("." + this.EVENT_NS);

	            Ractive.$win
	                .off("touchstart.hover-" + this.EVENT_NS)
	                .off("touchstart.PageElement");
	        },

	        handleTouchstart: function (event) {

	            throttleHoverByTouch();

	            if (event.original.touches.length > 1 || this.get("hover")) {

	                return;
	            }

	            this.touchstartTime = +new Date();
	            this.cancelTouchend = false;

	            var initX = event.original.touches[0].pageX,
	                initY = event.original.touches[0].pageY;

	            Ractive.$win
	                .off("touchstart.hover-" + this.EVENT_NS)
	                .on( "touchmove.hover-" + this.EVENT_NS, function (event) {

	                    this.cancelTouchend = Math.abs(initX - event.originalEvent.touches[0].pageX) > 5 ||
	                        Math.abs(initY - event.originalEvent.touches[0].pageY) > 5;

	                }.bind(this))
	                .on( "touchstart.hover-" + this.EVENT_NS, function (event) {

	                    throttleHoverByTouch();

	                    this.hideOutlineTouches = event.originalEvent.touches.length;

	                    clearTimeout(this.hideOutlineTimeout);

	                    this.hideOutlineTimeout = setTimeout(function() {

	                        if (this.hideOutlineTouches > 1) {

	                            return;
	                        }

	                        this.$temp[0] = event.target;

	                        //uživatel tapnul na jiný vnitřní/vnější element (nebo úplně jinam)
	                        if (this.$temp.closest("." + this.CLASS.self)[0] !== this.self) {

	                            this.set("hover", false);

	                            this.fire("stateChange", this.get("showOutline"));

	                            Ractive.$win.off("touchstart.hover-" + this.EVENT_NS);
	                        }

	                    }.bind(this), 50);

	                }.bind(this));
	        },

	        handleTouchend: function (event) {

	            throttleHoverByTouch();

	            Ractive.$win
	                .off("touchmove.hover-" + this.EVENT_NS);

	            if (this.cancelTouchend || !this.touchstartTime || event.original.touches.length > 1 || this.get("hover")) {

	                return;
	            }

	            this.set("hover", true);

	            this.fire("stateChange", this.get("showOutline"));

	            var touchendTime = +new Date();

	            //pokud uživatel drží prst na elmentu méně než 500ms, needitovat text - pouze zobrazit ui
	            if (touchendTime - this.touchstartTime < 500) {

	                event.original.preventDefault();
	            }

	            this.touchstartTime = 0;
	        },

	        handleHover: function (event) {

	            if (hoverByTouch) {

	                return;
	            }

	            setMouseTouchStyles(true);

	            this.set("hover", event.hover);
	        },

	        //zobrazí ui, pokud je stav "hover" nebo je otevřeno nastavení nebo má Editor focus,
	        //jinak ui skryje
	        updateOutlineState: function () {

	            var state = (this.get("hover") || this.get("openPageElementSettings") || this.hasFocusedEditor());

	            this.set("showOutline", state);

	            this.checkOutlineSize(state);

	            this.fire("sectionHasOutline", state);

	            this.fire("stateChange", !!state);
	        },

	        hasFocusedEditor: function () {

	            var editors = this.findAll("[data-medium-focused='true']"),
	                e = editors.length - 1;

	            for (e; e >= 0; e--) {

	                this.$temp[0] = editors[e];

	                if (this.$temp.closest("." + this.CLASS.self)[0] === this.self) {

	                    return true;
	                }
	            }

	            return false;
	        },

	        hasChildPageElementHoverState: function () {

	            var components = this.findAllComponents(),
	                c = components.length - 1;

	            for (c; c >= 0; c--) {

	                if (components[c].PAGE_ELEMENT && components[c].get("hover")) {

	                    return true;
	                }
	            }

	            return false;
	        },

	        togglePageElementSettings: function (state) {

	            this.set("openPageElementSettings", state);

	            this.updateOutlineState();
	        },

	        //pokud outline přesahuje velikost okna, je ptřeba ho změnšit
	        checkOutlineSize: function (state) {

	            if (!state) {

	                this.set("limitSize", false);
	            }

	            var rect = this.outlineElement.getBoundingClientRect(),

	                viewportWidth = U.viewportWidth();


	            if (rect.left < 0 || rect.right > viewportWidth) {

	                this.set("limitSize", true);
	            }
	        }
	    });

	}));



/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	/*global $*/
	(function (root, factory) {

	    if (typeof module === 'object' && module.exports) {

	        var Ractive = __webpack_require__(0),
	            EventEmitter = __webpack_require__(6)(),
	            on = __webpack_require__(1),

	            template = __webpack_require__(160),

	            partials = {
	                pageSectionEditUIContent: __webpack_require__(163),
	                EditUIControlsTopLeft: __webpack_require__(164),
	                EditUIControlsTopRight: __webpack_require__(165),
	                EditUIControlsBottomLeft: __webpack_require__(161),
	                EditUIControlsBottomRight: __webpack_require__(162),

	                FlatButton: __webpack_require__(44)
	            };

	        module.exports = factory(Ractive, EventEmitter, template, partials, on);

	    } else {

	        root.BasicEditUI = factory(root.Ractive, $({}), "", {client: true});
	    }

	}(this, function (Ractive, EventEmitter, template, partials, on) {

	    /*
	     * Základní typ ovládacích prvků sekce. Každý další typ by měl rozšiřovat tento typ.
	     * Komponent obsahuje "partials" s ovládacími prvky pro každý roh. Podtypy mohou tyto partialy
	     * přepsat nebo je možné je vypnout přidáním dat:
	     * { EditUIControlsTopLeft: false }
	     * Nebo je možné vypnout jen některá tlačítka:
	     * { removeSectionButton: false }
	     */

	    return Ractive.extend({

	        EDIT_UI: true,

	        CLASS: {
	            self: "E_PageSectionEditUI",
	            hiddenByUser: "E_PageSectionEditUI__hidden-by-user"
	        },

	        template: template,

	        components: {
	        },

	        partials: partials || {},

	        onconfig: function () {
	            this.superOnconfig();
	        },

	        onrender: function () {
	            this.superOnrender();
	        },

	        oncomplete: function () {
	            this.superOncomplete();
	        },

	        onteardown: function () {
	            this.superOnteardown();
	        },

	        superOnconfig: function () {

	            this.Page = this.findParent("Page");
	            this.PageSection = this.getPageSection();

	            if (!on.client) {

	                return;
	            }

	            EventEmitter.on("hover.PageSectionEditUI hasOutline.PageSection", function (event, state, editUI) {

	                if (state && editUI !== this) {

	                    this.blockTouchend = false;

	                    if (this.hiddenByUser) {

	                        //zrušit this.hiddenByUser === true, pokud sekce nemá outline ani settings
	                        this.setHiddenByUser(!(!this.PageSection.get("hasOutline") && !this.PageSection.get("hasSettings")));
	                    }

	                    this.blockHover = false;

	                    this.set("hover", false);
	                }

	                if (event.type === "hasOutline" && !this.hiddenByUser && state && editUI === this) {

	                    this.set("hover", true);
	                }

	            }.bind(this));

	            this.observe("hover", function (state) {

	                if (!state) {

	                    this.blockHover = false;

	                    this.set("removeSectionConfirmation", false);
	                }

	            }, {init: false});

	            //událost je spuštěna v příslušné PageSection
	            this.on("hover", function (event/*, pageSection*/) {

	                if (this.blockHover && event.hover) {

	                    return;
	                }

	                //přejetí z PageElementSetitngs -> neměnit stav UI
	                if (event.hover && $(event.original.fromElement).closest("." + this.parent.components.PageElementSettings.prototype.CLASS.self).length) {

	                    return;
	                }

	                //přejetí do PageElementSettings -> neměnit stav UI
	                if (!event.hover && $(event.original.toElement).closest("." + this.parent.components.PageElementSettings.prototype.CLASS.self).length) {

	                    return;
	                }

	                if (!event.hover) {

	                    this.blockHover = false;

	                } else {

	                    this.setHiddenByUser(false);
	                }

	                this.set("hover", event.hover && !this.Page.get("sortableActive"));
	            });

	            this.on("pageSectionTouchend", function (event, pageSection, touchmove) {

	                if (this.hiddenByUser) {

	                    var $target = $(event.original.target);

	                    //nezobrazovat UI, pokud ho uživatel zavřel a tapnul na Element nebo Settings
	                    if (!$target.closest("." + this.parent.components.PageElement.prototype.CLASS.self).length &&
	                        !$target.closest("." + this.parent.components.PageSectionSettings.prototype.CLASS.self).length) {

	                        this.blockTouchend = false;

	                    } else {

	                        this.blockHover = true;
	                    }
	                }

	                if (this.blockTouchend) {

	                    return;
	                }

	                this.blockHover = true;

	                if (touchmove) {

	                    return;
	                }

	                if (!this.get("hover")) {

	                    this.set("hover", !this.Page.get("sortableActive"));

	                    event.original.preventDefault();

	                    if (!pageSection.get("hasSettings") && !pageSection.get("hasOutline")) {

	                        EventEmitter.trigger("hover.PageSectionEditUI", [true, this]);
	                    }
	                }
	            });

	            this.on("cancelHideEditUI", this.cancelHideEditUI);
	            this.on("preHideEditUI", this.preHideEditUI);
	            this.on("hideEditUI", this.hideEditUI);
	            this.on("resetFocus", this.resetFocus);
	        },

	        superOnrender: function () {

	            this.self = this.find("." + this.CLASS.self);
	            this.$self = $(this.self);
	        },

	        superOncomplete: function () {

	        },

	        superOnteardown: function () {

	        },

	        //uživatel tapnul na zavření UI
	        preHideEditUI: function (event) {

	            this.startHideCoords = {
	                x: event.original.changedTouches ? event.original.changedTouches[0].clientX : event.original.clientX,
	                y: event.original.changedTouches ? event.original.changedTouches[0].clientY : event.original.clientY
	            };

	            event.original.preventDefault();
	            event.original.stopPropagation();
	            this.blockTouchend = true;

	            this.Page.forEachEditor("saveSelection");

	            this.$lastFocused = this.parent.get$SectionElement().find(":focus");
	        },

	        //uživatel tapnul na zavření UI
	        hideEditUI: function (event) {

	            if (this.startHideCoords) {

	                var currentX = event.original.changedTouches ? event.original.changedTouches[0].clientX : event.original.clientX,
	                    currentY = event.original.changedTouches ? event.original.changedTouches[0].clientY : event.original.clientY;

	                if (Math.abs(this.startHideCoords.x - currentX) || Math.abs(this.startHideCoords.y - currentY)) {

	                    this.startHideCoords = null;

	                    return;
	                }

	                this.startHideCoords = null;
	            }

	            this.set("hover", false);

	            this.setHiddenByUser(true);
	            this.blockTouchend = true;

	            event.original.preventDefault();
	            event.original.stopPropagation();

	            if (event.original.type !== "touchend") {

	                this.Page.forEachEditor("saveSelection");

	                this.$lastFocused = this.parent.get$SectionElement().find(":focus");
	            }

	            if (event.original.type === "touchend") {

	                this.resetFocus();
	            }
	        },

	        //po zavření UI je potřeba vrátit původní :focus a označení textu
	        resetFocus: function () {

	            if (this.$lastFocused) {

	                this.Page.forEachEditor("restoreSelection");

	                this.$lastFocused.focus();
	            }

	            this.blockHover = false;
	        },

	        setHiddenByUser: function (state) {

	            this.hiddenByUser = state;

	            this.self.classList[state ? "add" : "remove"](this.CLASS.hiddenByUser);
	        }
	     });

	}));



/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	/*global $*/
	(function (root, factory) {

	    if (typeof module === 'object' && module.exports) {

	        var Ractive = __webpack_require__(0),
	            ColorPickerPalette = __webpack_require__(14),
	            Spectra = __webpack_require__(29),
	            U = __webpack_require__(4),
	            template = __webpack_require__(184),
	            Select = __webpack_require__(47),
	            Text = __webpack_require__(48),
	            on = __webpack_require__(1);

	        module.exports = factory(Ractive, ColorPickerPalette, Spectra, U, template, Select, Text, on);

	    } else {

	        root.ColorPicker = factory(root.Ractive, root.ColorPickerPalette, root.Spectra, root.U, "", "", "", {client: true});
	    }

	}(this, function (Ractive, ColorPickerPalette, Spectra, U, template, Select, Text, on) {

	    var instanceCounter = 0;

	    return Ractive.extend({

	        COLOR_PICKER: true,

	        template: template,

	        components: {
	            ColorPickerPalette: ColorPickerPalette
	        },

	        partials: {
	            Select: Select,
	            Text: Text
	        },

	        computed: {
	            SVBoxHue: function () {

	                return this.HBoxColor.hue(this.get("hue") || 0).rgbaString();
	            },
	            current: function () {

	                return this.currentColor.rgbaString();
	            }
	        },

	        data: function () {

	            return {
	                initial: "rgb(255, 255, 255)",

	                SVSelector: {
	                    x: 0,
	                    y: 0
	                },

	                HSelector: {
	                    y: 0
	                },

	                animate: false,

	                inputType: "HEX",
	                inputTextHEX: "",
	                inputTextR: "",
	                inputTextG: "",
	                inputTextB: "",

	                TYPE_HEX: "HEX",
	                TYPE_RGB: "RGB",

	                NO_COLOR: "noColor"
	            };
	        },

	        onconstruct: function () {

	            if (on.client) {

	                Ractive.$win = Ractive.$win || $(window);
	            }

	            this.EVENT_NS = "ColorPicker-" + (++instanceCounter);
	        },

	        initializeColors: function () {

	            var input = this.get("input");

	            input = input || this.get("output");

	            if (input) {

	                this.set("initial", input);
	            }

	            var current = input || this.get("initial");

	            this.currentColor = Spectra(current);
	            //slouží pro získání barvy gradientu v SVBoxu
	            this.HBoxColor = Spectra({ h: 0, s: 1, v: 1 });

	            //počáteční hodnoty barvy
	            this.skipUdateCurrent = true;
	            this.set("hue", this.currentColor.hue());
	            this.set("saturation", this.currentColor.saturationv());
	            this.skipUdateCurrent = false;
	            this.set("value", this.currentColor.value());
	        },

	        onconfig: function () {

	            //nenastavovat barvu při otevření pickeru
	            this.waitForUserInteraction = !!this.get("defer");

	            this.initializeColors();

	            this.observeColorComponents();

	            this.observe("current", this.currentColorObserver, {init: false});

	            this.observeSelectors();

	            this.updateInputFields();

	            this.observe("input", function (value) {

	                //                                        this.waitForUserInteraction = this.get("defer");
	                //
	                //                    this.initializeColors();
	                //
	                //                    this.moveSelectorsToCurrentColorPosition(true);
	                //
	                //                    this.waitForUserInteraction = false;

	            }, {init: false});

	            this.on("inputTextHEXChanged", this.inputTextHEXChanged);
	            this.on("inputTextRGBChanged", this.inputTextRGBChanged);
	        },

	        currentColorObserver: function () {

	            if (this.skipUpdateCurrent)  {

	                return;
	            }

	            //pokud se saturace změní na 0, pak si barva nezachová odstín
	            if (!this.preserveCurrentColorHue) {

	                this.skipHueObserver = this.skipUpdateColor;

	                this.set("hue", this.currentColor.hue());

	                this.skipHueObserver = false;
	            }

	            //pokud si barva nezachovala odstín (černá / bílá) je potřeba ho vrátit, jakmile barva není bílá nebo černá
	            if (!this.skipUpdateColor && this.currentColor.hue() !== this.HBoxColor.hue() && (this.currentColor.saturationv() || this.currentColor.value())) {

	                var saturation = this.get("saturation");

	                //Pokud se nastaví černá, saturace se nastaví na 0, když se pak jede po hraně boxu (mění se "value"),
	                //hodnota "saturation" se nezmění (nespustí se observer) a barva tak zůstane šedá.
	                if (saturation && saturation !== this.currentColor.saturationv()) {

	                    this.currentColor.saturationv(saturation);
	                }

	                this.currentColor.hue(this.HBoxColor.hue());
	            }

	            if (!this.waitForUserInteraction) {

	                this.set("output", this.getCurrentRGB());
	                this.fire("output", this.getCurrentRGB());
	            }

	            this.updateInputFields();
	        },

	        observeColorComponents: function () {

	            this.observe("hue", function (hue) {

	                if (this.skipHueObserver) {

	                    return;
	                }

	                this.HBoxColor.hue(hue);

	                this.currentColor.hue(hue);

	                this.update("current");

	            }, {init: false});

	            this.observe("saturation", function (saturation) {

	                this.currentColor.saturationv(saturation);

	                if (!this.skipUpdateSV) {

	                    this.preserveCurrentColorHue = true;

	                    this.update("current");

	                    this.preserveCurrentColorHue = false;
	                }

	            }, {init: false});

	            this.observe("value", function (value) {

	                this.currentColor.value(value);

	                if (!this.skipUpdateSV) {

	                    this.preserveCurrentColorHue = true;

	                    this.update("current");

	                    this.preserveCurrentColorHue = false;
	                }

	            }, {init: false});
	        },

	        observeSelectors: function () {

	            this.observe("HSelector.y", function () {

	                if (!this.skipUpdateColor) {

	                    this.updateHue.apply(this, arguments);
	                }
	            }, {init: false});

	            this.observe("SVSelector", function () {

	                if (!this.skipUpdateColor) {

	                    this.preserveCurrentColorHue = true;

	                    this.skipUpdateSV = true;

	                    this.updateSaturationAndValue.apply(this, arguments);

	                    this.skipUpdateSV = false;

	                    this.preserveCurrentColorHue = false;
	                }
	            }, {init: false});
	        },

	        onrender: function () {

	            if (on.client) {

	                this.initPalettes();

	                this.SVBox = this.find(".ColorPicker--SV-box");
	                this.SVSelector = this.find(".ColorPicker--SV-selector");

	                this.HBox = this.find(".ColorPicker--H-box");
	                this.HSelector = this.find(".ColorPicker--H-selector");

	                this.$self = $(this.find(".ColorPicker"));

	                this.moveSelectorsToCurrentColorPosition();

	                if (!this.waitForUserInteraction) {

	                    this.fire("output", this.getCurrentRGB());
	                }

	                Ractive.$win.on("resize." + this.EVENT_NS, this.windowResizeHandler.bind(this));

	                var pageElementSettings = this.findParent("PageElementSettings");

	                if (pageElementSettings) {

	                    pageElementSettings.observe("resizableElementWidth resizableElementHeight", this.windowResizeHandler.bind(this), {init: false});
	                }

	                this.waitForUserInteraction = false;
	            }
	        },

	        initPalettes: function () {

	            this.palettes = this.findAllComponents("ColorPickerPalette");

	            var p = this.palettes.length - 1;

	            for (p; p >= 0; p--) {

	                this.palettes[p].on("setColor", function (event, color, animate) {

	                    this.setColor(color, animate);

	                    event.original.preventDefault();

	                }.bind(this));
	            }
	        },

	        onteardown: function () {

	            Ractive.$win.off("." + this.EVENT_NS);
	            this.$self.off("." + this.EVENT_NS);
	        },

	        windowResizeHandler: function () {

	            clearTimeout(this.windowResizeThrottle);

	            this.windowResizeThrottle = setTimeout(function() {

	                this.moveSelectorsToCurrentColorPosition();

	            }.bind(this), 100);
	        },

	        getCurrentRGB: function () {

	            return "rgb(" + this.currentColor.red() + ", " + this.currentColor.green() + ", " + this.currentColor.blue() + ")";
	        },

	        updateInputFields: function () {

	            this.set("inputTextHEX", this.currentColor.hex());
	            this.set("inputTextR",   this.currentColor.red());
	            this.set("inputTextG",   this.currentColor.green());
	            this.set("inputTextB",   this.currentColor.blue());
	        },

	        updateSaturationAndValue: function () {

	            this.updateSaturation();
	            this.updateValue();

	            this.update("current");
	        },

	        updateSaturation: function () {

	            var width = this.SVBox.offsetWidth,

	                x = this.get("SVSelector.x"),

	                saturation = Math.min(1, Math.max(0, (x / width)));

	            this.set("saturation", saturation);
	        },

	        updateValue: function () {

	            var height = this.SVBox.offsetHeight,

	                y = this.get("SVSelector.y"),

	                value = 1 - Math.min(1, Math.max(0, (y / height)));

	            this.set("value", value);
	        },

	        updateHue: function () {

	            var height = this.HBox.offsetHeight,

	                y = this.get("HSelector.y"),

	                hue = 360 - Math.min(360, Math.max(0, (y / height) * 360));

	            this.preserveCurrentColorHue = true;

	            this.set("hue", hue);

	            this.preserveCurrentColorHue = false;
	        },

	        moveSelectorsToCurrentColorPosition: function (animate) {

	            this.moveHSelector(this.getHSelectorPosition(), animate);
	            this.moveSVSelector(this.getSSelectorPosition(), this.getVSelectorPosition(), animate);
	        },

	        moveSVSelector: function (x, y, animate) {

	            if (this.SVSelector) {

	                var width = this.SVBox.offsetWidth,
	                    height = this.SVBox.offsetHeight;

	                x = Math.min(width, Math.max(0, x));
	                y = Math.min(height, Math.max(0, y));

	                this.set("animate", !!animate);

	                this.set("SVSelector", {
	                    x: x,
	                    y: y
	                });
	            }
	        },

	        moveHSelector: function (y, animate) {

	            if (this.HSelector) {

	                var height = this.HBox.offsetHeight;

	                y = Math.min(height, Math.max(0, y));

	                this.set("animate", !!animate);

	                this.set("HSelector.y", y);
	            }
	        },

	        setColor: function (color, animate) {

	            if (color === this.get("NO_COLOR")) {

	                this.set("output", "");
	                this.fire("output", "");

	                return;
	            }

	            this.currentColor = Spectra(color);

	            //při zadávání barvy klávesnicí může dojít k malé změně barvy,
	            //proto je potřeba zabránit její změně
	            this.skipUpdateColor = true;

	            this.moveSVSelector(this.getSSelectorPosition(), this.getVSelectorPosition(), animate);

	            //nastavuje se černá nebo bílá barva, sytost by tak zmizela (nastavila se červená - 0)
	            this.preserveCurrentColorHue = !this.currentColor.saturationv() || !this.currentColor.value();

	            this.update("current");

	            this.moveHSelector(this.getHSelectorPosition(), animate);

	            this.preserveCurrentColorHue = false;

	            this.skipUpdateColor = false;
	        },

	        getHSelectorPosition: function () {

	            return this.HBox.offsetHeight - ((this.HBox.offsetHeight * (this.HBoxColor.hue() / 360) || this.HBox.offsetHeight));
	        },

	        getSSelectorPosition: function () {

	            return this.SVBox.offsetWidth * this.currentColor.saturationv();
	        },

	        getVSelectorPosition: function () {

	            return this.SVBox.offsetHeight * (1 - this.currentColor.value());
	        },

	        activateSelector: function(e, type) {

	            var eventData = U.eventData(e);

	            if (eventData.pointers > 1) {

	                this.$self.off("mousemove." + this.EVENT_NS + " touchmove." + this.EVENT_NS + " mouseup." + this.EVENT_NS + " touchend." + this.EVENT_NS);

	                clearTimeout(this[type === "SV" ? "moveSVToPositionTimeout"   : "moveHToPositionTimeout"]);

	                return;
	            }

	            this.fire("activated", this);

	            var moveData = {};

	            moveData.type = type;

	            moveData.movedToPosition = false;

	            moveData.selector              = type === "SV" ? ".ColorPicker--SV-selector" : ".ColorPicker--H-selector";
	            moveData.moveToPositionTimeout = type === "SV" ? "moveSVToPositionTimeout"   : "moveHToPositionTimeout";
	            moveData.moveSelectorFn        = type === "SV" ? "moveSVSelector"            : "moveHSelector";
	            moveData.dataSelector          = type === "SV" ? "SVSelector"                : "HSelector";

	            moveData.$selector = $(eventData.target).closest(moveData.selector);

	            moveData.selectorPosition = moveData.$selector.position();

	            moveData.initPositions = {};

	            moveData.initPositions.pointerY = eventData.clientY;
	            moveData.initPositions.pointerX = eventData.clientX;

	            moveData.initPositions.handleY = this.get(moveData.dataSelector + ".y");

	            if (type === "SV") {

	                moveData.initPositions.handleX = this.get(moveData.dataSelector + ".x");
	            }

	            moveData.initPositions.startOffsetX = eventData.offsetX;
	            moveData.initPositions.startOffsetY = eventData.offsetY;

	            //událost vznikla na selektoru - je potřeba upravit pozici
	            if (moveData.$selector.length) {

	                moveData.initPositions.startOffsetX += moveData.selectorPosition.left;
	                moveData.initPositions.startOffsetY += moveData.selectorPosition.top;
	            }

	            moveData.moveToStartEventPosition = function (animate, byEndEvent) {

	                var args = [moveData.initPositions.startOffsetY, animate];

	                if (type === "SV") {

	                    args.unshift(moveData.initPositions.startOffsetX);
	                }

	                this[moveData.moveSelectorFn].apply(this, args);

	                if (!byEndEvent) {

	                    if (type === "SV") {

	                        moveData.initPositions.handleY = this.getVSelectorPosition();
	                        moveData.initPositions.handleX = this.getSSelectorPosition();

	                    } else {

	                        moveData.initPositions.handleY = this.getHSelectorPosition();
	                    }
	                }

	                moveData.movedToPosition = true;

	            }.bind(this);

	            clearTimeout(this[moveData.moveToPositionTimeout]);

	            //pokud uživatel nepohne myší/prstem => přesunout na místo
	            this[moveData.moveToPositionTimeout] = setTimeout(moveData.moveToStartEventPosition.bind(this, true), eventData.isTouchEvent ? 200 : 100);

	            if (eventData.type === "mousedown") {

	                Ractive.$win
	                    .off("mousemove." + this.EVENT_NS + " mouseup." + this.EVENT_NS)
	                    .on( "mousemove." + this.EVENT_NS, this.handlePointerMoveEvent.bind(this, moveData))
	                    .one("mouseup."   + this.EVENT_NS, this.handlePointerEndEvent.bind(this, moveData));

	            } else {

	                this.$self
	                    .off("touchmove." + this.EVENT_NS + " touchend." + this.EVENT_NS)
	                    .on( "touchmove." + this.EVENT_NS, this.handlePointerMoveEvent.bind(this, moveData))
	                    .one("touchend."  + this.EVENT_NS, this.handlePointerEndEvent.bind(this, moveData));
	            }

	            eventData.preventDefault();
	        },

	        handlePointerMoveEvent: function (moveData, e) {

	            var eventData = U.eventData(e);

	            if (eventData.pointers > 1) {

	                clearTimeout(this[moveData.moveToPositionTimeout]);

	                this.$self.off("touchmove." + this.EVENT_NS + " touchend." + this.EVENT_NS);
	                Ractive.$win.off("mousemove." + this.EVENT_NS + " mouseup." + this.EVENT_NS);

	                return;
	            }

	            if (!moveData.movedToPosition) {

	                clearTimeout(this[moveData.moveToPositionTimeout]);

	                //nejdříve je potřeba přesunout selektor na pozici myši/prstu
	                moveData.moveToStartEventPosition();
	            }

	            var args = [
	                moveData.initPositions.handleY + eventData.clientY - moveData.initPositions.pointerY
	            ];

	            if (moveData.type === "SV") {

	                args.unshift(moveData.initPositions.handleX + eventData.clientX - moveData.initPositions.pointerX);
	            }

	            this[moveData.moveSelectorFn].apply(this, args);

	            return false;
	        },

	        handlePointerEndEvent: function (moveData) {

	            if (!moveData.movedToPosition) {

	                clearTimeout(this[moveData.moveToPositionTimeout]);

	                moveData.moveToStartEventPosition(true, true);
	            }

	            this.$self.off("touchmove." + this.EVENT_NS);
	            Ractive.$win.off("mousemove." + this.EVENT_NS);

	            return false;
	        },

	        validateRGB: function (color) {

	            return /^\s*rgb\(\s*(?:\d{1,3})\s*,\s*(?:\d{1,3})\s*,\s*(?:\d{1,3})\s*\)\s*$/.test(color);
	        },

	        validateHEX: function (color) {

	            return /^\s*#?[0-9a-f]{6}\s*$/i.test(color);
	        },

	        inputTextHEXChanged: function () {

	            var currentHEX = this.get("inputTextHEX");

	            if (this.validateHEX(currentHEX)) {

	                this.setColor(~currentHEX.indexOf("#") ? currentHEX : "#" + currentHEX, true);

	            } else {

	                var hash = currentHEX.indexOf("#"),
	                    ch = currentHEX.length;

	                //zkrátit příliš dlouhou hodnotu
	                if ((ch > 6 && !~hash) || (ch > 7 && ~hash)) {

	                    currentHEX = currentHEX.substr(0, 7 + currentHEX.indexOf("#"));

	                    ch = currentHEX.length - 1;
	                }

	                //písmena "větší" než f změnit na f
	                for (--ch; ch >= 0; ch--) {

	                    if (currentHEX[ch] !== "#" && isNaN(parseInt(currentHEX[ch], 16))) {

	                        currentHEX = currentHEX.substr(0, ch) + "f" + currentHEX.substr(ch + 1);
	                    }
	                }

	                this.set("inputTextHEX", currentHEX);

	                if (this.validateHEX(currentHEX)) {

	                    this.setColor(~hash ? currentHEX : "#" + currentHEX, true);
	                }
	            }
	        },

	        inputTextRGBChanged: function () {

	            var red = this.get("inputTextR"),
	                green = this.get("inputTextG"),
	                blue = this.get("inputTextB");

	            if (red === "" || green === "" || blue === "") {

	                return;
	            }

	            var currentRGB = "rgb(" + red + ", " + green + ", " + blue + ")";

	            if (this.validateRGB(currentRGB)) {

	                this.setColor(currentRGB, true);

	            } else {

	                red = Math.min(255, Math.max(0, red));
	                green = Math.min(255, Math.max(0, green));
	                blue = Math.min(255, Math.max(0, blue));

	                this.set("inputTextR", red || 0);
	                this.set("inputTextG", green || 0);
	                this.set("inputTextB", blue || 0);

	                this.inputTextRGBChanged();
	            }
	        }

	    });

	}));


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	/*global $, MutationObserver*/
	var Ractive = __webpack_require__(0),

	    U = __webpack_require__(4),

	    EventEmitter = __webpack_require__(6)();

	var CLASS = {
	        resizableElement: "ResizableBox",
	        resizableBox: "ResizableBox--self",

	        scrollingElement: "ResizableBox--scrollable",
	        scrollingContent: "ResizableBox--scrolling-content",

	        resizer: "ResizableBox--resizer",
	        resizerActive: "ResizableBox--resizer__active",

	        minmax: "ResizableBox--min-max",
	        minmaxMax: "ResizableBox--min-max__max",
	        minmaxMin: "ResizableBox--min-max__min"
	    },

	    instanceCounter = 0;

	var ResizableBox = function () {

	    return initResizableBox.apply(this.decorators.ResizableBox ? this : this.parent, arguments);
	};

	var initResizableBox = function (node, floating, wheelPropagation) {

	    Ractive.$win = Ractive.$win || $(window);

	    this.BOX_EVENT_NS = "ResizableBox-" + (++instanceCounter);
	    this.floating = floating;

	    this.minmaxing = true;

	    this.getBoxHeight = ResizableBox.getBoxHeight.bind(this);
	    this.getBoxWidth = ResizableBox.getBoxWidth.bind(this);
	    this.activateResizer = ResizableBox.activateResizer.bind(this);
	    this.minmax = ResizableBox.minmax.bind(this);

	    var originalComplete = this.oncomplete;

	    this.oncomplete = function () {

	        ResizableBox.oncomplete.call(this);

	        originalComplete.apply(this, arguments);
	    };

	    this.self = this.self || this.find("." + this.CLASS.self);
	    this.$self = this.$self || $(this.self);
	    this.resizableBox  = node;
	    this.$resizableBox = $(node);
	    this.$scrollingElement = this.$resizableBox.is("." + CLASS.scrollingElement) ? this.$resizableBox : this.$resizableBox.find("." + CLASS.scrollingElement);
	    this.$scrollingContent = this.$scrollingElement.find("." + CLASS.scrollingContent);
	    this.resizableElement = this.find("." + CLASS.resizableElement);
	    this.$resizableElement = $(this.resizableElement);

	    this.minmaxButton = this.find("." + CLASS.minmax);

	    this.minmaxButton.classList.add(CLASS.minmaxMin);
	    this.resizableBox.classList.add(CLASS.resizableBox);

	    this.initHeight = this.getBoxHeight();

	    if (floating) {

	        this.initWidth = this.getBoxWidth();
	    }

	    this.beforeHeight = this.initHeight;

	    if (floating) {

	        this.beforeWidth = this.initWidth;
	    }

	    this.minHeight = parseFloat(this.$resizableElement.css("min-height")) || 0;

	    if (floating) {

	        this.minWidth = parseFloat(this.$resizableElement.css("min-width")) || 0;
	    }

	    this.minResizeHeight = parseFloat(this.$resizableBox.attr("data-min-resize-height")) || 0;
	    this.maxResizeHeight = parseFloat(this.$resizableBox.attr("data-max-resize-height")) || 0;

	    if (floating) {

	        this.minResizeWidth = parseFloat(this.$resizableBox.attr("data-min-resize-width")) || 0;
	        this.maxResizeWidth = parseFloat(this.$resizableBox.attr("data-max-resize-width")) || 0;

	        if (this.maxResizeWidth) {

	            if (this.maxResizeWidth > window.innerWidth) {

	                this.maxResizeWidth = window.innerWidth - 20;

	            }

	            Ractive.$win.on("resize." + this.BOX_EVENT_NS, function () {

	                if (this.maxResizeWidth > window.innerWidth) {

	                    this.maxResizeWidth = window.innerWidth - 20;

	                } else {

	                    this.minResizeWidth  = parseFloat(this.$resizableBox.attr("data-min-resize-width")) || 0;
	                }

	            }.bind(this));
	        }
	    }

	    this.lastRects = ResizableBox.getRectsForScrollables.call(this);
	    this.lastMutation = +new Date();

	    this.contentObserver = new MutationObserver(ResizableBox.contentMutationObserver.bind(this));

	    ResizableBox.initChangeObservers.call(this);

	    this.$scrollingElement
	        .css({
	            position: "relative"
	        })
	        .perfectScrollbar({
	            wheelPropagation: wheelPropagation || false,
	            swipePropagation: true
	        });

	    this.observe("resizableElementHeight", ResizableBox.observeHeight, {init: false});
	    this.observe("resizableElementWidth", ResizableBox.observeWidth, {init: false});

	    if (this.onresizableboxinit) {

	        this.onresizableboxinit();
	    }

	    var _this = this;

	    return {
	        teardown: function () {

	            ResizableBox.cancelChangeObservers.call(_this);

	            clearTimeout(_this.sizeTimeout);
	            clearTimeout(_this.transitionTimeout);
	            clearTimeout(_this.refreshThrottle);

	            _this.$scrollingElement
	                .css({
	                    position: ""
	                })
	                .perfectScrollbar("destroy");

	            Ractive.$win.off("." + _this.BOX_EVENT_NS);
	        }
	    };
	};

	ResizableBox.refreshScrollbars = function () {

	    clearTimeout(this.refreshThrottle);

	    this.refreshThrottle = setTimeout(function() {

	        this.$scrollingElement.each(function (i, element) {

	            var $element = $(element),

	                elementRect = element.getBoundingClientRect(),
	                contentRect = element.firstChild.getBoundingClientRect();

	            if (elementRect.bottom > contentRect.bottom) {

	                $element.stop()
	                    .animate({
	                        scrollTop: element.firstChild.offsetHeight - element.offsetHeight
	                    }, {
	                        duration: 200,
	                        progress: function () {
	                            clearTimeout(this.refreshThrottle);
	                        }.bind(this),
	                        complete: function () {
	                            $element.perfectScrollbar("update");
	                        }
	                    });

	            } else if (elementRect.bottom < contentRect.bottom) {

	                $element.stop().perfectScrollbar("update");
	            }
	        }.bind(this));

	    }.bind(this), 50);
	};

	ResizableBox.getRectsForScrollables = function () {

	    var rects = {};

	    if (this.$scrollingContent) {

	        this.$scrollingContent.each(function (i, el) {

	            rects[i] = el.getBoundingClientRect();
	        });
	    }

	    return rects;
	};

	ResizableBox.onContentChange = function (delay) {

	    var currentRects = ResizableBox.getRectsForScrollables.call(this);

	    $.each(currentRects, function (i, rect) {

	        if (rect.width !== this.lastRects[i].width || rect.height !== this.lastRects[i].height) {

	            var isMax = this.minmaxButton.classList.contains(CLASS.minmaxMax) && !this.minmaxButton.classList.contains(CLASS.minmaxMin),
	                isMin = !isMax;

	            clearTimeout(this.sizeTimeout);

	            this.set("resizableElementHeight", this.getBoxHeight());

	            if (this.floating) {

	                this.set("resizableElementWidth", this.getBoxWidth());
	            }

	            this.sizeTimeout = setTimeout(function() {

	                if (isMin) {

	                    this.beforeHeight = this.getBoxHeight();

	                    if (this.floating) {

	                        this.beforeWidth = this.getBoxWidth();
	                    }
	                }

	                if (!this.wasResized) {

	                    this.minmax(null, isMax, isMin);

	                } else {

	                    this.wasResized = false;

	                    this.set("resizableElementHeight", this.getBoxHeight());

	                    if (this.floating) {

	                        this.set("resizableElementWidth", this.getBoxWidth());
	                    }
	                }

	            }.bind(this), delay || 50);

	            return false;
	        }

	    }.bind(this));

	    this.lastRects = currentRects;
	};

	ResizableBox.observeHeight =  function (height) {

	    if (height < this.minHeight) {

	        height = this.minHeight;

	        this.set("resizableElementHeight", this.minHeight);
	    }

	    if (this.maxResizeHeight && height > this.maxResizeHeight) {

	        height = this.maxResizeHeight;

	        this.set("resizableElementHeight", this.maxResizeHeight);
	    }

	    this.resizableBox.style.maxHeight = height + "px";

	    if (this.minResizeHeight) {

	        this.resizableBox.style.minHeight = height >= this.minResizeHeight ? this.minResizeHeight + "px" : height + "px";
	    }

	    if (!this.doNotUpdateScrollbars) {

	        ResizableBox.refreshScrollbars.call(this);
	    }
	};

	ResizableBox.observeWidth =  function (width) {

	    if (width < this.minWidth) {

	        width = this.minWidth;

	        this.set("resizableElementWidth", this.minWidth);
	    }

	    if (this.maxResizeWidth && width > this.maxResizeWidth) {

	        width = this.maxResizeWidth;

	        this.set("resizableElementWidth", this.maxResizeWidth);
	    }

	    this.resizableBox.style.maxWidth = width + "px";

	    if (this.minResizeWidth) {

	        this.resizableBox.style.minWidth = width >= this.minResizeWidth ? this.minResizeWidth + "px" : width + "px";
	    }

	    if (!this.doNotUpdateScrollbars) {

	        ResizableBox.refreshScrollbars.call(this);
	    }
	};

	ResizableBox.contentMutationObserver = function (mutations) {

	    var currentTime = +new Date();

	    if (currentTime - this.lastMutation < 50) {

	        this.lastMutation = currentTime;

	        return;
	    }

	    var m = mutations.length - 1,
	        scrollbarMutations = 0;

	    for (m; m >= 0; m--) {

	        if (mutations[m].target && mutations[m].target.className && mutations[m].target.className.match("ps-scrollbar")) {

	            scrollbarMutations++;
	        }
	    }

	    if (mutations.length === scrollbarMutations) {

	        return;
	    }

	    if (this.find("." + CLASS.resizerActive)) {

	        return;
	    }

	    if (!this.minmaxing) {

	        var css = {
	            transition: "none",
	            height: this.getBoxHeight()
	        };

	        if (this.floating) {

	            css.width = this.getBoxWidth();
	        }

	        this.$resizableBox.css(css);
	    }

	    this.lastMutation = currentTime;

	    ResizableBox.onContentChange.call(this);
	};

	ResizableBox.initChangeObservers = function () {

	    EventEmitter
	        .off("change.resizableBox." + this.BOX_EVENT_NS)
	        .on( "change.ResizableBox." + this.BOX_EVENT_NS, function () {
	            ResizableBox.contentMutationObserver.call(this, [{}]);
	        }.bind(this));

	    this.contentObserver.disconnect();

	    this.contentObserver.observe(this.resizableBox, { attributes: true, childList: true, characterData: true, subtree: true });

	    clearInterval(this.interval);

	    this.interval = setInterval(function () {
	        ResizableBox.contentMutationObserver.call(this, [{}]);
	    }.bind(this), 1000);
	};

	ResizableBox.cancelChangeObservers = function () {

	    clearInterval(this.interval);

	    EventEmitter.off("change.resizableBox." + this.BOX_EVENT_NS);

	    this.contentObserver.disconnect();
	};

	ResizableBox.minmax = function (event, forceMax, forceMin) {

	    if (this.minmaxing && !event) {

	        this.nextRequest = true;

	        return;
	    }

	    this.minmaxing = true;

	    ResizableBox.cancelChangeObservers.call(this);

	    if (event) {

	        event.original.srcEvent.stopPropagation();
	        event.original.srcEvent.preventDefault();
	    }

	    //posuvníky je potřeba aktualizovat až na konci
	    this.doNotUpdateScrollbars = true;

	    this.$resizableBox
	        .off("transitionend.resize-" + this.BOX_EVENT_NS)
	        .css({
	            transition: "none"
	        });

	    clearTimeout(this.clearAnimStyles);
	    clearTimeout(this.transitionTimeout);

	    this.resizableBox.style.height = "";

	    if (this.floating) {

	        this.resizableBox.style.width = "";
	    }

	    var currentHeight = this.get("resizableElementHeight"),
	        currentWidth,

	        maximize = false;

	    if (this.floating) {

	        currentWidth = this.get("resizableElementWidth");
	    }

	    //zmenšit na výchozí velikost
	    if (forceMin || (!forceMax && this.minmaxButton.classList.contains(CLASS.minmaxMax))) {

	        var sameAsBefore;

	        if (this.floating) {

	            sameAsBefore = !forceMin && this.beforeHeight === currentHeight && this.beforeWidth === currentWidth;

	            this.set("resizableElementHeight", sameAsBefore ? this.initHeight : forceMin ? this.userDefHeight: this.beforeHeight);
	            this.set("resizableElementWidth" , sameAsBefore ? this.initWidth  : forceMin ? this.userDefWidth: this.beforeWidth);

	            if (!forceMin) {

	                this.userDefHeight = this.get("resizableElementHeight");
	                this.userDefWidth  = this.get("resizableElementWidth");
	            }

	        } else {

	            sameAsBefore = !forceMin && this.beforeHeight === currentHeight;

	            this.set("resizableElementHeight", sameAsBefore ? this.initHeight : forceMin ? this.userDefHeight: this.beforeHeight);
	        }

	        this.minmaxButton.classList.remove(CLASS.minmaxMax);
	        this.minmaxButton.classList.add(CLASS.minmaxMin);

	        //zvětšit na maximální velikost
	    } else {

	        if (!forceMax) {

	            this.beforeHeight = this.get("resizableElementHeight");
	        }

	        if (this.maxResizeHeight) {

	            this.set("resizableElementHeight", this.maxResizeHeight);
	        }

	        if (this.floating) {

	            if (!forceMax) {

	                this.beforeWidth = this.get("resizableElementWidth");
	            }

	            if (this.maxResizeWidth) {

	                this.set("resizableElementWidth", this.maxResizeWidth);
	            }
	        }

	        this.minmaxButton.classList.remove(CLASS.minmaxMin);
	        this.minmaxButton.classList.add(CLASS.minmaxMax);

	        maximize = true;
	    }

	    var offset, selfRect, resizableBoxRect;

	    if (this.floating) {

	        offset   = this.$self.offset();
	        selfRect = this.self.getBoundingClientRect();
	    }

	    //zjistit konečné rozměry boxu
	    resizableBoxRect = this.resizableBox.getBoundingClientRect();

	    //použije se, pokud nenastane transitionend
	    this.clearAnimStyles = setTimeout(function () {

	        if (this.minResizeHeight) {

	            this.resizableBox.style.minHeight = resizableBoxRect.height >= this.minResizeHeight ? this.minResizeHeight + "px" : resizableBoxRect.height + "px";
	        }

	        if (this.floating && this.minResizeWidth) {

	            this.resizableBox.style.minWidth = resizableBoxRect.width >= this.minResizeWidth ? this.minResizeWidth + "px" : resizableBoxRect.width + "px";
	        }

	        ResizableBox.initChangeObservers.call(this);

	    }.bind(this), 1000);

	    //po zjištění rozměrů po změně velikosti, je potřeba vrátit původní hodnoty kvůli animaci
	    this.set("resizableElementHeight", currentHeight);

	    if (this.floating) {

	        this.set("resizableElementWidth", currentWidth);
	    }

	    //pokud se velikost nezmění může se funkce ukončit
	    if (resizableBoxRect.height === currentHeight && (!this.floating || resizableBoxRect.width === currentWidth)) {

	        this.doNotUpdateScrollbars = false;

	        this.minmaxing = false;

	        clearTimeout(this.clearAnimStyles);

	        ResizableBox.refreshScrollbars.call(this);

	        ResizableBox.initChangeObservers.call(this);

	        return;
	    }

	    //začátek animace: zafixování současné velikosti
	    this.resizableBox.style.height = currentHeight + "px";

	    //Je potřeba odstranit maxVelikost, aby bylo možné roztáhnout element na požadovanou velikost.
	    //V případě, že se změní obsah a box není maximalizovaný, je potřeba velikost zafixovat,
	    //protože by měla zůstat stejná.
	    this.resizableBox.style.maxHeight = (forceMin ? this.userDefHeight + "px" : "none");

	    if (maximize && this.maxResizeHeight) {

	        this.resizableBox.style.maxHeight = this.maxResizeHeight + "px";
	    }

	    this.resizableBox.style.minHeight = this.minHeight + "px";

	    if (this.floating) {

	        //začátek animace: zafixování současné velikosti
	        this.resizableBox.style.width = currentWidth + "px";

	        //Je potřeba odstranit maxVelikost, aby bylo možné roztáhnout element na požadovanou velikost.
	        //V případě, že se změní obsah a box není maximalizovaný, je potřeba velikost zafixovat,
	        //protože by měla zůstat stejná.
	        this.resizableBox.style.maxWidth = (forceMin ? this.userDefWidth + "px" : "none");

	        if (maximize && this.maxResizeWidth) {

	            this.resizableBox.style.maxWidth = this.maxResizeWidth + "px";
	        }

	        this.resizableBox.style.minWidth = this.minWidth + "px";
	    }

	    this.transitionTimeout = setTimeout(function() {

	        //spuštění animace: konečná velikost
	        this.resizableBox.style.height = resizableBoxRect.height + "px";

	        if (this.floating) {

	            this.resizableBox.style.width = resizableBoxRect.width + "px";
	        }

	        var eventId = +new Date();

	        this.$resizableBox
	            .css({
	                transition: ""
	            })
	            .on("transitionend.resize-" + this.BOX_EVENT_NS + "." + eventId, function (e) {

	            if (e.originalEvent.propertyName === "height" || (this.floating && e.originalEvent.propertyName === "width")) {

	                //iOS fix
	                this.$resizableBox.css({
	                    transition: "none"
	                });

	                this.$resizableBox.off("transitionend.resize-" + this.BOX_EVENT_NS + "." + eventId);

	                //přiřadit aktuální vekost do max-rozměrů pro správnou funkčnost roztahování
	                this.set("resizableElementHeight", this.getBoxHeight());

	                if (this.floating) {

	                    this.set("resizableElementWidth", this.getBoxWidth());
	                }

	                if (this.minResizeHeight) {

	                    this.resizableBox.style.minHeight = resizableBoxRect.height >= this.minResizeHeight ? this.minResizeHeight + "px" : resizableBoxRect.height + "px";
	                }

	                if (this.floating && this.minResizeWidth) {

	                    this.resizableBox.style.minWidth = resizableBoxRect.width >= this.minResizeWidth ? this.minResizeWidth + "px" : resizableBoxRect.width + "px";
	                }

	                clearTimeout(this.clearAnimStyles);

	                ResizableBox.refreshScrollbars.call(this);

	                if (this.floating) {

	                    this.transitionTimeout = setTimeout(function() {

	                        this.$resizableBox.css({
	                            transition: ""
	                        });

	                        if (this.nextRequest) {

	                            this.nextRequest = false;

	                            ResizableBox.onContentChange.call(this, 100);
	                        }

	                        ResizableBox.initChangeObservers.call(this);

	                        this.minmaxing = false;

	                    }.bind(this), 0);

	                } else {

	                    this.$resizableBox.css({
	                        transition: ""
	                    });

	                    ResizableBox.initChangeObservers.call(this);

	                    this.minmaxing = false;

	                    if (this.nextRequest) {

	                        this.nextRequest = false;

	                        ResizableBox.onContentChange.call(this, 100);
	                    }
	                }
	            }
	        }.bind(this));

	        if (this.onresizableboxend) {

	            if (this.floating) {

	                this.onresizableboxend(offset, selfRect);

	            } else {

	                this.onresizableboxend(resizableBoxRect, true);
	            }
	        }

	        this.doNotUpdateScrollbars = false;

	    }.bind(this), 20);
	};

	ResizableBox.getBoxHeight = function () {

	    return this.resizableElement.getBoundingClientRect().height;
	};

	ResizableBox.getBoxWidth = function () {

	    return this.resizableElement.getBoundingClientRect().width;
	};

	ResizableBox.oncomplete = function () {

	    this.set("resizableElementHeight", this.getBoxHeight());

	    this.userDefHeight = this.get("resizableElementHeight");

	    if (this.floating) {

	        this.set("resizableElementWidth", this.getBoxWidth());

	        this.userDefWidth = this.get("resizableElementWidth");
	    }

	    this.minmaxing = false;
	};

	ResizableBox.activateResizer = function (e, position) {

	    var eventData = U.eventData(e),

	        lastY = eventData.clientY,
	        lastX = eventData.clientX,

	        resized = false;

	    if (eventData.pointers > 1) {

	        return;
	    }

	    if (this.$self) {

	        this.$self.css({
	            transition: "none"
	        });
	    }

	    eventData.target.classList.add(CLASS.resizerActive);

	    Ractive.$win
	        .off("mousemove." + this.BOX_EVENT_NS + " touchmove." + this.BOX_EVENT_NS)
	        .on("mousemove." + this.BOX_EVENT_NS + " touchmove." + this.BOX_EVENT_NS, function (e) {

	            var eventData = U.eventData(e);

	            if (eventData.pointers > 1) {

	                return;
	            }

	            if (this.$resizableBox) {

	                var css = {
	                    transition: "none",
	                    height: ""
	                };

	                if (this.floating) {

	                    css.width = "";
	                }

	                this.minmaxButton.classList.remove(CLASS.minmaxMax);

	                this.$resizableBox.css(css);
	            }

	            if (position.match(/bottom|top/)) {

	                var diffY = position.match(/bottom/) ? eventData.clientY - lastY : lastY - eventData.clientY;

	                this.set("resizableElementHeight", this.getBoxHeight() + diffY);
	            }

	            if (position.match(/left|right/)) {

	                var diffX = position.match(/right/) ? eventData.clientX - lastX : lastX - eventData.clientX;

	                this.set("resizableElementWidth" , this.getBoxWidth()  + diffX);
	            }

	            if (this.onresizableboxresize) {

	                this.onresizableboxresize(position);
	            }

	            lastY = eventData.clientY;
	            lastX = eventData.clientX;

	            resized = true;

	            e.preventDefault();
	            return false;

	        }.bind(this))
	        .one("mouseup." + this.BOX_EVENT_NS + " touchend." + this.BOX_EVENT_NS, function (e) {

	        this.wasResized = resized;

	        eventData.target.classList.remove(CLASS.resizerActive);

	        if (resized) {

	            this.set("resizableElementHeight", this.getBoxHeight());

	            this.userDefHeight = this.get("resizableElementHeight");

	            if (this.floating) {

	                this.set("resizableElementWidth", this.getBoxWidth());

	                this.userDefWidth = this.get("resizableElementWidth");
	            }

	            setTimeout(function() {

	                this.wasResized = false;

	            }.bind(this), 0);
	        }

	        if (this.$self) {

	            this.$self.css({
	                transition: ""
	            });
	        }

	        Ractive.$win.off("mousemove." + this.BOX_EVENT_NS + " touchmove." + this.BOX_EVENT_NS);

	        e.preventDefault();
	        return false;

	    }.bind(this));

	    eventData.preventDefault();
	    return false;
	};

	module.exports = ResizableBox;


/***/ },
/* 24 */
/***/ function(module, exports) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	/*global jQuery*/

	(function (root, factory) {

	    if (typeof module === 'object' && module.exports) {

	        module.exports = factory();

	    } else {

	        root.FixedElement = factory();
	    }

	}(this, function () {

	    var FixedElement = (function ($) {

	        var $win = $(window),

	            counter = 1,

	            isMobile = /Mobi/.test(navigator.userAgent),

	            constructor = function FixedElement($selectable, options) {

	                this.id = "fixedElement-" + (counter++);

	                this.throttle = options && typeof options.throttle !== "undefined" ? options.throttle : 250;
	                this.zoom = options && typeof options.zoom !== "undefined" ? options.zoom : true;

	                this.isSleeping = true;

	                this.init($selectable);
	            };

	        constructor.prototype.fix = function(noTransitions, hardFix) {

	            var savedDisplay = "";

	            if (noTransitions || hardFix) {

	                savedDisplay = this.$fixedElement.css("display");

	                this.$fixedElement.css({
	                    display: hardFix ? "none" : "",

	                    transition: "none"
	                });
	            }

	            if (this.zoom || document.documentElement.clientWidth / window.innerWidth <= 1 || hardFix) {

	                var position = this.calculatePosition();

	                this.transform(position.left, position.top);
	            }

	            if (noTransitions || hardFix) {

	                if (hardFix) {

	                    this.$fixedElement.css({
	                        display: savedDisplay
	                    });
	                }

	                setTimeout(function() {

	                    this.$fixedElement.css({
	                        transition: ""
	                    });

	                }.bind(this), 0);
	            }

	            return this;
	        };

	        constructor.prototype.fixOnNext = function(noTransitions, hardFix) {

	            setTimeout(this.fix.bind(this, noTransitions, hardFix), 0);

	            return this;
	        };

	        constructor.prototype.init = function ($selectable) {

	            this.$fixedElement = $($selectable);

	            this.$fixedElement.css({
	                transition: "none"
	            });

	            this.wake();

	            this.fix();

	            setTimeout(function() {

	                this.$fixedElement.css({
	                    transition: ""
	                });

	            }.bind(this), 0);

	            return this;
	        };

	        constructor.prototype.destroy = function () {

	            this.sleep();

	            this.$fixedElement = null;

	            return this;
	        };

	        constructor.prototype.sleep = function () {

	            if (this.isSleeping) {

	                return true;
	            }

	            clearTimeout(this.eventThrottle);

	            $win.off("scroll." + this.id + " resize." + this.id + " orientationchange." + this.id);

	            this.isSleeping = true;

	            return true;
	        };

	        constructor.prototype.wake = function () {

	            if (this.isSleeping) {

	                this.eventThrottle = null;

	                $win.on("scroll." + this.id + " resize." + this.id + " orientationchange." + this.id, function () {

	                    clearTimeout(this.eventThrottle);

	                    if (this.throttle) {

	                        this.eventThrottle = setTimeout(this.fix.bind(this), this.throttle);

	                    } else {

	                        this.fix();
	                    }

	                }.bind(this));

	                this.isSleeping = false;
	            }

	            return true;
	        };

	        constructor.prototype.calculatePosition = function () {

	            var scrollWidth = document.documentElement.offsetWidth,
	                scrollHeight = document.documentElement.offsetHeight,
	                viewWidth = document.documentElement.clientWidth > window.innerWidth || isMobile ? window.innerWidth : document.documentElement.clientWidth,
	                viewHeight = document.documentElement.clientHeight > window.innerHeight || isMobile ? window.innerHeight : document.documentElement.clientHeight,

	                scrollLeft = Math.max(0, $win.scrollLeft()),
	                scrollTop = Math.max(0, $win.scrollTop());

	            scrollLeft = Math.min(scrollLeft, scrollWidth - viewWidth);
	            scrollTop = Math.min(scrollTop, scrollHeight - viewHeight);

	            if (this.isFixedToRight()) {

	                scrollLeft = scrollLeft - (scrollWidth - viewWidth);
	            }

	            if (this.isFixedToBottom()) {

	                scrollTop = scrollTop - (scrollHeight - viewHeight);
	            }

	            return {
	                top: scrollTop,
	                left: scrollLeft
	            };
	        };

	        constructor.prototype.transform = function (left, top) {

	            this.$fixedElement.css({
	                transform: "translate(" + left + "px, " + top + "px)"
	            });

	            return this;
	        };

	        constructor.prototype.isFixedToRight = function () {

	            var css = this.$fixedElement.css("right");

	            return !isNaN(parseFloat(css));
	        };

	        constructor.prototype.isFixedToLeft = function () {

	            var css = this.$fixedElement.css("left");

	            return !isNaN(parseFloat(css));
	        };

	        constructor.prototype.isFixedToTop = function () {

	            var css = this.$fixedElement.css("top");

	            return !isNaN(parseFloat(css));
	        };

	        constructor.prototype.isFixedToBottom = function () {

	            var css = this.$fixedElement.css("bottom");

	            return !isNaN(parseFloat(css));
	        };

	        return constructor;

	    }(jQuery));

	    return FixedElement;

	}));


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */

	var parser = __webpack_require__(11);
	var Emitter = __webpack_require__(15);

	/**
	 * Module exports.
	 */

	module.exports = Transport;

	/**
	 * Transport abstract constructor.
	 *
	 * @param {Object} options.
	 * @api private
	 */

	function Transport (opts) {
	  this.path = opts.path;
	  this.hostname = opts.hostname;
	  this.port = opts.port;
	  this.secure = opts.secure;
	  this.query = opts.query;
	  this.timestampParam = opts.timestampParam;
	  this.timestampRequests = opts.timestampRequests;
	  this.readyState = '';
	  this.agent = opts.agent || false;
	  this.socket = opts.socket;
	  this.enablesXDR = opts.enablesXDR;

	  // SSL options for Node.js client
	  this.pfx = opts.pfx;
	  this.key = opts.key;
	  this.passphrase = opts.passphrase;
	  this.cert = opts.cert;
	  this.ca = opts.ca;
	  this.ciphers = opts.ciphers;
	  this.rejectUnauthorized = opts.rejectUnauthorized;

	  // other options for Node.js client
	  this.extraHeaders = opts.extraHeaders;
	}

	/**
	 * Mix in `Emitter`.
	 */

	Emitter(Transport.prototype);

	/**
	 * Emits an error.
	 *
	 * @param {String} str
	 * @return {Transport} for chaining
	 * @api public
	 */

	Transport.prototype.onError = function (msg, desc) {
	  var err = new Error(msg);
	  err.type = 'TransportError';
	  err.description = desc;
	  this.emit('error', err);
	  return this;
	};

	/**
	 * Opens the transport.
	 *
	 * @api public
	 */

	Transport.prototype.open = function () {
	  if ('closed' == this.readyState || '' == this.readyState) {
	    this.readyState = 'opening';
	    this.doOpen();
	  }

	  return this;
	};

	/**
	 * Closes the transport.
	 *
	 * @api private
	 */

	Transport.prototype.close = function () {
	  if ('opening' == this.readyState || 'open' == this.readyState) {
	    this.doClose();
	    this.onClose();
	  }

	  return this;
	};

	/**
	 * Sends multiple packets.
	 *
	 * @param {Array} packets
	 * @api private
	 */

	Transport.prototype.send = function(packets){
	  if ('open' == this.readyState) {
	    this.write(packets);
	  } else {
	    throw new Error('Transport not open');
	  }
	};

	/**
	 * Called upon open
	 *
	 * @api private
	 */

	Transport.prototype.onOpen = function () {
	  this.readyState = 'open';
	  this.writable = true;
	  this.emit('open');
	};

	/**
	 * Called with data.
	 *
	 * @param {String} data
	 * @api private
	 */

	Transport.prototype.onData = function(data){
	  var packet = parser.decodePacket(data, this.socket.binaryType);
	  this.onPacket(packet);
	};

	/**
	 * Called with a decoded packet.
	 */

	Transport.prototype.onPacket = function (packet) {
	  this.emit('packet', packet);
	};

	/**
	 * Called upon close.
	 *
	 * @api private
	 */

	Transport.prototype.onClose = function () {
	  this.readyState = 'closed';
	  this.emit('close');
	};


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	// browser shim for xmlhttprequest module
	var hasCORS = __webpack_require__(121);

	module.exports = function(opts) {
	  var xdomain = opts.xdomain;

	  // scheme must be same when usign XDomainRequest
	  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
	  var xscheme = opts.xscheme;

	  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
	  // https://github.com/Automattic/engine.io-client/pull/217
	  var enablesXDR = opts.enablesXDR;

	  // XMLHttpRequest can be disabled on IE
	  try {
	    if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {
	      return new XMLHttpRequest();
	    }
	  } catch (e) { }

	  // Use XDomainRequest for IE8 if enablesXDR is true
	  // because loading bar keeps flashing when using jsonp-polling
	  // https://github.com/yujiosaka/socke.io-ie8-loading-example
	  try {
	    if ('undefined' != typeof XDomainRequest && !xscheme && enablesXDR) {
	      return new XDomainRequest();
	    }
	  } catch (e) { }

	  if (!xdomain) {
	    try {
	      return new ActiveXObject('Microsoft.XMLHTTP');
	    } catch(e) { }
	  }
	}


/***/ },
/* 27 */
/***/ function(module, exports) {

	/**
	 * Compiles a querystring
	 * Returns string representation of the object
	 *
	 * @param {Object}
	 * @api private
	 */

	exports.encode = function (obj) {
	  var str = '';

	  for (var i in obj) {
	    if (obj.hasOwnProperty(i)) {
	      if (str.length) str += '&';
	      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
	    }
	  }

	  return str;
	};

	/**
	 * Parses a simple querystring into an object
	 *
	 * @param {String} qs
	 * @api private
	 */

	exports.decode = function(qs){
	  var qry = {};
	  var pairs = qs.split('&');
	  for (var i = 0, l = pairs.length; i < l; i++) {
	    var pair = pairs[i].split('=');
	    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
	  }
	  return qry;
	};


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {


	/**
	 * Module dependencies.
	 */

	var debug = __webpack_require__(7)('socket.io-parser');
	var json = __webpack_require__(201);
	var isArray = __webpack_require__(17);
	var Emitter = __webpack_require__(15);
	var binary = __webpack_require__(200);
	var isBuf = __webpack_require__(53);

	/**
	 * Protocol version.
	 *
	 * @api public
	 */

	exports.protocol = 4;

	/**
	 * Packet types.
	 *
	 * @api public
	 */

	exports.types = [
	  'CONNECT',
	  'DISCONNECT',
	  'EVENT',
	  'ACK',
	  'ERROR',
	  'BINARY_EVENT',
	  'BINARY_ACK'
	];

	/**
	 * Packet type `connect`.
	 *
	 * @api public
	 */

	exports.CONNECT = 0;

	/**
	 * Packet type `disconnect`.
	 *
	 * @api public
	 */

	exports.DISCONNECT = 1;

	/**
	 * Packet type `event`.
	 *
	 * @api public
	 */

	exports.EVENT = 2;

	/**
	 * Packet type `ack`.
	 *
	 * @api public
	 */

	exports.ACK = 3;

	/**
	 * Packet type `error`.
	 *
	 * @api public
	 */

	exports.ERROR = 4;

	/**
	 * Packet type 'binary event'
	 *
	 * @api public
	 */

	exports.BINARY_EVENT = 5;

	/**
	 * Packet type `binary ack`. For acks with binary arguments.
	 *
	 * @api public
	 */

	exports.BINARY_ACK = 6;

	/**
	 * Encoder constructor.
	 *
	 * @api public
	 */

	exports.Encoder = Encoder;

	/**
	 * Decoder constructor.
	 *
	 * @api public
	 */

	exports.Decoder = Decoder;

	/**
	 * A socket.io Encoder instance
	 *
	 * @api public
	 */

	function Encoder() {}

	/**
	 * Encode a packet as a single string if non-binary, or as a
	 * buffer sequence, depending on packet type.
	 *
	 * @param {Object} obj - packet object
	 * @param {Function} callback - function to handle encodings (likely engine.write)
	 * @return Calls callback with Array of encodings
	 * @api public
	 */

	Encoder.prototype.encode = function(obj, callback){
	  debug('encoding packet %j', obj);

	  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
	    encodeAsBinary(obj, callback);
	  }
	  else {
	    var encoding = encodeAsString(obj);
	    callback([encoding]);
	  }
	};

	/**
	 * Encode packet as string.
	 *
	 * @param {Object} packet
	 * @return {String} encoded
	 * @api private
	 */

	function encodeAsString(obj) {
	  var str = '';
	  var nsp = false;

	  // first is type
	  str += obj.type;

	  // attachments if we have them
	  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
	    str += obj.attachments;
	    str += '-';
	  }

	  // if we have a namespace other than `/`
	  // we append it followed by a comma `,`
	  if (obj.nsp && '/' != obj.nsp) {
	    nsp = true;
	    str += obj.nsp;
	  }

	  // immediately followed by the id
	  if (null != obj.id) {
	    if (nsp) {
	      str += ',';
	      nsp = false;
	    }
	    str += obj.id;
	  }

	  // json data
	  if (null != obj.data) {
	    if (nsp) str += ',';
	    str += json.stringify(obj.data);
	  }

	  debug('encoded %j as %s', obj, str);
	  return str;
	}

	/**
	 * Encode packet as 'buffer sequence' by removing blobs, and
	 * deconstructing packet into object with placeholders and
	 * a list of buffers.
	 *
	 * @param {Object} packet
	 * @return {Buffer} encoded
	 * @api private
	 */

	function encodeAsBinary(obj, callback) {

	  function writeEncoding(bloblessData) {
	    var deconstruction = binary.deconstructPacket(bloblessData);
	    var pack = encodeAsString(deconstruction.packet);
	    var buffers = deconstruction.buffers;

	    buffers.unshift(pack); // add packet info to beginning of data list
	    callback(buffers); // write all the buffers
	  }

	  binary.removeBlobs(obj, writeEncoding);
	}

	/**
	 * A socket.io Decoder instance
	 *
	 * @return {Object} decoder
	 * @api public
	 */

	function Decoder() {
	  this.reconstructor = null;
	}

	/**
	 * Mix in `Emitter` with Decoder.
	 */

	Emitter(Decoder.prototype);

	/**
	 * Decodes an ecoded packet string into packet JSON.
	 *
	 * @param {String} obj - encoded packet
	 * @return {Object} packet
	 * @api public
	 */

	Decoder.prototype.add = function(obj) {
	  var packet;
	  if ('string' == typeof obj) {
	    packet = decodeString(obj);
	    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json
	      this.reconstructor = new BinaryReconstructor(packet);

	      // no attachments, labeled binary but no binary data to follow
	      if (this.reconstructor.reconPack.attachments === 0) {
	        this.emit('decoded', packet);
	      }
	    } else { // non-binary full packet
	      this.emit('decoded', packet);
	    }
	  }
	  else if (isBuf(obj) || obj.base64) { // raw binary data
	    if (!this.reconstructor) {
	      throw new Error('got binary data when not reconstructing a packet');
	    } else {
	      packet = this.reconstructor.takeBinaryData(obj);
	      if (packet) { // received final buffer
	        this.reconstructor = null;
	        this.emit('decoded', packet);
	      }
	    }
	  }
	  else {
	    throw new Error('Unknown type: ' + obj);
	  }
	};

	/**
	 * Decode a packet String (JSON data)
	 *
	 * @param {String} str
	 * @return {Object} packet
	 * @api private
	 */

	function decodeString(str) {
	  var p = {};
	  var i = 0;

	  // look up type
	  p.type = Number(str.charAt(0));
	  if (null == exports.types[p.type]) return error();

	  // look up attachments if type binary
	  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
	    var buf = '';
	    while (str.charAt(++i) != '-') {
	      buf += str.charAt(i);
	      if (i == str.length) break;
	    }
	    if (buf != Number(buf) || str.charAt(i) != '-') {
	      throw new Error('Illegal attachments');
	    }
	    p.attachments = Number(buf);
	  }

	  // look up namespace (if any)
	  if ('/' == str.charAt(i + 1)) {
	    p.nsp = '';
	    while (++i) {
	      var c = str.charAt(i);
	      if (',' == c) break;
	      p.nsp += c;
	      if (i == str.length) break;
	    }
	  } else {
	    p.nsp = '/';
	  }

	  // look up id
	  var next = str.charAt(i + 1);
	  if ('' !== next && Number(next) == next) {
	    p.id = '';
	    while (++i) {
	      var c = str.charAt(i);
	      if (null == c || Number(c) != c) {
	        --i;
	        break;
	      }
	      p.id += str.charAt(i);
	      if (i == str.length) break;
	    }
	    p.id = Number(p.id);
	  }

	  // look up json data
	  if (str.charAt(++i)) {
	    try {
	      p.data = json.parse(str.substr(i));
	    } catch(e){
	      return error();
	    }
	  }

	  debug('decoded %s as %j', str, p);
	  return p;
	}

	/**
	 * Deallocates a parser's resources
	 *
	 * @api public
	 */

	Decoder.prototype.destroy = function() {
	  if (this.reconstructor) {
	    this.reconstructor.finishedReconstruction();
	  }
	};

	/**
	 * A manager of a binary event's 'buffer sequence'. Should
	 * be constructed whenever a packet of type BINARY_EVENT is
	 * decoded.
	 *
	 * @param {Object} packet
	 * @return {BinaryReconstructor} initialized reconstructor
	 * @api private
	 */

	function BinaryReconstructor(packet) {
	  this.reconPack = packet;
	  this.buffers = [];
	}

	/**
	 * Method to be called when binary data received from connection
	 * after a BINARY_EVENT packet.
	 *
	 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
	 * @return {null | Object} returns null if more binary data is expected or
	 *   a reconstructed packet object if all buffers have been received.
	 * @api private
	 */

	BinaryReconstructor.prototype.takeBinaryData = function(binData) {
	  this.buffers.push(binData);
	  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
	    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
	    this.finishedReconstruction();
	    return packet;
	  }
	  return null;
	};

	/**
	 * Cleans up binary packet reconstruction variables.
	 *
	 * @api private
	 */

	BinaryReconstructor.prototype.finishedReconstruction = function() {
	  this.reconPack = null;
	  this.buffers = [];
	};

	function error(data){
	  return {
	    type: exports.ERROR,
	    data: 'parser error'
	  };
	}


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/**!
	 * Spectra.js
	 *
	 * Wrapping a value with Spectra() returns a Spectra object.
	 *
	 * The object's color value is as follows:
	 * {
	 *   r: 0 to 255 [int], // Red
	 *   g: 0 to 255 [int], // Green
	 *   b: 0 to 255 [int], // Blue
	 *   a: 0 to 1 [float] // Alpha
	 * }
	 */

	(function() {
	  'use strict';

	  // Keep track of the global object.
	  var root = this;

	  // Store the old value of Spectra to reassign in case of a call to noConflict.
	  var oldSpectra = root.Spectra;

	  // Utility functions for use in Spectra.
	  var Util = {};

	  // All official predefined css colors.
	  var predefinedColors = {
	    "white": "#ffffff",
	    "silver": "#c0c0c0",
	    "gray": "#808080",
	    "black": "#000000",
	    "red": "#ff0000",
	    "maroon": "#800000",
	    "yellow": "#ffff00",
	    "olive": "#808000",
	    "lime": "#00ff00",
	    "green": "#008000",
	    "aqua": "#00ffff",
	    "teal": "#008080",
	    "blue": "#0000ff",
	    "navy": "#000080",
	    "fuschia": "#ff00ff",
	    "purple": "#800080",
	    "orange": "#ffa500"
	  };

	  /**
	   * Clamps x to be between lower and upper, inclusive.
	   * If not specified, lower and upper are 0 and 1 respectively.
	   * If x is outside the range lower to upper, the closest of lower or upper is used.
	   */
	  Util.clamp = function(x, lower, upper) {
	    x = x || 0;
	    lower = lower !== undefined ? lower : 0;
	    upper = upper !== undefined ? upper : 1;
	    return Math.max(lower, Math.min(upper, x));
	  };

	  /**
	   * Converts from RGB to HSV.
	   * RGB should have keys r, g, b.
	   * HSV will have keys h, s, v.
	   */
	  Util.rgbToHsv = function(rgb) {
	    var hsv = {};
	    var r = Number(rgb.r || 0) / 255;
	    var g = Number(rgb.g || 0) / 255;
	    var b = Number(rgb.b || 0) / 255;
	    var max = Math.max(r, g, b);
	    var min = Math.min(r, g, b);
	    var delta = max - min;

	    hsv.v = max;
	    if (hsv.v === 0) {
	      hsv.h = 0;
	      hsv.s = 0;
	    } else {
	      hsv.s = (max - min) / max;
	      if (hsv.s === 0) {
	        hsv.h = 0;
	      } else {
	        if (max === r) {
	          hsv.h = (g - b) / delta;
	        } else if (max === g) {
	          hsv.h = 2 + (b - r) / delta;
	        } else {
	          hsv.h = 4 + (r - g) / delta;
	        }
	        hsv.h *= 60;
	        if (hsv.h < 0) {
	          hsv.h += 360;
	        }
	      }
	    }

	    return hsv;
	  };

	  /**
	   * Converts from HSV to RGB.
	   * HSV should have keys h, s, v.
	   * RGB will have keys r, g, b.
	   */
	  Util.hsvToRgb = function(hsv) {
	    var rgb = {r: 0, g: 0, b: 0};

	    var h = Util.clamp((hsv.h || hsv.hue), 0, 360);
	    var s = Util.clamp((hsv.s || hsv.saturation), 0, 1);
	    var v = Util.clamp(hsv.v || hsv.value);
	    var chroma = s * v;
	    var sector = h / 60; // Sector of the color wheel.
	    var x = chroma * (1 - Math.abs((sector % 2) - 1));

	    if(sector < 1) {
	      rgb.r = chroma;
	      rgb.g = x;
	    } else if (sector < 2) {
	      rgb.r = x;
	      rgb.g = chroma;
	    } else if (sector < 3) {
	      rgb.g = chroma;
	      rgb.b = x;
	    } else if (sector < 4) {
	      rgb.g= x;
	      rgb.b = chroma;
	    } else if (sector < 5) {
	      rgb.r = x;
	      rgb.b = chroma;
	    } else {
	      rgb.r = chroma;
	      rgb.b = x;
	    }

	    var min = v - chroma;

	    rgb.r += min;
	    rgb.g += min;
	    rgb.b += min;

	    rgb.r *= 255;
	    rgb.g *= 255;
	    rgb.b *= 255;

	    return rgb;
	  };

	  /**
	   * Converts from RGB to HSL.
	   * RGB should have keys r, g, b.
	   * HSL will have keys h, s, l.
	   */
	  Util.rgbToHsl = function(rgb) {
	    var hsv = Util.rgbToHsv(rgb);
	    var hsl = {};
	    hsl.h = hsv.h;
	    hsl.l = (2 - hsv.s) * hsv.v;
	    hsl.s = hsv.s * hsv.v;
	    hsl.s /= (hsl.l <= 1) ? (hsl.l) : (2 - hsl.l);
	    hsl.l /= 2;

	    if (isNaN(hsl.s)) {
	      hsl.s = 0;
	    }
	    return hsl;
	  };

	  /**
	   * Converts from HSL to RGB.
	   * HSL should have keys h, s, l.
	   * RGB will have keys r, g, b.
	   */
	  Util.hslToRgb = function(hsl) {
	    var h = Util.clamp((hsl.h || hsl.hue), 0, 360);
	    var s = Util.clamp(hsl.s || hsl.saturation);
	    var l = Util.clamp(hsl.l || hsl.lightness);
	    var hsv = {};
	    hsv.h = h;
	    s *= (l < 0.5) ? l : 1 - l;
	    hsv.s = (2 * s) / (l + s);
	    hsv.v = l + s;
	    return Util.hsvToRgb(hsv);
	  };

	  /**
	   * Turns an rgb color into a LAB color.
	   */
	  Util.rgbToLab = function(rgb) {
	    // RGB to XYZ
	    rgb = {
	      r: rgb.r / 255,
	      g: rgb.g / 255,
	      b: rgb.b / 255
	    };

	    var xyz, tc;

	    for (tc in rgb) {
	      if (rgb[tc] > 0.04045) {
	        rgb[tc] = Math.pow(((rgb[tc] + 0.055) / 1.055), 2.4);
	      } else {
	        rgb[tc] /= 12.92;
	      }

	      rgb[tc] = rgb[tc] * 100;
	    }

	    xyz = {
	      x: rgb.r * 0.4124 + rgb.g * 0.3576 + rgb.b * 0.1805,
	      y: rgb.r * 0.2126 + rgb.g * 0.7152 + rgb.b * 0.0722,
	      z: rgb.r * 0.0193 + rgb.g * 0.1192 + rgb.b * 0.9505
	    };

	    // XYZ to LAB

	    var xyz2 = {};
	    var white = {
	      x: 95.047,
	      y: 100.000,
	      z: 108.883
	    };

	    for (tc in xyz) {
	      xyz2[tc] = xyz[tc] / white[tc];

	      if (xyz2[tc] > 0.008856) {
	        xyz2[tc] = Math.pow(xyz2[tc], (1 / 3));
	      } else {
	        xyz2[tc] = (7.787 * xyz2[tc]) + (16 / 116);
	      }
	    }

	    return {
	      l: 116 * xyz2.y - 16,
	      a: 500 * (xyz2.x - xyz2.y),
	      b: 200 * (xyz2.y - xyz2.z)
	    };
	  };

	  /**
	   * Converts an lab color to rgb.
	   */
	  Util.labToRgb = function(lab) {
	    var xyz = {};
	    var rgb = {};

	    // LAB to XYZ
	    xyz.y = ((lab.l || lab.L) + 16) / 116;
	    xyz.x = lab.a / 500 + xyz.y;
	    xyz.z = xyz.y - lab.b / 200;

	    if (Math.pow(xyz.y,3) > 0.008856) {
	      xyz.y = Math.pow(xyz.y,3);
	    } else {
	      xyz.y = (xyz.y - 16 / 116) / 7.787;
	    }

	    if (Math.pow(xyz.x,3) > 0.008856) {
	      xyz.x = Math.pow(xyz.x,3);
	    } else {
	      xyz.x = (xyz.x - 16 / 116) / 7.787;
	    }

	    if (Math.pow(xyz.z,3) > 0.008856) {
	      xyz.z = Math.pow(xyz.z,3);
	    } else {
	      xyz.z = (xyz.z - 16 / 116) / 7.787;
	    }

	    //  Observer= 2degree, Illuminant= D65
	    xyz.x *=  95.047 / 100;
	    xyz.y *= 100.000 / 100;
	    xyz.z *= 108.883 / 100;

	    //  XYZ to RGB
	    rgb.r = xyz.x *  3.2406 + xyz.y * -1.5372 + xyz.z * -0.4986;
	    rgb.g = xyz.x * -0.9689 + xyz.y *  1.8758 + xyz.z *  0.0415;
	    rgb.b = xyz.x *  0.0557 + xyz.y * -0.2040 + xyz.z *  1.0570;

	    if (rgb.r > 0.0031308) {
	      rgb.r = 1.055 * Math.pow(rgb.r, (1 / 2.4)) - 0.055;
	    } else {
	      rgb.r *= 12.92;
	    }

	    if (rgb.g > 0.0031308) {
	      rgb.g = 1.055 * Math.pow(rgb.g, (1 / 2.4)) - 0.055;
	    } else {
	      rgb.g *= 12.92;
	    }

	    if (rgb.b > 0.0031308) {
	      rgb.b = 1.055 * Math.pow(rgb.b, (1 / 2.4)) - 0.055;
	    } else {
	      rgb.b *= 12.92;
	    }

	    rgb.r = Util.clamp(rgb.r * 255, 0, 255);
	    rgb.g = Util.clamp(rgb.g * 255, 0, 255);
	    rgb.b = Util.clamp(rgb.b * 255, 0, 255);

	    return rgb;
	  };

	  /**
	   * Converts from CSS to RGB.
	   */
	  Util.parseCss = function(css) {
	    var color = {};
	    var shorthandRegex = /^#[0-9a-f]{3}$/i;
	    var shorthandMatch = css.match(shorthandRegex);
	    if (shorthandMatch) {
	      color = {
	        r: parseInt(css.charAt(1), 16) * 0x11,
	        g: parseInt(css.charAt(2), 16) * 0x11,
	        b: parseInt(css.charAt(3), 16) * 0x11
	      };
	      return Util.normalize(color);
	    }
	    var longhandRegex = /^#[0-9a-f]{6}$/i;
	    var longhandMatch = css.match(longhandRegex);
	    if (longhandMatch) {
	      color = {
	        r: parseInt(css.slice(1,3), 16),
	        g: parseInt(css.slice(3,5), 16),
	        b: parseInt(css.slice(5,7), 16)
	      };
	      return Util.normalize(color);
	    }
	    var rgbRegex = /^rgb\(\s*([0-9]+),\s*([0-9]+),\s*([0-9]+)\s*\)$/i;
	    var rgbMatch = css.match(rgbRegex);
	    if (rgbMatch) {
	      color = {
	        r: parseInt(rgbMatch[1], 10),
	        g: parseInt(rgbMatch[2], 10),
	        b: parseInt(rgbMatch[3], 10)
	      };
	      return Util.normalize(color);
	    }
	    var rgbaRegex = /^rgba\(\s*([0-9]+),\s*([0-9]+),\s*([0-9]+),\s*([0-9\.]+)\s*\)$/i;
	    var rgbaMatch = css.match(rgbaRegex);
	    if (rgbaMatch) {
	      color = {
	        r: parseInt(rgbaMatch[1], 10),
	        g: parseInt(rgbaMatch[2], 10),
	        b: parseInt(rgbaMatch[3], 10),
	        a: parseFloat(rgbaMatch[4])
	      };
	      return Util.normalize(color);
	    }

	    // If we can't parse it, we throw a TypeError.
	    throw new TypeError(css + ' is not a valid CSS string for Spectra.');
	  };

	  /**
	   * Converts a predefined color string to a Spectra object
	   * Eg Util.parsePredefinedColor('white') === Spectra('#ffffff') === Spectra('{r: 255, g: 255, b: 255}');
	   */
	  Util.parsePredefinedColor = function (string) {
	    return new Spectra.fn(predefinedColors[string]);
	  };

	  /**
	   * Performs any conversions necessary to turn the arg into a Spectra object.
	   */
	  Util.normalize = function(arg) {
	    arg.a = arg.a || 1;

	    var color = arg;

	    // Perform conversions if necessary.
	    if (color.hsv !== undefined) {
	      color = Util.hsvToRgb(color.hsv);
	      color.a = arg.a;
	    } else if (color.hsl !== undefined) {
	      color = Util.hslToRgb(color.hsl);
	      color.a = arg.a;
	    } else if (color.css !== undefined) {
	      color = Util.parseCss(color.css);
	    } else if (color.lab !== undefined) {
	      color = Util.labToRgb(color.lab);
	      color.a = arg.a;
	    }

	    // Convert any full words into the abbreviated versions.
	    color.r = color.red || color.r;
	    color.g = color.green || color.g;
	    color.b = color.blue || color.b;
	    color.a = color.alpha || color.a;

	    // Place all values in a valid range.
	    color.r = Util.clamp(color.r, 0, 255);
	    color.g = Util.clamp(color.g, 0, 255);
	    color.b = Util.clamp(color.b, 0, 255);
	    color.a = Util.clamp(color.a, 0, 1);

	    return color;
	  };

	  /**
	   * Constructor for Spectra object.
	   * @constructor
	   */
	  var Spectra = function(arg) {
	    return new Spectra.fn(arg);
	  };

	  Spectra.fn = function(arg) {
	    if (arg === null || arg === undefined) {
	      throw new TypeError('Spectra argument must be defined.');
	    }
	    if (arg instanceof Spectra.fn) {
	      return arg;
	    }
	    if (typeof arg === 'object') {
	      if (arg.r !== undefined || arg.red !== undefined) {
	        this.color = Util.normalize({r: arg.r, g: arg.g, b: arg.b, a: arg.a});
	      } else if (arg.v !== undefined || arg.value !== undefined) {
	        this.color = Util.normalize({hsv: arg, a: arg.a});
	      } else if ((arg.l !== undefined || arg.lightness !== undefined) &&
	        (arg.s !== undefined || arg.saturation !== undefined)) {
	        this.color = Util.normalize({hsl: arg, a: (arg.a || arg.alpha)});
	      } else if ((arg.l !== undefined || arg.L !== undefined) && (arg.a !== undefined)) {
	        this.color = Util.normalize({lab: arg, a: (arg.a || arg.alpha)});
	      } else {
	        throw new TypeError('Spectra argument ' + arg + ' is invalid.');
	      }
	    } else if (typeof arg === 'string') {
	      if (arg.toLowerCase() in predefinedColors) {
	        return Util.parsePredefinedColor(arg);
	      }
	      this.color = Util.normalize({css: arg});
	    } else {
	      throw new TypeError('Spectra argument ' + arg + ' is invalid.');
	    }
	    return this;
	  };

	  /**
	   * Get and set.
	   * These functions take an optional argument.
	   * If it is specified, the property is changed and the object is returned.
	   * Otherwise, the property value is returned.
	   */
	  Spectra.fn.prototype.red = function(arg) {
	    var color = this.color;
	    if (arguments.length) {
	      color.r = arg;
	      this.color = Util.normalize(color);
	      return this;
	    } else {
	      return Math.round(color.r);
	    }
	  };
	  Spectra.fn.prototype.green = function(arg) {
	    var color = this.color;
	    if (arguments.length) {
	      color.g = arg;
	      this.color = Util.normalize(color);
	      return this;
	    } else {
	      return Math.round(color.g);
	    }
	  };
	  Spectra.fn.prototype.blue = function(arg) {
	    var color = this.color;
	    if (arguments.length) {
	      color.b = arg;
	      this.color = Util.normalize(color);
	      return this;
	    } else {
	      return Math.round(color.b);
	    }
	  };
	  Spectra.fn.prototype.hue = function(arg) {
	    var color = Util.rgbToHsv(this.color);
	    if (arguments.length) {
	      color.h = arg;
	      this.color = Util.normalize({hsv: color, a: this.color.a});
	      return this;
	    } else {
	      return Math.round(color.h);
	    }
	  };
	  Spectra.fn.prototype.saturationv = function(arg) {
	    var color = Util.rgbToHsv(this.color);
	    if (arguments.length) {
	      color.s = arg;
	      this.color = Util.normalize({hsv: color, a: this.color.a});
	      return this;
	    } else {
	      return color.s;
	    }
	  };
	  Spectra.fn.prototype.value = function(arg) {
	    var color = Util.rgbToHsv(this.color);
	    if (arguments.length) {
	      color.v = arg;
	      this.color = Util.normalize({hsv: color, a: this.color.a});
	      return this;
	    } else {
	      return color.v;
	    }
	  };
	  Spectra.fn.prototype.saturation = function(arg) {
	    var color = Util.rgbToHsl(this.color);
	    if (arguments.length) {
	      color.s = arg;
	      this.color = Util.normalize({hsl: color, a: this.color.a});
	      return this;
	    } else {
	      return color.s;
	    }
	  };
	  Spectra.fn.prototype.lightness = function(arg) {
	    var color = Util.rgbToHsl(this.color);
	    if (arguments.length) {
	      color.l = arg;
	      this.color = Util.normalize({hsl: color, a: this.color.a});
	      return this;
	    } else {
	      return color.l;
	    }
	  };
	  Spectra.fn.prototype.alpha = function(arg) {
	    var color = this.color;
	    if (arguments.length) {
	      color.a = arg;
	      return this;
	    } else {
	      return color.a;
	    }
	  };

	  Spectra.fn.prototype.hex = function() {
	    // Pad the strings so that they are all 2 digits long, and concatenate.
	    var rString = ('0' + this.red().toString(16)).slice(-2);
	    var gString = ('0' + this.green().toString(16)).slice(-2);
	    var bString = ('0' + this.blue().toString(16)).slice(-2);
	    return '#' + rString + gString + bString;
	  };

	  Spectra.fn.prototype.rgbaString = function() {
	    return 'rgba(' + this.red() + ',' + this.green() + ',' + this.blue() + ',' + this.alpha() + ')';
	  };

	  Spectra.fn.prototype.hslString = function() {
	    return 'hsl(' + this.hue() + ',' + this.saturation() + ',' +
	                    (Math.round(this.lightness()*100) / 100) + ')';
	  };

	  Spectra.fn.prototype.hslaString = function() {
	    return 'hsla(' + this.hue() + ',' + this.saturation() + ',' +
	                     (Math.round(this.lightness()*100) / 100) + ',' +
	                     this.alpha() + ')';
	  };

	  Spectra.fn.prototype.rgbNumber = function() {
	    return (this.red() << 16) | (this.green() << 8) | (this.blue());
	  };

	  Spectra.fn.prototype.labObject = function() {
	    return Util.rgbToLab(this.color);
	  };

	  /**
	   * Use hex string function for toString() operations
	   * to allow direct assignment to CSS properties
	   */
	  Spectra.fn.prototype.toString = Spectra.fn.prototype.hex;

	  /**
	   * API Functions
	   * =============
	   *
	   * Below are any API functions that do not modify the current color, but return values based
	   * on the current color. As such, use red(), green(), etc. instead of actually accessing this.color.
	   */

	  /**
	   * Tests to see if this color is equal to other.
	   * Because other is also a color, it follows that we can simply compare red, green, blue, and alpha
	   * to see if the colors are equal.
	   */
	  Spectra.fn.prototype.equals = function(other) {
	    var color1 = this;
	    var color2 = other;

	    if (arguments.length < 1) {
	      return color1 === color2;
	    }

	    return color1.near(color2, 0);
	  };

	  /**
	   * Tests to see if an other color is within a percentage range of this color.
	   */
	  Spectra.fn.prototype.near = function(other, percentage) {
	    var color1 = this;
	    var color2 = other;

	    percentage = Math.abs(percentage || 0);
	    var adjustment = 255 * (percentage / 100);

	    return (Math.abs(color2.red() - color1.red()) <= adjustment) &&
	           (Math.abs(color2.green() - color1.green()) <= adjustment) &&
	           (Math.abs(color2.blue() - color1.blue()) <= adjustment) &&
	           (Math.abs(color2.alpha() - color1.alpha()) <= (percentage / 100));
	  };

	  /**
	   * Returns the complement of this color.
	   */
	  Spectra.fn.prototype.complement = function() {
	    var newColor = new Spectra(this.color);
	    newColor.hue((newColor.hue() + 180) % 360);
	    return newColor;
	  };

	  /**
	   * Negates this color.
	   * For a color {R, G, B}, returns a new color {R', G', B'}, where R' = 255 - R and so on.
	   */
	  Spectra.fn.prototype.negate = function() {
	    var newColor = new Spectra(this.color);
	    newColor.red(255 - newColor.red());
	    newColor.green(255 - newColor.green());
	    newColor.blue(255 - newColor.blue());
	    return newColor;
	  };

	  /**
	   * Lightens a color based on percentage value from 1 to 100.
	   */
	  Spectra.fn.prototype.lighten = function(percentage) {
	    var newColor = new Spectra(this.color);
	    var l = Util.clamp(newColor.lightness() + (percentage / 100), 0, 1);
	    newColor.lightness(l);
	    return newColor;
	  };

	  /**
	   * Darkens a color based on percentage value from 1 to 100.
	   */
	  Spectra.fn.prototype.darken = function(percentage) {
	    return this.lighten(-percentage);
	  };

	  /**
	   * Lightens or darkens a color based on a random value in the specified range.
	   * Percentage should be passed in as an integer, so 40 would lighten or darken up to 40%.
	   */
	  Spectra.fn.prototype.randomColorRange = function(percentage) {
	    var adjustment = ((Math.random() * 2) - 1) * percentage;
	    var newColor = new Spectra(this.color);
	    newColor = newColor.lighten(adjustment);
	    return newColor;
	  };

	  /**
	   * Adds saturation to the color based on a percentage value.
	   */
	  Spectra.fn.prototype.saturate = function(percentage) {
	    var p = percentage / 100;
	    var newColor = new Spectra(this.color);
	    newColor.saturation(newColor.saturation() + p);
	    return newColor;
	  };

	  /**
	   * Desaturates the color based on a percentage value.
	   */
	  Spectra.fn.prototype.desaturate = function(percentage) {
	    var p = percentage / 100;
	    var newColor = new Spectra(this.color);
	    newColor.saturation(newColor.saturation() - p);
	    return newColor;
	  };

	  /**
	   * Fades in the current color based on a percentage value, making it less transparent.
	   */
	  Spectra.fn.prototype.fadeIn = function(percentage) {
	    var p = percentage / 100;
	    var newColor = new Spectra(this.color);
	    newColor.alpha(newColor.alpha() + p);
	    return newColor;
	  };

	  /**
	   * Fades out the current color based on a percentage value, making it less transparent.
	   */
	  Spectra.fn.prototype.fadeOut = function(percentage) {
	    var p = percentage / 100;
	    var newColor = new Spectra(this.color);
	    newColor.alpha(newColor.alpha() - p);
	    return newColor;
	  };

	  /**
	   * Calculates the luma of the color, i.e. how it appears on screen.
	   */
	  Spectra.fn.prototype.luma = function() {
	    return (0.2126 * this.red()) + (0.7152 * this.green()) + (0.0722 * this.blue());
	  };

	  /**
	   * Returns a Spectra object, which is the grayscale of the current color.
	   */
	  Spectra.fn.prototype.grayscale = function() {
	    return this.desaturate(100);
	  };

	  /**
	   * If a color is dark then it's best to have white text on it.
	   * http://24ways.org/2010/calculating-color-contrast
	   */
	  Spectra.fn.prototype.isDark = function() {
	    var yiq = ((this.red()*299)+(this.green()*587)+(this.blue()*144))/1000;
	    return yiq < 131.5;
	  };

	  /**
	   * If a color is light then it's best to have black text on it.
	   */
	  Spectra.fn.prototype.isLight = function() {
	    return !this.isDark();
	  };

	  /**
	   * Returns the color that results from mixing percent of the other color into this color.
	   */
	  Spectra.fn.prototype.mix = function(other, percentage) {
	    other = new Spectra(other);
	    var p = arguments.length < 2 ? 0.5 : percentage / 100;
	    return new Spectra({
	      r: this.red() * (1 - p) + other.red() * p,
	      g: this.green() * (1 - p) + other.green() * p,
	      b: this.blue() * (1 - p) + other.blue() * p,
	      a: this.alpha() * (1 - p) + other.alpha() * p
	    });
	  };

	  /**
	   * Returns a number from 0 to 1 representing the color contrast between the two colors.
	   */
	  Spectra.fn.prototype.contrast = function(other) {
	    other = new Spectra(other);
	    var diff = Math.max(this.red(), other.red()) - Math.min(this.red(), other.red()) +
	               Math.max(this.green(), other.green()) - Math.min(this.green(), other.green()) +
	               Math.max(this.blue(), other.blue()) - Math.min(this.blue(), other.blue());
	    return diff / 765;
	  };

	  /**
	   * Returns a gradient of colors approximately from this color to the other, consisting of n colors.
	   */
	  Spectra.fn.prototype.gradient = function(other, n) {
	    other = new Spectra(other);
	    var gradient = [];
	    var r = this.red();
	    var g = this.green();
	    var b = this.blue();
	    var dr = (other.red() - this.red()) / (n - 1);
	    var dg = (other.green() - this.green()) / (n - 1);
	    var db = (other.blue() - this.blue()) / (n - 1);

	    for (var i = 0; i < n; i++) {
	      gradient.push(new Spectra({r: r, g: g, b: b}));
	      r += dr;
	      g += dg;
	      b += db;
	    }

	    return gradient;
	  };

	  /**
	   * Harmony
	   *
	   * @desc Returns an array of harmonious colors (goo.gl/R3FRlU).
	   * @author Benjamin Fleming (benjamminf)
	   * @since 2014-01-06
	   * @param type (string) - Type of harmony.
	   * @param index (int) - At which point the original color exists on the set harmonies. Since
	   *   some types of color harmonies have inconsistent offsets (eg. rectangle) it's useful to
	   *   note where this original color lies on the set harmony hues.
	   * @return Array of Spectra instances.
	   */
	  Spectra.fn.prototype.harmony = function(type, index) {
	    index = typeof index === 'number' ? Math.abs(parseInt(index, 10)) : 0;

	    var colors = [];
	    var hsv = Util.rgbToHsv(this.color);
	    var hues = [0, 180];

	    switch (type) {
	      case 'analogous':
	        hues = [0, 30, 60];
	        break;
	      case 'triad':
	        hues = [0, 120, 240];
	        break;
	      case 'split-complementary':
	        hues = [0, 150, 210];
	        break;
	      case 'rectangle':
	        hues = [0, 60, 180, 240];
	        break;
	      case 'square':
	        hues = [0, 90, 180, 270];
	        break;
	      case 'complementary':
	        hues = [0, 180];
	        break;
	    }

	    var n = hues.length;
	    var offset = hues[index % n];

	    for (var i = 0; i < n; i++) {
	      colors.push(new Spectra({
	        h: (hsv.h + hues[i] - offset) % 360,
	        s:  hsv.s,
	        v:  hsv.v,
	        a: this.color.a
	      }));
	    }

	    return colors;
	  };

	  /**
	   * Restores the old value of Spectra and returns the wrapper function.
	   */
	  Spectra.noConflict = function() {
	    root.Spectra = oldSpectra;
	    return Spectra;
	  };

	  /**
	   * Generates a random color.
	   */
	  Spectra.random = function() {
	    return new Spectra({
	      r: Math.floor(Math.random() * 255),
	      g: Math.floor(Math.random() * 255),
	      b: Math.floor(Math.random() * 255)
	    });
	  };

	  // Set the global variable Spectra to the wrapper that we have defined.
	  if (true) {
	    if (true) {
	      exports = module.exports = Spectra;
	    }
	    exports.Spectra = Spectra;
	  } else {
	    root.Spectra = Spectra;
	  }

	}).call(this);


/***/ },
/* 30 */
/***/ function(module, exports) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/

	module.exports = {

	    PageSection: {
	        self: "P_PageSection",

	        innerWrapper: "P_PageSection--inner-wrapper",

	        //Seřazování sekcí
	        parentOfSortable: "P_sortable-sections",
	        parentOfNonSortable: "P_nonsortable-sections",
	        sortHandle: "P_PageSection--sort-handle",
	        draggedSection: "P_PageSection__dragged",
	        placedSection: "P_PageSection__placed",
	        removedSection: "P_PageSection__removed",

	        placeholderTransitions: "P_PageSection--placeholder__transitions",
	        placeholder: "P_PageSection--placeholder",

	        //Editace
	        titleEditor: "E_Editor__title",
	        contentEditor: "E_Editor__content"
	    },

	    PageSectionSettings: {
	        self: "E_PageSectionSettings"
	    },

	    NewPageSectionSelector: {
	        self: "E_NewPageSectionSelector",

	        sectionType: "E_NewPageSectionSelector--page-section-type",
	        clone: "E_NewPageSectionSelector--clone",
	        inserted: "E_NewPageSectionSelector__inserted"
	    }

	};


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	/*global $*/
	(function (root, factory) {

	    if (typeof module === 'object' && module.exports) {

	        var Ractive = __webpack_require__(0),

	            U = __webpack_require__(4),
	            on = __webpack_require__(1),

	            components = {
	                IconBrowser: __webpack_require__(93),
	                ColorPicker: __webpack_require__(22),
	                ColorPickerPalette: __webpack_require__(14)
	            }/*,

	            ColorSettings = require("./Types/ColorSettings")*/;

	        module.exports = factory(
	            Ractive,
	            U,
	            //            "ColorSettings",
	            components,
	            __webpack_require__(153),
	            on
	        );

	    } else {

	        root.PageElementSettings = factory(
	            root.Ractive,
	            root.U,
	            root.ColorSettings,
	            "",
	            {client: true}
	        );
	    }

	}(this, function (Ractive, U/*, ColorSettings*/, components, template, on) {

	    /*
	     * Komponent s nastavením elementu v sekci. Obsah by měl tvořit komponent s konkrtétním nastavením
	     * (měl by být uložen v "/Types"). Každý komponent by měl obsahovat element s dekorátorem "PageElementSettingsBox",
	     * který zajistí roztahování nastavení a přidá posuvníky. Tento element by měl mít nastaveno max-width a max-height,
	     * pro nastavení výchozí velikosti.
	     */

	    var instanceCounter = 0;

	    return Ractive.extend({

	        template: template,

	        CLASS: {
	            self: "E_PageElementSettings",

	            wrapper: "E_PageElementSettings--wrapper",
	            content: "E_PageElementSettings--content",

	            resizer: "E_PageElementSettings--resizer",
	            resizerActive: "E_PageElementSettings--resizer__active",
	            resizableBox: "E_PageElementSettings--resizable-box",
	            scrollingContent: "E_PageElementSettings--scrolling-content",

	            minmax: "E_PageElementSettings--min-max",
	            minmaxMax: "E_PageElementSettings--min-max__max",
	            minmaxMin: "E_PageElementSettings--min-max__min"
	        },

	        OPTIONS: {
	            SETTINGS_OFFSET: -10
	        },

	        components: components || {
	            //            ColorSettings: ColorSettings
	        },

	        partials: {

	        },

	        decorators: {

	            ResizableBox: __webpack_require__(23)
	        },

	        data: function () {

	            return {
	            };
	        },

	        onconfig: function () {

	            this.EVENT_NS = "PageElementSettings-" + (++instanceCounter);

	            if (on.client) {

	                Ractive.$win = Ractive.$win || $(window);
	            }

	            this.onresizableboxend = function (offset, selfRect) {

	                //upravení pozice, pokud se element nevešel na stránku
	                offset = this.minmaxSettingsPosition(offset, 0, 0, offset, selfRect);

	                offset.bottom = offset.top  + selfRect.height;
	                offset.right  = offset.left + selfRect.width;

	                this.$self
	                    .offset(offset)
	                    .data("lastOffset.PageElementSettings", offset);
	            };

	            this.onresizableboxresize = function (position) {

	                this.setPosition(true, position);
	            };
	        },

	        onrender: function () {

	            if (on.client) {

	                this.self  = this.find("." + this.CLASS.self);
	                this.$self = $(this.self);

	                this.$self.css({
	                    transition: "none"
	                });

	                //přesunout element do #page kvůli správnému z-indexu
	                //parent === obalovací element pro transition
	                this.$self.parent().prependTo("#page");

	                //element, podle kterého se nastaví pozice nastavení (aktivační tlačítko)
	                this.positionElement  = this.get("positionElement");
	                this.$positionElement = $(this.positionElement);

	                this.setPosition();

	                Ractive.$win.on("resize." + this.EVENT_NS, this.setPosition.bind(this, false, null, true));
	            }
	        },

	        oncomplete: function () {

	            if (on.client) {

	                this.$self.css({
	                    transition: ""
	                });
	            }
	        },

	        onteardown: function () {

	            Ractive.$win.off("." + this.EVENT_NS);
	        },

	        activateMover: function (e) {

	            var eventData = U.eventData(e),

	                lastY = eventData.pageY,
	                lastX = eventData.pageX;

	            if (eventData.pointers > 1) {

	                return;
	            }

	            this.$self.css({
	                transition: "none"
	            });

	            Ractive.$win
	                .off("mousemove." + this.EVENT_NS + " touchmove." + this.EVENT_NS)
	                .on( "mousemove." + this.EVENT_NS + " touchmove." + this.EVENT_NS, function (e) {

	                    var eventData = U.eventData(e);

	                    if (eventData.pointers > 1) {

	                        return;
	                    }

	                    var offset = this.$self.offset(),
	                        newOffset = {};

	                    newOffset.top  = offset.top  + (eventData.pageY - lastY);
	                    newOffset.left = offset.left + (eventData.pageX - lastX);

	                    newOffset = this.minmaxSettingsPosition(newOffset, eventData.pageX - lastX, eventData.pageY - lastY, offset);

	                    this.$self.offset(newOffset);

	                    lastX = eventData.pageX;
	                    lastY = eventData.pageY;

	                    e.preventDefault();
	                    return false;

	                }.bind(this))
	                .one("mouseup." + this.EVENT_NS + " touchend." + this.EVENT_NS, function (e) {

	                    Ractive.$win.off("mousemove." + this.EVENT_NS + " touchmove." + this.EVENT_NS);

	                    var currentOffset = this.$self.offset(),
	                        selfRect      = this.self.getBoundingClientRect();

	                    currentOffset.right  = currentOffset.left + selfRect.width;
	                    currentOffset.bottom = currentOffset.top  + selfRect.height;
	                    currentOffset.changedByUser = true;

	                    //uložení aktuálního offsetu pro použití v setPosition
	                    this.$self
	                        .offset(currentOffset)
	                        .data("lastOffset.PageElementSettings", currentOffset)
	                        .css({
	                            transition: ""
	                        });

	                    e.preventDefault();
	                    return false;

	                }.bind(this));

	            eventData.preventDefault();
	            return false;
	        },

	        minmaxSettingsPosition: function (newOffset, changeX, changeY, currentOffset, currentSelfRect) {

	            var offset   = currentOffset   || this.$self.offset(),
	                selfRect = currentSelfRect || this.self.getBoundingClientRect();

	            //element by přesahoval pravý okraj stránky
	            if (offset.left + selfRect.width + changeX >= document.documentElement.offsetWidth) {

	                newOffset.left = document.documentElement.offsetWidth - selfRect.width;

	                //element by přesahoval levý okraj stránky
	            } else if (offset.left + changeX < 0) {

	                newOffset.left = 0;
	            }

	            //element by přesahoval dolní okraj stránky
	            if (offset.top + selfRect.height + changeY >= document.documentElement.offsetHeight) {

	                newOffset.top = document.documentElement.offsetHeight - selfRect.height;

	                //element by přesahoval horní okraj stránky
	            } else if (offset.top + changeY < 0) {

	                newOffset.top = 0;
	            }

	            return newOffset;
	        },

	        setPosition: function (savedPosition, resizerPosition, checkDocOverflow) {

	            this.savedPosition = this.savedPosition || {};

	            var selfRect   = this.self.getBoundingClientRect(),
	                lastOffset = this.$self.data("lastOffset.PageElementSettings") || {},

	                buttonOffset = this.$positionElement.offset(),
	                buttonRect   = this.positionElement.getBoundingClientRect(),

	                finalOffset = buttonOffset,

	                right       = buttonRect.right  + selfRect.width  + this.OPTIONS.SETTINGS_OFFSET,
	                left        = buttonRect.left   - selfRect.width  - this.OPTIONS.SETTINGS_OFFSET,
	                top         = buttonRect.top    - selfRect.height - this.OPTIONS.SETTINGS_OFFSET,
	                bottom      = buttonRect.bottom + selfRect.height + this.OPTIONS.SETTINGS_OFFSET,
	                centerLeft  = buttonRect.left   + (buttonRect.width / 2) - (selfRect.width / 2),
	                centerRight = buttonRect.left   + (buttonRect.width / 2) + (selfRect.width / 2),

	                viewportWidth = U.viewportWidth();

	            //Pokud se kontroluje velikost stránky (= v případě resize události, pokud uživatel element přesunul)
	            //a element není mimo stránku, pozice se nezmění
	            if (checkDocOverflow && lastOffset.changedByUser && !this.overflowsDoc(lastOffset)) {

	                return;

	            } else if (checkDocOverflow) {

	                //pokud se pozice změní vrátí se zpět automatcké upravování pozice
	                finalOffset.changedByUser = false;
	            }

	            //element bude po změně pozice pod horním okrajem okna nebo byl při inicializaci takto nastaven,
	            //protože by jinak při zvětšování mohlo dojít k přeskočení elementu
	            if ((!savedPosition && top >= 0) || (savedPosition && this.savedPosition.v === "top")) {

	                finalOffset.top -= selfRect.height + this.OPTIONS.SETTINGS_OFFSET;

	                this.savedPosition.v = "top";

	            } else {

	                finalOffset.top += buttonRect.height + this.OPTIONS.SETTINGS_OFFSET;

	                this.savedPosition.v = "bottom";
	            }

	            //pokud je obrazovka menší jak 768 (včetně), element se zarovná do středu
	            if ((!savedPosition && (viewportWidth <= 768 && centerLeft >= 0 && centerRight <= viewportWidth)) || (savedPosition && this.savedPosition.h === "center")) {

	                finalOffset.left -= (selfRect.width / 2) - (buttonRect.width / 2);

	                finalOffset.top += this.savedPosition.v === "top" ? this.OPTIONS.SETTINGS_OFFSET : this.OPTIONS.SETTINGS_OFFSET * -1;

	                this.savedPosition.h = "center";

	                //element bude po změně pozice před pravým okrajem okna nebo byl při inicializaci takto nastaven,
	                //protože by jinak při zvětšování mohlo dojít k přeskočení elementu
	            } else if ((!savedPosition && (right <= viewportWidth || left < 0)) || (savedPosition && this.savedPosition.h === "right")) {

	                finalOffset.left += buttonRect.width + this.OPTIONS.SETTINGS_OFFSET;

	                this.savedPosition.h = "right";

	            } else {

	                finalOffset.left -= selfRect.width + this.OPTIONS.SETTINGS_OFFSET;

	                this.savedPosition.h = "left";
	            }

	            //úprava offsetu, pokud uživatel změní velikost elementu (je potřeba změnit css top a left)
	            if (resizerPosition) {

	                var diffX,
	                    diffY;

	                if (resizerPosition.match(/right/) || !resizerPosition.match(/left/)) {

	                    diffX = lastOffset.left - finalOffset.left;

	                    finalOffset.left += diffX;

	                } else {

	                    diffX = lastOffset.right - (finalOffset.left + selfRect.width);

	                    finalOffset.left += diffX;
	                }

	                if (resizerPosition.match(/bottom/) || !resizerPosition.match(/top/)) {

	                    diffY = lastOffset.top - finalOffset.top;

	                    finalOffset.top += diffY;

	                } else {

	                    diffY = lastOffset.bottom - (finalOffset.top + selfRect.height);

	                    finalOffset.top += diffY;
	                }
	            }

	            finalOffset.top    = Math.max(0, finalOffset.top);
	            finalOffset.left   = Math.max(0, finalOffset.left);
	            finalOffset.right  = finalOffset.left + selfRect.width;
	            finalOffset.bottom = finalOffset.top  + selfRect.height;

	            finalOffset.changedByUser = finalOffset.changedByUser === undefined ? lastOffset.changedByUser : finalOffset.changedByUser;

	            this.$self
	                .offset(finalOffset)
	                .data("lastOffset.PageElementSettings", finalOffset);
	        },

	        overflowsDoc: function (offsetWithBottomAndRight) {

	            return document.documentElement.offsetWidth < offsetWithBottomAndRight.right || document.documentElement.offsetHeight < offsetWithBottomAndRight.bottom;
	        }
	    });

	}));



/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./PageSectionA/dataTemplate.js": 68,
		"./PageSectionB/dataTemplate.js": 70,
		"./PageSectionC/dataTemplate.js": 72
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		var id = map[req];
		if(!(id + 1)) // check for number
			throw new Error("Cannot find module '" + req + "'.");
		return id;
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 32;


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	/*global $*/

	var FixedElement = __webpack_require__(24);

	var MediumEditor = __webpack_require__(126);

	__webpack_require__(80)(MediumEditor);
	__webpack_require__(79)(MediumEditor, FixedElement);
	__webpack_require__(77)(MediumEditor);
	__webpack_require__(78)(MediumEditor);

	var SuperEditor = function SuperEditor($editableSelector, getSections) {

	    MediumEditor.extensions.anchor.prototype.getSections =
	        MediumEditor.extensions.anchor.prototype.getSections || getSections || function () { return []; };

	    this.$editableSelector = $editableSelector || "[contenteditable='true']";

	    this.configure();

	    this.init();
	};

	SuperEditor.prototype.configure = function () {

	    this.options = {};
	};

	SuperEditor.prototype.init = function () {

	    this.editor = new MediumEditor($(this.$editableSelector), this.options);

	    this.$toolbar = $(this.editor.toolbar && this.editor.toolbar.toolbar);
	};

	SuperEditor.prototype.destroy = function () {

	    if (this.editor) {

	        this.editor.destroy();
	    }
	};

	SuperEditor.prototype.refresh = function (elementsOnly) {

	    if (elementsOnly && this.editor) {

	        var editables = $(this.$editableSelector).get(),

	            add = [],
	            remove = [],

	            newCount = editables.length - 1,
	            currentCount = this.editor.elements.length - 1;

	        for (newCount; newCount >= 0; newCount--) {

	            if (this.editor.elements.indexOf(editables[newCount]) === -1) {

	                add.push(editables[newCount]);
	            }
	        }

	        for (currentCount; currentCount >= 0; currentCount--) {

	            if (editables.indexOf(this.editor.elements[currentCount]) === -1) {

	                remove.push(this.editor.elements[currentCount]);
	            }
	        }

	        this.editor.removeElements(remove);
	        this.editor.addElements(add);

	        return;
	    }

	    this.destroy();

	    this.init();
	};

	SuperEditor.BUTTONS = {
	    H2: {
	        name: "h2",
	        aria: "Nadpis"
	    },
	    I: {
	        name: "italic",
	        aria: "Kurzíva"
	    },
	    B: {
	        name: "bold",
	        aria: "Tučné"
	    },
	    UL: {
	        name: "unorderedlist",
	        aria: "Odrážkový seznam"
	    },
	    OL: {
	        name: "orderedlist",
	        aria: "Číslovaný seznam"
	    },
	    SUP: {
	        name: "superscript",
	        aria: "Horní index"
	    },
	    SUB: {
	        name: "subscript",
	        aria: "Dolní index"
	    },
	    A: {
	        name: "anchor",
	        aria: "Odkaz"
	    }
	};

	SuperEditor.MediumEditor = MediumEditor;

	module.exports = SuperEditor;


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	/*global $*/
	(function (root, factory) {

	    if (typeof module === 'object' && module.exports) {

	        var Ractive = __webpack_require__(0),
	            on = __webpack_require__(1),

	            Dropzone = on.client ? __webpack_require__(38) : function () { return {}; },

	            template = __webpack_require__(45);

	        module.exports = factory(Ractive, Dropzone, template, on);

	    } else {

	        root.FileBrowser = factory(root.Ractive, root.Dropzone, "", {client: true});
	    }

	}(this, function (Ractive, Dropzone, template) {

	    var savedDirectories = {},

	        savedSearchText = {};

	    return Ractive.extend({

	        template: template,

	        CLASS: {
	            self: "FileBrowser",

	            dragDropOverlay: "FileBrowser--drag-drop-overlay",
	            message: "FileBrowser--message",

	            uploadFiles: "FileBrowser--upload-files",

	            searchInput: "FileBrowser--search-input",

	            notFileDragged: "dz-not-file"
	        },

	        OPTIONS: {
	            FILETYPE_IMAGE: "image",
	            FILETYPE_ICON: "icon" ,

	            DROPZONE: function () {

	                return {
	                    url: "/upload-files",
	                    paramName: "files",

	                    uploadMultiple: true,
	                    acceptedFiles: "",
	                    maxFilesize: 1,
	                    parallelUploads: 5,

	                    clickable: false,

	                    thumbnailWidth: 100,
	                    thumbnailHeight: 100,

	                    dictInvalidFileType: "Nepodporovaný formát.",
	                    dictFileTooBig: "Soubor je příliš velký ({{filesize}} MB). Velikost souboru může být maximálně {{maxFilesize}} MB.",
	                    dictResponseError: "Soubor se nepodařilo nahrát (chyba: {{statusCode}})"
	                };
	            }
	        },

	        components: {

	        },

	        partials: {

	        },

	        data: function () {

	            return {
	                type: "default",

	                directories: [],
	                openDirectory: null,
	                loadingDirectory: null,

	                //název requestu odesílaného na server
	                reqName: "files",

	                filesType: "",

	                srcPath: window.location.origin,
	                thumbsPath: "/thumbs",
	                thumbsFullPath: this.getThumbsFullPath,
	                selectedPath: "",

	                uploadDirectory: "",

	                uploadOverlayTitle: "Nahrát soubory",
	                uploadOverlayText: "",

	                uploading: [],

	                showMessage: false,

	                saveOnTeardown: true,

	                searchable: false,
	                searchDirPath: "#search",
	                searchPlaceholder: "Najít...",
	                searchText: ""
	            };
	        },

	        superOnconstruct: function () {

	            if (!window.location.origin) {

	                window.location.origin = window.location.protocol + "//" + window.location.hostname + (window.location.port ? ":" + window.location.port: "");
	            }
	        },

	        onconstruct: function () {

	            this.superOnconstruct();
	        },

	        superOnconfig: function () {

	            this.observe("openDirectory", this.openDirectory, {init: false});

	            this.on("deleteFile", this.deleteFile);

	            if (this.get("saveOnTeardown")) {

	                this.set("directories", savedDirectories[this.get("reqName")] || []);

	                this.set("searchText", savedSearchText[this.get("reqName")] || "");
	            }

	            if (!this.get("directories").length) {

	                this.loadDirectories();
	            }

	            this.observe("directories.*.files openDirectory", this.hasInitContentOnOpen);

	            if (this.get("searchable")) {

	                this.observe("searchText", function (searchText) {

	                    clearTimeout(this.searchTimeout);

	                    this.searchTimeout = setTimeout(
	                        this.searchFiles.bind(this, searchText),
	                        window.navigator.userAgent.match(/Mobi/) ? 1000 : 500
	                    );

	                }, {init: false});
	            }
	        },

	        superOnrender: function () {

	            this.self = this.find("." + this.CLASS.self);
	            this.$self = $(this.self);

	            if (this.get("directories").length) {

	                this.initUploadFiles();

	                this.searchInput = this.find("." + this.CLASS.searchInput);
	            }

	            this.$overlays = $(this.findAll("." + this.CLASS.dragDropOverlay + ", ." + this.CLASS.message));

	            this.$offsetElement = $([]);
	        },

	        superOncomplete: function () {

	            this.$offsetElement = this.$self.offsetParent().on("scroll.FileBrowser", function (e) {

	                this.$overlays.css({
	                    top: e.target.scrollTop
	                });

	            }.bind(this));
	        },

	        superOnteardown: function () {

	            this.torndown = true;

	            this.$offsetElement.off(".FileBrowser");

	            if (this.dirReq) {

	                this.dirReq.cancelReq(true);
	            }

	            if (this.filesReq) {

	                this.filesReq.cancelReq(true);
	            }

	            if (this.searchReq) {

	                this.searchReq.cancelReq(true);
	            }

	            if (this.dropzone) {

	                this.dropzone.off("*");

	                this.dropzoneInstance.removeAllFiles(true);
	                this.dropzoneInstance.destroy();

	                this.$dropzonePreview.remove();
	                this.$dropzonePreview = null;

	                this.$dropzoneClickable.off(".FileBrowser");
	            }

	            if (this.uploadErrorRemovingFnTimeouts) {

	                var t = this.uploadErrorRemovingFnTimeouts.length - 1;

	                for (t; t >= 0; t--) {

	                    clearTimeout(this.uploadErrorRemovingFnTimeouts[t]);
	                }
	            }

	            //uložit složky pro další instanci (kromě uploadovací složky)
	            if (this.get("saveOnTeardown")) {

	                var directories = this.get("directories");

	                if (this.get("uploadDirectory")) {

	                    var directoryIndex = this.getDirectoryIndexByName(this.get("uploadDirectory"));

	                    if (~directoryIndex) {

	                        directories[directoryIndex].files = [];
	                    }
	                }

	                savedDirectories[this.get("reqName")] = directories;

	                savedSearchText[this.get("reqName")] = this.get("searchText");
	            }
	        },

	        onconfig: function () {

	            this.superOnconfig();
	        },

	        onrender: function () {

	            this.superOnrender();
	        },

	        oncomplete: function () {

	            this.superOncomplete();
	        },

	        onteardown: function () {

	            this.superOnteardown();
	        },

	        initUploadFiles: function () {

	            if (!this.get("uploadDirectory") || this.uploadFilesLoaded) {

	                return;
	            }

	            Dropzone.autoDiscover = false;

	            var options = this.OPTIONS.DROPZONE();

	            //element pro uložení náhledů (nelze v Dropzone zrušit)
	            this.$dropzonePreview = $("<div/>");
	            options.previewsContainer = this.$dropzonePreview[0];

	            options.clickable = this.find("." + this.CLASS.uploadFiles);

	            this.$dropzoneClickable = $(options.clickable);

	            this.$dropzoneClickable.on("mousedown.FileBrowser touchend.FileBrowser", function (e) {

	                e.stopPropagation();

	                if (e.type !== "touchend") {

	                    e.preventDefault();
	                    return false;
	                }
	            });

	            options.addedfile = this.handleAddedfile.bind(this);

	            if (this.handleResize) {

	                options.resize = this.handleResize.bind(this);
	            }

	            if (this.handleThumbnail) {

	                options.thumbnail = this.handleThumbnail.bind(this);
	            }

	            options.uploadprogress = this.handleUploadProgress.bind(this);
	            options.successmultiple = this.handleUploadSuccessmultiple.bind(this);
	            options.error = this.handleUploadError.bind(this);
	            options.complete = this.handleUploadComplete.bind(this);

	            this.dropzone = this.$self.dropzone(options);

	            this.dropzoneInstance = Dropzone.forElement(this.self);

	            this.thumbWidth = options.thumbnailWidth;
	            this.thumbHeight = options.thumbnailHeight;

	            this.uploadFilesLoaded = true;

	            this.dropzone.on("dragenter", function (event) {

	                if (!event.originalEvent.dataTransfer.types[0] ||
	                    !event.originalEvent.dataTransfer.types[0].match(/file/i)) {

	                    this.self.classList.add(this.CLASS.notFileDragged);

	                    return;
	                }

	                this.self.classList.remove(this.CLASS.notFileDragged);

	                this.$overlays.css({
	                    top: this.$offsetElement.scrollTop()
	                });

	            }.bind(this));
	        },

	        //pokud složka při otevření obsahuje soubory je potřeba použit jinou intro animaci
	        hasInitContentOnOpen: function (current, before, path, index) {

	            var dirIndex = path === "openDirectory" ? current : +index;

	            if (this.skipInitDirContentObserver === dirIndex) {

	                return;
	            }

	            if (path === "openDirectory") {

	                this.skipInitDirContentObserver = dirIndex;
	            }

	            if (dirIndex || dirIndex === 0) {

	                this.set("directories." + dirIndex + ".initDirContent", !before || !before.length || path === "openDirectory");
	            }

	            this.skipInitDirContentObserver = null;
	        },

	        handleAddedfile: function (file) {

	            if (this.torndown) {

	                return;
	            }

	            var uploadDirectory = this.getDirectoryByName(this.get("uploadDirectory"));

	            if (uploadDirectory.uploadable && uploadDirectory.files) {

	                this.fileUploadCounter = !this.fileUploadCounter ? 1 : this.fileUploadCounter + 1;

	                uploadDirectory.files.unshift({
	                    name: file.name,
	                    uploading: true,
	                    uploadingId: this.fileUploadCounter,
	                    file: file
	                });

	                file.fileBrowserId = this.fileUploadCounter;
	            }

	            this.push("uploading", file);
	        },

	        handleResize: function (file) {

	            if (this.torndown) {

	                return;
	            }

	            return {
	                srcY: 0,
	                srcX: 0,
	                srcWidth: file.width,
	                srcHeight: file.height,
	                trgWidth: file.width > file.height ? this.thumbWidth : this.thumbWidth * (file.width / file.height),
	                trgHeight: file.width > file.height ? this.thumbHeight * (file.height / file.width) : this.thumbHeight
	            };
	        },

	        handleThumbnail: function (file, data) {

	            if (this.torndown || !file.accepted) {

	                return;
	            }

	            if (file.fileBrowserId && data) {

	                var directoryIndex = this.getDirectoryIndexByName(this.get("uploadDirectory")),
	                    fileIndex = this.getFileIndexByUploadingId(file.fileBrowserId);

	                this.set("directories." + directoryIndex + ".files." + fileIndex + ".preview", data);
	            }
	        },

	        handleUploadProgress: function (file, progress) {

	            if (this.torndown) {

	                return;
	            }

	            this.fire(this.get("progressBarId") + "ProgressBarProgress", {
	                id: file.name.replace(".", "_"),
	                progress: progress
	            });
	        },

	        handleUploadSuccessmultiple: function (files, paths) {

	            if (this.torndown) {

	                return;
	            }

	            var directoryIndex = this.getDirectoryIndexByName(this.get("uploadDirectory")),
	                filesInDir = this.get("directories." + directoryIndex + ".files"),
	                p,
	                f = filesInDir.length - 1;

	            for (f; f >= 0; f--) {

	                p = paths.files.length - 1;

	                for (p; p >= 0; p--) {

	                    if (filesInDir[f].name === paths.files[p].originalname) {

	                        var dataFilePath = "directories." + directoryIndex + ".files." + f;

	                        this.set(dataFilePath + ".uploading", false);
	                        this.set(dataFilePath + ".uploaded", true);
	                        this.set(dataFilePath + ".path", paths.files[p].path.replace(/\\/g, "/").replace(/^public\//g, ""));
	                        this.set(dataFilePath + ".name", paths.files[p].name);

	                        if (paths.files[p].svg) {

	                            this.set(dataFilePath + ".svg", paths.files[p].svg);
	                        }
	                    }
	                }
	            }
	        },

	        handleUploadError: function (file, error) {

	            if (this.torndown) {

	                return;
	            }

	            if (file.fileBrowserId) {

	                var directoryIndex = this.getDirectoryIndexByName(this.get("uploadDirectory")),
	                    fileIndex = this.getFileIndexByUploadingId(file.fileBrowserId);

	                this.set("directories." + directoryIndex + ".files." + fileIndex + ".uploadError", error);
	                this.set("directories." + directoryIndex + ".files." + fileIndex + ".uploading", false);

	                //odstranit chybné soubory ze složky
	                this.uploadErrorRemovingFnTimeouts = this.uploadErrorRemovingFnTimeouts || [];

	                this.uploadErrorRemovingFnTimeouts.push(setTimeout(function () {

	                    var directoryIndex = this.getDirectoryIndexByName(this.get("uploadDirectory")),
	                        fileIndex = this.getFileIndexByUploadingId(file.fileBrowserId);

	                    if (fileIndex >= 0) {

	                        this.splice("directories." + directoryIndex + ".files", fileIndex, 1);
	                    }

	                }.bind(this), directoryIndex === this.get("openDirectory") ? 2000 : 0));
	            }

	            this.fire(this.get("progressBarId") + "ProgressBarError", {
	                id: file.name.replace(".", "_")
	            });

	            this.showMessage(file.name, "Soubor se nepodařilo nahrát: " + error);
	        },

	        handleUploadComplete: function (file) {

	            if (this.torndown) {

	                return;
	            }

	            this.removeFileFromUploading(file);
	        },

	        removeFileFromUploading: function (file) {

	            var files = this.get("uploading"),
	                f = files.length - 1;

	            for (f; f >= 0; f--) {

	                if (files[f] === file) {

	                    return this.splice("uploading", f, 1);
	                }
	            }
	        },

	        loadDirectories: function () {

	            this.dirReq = this.req(this.get("reqName") + ".dirs");

	            this.dirReq.then(function (res) {

	                var d = res.directories.length - 1;

	                for (d; d >= 0; d--) {

	                    res.directories[d].files = [];
	                }

	                //vytvořit "složku" pro vyhledávání
	                if (this.get("searchable")) {

	                    res.directories.unshift({
	                        name: this.get("searchPlaceholder"),
	                        path: this.get("searchDirPath"),
	                        files: [],
	                        searchDir: true
	                    });
	                }

	                this.set("directories", res.directories);

	                setTimeout(function () {

	                    this.searchInput = this.find("." + this.CLASS.searchInput);

	                    this.initUploadFiles();

	                }.bind(this), 0);

	            }.bind(this)).catch(function () {});
	        },

	        loadFilesForDirectory: function (directory, directoryIndex) {

	            this.set("loadingDirectory", directoryIndex);

	            if (this.filesReq) {

	                this.filesReq.cancelReq();
	            }

	            this.filesReq = this.req(this.get("reqName"), {
	                directory: directory.path
	            });

	            this.filesReq.then(function (res) {

	                if (res && res.files) {

	                    var f = 0,
	                        files = [];

	                    for (f; f < res.files.length; f++) {

	                        res.files[f].path = res.files[f].path.replace(/\\/g, "/");

	                        files.push(res.files[f]);
	                    }

	                    this.merge("directories." + directoryIndex + ".files", directory.files.concat(files), {compare: "svg"});

	                    //odstranit již nahrané soubory - jsou opět načtené ze serveru
	                    var inF = directory.files.length - 1;

	                    for (inF; inF >= 0; inF--) {

	                        if (directory.files[inF].uploaded) {

	                            directory.files.splice(inF, 1);
	                        }
	                    }
	                }

	                this.set("loadingDirectory", null);

	            }.bind(this)).catch(function () {});
	        },

	        addFileToUploadDirectory: function (name, path) {

	            if (path && name) {

	                setTimeout(function() {

	                    if (this.torndown) {

	                        return;
	                    }

	                    var directoryIndex = this.getDirectoryIndexByName(this.get("uploadDirectory"));

	                    if (~directoryIndex) {

	                        this.set("directories." + directoryIndex + ".initDirContent", false);

	                        this.unshift("directories." + directoryIndex + ".files", {
	                            name: name,
	                            path: path,
	                            uploaded: true
	                        });
	                    }

	                }.bind(this), 1000);
	            }
	        },

	        deleteFile: function (event, file) {

	            var index = event.keypath.match(/[0-9]+$/);

	            this.splice(event.keypath.replace(/\.[0-9]+$/, ""), index, 1);

	            if (file.path) {

	                this.req(this.get("reqName") + ".delete", {
	                    path: file.path
	                }, true);
	            }
	        },

	        openDirectory: function (directoryIndex) {

	            this.set("showRemoveConfirmation", null);

	            var directory;

	            if (directoryIndex || directoryIndex === 0) {

	                directory = this.getDirectoryByIndex(directoryIndex);

	                //pokud jsou soubory již načteny -> return
	                if (directory && directory.files && directory.files.length && !this.directoryHasOnlyUploadedFiles(directoryIndex))  {

	                    return;
	                }

	                this.loadFilesForDirectory(directory, directoryIndex);

	            } else {

	                this.set("loadingDirectory", null);
	            }

	            //nastavit/odstranit focus u vyhledávání
	            if (this.searchInput) {

	                this.searchInput[directory && directory.searchDir ? "focus" : "blur"]();
	            }
	        },

	        directoryHasOnlyUploadedFiles: function (directoryIndex) {

	            var files = this.get("directories." + directoryIndex + ".files"),
	                f = files.length - 1;

	            for (f; f >= 0; f--) {

	                if (typeof files[f].uploading === "undefined" && typeof files[f].uploaded === "undefined") {

	                    return false;
	                }
	            }

	            return true;
	        },

	        getDirectoryByIndex: function (index) {

	            return this.get("directories." + index);
	        },

	        getDirectoryByName: function (name) {

	            var directories = this.get("directories"),
	                d = directories.length - 1;

	            for (d; d >= 0; d--) {

	                if (directories[d].name === name) {

	                    return directories[d];
	                }
	            }

	            return null;
	        },

	        getDirectoryIndexByName: function (name) {

	            var directories = this.get("directories"),
	                d = directories.length - 1;

	            for (d; d >= 0; d--) {

	                if (directories[d].name === name) {

	                    return d;
	                }
	            }

	            return -1;
	        },

	        getDirectoryIndexByPath: function (path) {

	            var directories = this.get("directories"),
	                d = directories.length - 1;

	            for (d; d >= 0; d--) {

	                if (directories[d].path === path) {

	                    return d;
	                }
	            }

	            return -1;
	        },

	        getDirectoryByPath: function (path) {

	            var directories = this.get("directories"),
	                d = directories.length - 1;

	            for (d; d >= 0; d--) {

	                if (directories[d].path === path) {

	                    return directories[d];
	                }
	            }

	            return null;
	        },

	        getFileIndexByUploadingId: function (id) {

	            var uploadDirectory = this.getDirectoryByName(this.get("uploadDirectory")),

	                files = uploadDirectory.files,
	                f = files.length - 1;

	            for (f; f >= 0; f--) {

	                if (files[f].uploadingId === id) {

	                    return f;
	                }
	            }

	            return -1;
	        },

	        getThumbsFullPath: function (path) {

	            var srcPath = this.get("srcPath").replace(/\/$/, ""),
	                thumbsPath = this.get("thumbsPath").replace(/^\/|\/$/, "");

	            thumbsPath = thumbsPath ? "/" + thumbsPath + "/" : "/";

	            return [
	                srcPath, "/",
	                path.replace(/^\/|\/$/, "")
	                    .replace(/\/([^\/]*)$/, thumbsPath + "$1")
	            ].join("");
	        },

	        showMessage: function (title, text, hideTimeout) {

	            this.$overlays.css({
	                top: this.$offsetElement.scrollTop()
	            });

	            this.set("messageTitle", title);
	            this.set("messageText", text);

	            this.set("showMessage", true);

	            clearTimeout(this.hideMessageTimeout);

	            this.hideMessageTimeout = setTimeout(this.set.bind(this, "showMessage", false), hideTimeout || 3000);
	        },

	        searchFiles: function (searchText) {

	            if (this.searchReq) {

	                this.searchReq.cancelReq(true);
	            }

	            if (!searchText || searchText.length < 2) {

	                var directoryIndex = this.getDirectoryIndexByPath(this.get("searchDirPath"));

	                this.set("directories." + directoryIndex + ".files", []);

	                return;
	            }

	            this.set("searching", true);

	            this.searchReq = this.req(this.get("reqName") + ".search", {search: searchText});

	            this.searchReq.then(function (result) {

	                if (result && result.files) {

	                    var directoryIndex = this.getDirectoryIndexByPath(this.get("searchDirPath"));

	                    this.merge("directories." + directoryIndex + ".files", result.files, {compare: true});

	                    this.set("directories." + directoryIndex + ".initDirContent", false);
	                }

	                this.set("searching", null);

	            }.bind(this)).catch(function () {

	                this.set("searching", null);

	            }.bind(this));
	        }
	    });

	}));



/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	/*global $*/
	var Ractive = __webpack_require__(0);

	module.exports = Ractive.extend({

	    template: __webpack_require__(186),

	    CLASS: {
	        self: "InlineWidget",

	        wrapper: "InlineWidget--wrapper",
	        scrollingContent: "InlineWidget--scrolling-content",

	        minmax: "InlineWidget--min-max"
	    },

	    components: {
	    },

	    partials: {
	    },

	    decorators: {
	        ResizableBox: __webpack_require__(23)
	    },

	    data: function () {

	        return {

	        };
	    },

	    onconfig: function () {

	    },

	    onrender: function () {

	    },

	    oncomplete: function () {
	    },

	    setOnParent: function (path, value) {

	        this.parent.set(path, value);
	    }

	});


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	/*global $*/
	var Ractive = __webpack_require__(0);

	/*ProgressBar se aktivuje, pokud nastane u rodičovského komponentu událost
	 * progressBarProgress nebo (idProgressBarProggress). Object události musí obsahovat
	 * unikátní id a aktuální stav:
	 * {
	 *     id: "uniqueID",
	 *     progress: 10
	 * }
	 * */

	module.exports = Ractive.extend({

	    template: __webpack_require__(187),

	    CLASS: {
	        self: "E_ProgressBar",
	        progress: "E_ProgressBar--progress",

	        success: "E_ProgressBar__success",
	        error: "E_ProgressBar__error",
	        warn: "E_ProgressBar__warn"
	    },

	    components: {
	    },

	    partials: {
	    },

	    data: function () {

	        return {
	            active: false,
	            error: false,
	            warn: false,
	            success: false,

	            progress: 0,

	            data: {},
	            errors: {},

	            id: +new Date()
	        };
	    },

	    onconfig: function () {

	        var id = this.get("id");

	        this.parent.on("progressBarProgress *.progressBarProgress " + id + "ProgressBarProgress *." + id + "ProgressBarProgress", function (progress) {

	            if (!progress || !progress.id || typeof progress.progress === "undefined") {

	                throw "ProgressBar: Progress object must be like: {id: 'uniqueId', progress: 50};";
	            }

	            //předchozí progress by dokončen -> reset
	            if (!this.hasData()) {

	                this.$progress.css({
	                    transition: "none"
	                });

	                this.set("progress", 0);
	                this.set("success", false);
	                this.set("warn", false);
	                this.set("error", false);

	                setTimeout(function() {

	                    this.$progress.css({
	                        transition: ""
	                    });

	                    this.set("data." + progress.id, progress.progress);

	                    this.set("active", true);

	                    if (progress.progress === 100) {

	                        this.activeTimeout = setTimeout(this.set.bind(this, "active", false), 500);
	                    }

	                }.bind(this), 0);

	            } else {

	                this.set("data." + progress.id, progress.progress);
	            }

	        }.bind(this));

	        this.parent.on("progressBarError *.progressBarError " + id + "ProgressBarError *." + id + "ProgressBarError", function (progress) {

	            if (!progress || !progress.id) {

	                throw "ProgressBar: Progress object must be like: {id: 'uniqueId'};";
	            }

	            //pokud by nedošlo k zresetování "progress", nespustil by se observer
	            if (this.get("progress") === 100) {

	                this.set("progress", 0);
	            }

	            //předchozí progress by dokončen -> reset
	            if (!this.hasData()) {

	                this.$progress.css({
	                    transition: "none"
	                });

	                this.set("success", false);
	                this.set("warn", false);

	                setTimeout(function() {

	                    this.$progress.css({
	                        transition: ""
	                    });

	                    this.set("data." + progress.id, 100);
	                    this.set("active", true);

	                    this.activeTimeout = setTimeout(this.set.bind(this, "active", false), 500);

	                }.bind(this), 0);

	            } else {

	                this.set("data." + progress.id, 100);
	            }

	            this.set("error", progress.id);
	            this.set("errors." + progress.id, true);

	        }.bind(this));

	        this.observe("data", function (data) {

	            if (this.skipDataObserver) {

	                return;
	            }

	            var errors = this.get("errors"),

	                totalProgress = 0,

	                itemsCount = 0,
	                errorsCount = 0;

	            $.each(data, function (id, progress) {

	                totalProgress += progress;

	                itemsCount++;

	                if (errors[id]) {

	                    errorsCount++;
	                }

	            }.bind(this));

	            this.set("progress", totalProgress ? totalProgress / itemsCount : 0);

	            if (errorsCount) {

	                //pokud jsou některé probíhající události chybové -> změnit stav na "warn",
	                //pokud všechny, ponechat stav "error"
	                this.set("warn", errorsCount < itemsCount);
	            }

	        }, {init: false});

	        this.observe("progress", function (state) {

	            clearTimeout(this.activeTimeout);

	            if (state === 100) {

	                if (!this.get("error") && !this.get("warn")) {

	                    this.set("success", true);
	                }

	                this.set("active", false);

	                this.skipDataObserver = true;

	                this.set("data", {});
	                this.set("errors", {});

	                this.skipDataObserver = false;
	            }

	        }, {init: false, defer: true});
	    },

	    onrender: function () {

	        this.$progress = $(this.find("." + this.CLASS.progress));
	    },

	    oncomplete: function () {
	    },

	    hasData: function () {

	        var data = this.get("data"),

	            hasData = false;

	        $.each(data, function () {

	            hasData = true;

	            return false;
	        });

	        return hasData;
	    }

	});


/***/ },
/* 37 */
/***/ function(module, exports) {

	/**
	 * Slice reference.
	 */

	var slice = [].slice;

	/**
	 * Bind `obj` to `fn`.
	 *
	 * @param {Object} obj
	 * @param {Function|String} fn or string
	 * @return {Function}
	 * @api public
	 */

	module.exports = function(obj, fn){
	  if ('string' == typeof fn) fn = obj[fn];
	  if ('function' != typeof fn) throw new Error('bind() requires a function');
	  var args = slice.call(arguments, 2);
	  return function(){
	    return fn.apply(obj, args.concat(slice.call(arguments)));
	  }
	};


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {
	/*
	 *
	 * More info at [www.dropzonejs.com](http://www.dropzonejs.com)
	 *
	 * Copyright (c) 2012, Matias Meno
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */

	(function() {
	  var Dropzone, Emitter, camelize, contentLoaded, detectVerticalSquash, drawImageIOSFix, noop, without,
	    __slice = [].slice,
	    __hasProp = {}.hasOwnProperty,
	    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

	  noop = function() {};

	  Emitter = (function() {
	    function Emitter() {}

	    Emitter.prototype.addEventListener = Emitter.prototype.on;

	    Emitter.prototype.on = function(event, fn) {
	      this._callbacks = this._callbacks || {};
	      if (!this._callbacks[event]) {
	        this._callbacks[event] = [];
	      }
	      this._callbacks[event].push(fn);
	      return this;
	    };

	    Emitter.prototype.emit = function() {
	      var args, callback, callbacks, event, _i, _len;
	      event = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
	      this._callbacks = this._callbacks || {};
	      callbacks = this._callbacks[event];
	      if (callbacks) {
	        for (_i = 0, _len = callbacks.length; _i < _len; _i++) {
	          callback = callbacks[_i];
	          callback.apply(this, args);
	        }
	      }
	      return this;
	    };

	    Emitter.prototype.removeListener = Emitter.prototype.off;

	    Emitter.prototype.removeAllListeners = Emitter.prototype.off;

	    Emitter.prototype.removeEventListener = Emitter.prototype.off;

	    Emitter.prototype.off = function(event, fn) {
	      var callback, callbacks, i, _i, _len;
	      if (!this._callbacks || arguments.length === 0) {
	        this._callbacks = {};
	        return this;
	      }
	      callbacks = this._callbacks[event];
	      if (!callbacks) {
	        return this;
	      }
	      if (arguments.length === 1) {
	        delete this._callbacks[event];
	        return this;
	      }
	      for (i = _i = 0, _len = callbacks.length; _i < _len; i = ++_i) {
	        callback = callbacks[i];
	        if (callback === fn) {
	          callbacks.splice(i, 1);
	          break;
	        }
	      }
	      return this;
	    };

	    return Emitter;

	  })();

	  Dropzone = (function(_super) {
	    var extend, resolveOption;

	    __extends(Dropzone, _super);

	    Dropzone.prototype.Emitter = Emitter;


	    /*
	    This is a list of all available events you can register on a dropzone object.

	    You can register an event handler like this:

	        dropzone.on("dragEnter", function() { });
	     */

	    Dropzone.prototype.events = ["drop", "dragstart", "dragend", "dragenter", "dragover", "dragleave", "addedfile", "addedfiles", "removedfile", "thumbnail", "error", "errormultiple", "processing", "processingmultiple", "uploadprogress", "totaluploadprogress", "sending", "sendingmultiple", "success", "successmultiple", "canceled", "canceledmultiple", "complete", "completemultiple", "reset", "maxfilesexceeded", "maxfilesreached", "queuecomplete"];

	    Dropzone.prototype.defaultOptions = {
	      url: null,
	      method: "post",
	      withCredentials: false,
	      parallelUploads: 2,
	      uploadMultiple: false,
	      maxFilesize: 256,
	      paramName: "file",
	      createImageThumbnails: true,
	      maxThumbnailFilesize: 10,
	      thumbnailWidth: 120,
	      thumbnailHeight: 120,
	      filesizeBase: 1000,
	      maxFiles: null,
	      params: {},
	      clickable: true,
	      ignoreHiddenFiles: true,
	      acceptedFiles: null,
	      acceptedMimeTypes: null,
	      autoProcessQueue: true,
	      autoQueue: true,
	      addRemoveLinks: false,
	      previewsContainer: null,
	      hiddenInputContainer: "body",
	      capture: null,
	      renameFilename: null,
	      dictDefaultMessage: "Drop files here to upload",
	      dictFallbackMessage: "Your browser does not support drag'n'drop file uploads.",
	      dictFallbackText: "Please use the fallback form below to upload your files like in the olden days.",
	      dictFileTooBig: "File is too big ({{filesize}}MiB). Max filesize: {{maxFilesize}}MiB.",
	      dictInvalidFileType: "You can't upload files of this type.",
	      dictResponseError: "Server responded with {{statusCode}} code.",
	      dictCancelUpload: "Cancel upload",
	      dictCancelUploadConfirmation: "Are you sure you want to cancel this upload?",
	      dictRemoveFile: "Remove file",
	      dictRemoveFileConfirmation: null,
	      dictMaxFilesExceeded: "You can not upload any more files.",
	      accept: function(file, done) {
	        return done();
	      },
	      init: function() {
	        return noop;
	      },
	      forceFallback: false,
	      fallback: function() {
	        var child, messageElement, span, _i, _len, _ref;
	        this.element.className = "" + this.element.className + " dz-browser-not-supported";
	        _ref = this.element.getElementsByTagName("div");
	        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	          child = _ref[_i];
	          if (/(^| )dz-message($| )/.test(child.className)) {
	            messageElement = child;
	            child.className = "dz-message";
	            continue;
	          }
	        }
	        if (!messageElement) {
	          messageElement = Dropzone.createElement("<div class=\"dz-message\"><span></span></div>");
	          this.element.appendChild(messageElement);
	        }
	        span = messageElement.getElementsByTagName("span")[0];
	        if (span) {
	          if (span.textContent != null) {
	            span.textContent = this.options.dictFallbackMessage;
	          } else if (span.innerText != null) {
	            span.innerText = this.options.dictFallbackMessage;
	          }
	        }
	        return this.element.appendChild(this.getFallbackForm());
	      },
	      resize: function(file) {
	        var info, srcRatio, trgRatio;
	        info = {
	          srcX: 0,
	          srcY: 0,
	          srcWidth: file.width,
	          srcHeight: file.height
	        };
	        srcRatio = file.width / file.height;
	        info.optWidth = this.options.thumbnailWidth;
	        info.optHeight = this.options.thumbnailHeight;
	        if ((info.optWidth == null) && (info.optHeight == null)) {
	          info.optWidth = info.srcWidth;
	          info.optHeight = info.srcHeight;
	        } else if (info.optWidth == null) {
	          info.optWidth = srcRatio * info.optHeight;
	        } else if (info.optHeight == null) {
	          info.optHeight = (1 / srcRatio) * info.optWidth;
	        }
	        trgRatio = info.optWidth / info.optHeight;
	        if (file.height < info.optHeight || file.width < info.optWidth) {
	          info.trgHeight = info.srcHeight;
	          info.trgWidth = info.srcWidth;
	        } else {
	          if (srcRatio > trgRatio) {
	            info.srcHeight = file.height;
	            info.srcWidth = info.srcHeight * trgRatio;
	          } else {
	            info.srcWidth = file.width;
	            info.srcHeight = info.srcWidth / trgRatio;
	          }
	        }
	        info.srcX = (file.width - info.srcWidth) / 2;
	        info.srcY = (file.height - info.srcHeight) / 2;
	        return info;
	      },

	      /*
	      Those functions register themselves to the events on init and handle all
	      the user interface specific stuff. Overwriting them won't break the upload
	      but can break the way it's displayed.
	      You can overwrite them if you don't like the default behavior. If you just
	      want to add an additional event handler, register it on the dropzone object
	      and don't overwrite those options.
	       */
	      drop: function(e) {
	        return this.element.classList.remove("dz-drag-hover");
	      },
	      dragstart: noop,
	      dragend: function(e) {
	        return this.element.classList.remove("dz-drag-hover");
	      },
	      dragenter: function(e) {
	        return this.element.classList.add("dz-drag-hover");
	      },
	      dragover: function(e) {
	        return this.element.classList.add("dz-drag-hover");
	      },
	      dragleave: function(e) {
	        return this.element.classList.remove("dz-drag-hover");
	      },
	      paste: noop,
	      reset: function() {
	        return this.element.classList.remove("dz-started");
	      },
	      addedfile: function(file) {
	        var node, removeFileEvent, removeLink, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
	        if (this.element === this.previewsContainer) {
	          this.element.classList.add("dz-started");
	        }
	        if (this.previewsContainer) {
	          file.previewElement = Dropzone.createElement(this.options.previewTemplate.trim());
	          file.previewTemplate = file.previewElement;
	          this.previewsContainer.appendChild(file.previewElement);
	          _ref = file.previewElement.querySelectorAll("[data-dz-name]");
	          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	            node = _ref[_i];
	            node.textContent = this._renameFilename(file.name);
	          }
	          _ref1 = file.previewElement.querySelectorAll("[data-dz-size]");
	          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
	            node = _ref1[_j];
	            node.innerHTML = this.filesize(file.size);
	          }
	          if (this.options.addRemoveLinks) {
	            file._removeLink = Dropzone.createElement("<a class=\"dz-remove\" href=\"javascript:undefined;\" data-dz-remove>" + this.options.dictRemoveFile + "</a>");
	            file.previewElement.appendChild(file._removeLink);
	          }
	          removeFileEvent = (function(_this) {
	            return function(e) {
	              e.preventDefault();
	              e.stopPropagation();
	              if (file.status === Dropzone.UPLOADING) {
	                return Dropzone.confirm(_this.options.dictCancelUploadConfirmation, function() {
	                  return _this.removeFile(file);
	                });
	              } else {
	                if (_this.options.dictRemoveFileConfirmation) {
	                  return Dropzone.confirm(_this.options.dictRemoveFileConfirmation, function() {
	                    return _this.removeFile(file);
	                  });
	                } else {
	                  return _this.removeFile(file);
	                }
	              }
	            };
	          })(this);
	          _ref2 = file.previewElement.querySelectorAll("[data-dz-remove]");
	          _results = [];
	          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
	            removeLink = _ref2[_k];
	            _results.push(removeLink.addEventListener("click", removeFileEvent));
	          }
	          return _results;
	        }
	      },
	      removedfile: function(file) {
	        var _ref;
	        if (file.previewElement) {
	          if ((_ref = file.previewElement) != null) {
	            _ref.parentNode.removeChild(file.previewElement);
	          }
	        }
	        return this._updateMaxFilesReachedClass();
	      },
	      thumbnail: function(file, dataUrl) {
	        var thumbnailElement, _i, _len, _ref;
	        if (file.previewElement) {
	          file.previewElement.classList.remove("dz-file-preview");
	          _ref = file.previewElement.querySelectorAll("[data-dz-thumbnail]");
	          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	            thumbnailElement = _ref[_i];
	            thumbnailElement.alt = file.name;
	            thumbnailElement.src = dataUrl;
	          }
	          return setTimeout(((function(_this) {
	            return function() {
	              return file.previewElement.classList.add("dz-image-preview");
	            };
	          })(this)), 1);
	        }
	      },
	      error: function(file, message) {
	        var node, _i, _len, _ref, _results;
	        if (file.previewElement) {
	          file.previewElement.classList.add("dz-error");
	          if (typeof message !== "String" && message.error) {
	            message = message.error;
	          }
	          _ref = file.previewElement.querySelectorAll("[data-dz-errormessage]");
	          _results = [];
	          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	            node = _ref[_i];
	            _results.push(node.textContent = message);
	          }
	          return _results;
	        }
	      },
	      errormultiple: noop,
	      processing: function(file) {
	        if (file.previewElement) {
	          file.previewElement.classList.add("dz-processing");
	          if (file._removeLink) {
	            return file._removeLink.textContent = this.options.dictCancelUpload;
	          }
	        }
	      },
	      processingmultiple: noop,
	      uploadprogress: function(file, progress, bytesSent) {
	        var node, _i, _len, _ref, _results;
	        if (file.previewElement) {
	          _ref = file.previewElement.querySelectorAll("[data-dz-uploadprogress]");
	          _results = [];
	          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	            node = _ref[_i];
	            if (node.nodeName === 'PROGRESS') {
	              _results.push(node.value = progress);
	            } else {
	              _results.push(node.style.width = "" + progress + "%");
	            }
	          }
	          return _results;
	        }
	      },
	      totaluploadprogress: noop,
	      sending: noop,
	      sendingmultiple: noop,
	      success: function(file) {
	        if (file.previewElement) {
	          return file.previewElement.classList.add("dz-success");
	        }
	      },
	      successmultiple: noop,
	      canceled: function(file) {
	        return this.emit("error", file, "Upload canceled.");
	      },
	      canceledmultiple: noop,
	      complete: function(file) {
	        if (file._removeLink) {
	          file._removeLink.textContent = this.options.dictRemoveFile;
	        }
	        if (file.previewElement) {
	          return file.previewElement.classList.add("dz-complete");
	        }
	      },
	      completemultiple: noop,
	      maxfilesexceeded: noop,
	      maxfilesreached: noop,
	      queuecomplete: noop,
	      addedfiles: noop,
	      previewTemplate: "<div class=\"dz-preview dz-file-preview\">\n  <div class=\"dz-image\"><img data-dz-thumbnail /></div>\n  <div class=\"dz-details\">\n    <div class=\"dz-size\"><span data-dz-size></span></div>\n    <div class=\"dz-filename\"><span data-dz-name></span></div>\n  </div>\n  <div class=\"dz-progress\"><span class=\"dz-upload\" data-dz-uploadprogress></span></div>\n  <div class=\"dz-error-message\"><span data-dz-errormessage></span></div>\n  <div class=\"dz-success-mark\">\n    <svg width=\"54px\" height=\"54px\" viewBox=\"0 0 54 54\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:sketch=\"http://www.bohemiancoding.com/sketch/ns\">\n      <title>Check</title>\n      <defs></defs>\n      <g id=\"Page-1\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\" sketch:type=\"MSPage\">\n        <path d=\"M23.5,31.8431458 L17.5852419,25.9283877 C16.0248253,24.3679711 13.4910294,24.366835 11.9289322,25.9289322 C10.3700136,27.4878508 10.3665912,30.0234455 11.9283877,31.5852419 L20.4147581,40.0716123 C20.5133999,40.1702541 20.6159315,40.2626649 20.7218615,40.3488435 C22.2835669,41.8725651 24.794234,41.8626202 26.3461564,40.3106978 L43.3106978,23.3461564 C44.8771021,21.7797521 44.8758057,19.2483887 43.3137085,17.6862915 C41.7547899,16.1273729 39.2176035,16.1255422 37.6538436,17.6893022 L23.5,31.8431458 Z M27,53 C41.3594035,53 53,41.3594035 53,27 C53,12.6405965 41.3594035,1 27,1 C12.6405965,1 1,12.6405965 1,27 C1,41.3594035 12.6405965,53 27,53 Z\" id=\"Oval-2\" stroke-opacity=\"0.198794158\" stroke=\"#747474\" fill-opacity=\"0.816519475\" fill=\"#FFFFFF\" sketch:type=\"MSShapeGroup\"></path>\n      </g>\n    </svg>\n  </div>\n  <div class=\"dz-error-mark\">\n    <svg width=\"54px\" height=\"54px\" viewBox=\"0 0 54 54\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:sketch=\"http://www.bohemiancoding.com/sketch/ns\">\n      <title>Error</title>\n      <defs></defs>\n      <g id=\"Page-1\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\" sketch:type=\"MSPage\">\n        <g id=\"Check-+-Oval-2\" sketch:type=\"MSLayerGroup\" stroke=\"#747474\" stroke-opacity=\"0.198794158\" fill=\"#FFFFFF\" fill-opacity=\"0.816519475\">\n          <path d=\"M32.6568542,29 L38.3106978,23.3461564 C39.8771021,21.7797521 39.8758057,19.2483887 38.3137085,17.6862915 C36.7547899,16.1273729 34.2176035,16.1255422 32.6538436,17.6893022 L27,23.3431458 L21.3461564,17.6893022 C19.7823965,16.1255422 17.2452101,16.1273729 15.6862915,17.6862915 C14.1241943,19.2483887 14.1228979,21.7797521 15.6893022,23.3461564 L21.3431458,29 L15.6893022,34.6538436 C14.1228979,36.2202479 14.1241943,38.7516113 15.6862915,40.3137085 C17.2452101,41.8726271 19.7823965,41.8744578 21.3461564,40.3106978 L27,34.6568542 L32.6538436,40.3106978 C34.2176035,41.8744578 36.7547899,41.8726271 38.3137085,40.3137085 C39.8758057,38.7516113 39.8771021,36.2202479 38.3106978,34.6538436 L32.6568542,29 Z M27,53 C41.3594035,53 53,41.3594035 53,27 C53,12.6405965 41.3594035,1 27,1 C12.6405965,1 1,12.6405965 1,27 C1,41.3594035 12.6405965,53 27,53 Z\" id=\"Oval-2\" sketch:type=\"MSShapeGroup\"></path>\n        </g>\n      </g>\n    </svg>\n  </div>\n</div>"
	    };

	    extend = function() {
	      var key, object, objects, target, val, _i, _len;
	      target = arguments[0], objects = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
	      for (_i = 0, _len = objects.length; _i < _len; _i++) {
	        object = objects[_i];
	        for (key in object) {
	          val = object[key];
	          target[key] = val;
	        }
	      }
	      return target;
	    };

	    function Dropzone(element, options) {
	      var elementOptions, fallback, _ref;
	      this.element = element;
	      this.version = Dropzone.version;
	      this.defaultOptions.previewTemplate = this.defaultOptions.previewTemplate.replace(/\n*/g, "");
	      this.clickableElements = [];
	      this.listeners = [];
	      this.files = [];
	      if (typeof this.element === "string") {
	        this.element = document.querySelector(this.element);
	      }
	      if (!(this.element && (this.element.nodeType != null))) {
	        throw new Error("Invalid dropzone element.");
	      }
	      if (this.element.dropzone) {
	        throw new Error("Dropzone already attached.");
	      }
	      Dropzone.instances.push(this);
	      this.element.dropzone = this;
	      elementOptions = (_ref = Dropzone.optionsForElement(this.element)) != null ? _ref : {};
	      this.options = extend({}, this.defaultOptions, elementOptions, options != null ? options : {});
	      if (this.options.forceFallback || !Dropzone.isBrowserSupported()) {
	        return this.options.fallback.call(this);
	      }
	      if (this.options.url == null) {
	        this.options.url = this.element.getAttribute("action");
	      }
	      if (!this.options.url) {
	        throw new Error("No URL provided.");
	      }
	      if (this.options.acceptedFiles && this.options.acceptedMimeTypes) {
	        throw new Error("You can't provide both 'acceptedFiles' and 'acceptedMimeTypes'. 'acceptedMimeTypes' is deprecated.");
	      }
	      if (this.options.acceptedMimeTypes) {
	        this.options.acceptedFiles = this.options.acceptedMimeTypes;
	        delete this.options.acceptedMimeTypes;
	      }
	      this.options.method = this.options.method.toUpperCase();
	      if ((fallback = this.getExistingFallback()) && fallback.parentNode) {
	        fallback.parentNode.removeChild(fallback);
	      }
	      if (this.options.previewsContainer !== false) {
	        if (this.options.previewsContainer) {
	          this.previewsContainer = Dropzone.getElement(this.options.previewsContainer, "previewsContainer");
	        } else {
	          this.previewsContainer = this.element;
	        }
	      }
	      if (this.options.clickable) {
	        if (this.options.clickable === true) {
	          this.clickableElements = [this.element];
	        } else {
	          this.clickableElements = Dropzone.getElements(this.options.clickable, "clickable");
	        }
	      }
	      this.init();
	    }

	    Dropzone.prototype.getAcceptedFiles = function() {
	      var file, _i, _len, _ref, _results;
	      _ref = this.files;
	      _results = [];
	      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	        file = _ref[_i];
	        if (file.accepted) {
	          _results.push(file);
	        }
	      }
	      return _results;
	    };

	    Dropzone.prototype.getRejectedFiles = function() {
	      var file, _i, _len, _ref, _results;
	      _ref = this.files;
	      _results = [];
	      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	        file = _ref[_i];
	        if (!file.accepted) {
	          _results.push(file);
	        }
	      }
	      return _results;
	    };

	    Dropzone.prototype.getFilesWithStatus = function(status) {
	      var file, _i, _len, _ref, _results;
	      _ref = this.files;
	      _results = [];
	      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	        file = _ref[_i];
	        if (file.status === status) {
	          _results.push(file);
	        }
	      }
	      return _results;
	    };

	    Dropzone.prototype.getQueuedFiles = function() {
	      return this.getFilesWithStatus(Dropzone.QUEUED);
	    };

	    Dropzone.prototype.getUploadingFiles = function() {
	      return this.getFilesWithStatus(Dropzone.UPLOADING);
	    };

	    Dropzone.prototype.getAddedFiles = function() {
	      return this.getFilesWithStatus(Dropzone.ADDED);
	    };

	    Dropzone.prototype.getActiveFiles = function() {
	      var file, _i, _len, _ref, _results;
	      _ref = this.files;
	      _results = [];
	      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	        file = _ref[_i];
	        if (file.status === Dropzone.UPLOADING || file.status === Dropzone.QUEUED) {
	          _results.push(file);
	        }
	      }
	      return _results;
	    };

	    Dropzone.prototype.init = function() {
	      var eventName, noPropagation, setupHiddenFileInput, _i, _len, _ref, _ref1;
	      if (this.element.tagName === "form") {
	        this.element.setAttribute("enctype", "multipart/form-data");
	      }
	      if (this.element.classList.contains("dropzone") && !this.element.querySelector(".dz-message")) {
	        this.element.appendChild(Dropzone.createElement("<div class=\"dz-default dz-message\"><span>" + this.options.dictDefaultMessage + "</span></div>"));
	      }
	      if (this.clickableElements.length) {
	        setupHiddenFileInput = (function(_this) {
	          return function() {
	            if (_this.hiddenFileInput) {
	              _this.hiddenFileInput.parentNode.removeChild(_this.hiddenFileInput);
	            }
	            _this.hiddenFileInput = document.createElement("input");
	            _this.hiddenFileInput.setAttribute("type", "file");
	            if ((_this.options.maxFiles == null) || _this.options.maxFiles > 1) {
	              _this.hiddenFileInput.setAttribute("multiple", "multiple");
	            }
	            _this.hiddenFileInput.className = "dz-hidden-input";
	            if (_this.options.acceptedFiles != null) {
	              _this.hiddenFileInput.setAttribute("accept", _this.options.acceptedFiles);
	            }
	            if (_this.options.capture != null) {
	              _this.hiddenFileInput.setAttribute("capture", _this.options.capture);
	            }
	            _this.hiddenFileInput.style.visibility = "hidden";
	            _this.hiddenFileInput.style.position = "absolute";
	            _this.hiddenFileInput.style.top = "0";
	            _this.hiddenFileInput.style.left = "0";
	            _this.hiddenFileInput.style.height = "0";
	            _this.hiddenFileInput.style.width = "0";
	            document.querySelector(_this.options.hiddenInputContainer).appendChild(_this.hiddenFileInput);
	            return _this.hiddenFileInput.addEventListener("change", function() {
	              var file, files, _i, _len;
	              files = _this.hiddenFileInput.files;
	              if (files.length) {
	                for (_i = 0, _len = files.length; _i < _len; _i++) {
	                  file = files[_i];
	                  _this.addFile(file);
	                }
	              }
	              _this.emit("addedfiles", files);
	              return setupHiddenFileInput();
	            });
	          };
	        })(this);
	        setupHiddenFileInput();
	      }
	      this.URL = (_ref = window.URL) != null ? _ref : window.webkitURL;
	      _ref1 = this.events;
	      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
	        eventName = _ref1[_i];
	        this.on(eventName, this.options[eventName]);
	      }
	      this.on("uploadprogress", (function(_this) {
	        return function() {
	          return _this.updateTotalUploadProgress();
	        };
	      })(this));
	      this.on("removedfile", (function(_this) {
	        return function() {
	          return _this.updateTotalUploadProgress();
	        };
	      })(this));
	      this.on("canceled", (function(_this) {
	        return function(file) {
	          return _this.emit("complete", file);
	        };
	      })(this));
	      this.on("complete", (function(_this) {
	        return function(file) {
	          if (_this.getAddedFiles().length === 0 && _this.getUploadingFiles().length === 0 && _this.getQueuedFiles().length === 0) {
	            return setTimeout((function() {
	              return _this.emit("queuecomplete");
	            }), 0);
	          }
	        };
	      })(this));
	      noPropagation = function(e) {
	        e.stopPropagation();
	        if (e.preventDefault) {
	          return e.preventDefault();
	        } else {
	          return e.returnValue = false;
	        }
	      };
	      this.listeners = [
	        {
	          element: this.element,
	          events: {
	            "dragstart": (function(_this) {
	              return function(e) {
	                return _this.emit("dragstart", e);
	              };
	            })(this),
	            "dragenter": (function(_this) {
	              return function(e) {
	                noPropagation(e);
	                return _this.emit("dragenter", e);
	              };
	            })(this),
	            "dragover": (function(_this) {
	              return function(e) {
	                var efct;
	                try {
	                  efct = e.dataTransfer.effectAllowed;
	                } catch (_error) {}
	                e.dataTransfer.dropEffect = 'move' === efct || 'linkMove' === efct ? 'move' : 'copy';
	                noPropagation(e);
	                return _this.emit("dragover", e);
	              };
	            })(this),
	            "dragleave": (function(_this) {
	              return function(e) {
	                return _this.emit("dragleave", e);
	              };
	            })(this),
	            "drop": (function(_this) {
	              return function(e) {
	                noPropagation(e);
	                return _this.drop(e);
	              };
	            })(this),
	            "dragend": (function(_this) {
	              return function(e) {
	                return _this.emit("dragend", e);
	              };
	            })(this)
	          }
	        }
	      ];
	      this.clickableElements.forEach((function(_this) {
	        return function(clickableElement) {
	          return _this.listeners.push({
	            element: clickableElement,
	            events: {
	              "click": function(evt) {
	                if ((clickableElement !== _this.element) || (evt.target === _this.element || Dropzone.elementInside(evt.target, _this.element.querySelector(".dz-message")))) {
	                  _this.hiddenFileInput.click();
	                }
	                return true;
	              }
	            }
	          });
	        };
	      })(this));
	      this.enable();
	      return this.options.init.call(this);
	    };

	    Dropzone.prototype.destroy = function() {
	      var _ref;
	      this.disable();
	      this.removeAllFiles(true);
	      if ((_ref = this.hiddenFileInput) != null ? _ref.parentNode : void 0) {
	        this.hiddenFileInput.parentNode.removeChild(this.hiddenFileInput);
	        this.hiddenFileInput = null;
	      }
	      delete this.element.dropzone;
	      return Dropzone.instances.splice(Dropzone.instances.indexOf(this), 1);
	    };

	    Dropzone.prototype.updateTotalUploadProgress = function() {
	      var activeFiles, file, totalBytes, totalBytesSent, totalUploadProgress, _i, _len, _ref;
	      totalBytesSent = 0;
	      totalBytes = 0;
	      activeFiles = this.getActiveFiles();
	      if (activeFiles.length) {
	        _ref = this.getActiveFiles();
	        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	          file = _ref[_i];
	          totalBytesSent += file.upload.bytesSent;
	          totalBytes += file.upload.total;
	        }
	        totalUploadProgress = 100 * totalBytesSent / totalBytes;
	      } else {
	        totalUploadProgress = 100;
	      }
	      return this.emit("totaluploadprogress", totalUploadProgress, totalBytes, totalBytesSent);
	    };

	    Dropzone.prototype._getParamName = function(n) {
	      if (typeof this.options.paramName === "function") {
	        return this.options.paramName(n);
	      } else {
	        return "" + this.options.paramName + (this.options.uploadMultiple ? "[" + n + "]" : "");
	      }
	    };

	    Dropzone.prototype._renameFilename = function(name) {
	      if (typeof this.options.renameFilename !== "function") {
	        return name;
	      }
	      return this.options.renameFilename(name);
	    };

	    Dropzone.prototype.getFallbackForm = function() {
	      var existingFallback, fields, fieldsString, form;
	      if (existingFallback = this.getExistingFallback()) {
	        return existingFallback;
	      }
	      fieldsString = "<div class=\"dz-fallback\">";
	      if (this.options.dictFallbackText) {
	        fieldsString += "<p>" + this.options.dictFallbackText + "</p>";
	      }
	      fieldsString += "<input type=\"file\" name=\"" + (this._getParamName(0)) + "\" " + (this.options.uploadMultiple ? 'multiple="multiple"' : void 0) + " /><input type=\"submit\" value=\"Upload!\"></div>";
	      fields = Dropzone.createElement(fieldsString);
	      if (this.element.tagName !== "FORM") {
	        form = Dropzone.createElement("<form action=\"" + this.options.url + "\" enctype=\"multipart/form-data\" method=\"" + this.options.method + "\"></form>");
	        form.appendChild(fields);
	      } else {
	        this.element.setAttribute("enctype", "multipart/form-data");
	        this.element.setAttribute("method", this.options.method);
	      }
	      return form != null ? form : fields;
	    };

	    Dropzone.prototype.getExistingFallback = function() {
	      var fallback, getFallback, tagName, _i, _len, _ref;
	      getFallback = function(elements) {
	        var el, _i, _len;
	        for (_i = 0, _len = elements.length; _i < _len; _i++) {
	          el = elements[_i];
	          if (/(^| )fallback($| )/.test(el.className)) {
	            return el;
	          }
	        }
	      };
	      _ref = ["div", "form"];
	      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	        tagName = _ref[_i];
	        if (fallback = getFallback(this.element.getElementsByTagName(tagName))) {
	          return fallback;
	        }
	      }
	    };

	    Dropzone.prototype.setupEventListeners = function() {
	      var elementListeners, event, listener, _i, _len, _ref, _results;
	      _ref = this.listeners;
	      _results = [];
	      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	        elementListeners = _ref[_i];
	        _results.push((function() {
	          var _ref1, _results1;
	          _ref1 = elementListeners.events;
	          _results1 = [];
	          for (event in _ref1) {
	            listener = _ref1[event];
	            _results1.push(elementListeners.element.addEventListener(event, listener, false));
	          }
	          return _results1;
	        })());
	      }
	      return _results;
	    };

	    Dropzone.prototype.removeEventListeners = function() {
	      var elementListeners, event, listener, _i, _len, _ref, _results;
	      _ref = this.listeners;
	      _results = [];
	      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	        elementListeners = _ref[_i];
	        _results.push((function() {
	          var _ref1, _results1;
	          _ref1 = elementListeners.events;
	          _results1 = [];
	          for (event in _ref1) {
	            listener = _ref1[event];
	            _results1.push(elementListeners.element.removeEventListener(event, listener, false));
	          }
	          return _results1;
	        })());
	      }
	      return _results;
	    };

	    Dropzone.prototype.disable = function() {
	      var file, _i, _len, _ref, _results;
	      this.clickableElements.forEach(function(element) {
	        return element.classList.remove("dz-clickable");
	      });
	      this.removeEventListeners();
	      _ref = this.files;
	      _results = [];
	      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	        file = _ref[_i];
	        _results.push(this.cancelUpload(file));
	      }
	      return _results;
	    };

	    Dropzone.prototype.enable = function() {
	      this.clickableElements.forEach(function(element) {
	        return element.classList.add("dz-clickable");
	      });
	      return this.setupEventListeners();
	    };

	    Dropzone.prototype.filesize = function(size) {
	      var cutoff, i, selectedSize, selectedUnit, unit, units, _i, _len;
	      selectedSize = 0;
	      selectedUnit = "b";
	      if (size > 0) {
	        units = ['TB', 'GB', 'MB', 'KB', 'b'];
	        for (i = _i = 0, _len = units.length; _i < _len; i = ++_i) {
	          unit = units[i];
	          cutoff = Math.pow(this.options.filesizeBase, 4 - i) / 10;
	          if (size >= cutoff) {
	            selectedSize = size / Math.pow(this.options.filesizeBase, 4 - i);
	            selectedUnit = unit;
	            break;
	          }
	        }
	        selectedSize = Math.round(10 * selectedSize) / 10;
	      }
	      return "<strong>" + selectedSize + "</strong> " + selectedUnit;
	    };

	    Dropzone.prototype._updateMaxFilesReachedClass = function() {
	      if ((this.options.maxFiles != null) && this.getAcceptedFiles().length >= this.options.maxFiles) {
	        if (this.getAcceptedFiles().length === this.options.maxFiles) {
	          this.emit('maxfilesreached', this.files);
	        }
	        return this.element.classList.add("dz-max-files-reached");
	      } else {
	        return this.element.classList.remove("dz-max-files-reached");
	      }
	    };

	    Dropzone.prototype.drop = function(e) {
	      var files, items;
	      if (!e.dataTransfer) {
	        return;
	      }
	      this.emit("drop", e);
	      files = e.dataTransfer.files;
	      this.emit("addedfiles", files);
	      if (files.length) {
	        items = e.dataTransfer.items;
	        if (items && items.length && (items[0].webkitGetAsEntry != null)) {
	          this._addFilesFromItems(items);
	        } else {
	          this.handleFiles(files);
	        }
	      }
	    };

	    Dropzone.prototype.paste = function(e) {
	      var items, _ref;
	      if ((e != null ? (_ref = e.clipboardData) != null ? _ref.items : void 0 : void 0) == null) {
	        return;
	      }
	      this.emit("paste", e);
	      items = e.clipboardData.items;
	      if (items.length) {
	        return this._addFilesFromItems(items);
	      }
	    };

	    Dropzone.prototype.handleFiles = function(files) {
	      var file, _i, _len, _results;
	      _results = [];
	      for (_i = 0, _len = files.length; _i < _len; _i++) {
	        file = files[_i];
	        _results.push(this.addFile(file));
	      }
	      return _results;
	    };

	    Dropzone.prototype._addFilesFromItems = function(items) {
	      var entry, item, _i, _len, _results;
	      _results = [];
	      for (_i = 0, _len = items.length; _i < _len; _i++) {
	        item = items[_i];
	        if ((item.webkitGetAsEntry != null) && (entry = item.webkitGetAsEntry())) {
	          if (entry.isFile) {
	            _results.push(this.addFile(item.getAsFile()));
	          } else if (entry.isDirectory) {
	            _results.push(this._addFilesFromDirectory(entry, entry.name));
	          } else {
	            _results.push(void 0);
	          }
	        } else if (item.getAsFile != null) {
	          if ((item.kind == null) || item.kind === "file") {
	            _results.push(this.addFile(item.getAsFile()));
	          } else {
	            _results.push(void 0);
	          }
	        } else {
	          _results.push(void 0);
	        }
	      }
	      return _results;
	    };

	    Dropzone.prototype._addFilesFromDirectory = function(directory, path) {
	      var dirReader, errorHandler, readEntries;
	      dirReader = directory.createReader();
	      errorHandler = function(error) {
	        return typeof console !== "undefined" && console !== null ? typeof console.log === "function" ? console.log(error) : void 0 : void 0;
	      };
	      readEntries = (function(_this) {
	        return function() {
	          return dirReader.readEntries(function(entries) {
	            var entry, _i, _len;
	            if (entries.length > 0) {
	              for (_i = 0, _len = entries.length; _i < _len; _i++) {
	                entry = entries[_i];
	                if (entry.isFile) {
	                  entry.file(function(file) {
	                    if (_this.options.ignoreHiddenFiles && file.name.substring(0, 1) === '.') {
	                      return;
	                    }
	                    file.fullPath = "" + path + "/" + file.name;
	                    return _this.addFile(file);
	                  });
	                } else if (entry.isDirectory) {
	                  _this._addFilesFromDirectory(entry, "" + path + "/" + entry.name);
	                }
	              }
	              readEntries();
	            }
	            return null;
	          }, errorHandler);
	        };
	      })(this);
	      return readEntries();
	    };

	    Dropzone.prototype.accept = function(file, done) {
	      if (file.size > this.options.maxFilesize * 1024 * 1024) {
	        return done(this.options.dictFileTooBig.replace("{{filesize}}", Math.round(file.size / 1024 / 10.24) / 100).replace("{{maxFilesize}}", this.options.maxFilesize));
	      } else if (!Dropzone.isValidFile(file, this.options.acceptedFiles)) {
	        return done(this.options.dictInvalidFileType);
	      } else if ((this.options.maxFiles != null) && this.getAcceptedFiles().length >= this.options.maxFiles) {
	        done(this.options.dictMaxFilesExceeded.replace("{{maxFiles}}", this.options.maxFiles));
	        return this.emit("maxfilesexceeded", file);
	      } else {
	        return this.options.accept.call(this, file, done);
	      }
	    };

	    Dropzone.prototype.addFile = function(file) {
	      file.upload = {
	        progress: 0,
	        total: file.size,
	        bytesSent: 0
	      };
	      this.files.push(file);
	      file.status = Dropzone.ADDED;
	      this.emit("addedfile", file);
	      this._enqueueThumbnail(file);
	      return this.accept(file, (function(_this) {
	        return function(error) {
	          if (error) {
	            file.accepted = false;
	            _this._errorProcessing([file], error);
	          } else {
	            file.accepted = true;
	            if (_this.options.autoQueue) {
	              _this.enqueueFile(file);
	            }
	          }
	          return _this._updateMaxFilesReachedClass();
	        };
	      })(this));
	    };

	    Dropzone.prototype.enqueueFiles = function(files) {
	      var file, _i, _len;
	      for (_i = 0, _len = files.length; _i < _len; _i++) {
	        file = files[_i];
	        this.enqueueFile(file);
	      }
	      return null;
	    };

	    Dropzone.prototype.enqueueFile = function(file) {
	      if (file.status === Dropzone.ADDED && file.accepted === true) {
	        file.status = Dropzone.QUEUED;
	        if (this.options.autoProcessQueue) {
	          return setTimeout(((function(_this) {
	            return function() {
	              return _this.processQueue();
	            };
	          })(this)), 0);
	        }
	      } else {
	        throw new Error("This file can't be queued because it has already been processed or was rejected.");
	      }
	    };

	    Dropzone.prototype._thumbnailQueue = [];

	    Dropzone.prototype._processingThumbnail = false;

	    Dropzone.prototype._enqueueThumbnail = function(file) {
	      if (this.options.createImageThumbnails && file.type.match(/image.*/) && file.size <= this.options.maxThumbnailFilesize * 1024 * 1024) {
	        this._thumbnailQueue.push(file);
	        return setTimeout(((function(_this) {
	          return function() {
	            return _this._processThumbnailQueue();
	          };
	        })(this)), 0);
	      }
	    };

	    Dropzone.prototype._processThumbnailQueue = function() {
	      if (this._processingThumbnail || this._thumbnailQueue.length === 0) {
	        return;
	      }
	      this._processingThumbnail = true;
	      return this.createThumbnail(this._thumbnailQueue.shift(), (function(_this) {
	        return function() {
	          _this._processingThumbnail = false;
	          return _this._processThumbnailQueue();
	        };
	      })(this));
	    };

	    Dropzone.prototype.removeFile = function(file) {
	      if (file.status === Dropzone.UPLOADING) {
	        this.cancelUpload(file);
	      }
	      this.files = without(this.files, file);
	      this.emit("removedfile", file);
	      if (this.files.length === 0) {
	        return this.emit("reset");
	      }
	    };

	    Dropzone.prototype.removeAllFiles = function(cancelIfNecessary) {
	      var file, _i, _len, _ref;
	      if (cancelIfNecessary == null) {
	        cancelIfNecessary = false;
	      }
	      _ref = this.files.slice();
	      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	        file = _ref[_i];
	        if (file.status !== Dropzone.UPLOADING || cancelIfNecessary) {
	          this.removeFile(file);
	        }
	      }
	      return null;
	    };

	    Dropzone.prototype.createThumbnail = function(file, callback) {
	      var fileReader;
	      fileReader = new FileReader;
	      fileReader.onload = (function(_this) {
	        return function() {
	          if (file.type === "image/svg+xml") {
	            _this.emit("thumbnail", file, fileReader.result);
	            if (callback != null) {
	              callback();
	            }
	            return;
	          }
	          return _this.createThumbnailFromUrl(file, fileReader.result, callback);
	        };
	      })(this);
	      return fileReader.readAsDataURL(file);
	    };

	    Dropzone.prototype.createThumbnailFromUrl = function(file, imageUrl, callback, crossOrigin) {
	      var img;
	      img = document.createElement("img");
	      if (crossOrigin) {
	        img.crossOrigin = crossOrigin;
	      }
	      img.onload = (function(_this) {
	        return function() {
	          var canvas, ctx, resizeInfo, thumbnail, _ref, _ref1, _ref2, _ref3;
	          file.width = img.width;
	          file.height = img.height;
	          resizeInfo = _this.options.resize.call(_this, file);
	          if (resizeInfo.trgWidth == null) {
	            resizeInfo.trgWidth = resizeInfo.optWidth;
	          }
	          if (resizeInfo.trgHeight == null) {
	            resizeInfo.trgHeight = resizeInfo.optHeight;
	          }
	          canvas = document.createElement("canvas");
	          ctx = canvas.getContext("2d");
	          canvas.width = resizeInfo.trgWidth;
	          canvas.height = resizeInfo.trgHeight;
	          drawImageIOSFix(ctx, img, (_ref = resizeInfo.srcX) != null ? _ref : 0, (_ref1 = resizeInfo.srcY) != null ? _ref1 : 0, resizeInfo.srcWidth, resizeInfo.srcHeight, (_ref2 = resizeInfo.trgX) != null ? _ref2 : 0, (_ref3 = resizeInfo.trgY) != null ? _ref3 : 0, resizeInfo.trgWidth, resizeInfo.trgHeight);
	          thumbnail = canvas.toDataURL("image/png");
	          _this.emit("thumbnail", file, thumbnail);
	          if (callback != null) {
	            return callback();
	          }
	        };
	      })(this);
	      if (callback != null) {
	        img.onerror = callback;
	      }
	      return img.src = imageUrl;
	    };

	    Dropzone.prototype.processQueue = function() {
	      var i, parallelUploads, processingLength, queuedFiles;
	      parallelUploads = this.options.parallelUploads;
	      processingLength = this.getUploadingFiles().length;
	      i = processingLength;
	      if (processingLength >= parallelUploads) {
	        return;
	      }
	      queuedFiles = this.getQueuedFiles();
	      if (!(queuedFiles.length > 0)) {
	        return;
	      }
	      if (this.options.uploadMultiple) {
	        return this.processFiles(queuedFiles.slice(0, parallelUploads - processingLength));
	      } else {
	        while (i < parallelUploads) {
	          if (!queuedFiles.length) {
	            return;
	          }
	          this.processFile(queuedFiles.shift());
	          i++;
	        }
	      }
	    };

	    Dropzone.prototype.processFile = function(file) {
	      return this.processFiles([file]);
	    };

	    Dropzone.prototype.processFiles = function(files) {
	      var file, _i, _len;
	      for (_i = 0, _len = files.length; _i < _len; _i++) {
	        file = files[_i];
	        file.processing = true;
	        file.status = Dropzone.UPLOADING;
	        this.emit("processing", file);
	      }
	      if (this.options.uploadMultiple) {
	        this.emit("processingmultiple", files);
	      }
	      return this.uploadFiles(files);
	    };

	    Dropzone.prototype._getFilesWithXhr = function(xhr) {
	      var file, files;
	      return files = (function() {
	        var _i, _len, _ref, _results;
	        _ref = this.files;
	        _results = [];
	        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	          file = _ref[_i];
	          if (file.xhr === xhr) {
	            _results.push(file);
	          }
	        }
	        return _results;
	      }).call(this);
	    };

	    Dropzone.prototype.cancelUpload = function(file) {
	      var groupedFile, groupedFiles, _i, _j, _len, _len1, _ref;
	      if (file.status === Dropzone.UPLOADING) {
	        groupedFiles = this._getFilesWithXhr(file.xhr);
	        for (_i = 0, _len = groupedFiles.length; _i < _len; _i++) {
	          groupedFile = groupedFiles[_i];
	          groupedFile.status = Dropzone.CANCELED;
	        }
	        file.xhr.abort();
	        for (_j = 0, _len1 = groupedFiles.length; _j < _len1; _j++) {
	          groupedFile = groupedFiles[_j];
	          this.emit("canceled", groupedFile);
	        }
	        if (this.options.uploadMultiple) {
	          this.emit("canceledmultiple", groupedFiles);
	        }
	      } else if ((_ref = file.status) === Dropzone.ADDED || _ref === Dropzone.QUEUED) {
	        file.status = Dropzone.CANCELED;
	        this.emit("canceled", file);
	        if (this.options.uploadMultiple) {
	          this.emit("canceledmultiple", [file]);
	        }
	      }
	      if (this.options.autoProcessQueue) {
	        return this.processQueue();
	      }
	    };

	    resolveOption = function() {
	      var args, option;
	      option = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
	      if (typeof option === 'function') {
	        return option.apply(this, args);
	      }
	      return option;
	    };

	    Dropzone.prototype.uploadFile = function(file) {
	      return this.uploadFiles([file]);
	    };

	    Dropzone.prototype.uploadFiles = function(files) {
	      var file, formData, handleError, headerName, headerValue, headers, i, input, inputName, inputType, key, method, option, progressObj, response, updateProgress, url, value, xhr, _i, _j, _k, _l, _len, _len1, _len2, _len3, _m, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
	      xhr = new XMLHttpRequest();
	      for (_i = 0, _len = files.length; _i < _len; _i++) {
	        file = files[_i];
	        file.xhr = xhr;
	      }
	      method = resolveOption(this.options.method, files);
	      url = resolveOption(this.options.url, files);
	      xhr.open(method, url, true);
	      xhr.withCredentials = !!this.options.withCredentials;
	      response = null;
	      handleError = (function(_this) {
	        return function() {
	          var _j, _len1, _results;
	          _results = [];
	          for (_j = 0, _len1 = files.length; _j < _len1; _j++) {
	            file = files[_j];
	            _results.push(_this._errorProcessing(files, response || _this.options.dictResponseError.replace("{{statusCode}}", xhr.status), xhr));
	          }
	          return _results;
	        };
	      })(this);
	      updateProgress = (function(_this) {
	        return function(e) {
	          var allFilesFinished, progress, _j, _k, _l, _len1, _len2, _len3, _results;
	          if (e != null) {
	            progress = 100 * e.loaded / e.total;
	            for (_j = 0, _len1 = files.length; _j < _len1; _j++) {
	              file = files[_j];
	              file.upload = {
	                progress: progress,
	                total: e.total,
	                bytesSent: e.loaded
	              };
	            }
	          } else {
	            allFilesFinished = true;
	            progress = 100;
	            for (_k = 0, _len2 = files.length; _k < _len2; _k++) {
	              file = files[_k];
	              if (!(file.upload.progress === 100 && file.upload.bytesSent === file.upload.total)) {
	                allFilesFinished = false;
	              }
	              file.upload.progress = progress;
	              file.upload.bytesSent = file.upload.total;
	            }
	            if (allFilesFinished) {
	              return;
	            }
	          }
	          _results = [];
	          for (_l = 0, _len3 = files.length; _l < _len3; _l++) {
	            file = files[_l];
	            _results.push(_this.emit("uploadprogress", file, progress, file.upload.bytesSent));
	          }
	          return _results;
	        };
	      })(this);
	      xhr.onload = (function(_this) {
	        return function(e) {
	          var _ref;
	          if (files[0].status === Dropzone.CANCELED) {
	            return;
	          }
	          if (xhr.readyState !== 4) {
	            return;
	          }
	          response = xhr.responseText;
	          if (xhr.getResponseHeader("content-type") && ~xhr.getResponseHeader("content-type").indexOf("application/json")) {
	            try {
	              response = JSON.parse(response);
	            } catch (_error) {
	              e = _error;
	              response = "Invalid JSON response from server.";
	            }
	          }
	          updateProgress();
	          if (!((200 <= (_ref = xhr.status) && _ref < 300))) {
	            return handleError();
	          } else {
	            return _this._finished(files, response, e);
	          }
	        };
	      })(this);
	      xhr.onerror = (function(_this) {
	        return function() {
	          if (files[0].status === Dropzone.CANCELED) {
	            return;
	          }
	          return handleError();
	        };
	      })(this);
	      progressObj = (_ref = xhr.upload) != null ? _ref : xhr;
	      progressObj.onprogress = updateProgress;
	      headers = {
	        "Accept": "application/json",
	        "Cache-Control": "no-cache",
	        "X-Requested-With": "XMLHttpRequest"
	      };
	      if (this.options.headers) {
	        extend(headers, this.options.headers);
	      }
	      for (headerName in headers) {
	        headerValue = headers[headerName];
	        if (headerValue) {
	          xhr.setRequestHeader(headerName, headerValue);
	        }
	      }
	      formData = new FormData();
	      if (this.options.params) {
	        _ref1 = this.options.params;
	        for (key in _ref1) {
	          value = _ref1[key];
	          formData.append(key, value);
	        }
	      }
	      for (_j = 0, _len1 = files.length; _j < _len1; _j++) {
	        file = files[_j];
	        this.emit("sending", file, xhr, formData);
	      }
	      if (this.options.uploadMultiple) {
	        this.emit("sendingmultiple", files, xhr, formData);
	      }
	      if (this.element.tagName === "FORM") {
	        _ref2 = this.element.querySelectorAll("input, textarea, select, button");
	        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
	          input = _ref2[_k];
	          inputName = input.getAttribute("name");
	          inputType = input.getAttribute("type");
	          if (input.tagName === "SELECT" && input.hasAttribute("multiple")) {
	            _ref3 = input.options;
	            for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
	              option = _ref3[_l];
	              if (option.selected) {
	                formData.append(inputName, option.value);
	              }
	            }
	          } else if (!inputType || ((_ref4 = inputType.toLowerCase()) !== "checkbox" && _ref4 !== "radio") || input.checked) {
	            formData.append(inputName, input.value);
	          }
	        }
	      }
	      for (i = _m = 0, _ref5 = files.length - 1; 0 <= _ref5 ? _m <= _ref5 : _m >= _ref5; i = 0 <= _ref5 ? ++_m : --_m) {
	        formData.append(this._getParamName(i), files[i], this._renameFilename(files[i].name));
	      }
	      return this.submitRequest(xhr, formData, files);
	    };

	    Dropzone.prototype.submitRequest = function(xhr, formData, files) {
	      return xhr.send(formData);
	    };

	    Dropzone.prototype._finished = function(files, responseText, e) {
	      var file, _i, _len;
	      for (_i = 0, _len = files.length; _i < _len; _i++) {
	        file = files[_i];
	        file.status = Dropzone.SUCCESS;
	        this.emit("success", file, responseText, e);
	        this.emit("complete", file);
	      }
	      if (this.options.uploadMultiple) {
	        this.emit("successmultiple", files, responseText, e);
	        this.emit("completemultiple", files);
	      }
	      if (this.options.autoProcessQueue) {
	        return this.processQueue();
	      }
	    };

	    Dropzone.prototype._errorProcessing = function(files, message, xhr) {
	      var file, _i, _len;
	      for (_i = 0, _len = files.length; _i < _len; _i++) {
	        file = files[_i];
	        file.status = Dropzone.ERROR;
	        this.emit("error", file, message, xhr);
	        this.emit("complete", file);
	      }
	      if (this.options.uploadMultiple) {
	        this.emit("errormultiple", files, message, xhr);
	        this.emit("completemultiple", files);
	      }
	      if (this.options.autoProcessQueue) {
	        return this.processQueue();
	      }
	    };

	    return Dropzone;

	  })(Emitter);

	  Dropzone.version = "4.3.0";

	  Dropzone.options = {};

	  Dropzone.optionsForElement = function(element) {
	    if (element.getAttribute("id")) {
	      return Dropzone.options[camelize(element.getAttribute("id"))];
	    } else {
	      return void 0;
	    }
	  };

	  Dropzone.instances = [];

	  Dropzone.forElement = function(element) {
	    if (typeof element === "string") {
	      element = document.querySelector(element);
	    }
	    if ((element != null ? element.dropzone : void 0) == null) {
	      throw new Error("No Dropzone found for given element. This is probably because you're trying to access it before Dropzone had the time to initialize. Use the `init` option to setup any additional observers on your Dropzone.");
	    }
	    return element.dropzone;
	  };

	  Dropzone.autoDiscover = true;

	  Dropzone.discover = function() {
	    var checkElements, dropzone, dropzones, _i, _len, _results;
	    if (document.querySelectorAll) {
	      dropzones = document.querySelectorAll(".dropzone");
	    } else {
	      dropzones = [];
	      checkElements = function(elements) {
	        var el, _i, _len, _results;
	        _results = [];
	        for (_i = 0, _len = elements.length; _i < _len; _i++) {
	          el = elements[_i];
	          if (/(^| )dropzone($| )/.test(el.className)) {
	            _results.push(dropzones.push(el));
	          } else {
	            _results.push(void 0);
	          }
	        }
	        return _results;
	      };
	      checkElements(document.getElementsByTagName("div"));
	      checkElements(document.getElementsByTagName("form"));
	    }
	    _results = [];
	    for (_i = 0, _len = dropzones.length; _i < _len; _i++) {
	      dropzone = dropzones[_i];
	      if (Dropzone.optionsForElement(dropzone) !== false) {
	        _results.push(new Dropzone(dropzone));
	      } else {
	        _results.push(void 0);
	      }
	    }
	    return _results;
	  };

	  Dropzone.blacklistedBrowsers = [/opera.*Macintosh.*version\/12/i];

	  Dropzone.isBrowserSupported = function() {
	    var capableBrowser, regex, _i, _len, _ref;
	    capableBrowser = true;
	    if (window.File && window.FileReader && window.FileList && window.Blob && window.FormData && document.querySelector) {
	      if (!("classList" in document.createElement("a"))) {
	        capableBrowser = false;
	      } else {
	        _ref = Dropzone.blacklistedBrowsers;
	        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	          regex = _ref[_i];
	          if (regex.test(navigator.userAgent)) {
	            capableBrowser = false;
	            continue;
	          }
	        }
	      }
	    } else {
	      capableBrowser = false;
	    }
	    return capableBrowser;
	  };

	  without = function(list, rejectedItem) {
	    var item, _i, _len, _results;
	    _results = [];
	    for (_i = 0, _len = list.length; _i < _len; _i++) {
	      item = list[_i];
	      if (item !== rejectedItem) {
	        _results.push(item);
	      }
	    }
	    return _results;
	  };

	  camelize = function(str) {
	    return str.replace(/[\-_](\w)/g, function(match) {
	      return match.charAt(1).toUpperCase();
	    });
	  };

	  Dropzone.createElement = function(string) {
	    var div;
	    div = document.createElement("div");
	    div.innerHTML = string;
	    return div.childNodes[0];
	  };

	  Dropzone.elementInside = function(element, container) {
	    if (element === container) {
	      return true;
	    }
	    while (element = element.parentNode) {
	      if (element === container) {
	        return true;
	      }
	    }
	    return false;
	  };

	  Dropzone.getElement = function(el, name) {
	    var element;
	    if (typeof el === "string") {
	      element = document.querySelector(el);
	    } else if (el.nodeType != null) {
	      element = el;
	    }
	    if (element == null) {
	      throw new Error("Invalid `" + name + "` option provided. Please provide a CSS selector or a plain HTML element.");
	    }
	    return element;
	  };

	  Dropzone.getElements = function(els, name) {
	    var e, el, elements, _i, _j, _len, _len1, _ref;
	    if (els instanceof Array) {
	      elements = [];
	      try {
	        for (_i = 0, _len = els.length; _i < _len; _i++) {
	          el = els[_i];
	          elements.push(this.getElement(el, name));
	        }
	      } catch (_error) {
	        e = _error;
	        elements = null;
	      }
	    } else if (typeof els === "string") {
	      elements = [];
	      _ref = document.querySelectorAll(els);
	      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
	        el = _ref[_j];
	        elements.push(el);
	      }
	    } else if (els.nodeType != null) {
	      elements = [els];
	    }
	    if (!((elements != null) && elements.length)) {
	      throw new Error("Invalid `" + name + "` option provided. Please provide a CSS selector, a plain HTML element or a list of those.");
	    }
	    return elements;
	  };

	  Dropzone.confirm = function(question, accepted, rejected) {
	    if (window.confirm(question)) {
	      return accepted();
	    } else if (rejected != null) {
	      return rejected();
	    }
	  };

	  Dropzone.isValidFile = function(file, acceptedFiles) {
	    var baseMimeType, mimeType, validType, _i, _len;
	    if (!acceptedFiles) {
	      return true;
	    }
	    acceptedFiles = acceptedFiles.split(",");
	    mimeType = file.type;
	    baseMimeType = mimeType.replace(/\/.*$/, "");
	    for (_i = 0, _len = acceptedFiles.length; _i < _len; _i++) {
	      validType = acceptedFiles[_i];
	      validType = validType.trim();
	      if (validType.charAt(0) === ".") {
	        if (file.name.toLowerCase().indexOf(validType.toLowerCase(), file.name.length - validType.length) !== -1) {
	          return true;
	        }
	      } else if (/\/\*$/.test(validType)) {
	        if (baseMimeType === validType.replace(/\/.*$/, "")) {
	          return true;
	        }
	      } else {
	        if (mimeType === validType) {
	          return true;
	        }
	      }
	    }
	    return false;
	  };

	  if (typeof jQuery !== "undefined" && jQuery !== null) {
	    jQuery.fn.dropzone = function(options) {
	      return this.each(function() {
	        return new Dropzone(this, options);
	      });
	    };
	  }

	  if (typeof module !== "undefined" && module !== null) {
	    module.exports = Dropzone;
	  } else {
	    window.Dropzone = Dropzone;
	  }

	  Dropzone.ADDED = "added";

	  Dropzone.QUEUED = "queued";

	  Dropzone.ACCEPTED = Dropzone.QUEUED;

	  Dropzone.UPLOADING = "uploading";

	  Dropzone.PROCESSING = Dropzone.UPLOADING;

	  Dropzone.CANCELED = "canceled";

	  Dropzone.ERROR = "error";

	  Dropzone.SUCCESS = "success";


	  /*

	  Bugfix for iOS 6 and 7
	  Source: http://stackoverflow.com/questions/11929099/html5-canvas-drawimage-ratio-bug-ios
	  based on the work of https://github.com/stomita/ios-imagefile-megapixel
	   */

	  detectVerticalSquash = function(img) {
	    var alpha, canvas, ctx, data, ey, ih, iw, py, ratio, sy;
	    iw = img.naturalWidth;
	    ih = img.naturalHeight;
	    canvas = document.createElement("canvas");
	    canvas.width = 1;
	    canvas.height = ih;
	    ctx = canvas.getContext("2d");
	    ctx.drawImage(img, 0, 0);
	    data = ctx.getImageData(0, 0, 1, ih).data;
	    sy = 0;
	    ey = ih;
	    py = ih;
	    while (py > sy) {
	      alpha = data[(py - 1) * 4 + 3];
	      if (alpha === 0) {
	        ey = py;
	      } else {
	        sy = py;
	      }
	      py = (ey + sy) >> 1;
	    }
	    ratio = py / ih;
	    if (ratio === 0) {
	      return 1;
	    } else {
	      return ratio;
	    }
	  };

	  drawImageIOSFix = function(ctx, img, sx, sy, sw, sh, dx, dy, dw, dh) {
	    var vertSquashRatio;
	    vertSquashRatio = detectVerticalSquash(img);
	    return ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh / vertSquashRatio);
	  };


	  /*
	   * contentloaded.js
	   *
	   * Author: Diego Perini (diego.perini at gmail.com)
	   * Summary: cross-browser wrapper for DOMContentLoaded
	   * Updated: 20101020
	   * License: MIT
	   * Version: 1.2
	   *
	   * URL:
	   * http://javascript.nwbox.com/ContentLoaded/
	   * http://javascript.nwbox.com/ContentLoaded/MIT-LICENSE
	   */

	  contentLoaded = function(win, fn) {
	    var add, doc, done, init, poll, pre, rem, root, top;
	    done = false;
	    top = true;
	    doc = win.document;
	    root = doc.documentElement;
	    add = (doc.addEventListener ? "addEventListener" : "attachEvent");
	    rem = (doc.addEventListener ? "removeEventListener" : "detachEvent");
	    pre = (doc.addEventListener ? "" : "on");
	    init = function(e) {
	      if (e.type === "readystatechange" && doc.readyState !== "complete") {
	        return;
	      }
	      (e.type === "load" ? win : doc)[rem](pre + e.type, init, false);
	      if (!done && (done = true)) {
	        return fn.call(win, e.type || e);
	      }
	    };
	    poll = function() {
	      var e;
	      try {
	        root.doScroll("left");
	      } catch (_error) {
	        e = _error;
	        setTimeout(poll, 50);
	        return;
	      }
	      return init("poll");
	    };
	    if (doc.readyState !== "complete") {
	      if (doc.createEventObject && root.doScroll) {
	        try {
	          top = !win.frameElement;
	        } catch (_error) {}
	        if (top) {
	          poll();
	        }
	      }
	      doc[add](pre + "DOMContentLoaded", init, false);
	      doc[add](pre + "readystatechange", init, false);
	      return win[add](pre + "load", init, false);
	    }
	  };

	  Dropzone._autoDiscoverFunction = function() {
	    if (Dropzone.autoDiscover) {
	      return Dropzone.discover();
	    }
	  };

	  contentLoaded(window, Dropzone._autoDiscoverFunction);

	}).call(this);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(19)(module)))

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module dependencies
	 */

	var XMLHttpRequest = __webpack_require__(26);
	var XHR = __webpack_require__(113);
	var JSONP = __webpack_require__(112);
	var websocket = __webpack_require__(114);

	/**
	 * Export transports.
	 */

	exports.polling = polling;
	exports.websocket = websocket;

	/**
	 * Polling transport polymorphic constructor.
	 * Decides on xhr vs jsonp based on feature detection.
	 *
	 * @api private
	 */

	function polling(opts){
	  var xhr;
	  var xd = false;
	  var xs = false;
	  var jsonp = false !== opts.jsonp;

	  if (global.location) {
	    var isSSL = 'https:' == location.protocol;
	    var port = location.port;

	    // some user agents have empty `location.port`
	    if (!port) {
	      port = isSSL ? 443 : 80;
	    }

	    xd = opts.hostname != location.hostname || port != opts.port;
	    xs = opts.secure != isSSL;
	  }

	  opts.xdomain = xd;
	  opts.xscheme = xs;
	  xhr = new XMLHttpRequest(opts);

	  if ('open' in xhr && !opts.forceJSONP) {
	    return new XHR(opts);
	  } else {
	    if (!jsonp) throw new Error('JSONP disabled');
	    return new JSONP(opts);
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */

	var Transport = __webpack_require__(25);
	var parseqs = __webpack_require__(27);
	var parser = __webpack_require__(11);
	var inherit = __webpack_require__(16);
	var yeast = __webpack_require__(54);
	var debug = __webpack_require__(7)('engine.io-client:polling');

	/**
	 * Module exports.
	 */

	module.exports = Polling;

	/**
	 * Is XHR2 supported?
	 */

	var hasXHR2 = (function() {
	  var XMLHttpRequest = __webpack_require__(26);
	  var xhr = new XMLHttpRequest({ xdomain: false });
	  return null != xhr.responseType;
	})();

	/**
	 * Polling interface.
	 *
	 * @param {Object} opts
	 * @api private
	 */

	function Polling(opts){
	  var forceBase64 = (opts && opts.forceBase64);
	  if (!hasXHR2 || forceBase64) {
	    this.supportsBinary = false;
	  }
	  Transport.call(this, opts);
	}

	/**
	 * Inherits from Transport.
	 */

	inherit(Polling, Transport);

	/**
	 * Transport name.
	 */

	Polling.prototype.name = 'polling';

	/**
	 * Opens the socket (triggers polling). We write a PING message to determine
	 * when the transport is open.
	 *
	 * @api private
	 */

	Polling.prototype.doOpen = function(){
	  this.poll();
	};

	/**
	 * Pauses polling.
	 *
	 * @param {Function} callback upon buffers are flushed and transport is paused
	 * @api private
	 */

	Polling.prototype.pause = function(onPause){
	  var pending = 0;
	  var self = this;

	  this.readyState = 'pausing';

	  function pause(){
	    debug('paused');
	    self.readyState = 'paused';
	    onPause();
	  }

	  if (this.polling || !this.writable) {
	    var total = 0;

	    if (this.polling) {
	      debug('we are currently polling - waiting to pause');
	      total++;
	      this.once('pollComplete', function(){
	        debug('pre-pause polling complete');
	        --total || pause();
	      });
	    }

	    if (!this.writable) {
	      debug('we are currently writing - waiting to pause');
	      total++;
	      this.once('drain', function(){
	        debug('pre-pause writing complete');
	        --total || pause();
	      });
	    }
	  } else {
	    pause();
	  }
	};

	/**
	 * Starts polling cycle.
	 *
	 * @api public
	 */

	Polling.prototype.poll = function(){
	  debug('polling');
	  this.polling = true;
	  this.doPoll();
	  this.emit('poll');
	};

	/**
	 * Overloads onData to detect payloads.
	 *
	 * @api private
	 */

	Polling.prototype.onData = function(data){
	  var self = this;
	  debug('polling got data %s', data);
	  var callback = function(packet, index, total) {
	    // if its the first message we consider the transport open
	    if ('opening' == self.readyState) {
	      self.onOpen();
	    }

	    // if its a close packet, we close the ongoing requests
	    if ('close' == packet.type) {
	      self.onClose();
	      return false;
	    }

	    // otherwise bypass onData and handle the message
	    self.onPacket(packet);
	  };

	  // decode payload
	  parser.decodePayload(data, this.socket.binaryType, callback);

	  // if an event did not trigger closing
	  if ('closed' != this.readyState) {
	    // if we got data we're not polling
	    this.polling = false;
	    this.emit('pollComplete');

	    if ('open' == this.readyState) {
	      this.poll();
	    } else {
	      debug('ignoring poll - transport state "%s"', this.readyState);
	    }
	  }
	};

	/**
	 * For polling, send a close packet.
	 *
	 * @api private
	 */

	Polling.prototype.doClose = function(){
	  var self = this;

	  function close(){
	    debug('writing close packet');
	    self.write([{ type: 'close' }]);
	  }

	  if ('open' == this.readyState) {
	    debug('transport open - closing');
	    close();
	  } else {
	    // in case we're trying to close while
	    // handshaking is in progress (GH-164)
	    debug('transport not open - deferring close');
	    this.once('open', close);
	  }
	};

	/**
	 * Writes a packets payload.
	 *
	 * @param {Array} data packets
	 * @param {Function} drain callback
	 * @api private
	 */

	Polling.prototype.write = function(packets){
	  var self = this;
	  this.writable = false;
	  var callbackfn = function() {
	    self.writable = true;
	    self.emit('drain');
	  };

	  var self = this;
	  parser.encodePayload(packets, this.supportsBinary, function(data) {
	    self.doWrite(data, callbackfn);
	  });
	};

	/**
	 * Generates uri for connection.
	 *
	 * @api private
	 */

	Polling.prototype.uri = function(){
	  var query = this.query || {};
	  var schema = this.secure ? 'https' : 'http';
	  var port = '';

	  // cache busting is forced
	  if (false !== this.timestampRequests) {
	    query[this.timestampParam] = yeast();
	  }

	  if (!this.supportsBinary && !query.sid) {
	    query.b64 = 1;
	  }

	  query = parseqs.encode(query);

	  // avoid port if default for schema
	  if (this.port && (('https' == schema && this.port != 443) ||
	     ('http' == schema && this.port != 80))) {
	    port = ':' + this.port;
	  }

	  // prepend ? to query
	  if (query.length) {
	    query = '?' + query;
	  }

	  var ipv6 = this.hostname.indexOf(':') !== -1;
	  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
	};


/***/ },
/* 41 */
/***/ function(module, exports) {

	var ENTITIES = [['Aacute', [193]], ['aacute', [225]], ['Abreve', [258]], ['abreve', [259]], ['ac', [8766]], ['acd', [8767]], ['acE', [8766, 819]], ['Acirc', [194]], ['acirc', [226]], ['acute', [180]], ['Acy', [1040]], ['acy', [1072]], ['AElig', [198]], ['aelig', [230]], ['af', [8289]], ['Afr', [120068]], ['afr', [120094]], ['Agrave', [192]], ['agrave', [224]], ['alefsym', [8501]], ['aleph', [8501]], ['Alpha', [913]], ['alpha', [945]], ['Amacr', [256]], ['amacr', [257]], ['amalg', [10815]], ['amp', [38]], ['AMP', [38]], ['andand', [10837]], ['And', [10835]], ['and', [8743]], ['andd', [10844]], ['andslope', [10840]], ['andv', [10842]], ['ang', [8736]], ['ange', [10660]], ['angle', [8736]], ['angmsdaa', [10664]], ['angmsdab', [10665]], ['angmsdac', [10666]], ['angmsdad', [10667]], ['angmsdae', [10668]], ['angmsdaf', [10669]], ['angmsdag', [10670]], ['angmsdah', [10671]], ['angmsd', [8737]], ['angrt', [8735]], ['angrtvb', [8894]], ['angrtvbd', [10653]], ['angsph', [8738]], ['angst', [197]], ['angzarr', [9084]], ['Aogon', [260]], ['aogon', [261]], ['Aopf', [120120]], ['aopf', [120146]], ['apacir', [10863]], ['ap', [8776]], ['apE', [10864]], ['ape', [8778]], ['apid', [8779]], ['apos', [39]], ['ApplyFunction', [8289]], ['approx', [8776]], ['approxeq', [8778]], ['Aring', [197]], ['aring', [229]], ['Ascr', [119964]], ['ascr', [119990]], ['Assign', [8788]], ['ast', [42]], ['asymp', [8776]], ['asympeq', [8781]], ['Atilde', [195]], ['atilde', [227]], ['Auml', [196]], ['auml', [228]], ['awconint', [8755]], ['awint', [10769]], ['backcong', [8780]], ['backepsilon', [1014]], ['backprime', [8245]], ['backsim', [8765]], ['backsimeq', [8909]], ['Backslash', [8726]], ['Barv', [10983]], ['barvee', [8893]], ['barwed', [8965]], ['Barwed', [8966]], ['barwedge', [8965]], ['bbrk', [9141]], ['bbrktbrk', [9142]], ['bcong', [8780]], ['Bcy', [1041]], ['bcy', [1073]], ['bdquo', [8222]], ['becaus', [8757]], ['because', [8757]], ['Because', [8757]], ['bemptyv', [10672]], ['bepsi', [1014]], ['bernou', [8492]], ['Bernoullis', [8492]], ['Beta', [914]], ['beta', [946]], ['beth', [8502]], ['between', [8812]], ['Bfr', [120069]], ['bfr', [120095]], ['bigcap', [8898]], ['bigcirc', [9711]], ['bigcup', [8899]], ['bigodot', [10752]], ['bigoplus', [10753]], ['bigotimes', [10754]], ['bigsqcup', [10758]], ['bigstar', [9733]], ['bigtriangledown', [9661]], ['bigtriangleup', [9651]], ['biguplus', [10756]], ['bigvee', [8897]], ['bigwedge', [8896]], ['bkarow', [10509]], ['blacklozenge', [10731]], ['blacksquare', [9642]], ['blacktriangle', [9652]], ['blacktriangledown', [9662]], ['blacktriangleleft', [9666]], ['blacktriangleright', [9656]], ['blank', [9251]], ['blk12', [9618]], ['blk14', [9617]], ['blk34', [9619]], ['block', [9608]], ['bne', [61, 8421]], ['bnequiv', [8801, 8421]], ['bNot', [10989]], ['bnot', [8976]], ['Bopf', [120121]], ['bopf', [120147]], ['bot', [8869]], ['bottom', [8869]], ['bowtie', [8904]], ['boxbox', [10697]], ['boxdl', [9488]], ['boxdL', [9557]], ['boxDl', [9558]], ['boxDL', [9559]], ['boxdr', [9484]], ['boxdR', [9554]], ['boxDr', [9555]], ['boxDR', [9556]], ['boxh', [9472]], ['boxH', [9552]], ['boxhd', [9516]], ['boxHd', [9572]], ['boxhD', [9573]], ['boxHD', [9574]], ['boxhu', [9524]], ['boxHu', [9575]], ['boxhU', [9576]], ['boxHU', [9577]], ['boxminus', [8863]], ['boxplus', [8862]], ['boxtimes', [8864]], ['boxul', [9496]], ['boxuL', [9563]], ['boxUl', [9564]], ['boxUL', [9565]], ['boxur', [9492]], ['boxuR', [9560]], ['boxUr', [9561]], ['boxUR', [9562]], ['boxv', [9474]], ['boxV', [9553]], ['boxvh', [9532]], ['boxvH', [9578]], ['boxVh', [9579]], ['boxVH', [9580]], ['boxvl', [9508]], ['boxvL', [9569]], ['boxVl', [9570]], ['boxVL', [9571]], ['boxvr', [9500]], ['boxvR', [9566]], ['boxVr', [9567]], ['boxVR', [9568]], ['bprime', [8245]], ['breve', [728]], ['Breve', [728]], ['brvbar', [166]], ['bscr', [119991]], ['Bscr', [8492]], ['bsemi', [8271]], ['bsim', [8765]], ['bsime', [8909]], ['bsolb', [10693]], ['bsol', [92]], ['bsolhsub', [10184]], ['bull', [8226]], ['bullet', [8226]], ['bump', [8782]], ['bumpE', [10926]], ['bumpe', [8783]], ['Bumpeq', [8782]], ['bumpeq', [8783]], ['Cacute', [262]], ['cacute', [263]], ['capand', [10820]], ['capbrcup', [10825]], ['capcap', [10827]], ['cap', [8745]], ['Cap', [8914]], ['capcup', [10823]], ['capdot', [10816]], ['CapitalDifferentialD', [8517]], ['caps', [8745, 65024]], ['caret', [8257]], ['caron', [711]], ['Cayleys', [8493]], ['ccaps', [10829]], ['Ccaron', [268]], ['ccaron', [269]], ['Ccedil', [199]], ['ccedil', [231]], ['Ccirc', [264]], ['ccirc', [265]], ['Cconint', [8752]], ['ccups', [10828]], ['ccupssm', [10832]], ['Cdot', [266]], ['cdot', [267]], ['cedil', [184]], ['Cedilla', [184]], ['cemptyv', [10674]], ['cent', [162]], ['centerdot', [183]], ['CenterDot', [183]], ['cfr', [120096]], ['Cfr', [8493]], ['CHcy', [1063]], ['chcy', [1095]], ['check', [10003]], ['checkmark', [10003]], ['Chi', [935]], ['chi', [967]], ['circ', [710]], ['circeq', [8791]], ['circlearrowleft', [8634]], ['circlearrowright', [8635]], ['circledast', [8859]], ['circledcirc', [8858]], ['circleddash', [8861]], ['CircleDot', [8857]], ['circledR', [174]], ['circledS', [9416]], ['CircleMinus', [8854]], ['CirclePlus', [8853]], ['CircleTimes', [8855]], ['cir', [9675]], ['cirE', [10691]], ['cire', [8791]], ['cirfnint', [10768]], ['cirmid', [10991]], ['cirscir', [10690]], ['ClockwiseContourIntegral', [8754]], ['CloseCurlyDoubleQuote', [8221]], ['CloseCurlyQuote', [8217]], ['clubs', [9827]], ['clubsuit', [9827]], ['colon', [58]], ['Colon', [8759]], ['Colone', [10868]], ['colone', [8788]], ['coloneq', [8788]], ['comma', [44]], ['commat', [64]], ['comp', [8705]], ['compfn', [8728]], ['complement', [8705]], ['complexes', [8450]], ['cong', [8773]], ['congdot', [10861]], ['Congruent', [8801]], ['conint', [8750]], ['Conint', [8751]], ['ContourIntegral', [8750]], ['copf', [120148]], ['Copf', [8450]], ['coprod', [8720]], ['Coproduct', [8720]], ['copy', [169]], ['COPY', [169]], ['copysr', [8471]], ['CounterClockwiseContourIntegral', [8755]], ['crarr', [8629]], ['cross', [10007]], ['Cross', [10799]], ['Cscr', [119966]], ['cscr', [119992]], ['csub', [10959]], ['csube', [10961]], ['csup', [10960]], ['csupe', [10962]], ['ctdot', [8943]], ['cudarrl', [10552]], ['cudarrr', [10549]], ['cuepr', [8926]], ['cuesc', [8927]], ['cularr', [8630]], ['cularrp', [10557]], ['cupbrcap', [10824]], ['cupcap', [10822]], ['CupCap', [8781]], ['cup', [8746]], ['Cup', [8915]], ['cupcup', [10826]], ['cupdot', [8845]], ['cupor', [10821]], ['cups', [8746, 65024]], ['curarr', [8631]], ['curarrm', [10556]], ['curlyeqprec', [8926]], ['curlyeqsucc', [8927]], ['curlyvee', [8910]], ['curlywedge', [8911]], ['curren', [164]], ['curvearrowleft', [8630]], ['curvearrowright', [8631]], ['cuvee', [8910]], ['cuwed', [8911]], ['cwconint', [8754]], ['cwint', [8753]], ['cylcty', [9005]], ['dagger', [8224]], ['Dagger', [8225]], ['daleth', [8504]], ['darr', [8595]], ['Darr', [8609]], ['dArr', [8659]], ['dash', [8208]], ['Dashv', [10980]], ['dashv', [8867]], ['dbkarow', [10511]], ['dblac', [733]], ['Dcaron', [270]], ['dcaron', [271]], ['Dcy', [1044]], ['dcy', [1076]], ['ddagger', [8225]], ['ddarr', [8650]], ['DD', [8517]], ['dd', [8518]], ['DDotrahd', [10513]], ['ddotseq', [10871]], ['deg', [176]], ['Del', [8711]], ['Delta', [916]], ['delta', [948]], ['demptyv', [10673]], ['dfisht', [10623]], ['Dfr', [120071]], ['dfr', [120097]], ['dHar', [10597]], ['dharl', [8643]], ['dharr', [8642]], ['DiacriticalAcute', [180]], ['DiacriticalDot', [729]], ['DiacriticalDoubleAcute', [733]], ['DiacriticalGrave', [96]], ['DiacriticalTilde', [732]], ['diam', [8900]], ['diamond', [8900]], ['Diamond', [8900]], ['diamondsuit', [9830]], ['diams', [9830]], ['die', [168]], ['DifferentialD', [8518]], ['digamma', [989]], ['disin', [8946]], ['div', [247]], ['divide', [247]], ['divideontimes', [8903]], ['divonx', [8903]], ['DJcy', [1026]], ['djcy', [1106]], ['dlcorn', [8990]], ['dlcrop', [8973]], ['dollar', [36]], ['Dopf', [120123]], ['dopf', [120149]], ['Dot', [168]], ['dot', [729]], ['DotDot', [8412]], ['doteq', [8784]], ['doteqdot', [8785]], ['DotEqual', [8784]], ['dotminus', [8760]], ['dotplus', [8724]], ['dotsquare', [8865]], ['doublebarwedge', [8966]], ['DoubleContourIntegral', [8751]], ['DoubleDot', [168]], ['DoubleDownArrow', [8659]], ['DoubleLeftArrow', [8656]], ['DoubleLeftRightArrow', [8660]], ['DoubleLeftTee', [10980]], ['DoubleLongLeftArrow', [10232]], ['DoubleLongLeftRightArrow', [10234]], ['DoubleLongRightArrow', [10233]], ['DoubleRightArrow', [8658]], ['DoubleRightTee', [8872]], ['DoubleUpArrow', [8657]], ['DoubleUpDownArrow', [8661]], ['DoubleVerticalBar', [8741]], ['DownArrowBar', [10515]], ['downarrow', [8595]], ['DownArrow', [8595]], ['Downarrow', [8659]], ['DownArrowUpArrow', [8693]], ['DownBreve', [785]], ['downdownarrows', [8650]], ['downharpoonleft', [8643]], ['downharpoonright', [8642]], ['DownLeftRightVector', [10576]], ['DownLeftTeeVector', [10590]], ['DownLeftVectorBar', [10582]], ['DownLeftVector', [8637]], ['DownRightTeeVector', [10591]], ['DownRightVectorBar', [10583]], ['DownRightVector', [8641]], ['DownTeeArrow', [8615]], ['DownTee', [8868]], ['drbkarow', [10512]], ['drcorn', [8991]], ['drcrop', [8972]], ['Dscr', [119967]], ['dscr', [119993]], ['DScy', [1029]], ['dscy', [1109]], ['dsol', [10742]], ['Dstrok', [272]], ['dstrok', [273]], ['dtdot', [8945]], ['dtri', [9663]], ['dtrif', [9662]], ['duarr', [8693]], ['duhar', [10607]], ['dwangle', [10662]], ['DZcy', [1039]], ['dzcy', [1119]], ['dzigrarr', [10239]], ['Eacute', [201]], ['eacute', [233]], ['easter', [10862]], ['Ecaron', [282]], ['ecaron', [283]], ['Ecirc', [202]], ['ecirc', [234]], ['ecir', [8790]], ['ecolon', [8789]], ['Ecy', [1069]], ['ecy', [1101]], ['eDDot', [10871]], ['Edot', [278]], ['edot', [279]], ['eDot', [8785]], ['ee', [8519]], ['efDot', [8786]], ['Efr', [120072]], ['efr', [120098]], ['eg', [10906]], ['Egrave', [200]], ['egrave', [232]], ['egs', [10902]], ['egsdot', [10904]], ['el', [10905]], ['Element', [8712]], ['elinters', [9191]], ['ell', [8467]], ['els', [10901]], ['elsdot', [10903]], ['Emacr', [274]], ['emacr', [275]], ['empty', [8709]], ['emptyset', [8709]], ['EmptySmallSquare', [9723]], ['emptyv', [8709]], ['EmptyVerySmallSquare', [9643]], ['emsp13', [8196]], ['emsp14', [8197]], ['emsp', [8195]], ['ENG', [330]], ['eng', [331]], ['ensp', [8194]], ['Eogon', [280]], ['eogon', [281]], ['Eopf', [120124]], ['eopf', [120150]], ['epar', [8917]], ['eparsl', [10723]], ['eplus', [10865]], ['epsi', [949]], ['Epsilon', [917]], ['epsilon', [949]], ['epsiv', [1013]], ['eqcirc', [8790]], ['eqcolon', [8789]], ['eqsim', [8770]], ['eqslantgtr', [10902]], ['eqslantless', [10901]], ['Equal', [10869]], ['equals', [61]], ['EqualTilde', [8770]], ['equest', [8799]], ['Equilibrium', [8652]], ['equiv', [8801]], ['equivDD', [10872]], ['eqvparsl', [10725]], ['erarr', [10609]], ['erDot', [8787]], ['escr', [8495]], ['Escr', [8496]], ['esdot', [8784]], ['Esim', [10867]], ['esim', [8770]], ['Eta', [919]], ['eta', [951]], ['ETH', [208]], ['eth', [240]], ['Euml', [203]], ['euml', [235]], ['euro', [8364]], ['excl', [33]], ['exist', [8707]], ['Exists', [8707]], ['expectation', [8496]], ['exponentiale', [8519]], ['ExponentialE', [8519]], ['fallingdotseq', [8786]], ['Fcy', [1060]], ['fcy', [1092]], ['female', [9792]], ['ffilig', [64259]], ['fflig', [64256]], ['ffllig', [64260]], ['Ffr', [120073]], ['ffr', [120099]], ['filig', [64257]], ['FilledSmallSquare', [9724]], ['FilledVerySmallSquare', [9642]], ['fjlig', [102, 106]], ['flat', [9837]], ['fllig', [64258]], ['fltns', [9649]], ['fnof', [402]], ['Fopf', [120125]], ['fopf', [120151]], ['forall', [8704]], ['ForAll', [8704]], ['fork', [8916]], ['forkv', [10969]], ['Fouriertrf', [8497]], ['fpartint', [10765]], ['frac12', [189]], ['frac13', [8531]], ['frac14', [188]], ['frac15', [8533]], ['frac16', [8537]], ['frac18', [8539]], ['frac23', [8532]], ['frac25', [8534]], ['frac34', [190]], ['frac35', [8535]], ['frac38', [8540]], ['frac45', [8536]], ['frac56', [8538]], ['frac58', [8541]], ['frac78', [8542]], ['frasl', [8260]], ['frown', [8994]], ['fscr', [119995]], ['Fscr', [8497]], ['gacute', [501]], ['Gamma', [915]], ['gamma', [947]], ['Gammad', [988]], ['gammad', [989]], ['gap', [10886]], ['Gbreve', [286]], ['gbreve', [287]], ['Gcedil', [290]], ['Gcirc', [284]], ['gcirc', [285]], ['Gcy', [1043]], ['gcy', [1075]], ['Gdot', [288]], ['gdot', [289]], ['ge', [8805]], ['gE', [8807]], ['gEl', [10892]], ['gel', [8923]], ['geq', [8805]], ['geqq', [8807]], ['geqslant', [10878]], ['gescc', [10921]], ['ges', [10878]], ['gesdot', [10880]], ['gesdoto', [10882]], ['gesdotol', [10884]], ['gesl', [8923, 65024]], ['gesles', [10900]], ['Gfr', [120074]], ['gfr', [120100]], ['gg', [8811]], ['Gg', [8921]], ['ggg', [8921]], ['gimel', [8503]], ['GJcy', [1027]], ['gjcy', [1107]], ['gla', [10917]], ['gl', [8823]], ['glE', [10898]], ['glj', [10916]], ['gnap', [10890]], ['gnapprox', [10890]], ['gne', [10888]], ['gnE', [8809]], ['gneq', [10888]], ['gneqq', [8809]], ['gnsim', [8935]], ['Gopf', [120126]], ['gopf', [120152]], ['grave', [96]], ['GreaterEqual', [8805]], ['GreaterEqualLess', [8923]], ['GreaterFullEqual', [8807]], ['GreaterGreater', [10914]], ['GreaterLess', [8823]], ['GreaterSlantEqual', [10878]], ['GreaterTilde', [8819]], ['Gscr', [119970]], ['gscr', [8458]], ['gsim', [8819]], ['gsime', [10894]], ['gsiml', [10896]], ['gtcc', [10919]], ['gtcir', [10874]], ['gt', [62]], ['GT', [62]], ['Gt', [8811]], ['gtdot', [8919]], ['gtlPar', [10645]], ['gtquest', [10876]], ['gtrapprox', [10886]], ['gtrarr', [10616]], ['gtrdot', [8919]], ['gtreqless', [8923]], ['gtreqqless', [10892]], ['gtrless', [8823]], ['gtrsim', [8819]], ['gvertneqq', [8809, 65024]], ['gvnE', [8809, 65024]], ['Hacek', [711]], ['hairsp', [8202]], ['half', [189]], ['hamilt', [8459]], ['HARDcy', [1066]], ['hardcy', [1098]], ['harrcir', [10568]], ['harr', [8596]], ['hArr', [8660]], ['harrw', [8621]], ['Hat', [94]], ['hbar', [8463]], ['Hcirc', [292]], ['hcirc', [293]], ['hearts', [9829]], ['heartsuit', [9829]], ['hellip', [8230]], ['hercon', [8889]], ['hfr', [120101]], ['Hfr', [8460]], ['HilbertSpace', [8459]], ['hksearow', [10533]], ['hkswarow', [10534]], ['hoarr', [8703]], ['homtht', [8763]], ['hookleftarrow', [8617]], ['hookrightarrow', [8618]], ['hopf', [120153]], ['Hopf', [8461]], ['horbar', [8213]], ['HorizontalLine', [9472]], ['hscr', [119997]], ['Hscr', [8459]], ['hslash', [8463]], ['Hstrok', [294]], ['hstrok', [295]], ['HumpDownHump', [8782]], ['HumpEqual', [8783]], ['hybull', [8259]], ['hyphen', [8208]], ['Iacute', [205]], ['iacute', [237]], ['ic', [8291]], ['Icirc', [206]], ['icirc', [238]], ['Icy', [1048]], ['icy', [1080]], ['Idot', [304]], ['IEcy', [1045]], ['iecy', [1077]], ['iexcl', [161]], ['iff', [8660]], ['ifr', [120102]], ['Ifr', [8465]], ['Igrave', [204]], ['igrave', [236]], ['ii', [8520]], ['iiiint', [10764]], ['iiint', [8749]], ['iinfin', [10716]], ['iiota', [8489]], ['IJlig', [306]], ['ijlig', [307]], ['Imacr', [298]], ['imacr', [299]], ['image', [8465]], ['ImaginaryI', [8520]], ['imagline', [8464]], ['imagpart', [8465]], ['imath', [305]], ['Im', [8465]], ['imof', [8887]], ['imped', [437]], ['Implies', [8658]], ['incare', [8453]], ['in', [8712]], ['infin', [8734]], ['infintie', [10717]], ['inodot', [305]], ['intcal', [8890]], ['int', [8747]], ['Int', [8748]], ['integers', [8484]], ['Integral', [8747]], ['intercal', [8890]], ['Intersection', [8898]], ['intlarhk', [10775]], ['intprod', [10812]], ['InvisibleComma', [8291]], ['InvisibleTimes', [8290]], ['IOcy', [1025]], ['iocy', [1105]], ['Iogon', [302]], ['iogon', [303]], ['Iopf', [120128]], ['iopf', [120154]], ['Iota', [921]], ['iota', [953]], ['iprod', [10812]], ['iquest', [191]], ['iscr', [119998]], ['Iscr', [8464]], ['isin', [8712]], ['isindot', [8949]], ['isinE', [8953]], ['isins', [8948]], ['isinsv', [8947]], ['isinv', [8712]], ['it', [8290]], ['Itilde', [296]], ['itilde', [297]], ['Iukcy', [1030]], ['iukcy', [1110]], ['Iuml', [207]], ['iuml', [239]], ['Jcirc', [308]], ['jcirc', [309]], ['Jcy', [1049]], ['jcy', [1081]], ['Jfr', [120077]], ['jfr', [120103]], ['jmath', [567]], ['Jopf', [120129]], ['jopf', [120155]], ['Jscr', [119973]], ['jscr', [119999]], ['Jsercy', [1032]], ['jsercy', [1112]], ['Jukcy', [1028]], ['jukcy', [1108]], ['Kappa', [922]], ['kappa', [954]], ['kappav', [1008]], ['Kcedil', [310]], ['kcedil', [311]], ['Kcy', [1050]], ['kcy', [1082]], ['Kfr', [120078]], ['kfr', [120104]], ['kgreen', [312]], ['KHcy', [1061]], ['khcy', [1093]], ['KJcy', [1036]], ['kjcy', [1116]], ['Kopf', [120130]], ['kopf', [120156]], ['Kscr', [119974]], ['kscr', [120000]], ['lAarr', [8666]], ['Lacute', [313]], ['lacute', [314]], ['laemptyv', [10676]], ['lagran', [8466]], ['Lambda', [923]], ['lambda', [955]], ['lang', [10216]], ['Lang', [10218]], ['langd', [10641]], ['langle', [10216]], ['lap', [10885]], ['Laplacetrf', [8466]], ['laquo', [171]], ['larrb', [8676]], ['larrbfs', [10527]], ['larr', [8592]], ['Larr', [8606]], ['lArr', [8656]], ['larrfs', [10525]], ['larrhk', [8617]], ['larrlp', [8619]], ['larrpl', [10553]], ['larrsim', [10611]], ['larrtl', [8610]], ['latail', [10521]], ['lAtail', [10523]], ['lat', [10923]], ['late', [10925]], ['lates', [10925, 65024]], ['lbarr', [10508]], ['lBarr', [10510]], ['lbbrk', [10098]], ['lbrace', [123]], ['lbrack', [91]], ['lbrke', [10635]], ['lbrksld', [10639]], ['lbrkslu', [10637]], ['Lcaron', [317]], ['lcaron', [318]], ['Lcedil', [315]], ['lcedil', [316]], ['lceil', [8968]], ['lcub', [123]], ['Lcy', [1051]], ['lcy', [1083]], ['ldca', [10550]], ['ldquo', [8220]], ['ldquor', [8222]], ['ldrdhar', [10599]], ['ldrushar', [10571]], ['ldsh', [8626]], ['le', [8804]], ['lE', [8806]], ['LeftAngleBracket', [10216]], ['LeftArrowBar', [8676]], ['leftarrow', [8592]], ['LeftArrow', [8592]], ['Leftarrow', [8656]], ['LeftArrowRightArrow', [8646]], ['leftarrowtail', [8610]], ['LeftCeiling', [8968]], ['LeftDoubleBracket', [10214]], ['LeftDownTeeVector', [10593]], ['LeftDownVectorBar', [10585]], ['LeftDownVector', [8643]], ['LeftFloor', [8970]], ['leftharpoondown', [8637]], ['leftharpoonup', [8636]], ['leftleftarrows', [8647]], ['leftrightarrow', [8596]], ['LeftRightArrow', [8596]], ['Leftrightarrow', [8660]], ['leftrightarrows', [8646]], ['leftrightharpoons', [8651]], ['leftrightsquigarrow', [8621]], ['LeftRightVector', [10574]], ['LeftTeeArrow', [8612]], ['LeftTee', [8867]], ['LeftTeeVector', [10586]], ['leftthreetimes', [8907]], ['LeftTriangleBar', [10703]], ['LeftTriangle', [8882]], ['LeftTriangleEqual', [8884]], ['LeftUpDownVector', [10577]], ['LeftUpTeeVector', [10592]], ['LeftUpVectorBar', [10584]], ['LeftUpVector', [8639]], ['LeftVectorBar', [10578]], ['LeftVector', [8636]], ['lEg', [10891]], ['leg', [8922]], ['leq', [8804]], ['leqq', [8806]], ['leqslant', [10877]], ['lescc', [10920]], ['les', [10877]], ['lesdot', [10879]], ['lesdoto', [10881]], ['lesdotor', [10883]], ['lesg', [8922, 65024]], ['lesges', [10899]], ['lessapprox', [10885]], ['lessdot', [8918]], ['lesseqgtr', [8922]], ['lesseqqgtr', [10891]], ['LessEqualGreater', [8922]], ['LessFullEqual', [8806]], ['LessGreater', [8822]], ['lessgtr', [8822]], ['LessLess', [10913]], ['lesssim', [8818]], ['LessSlantEqual', [10877]], ['LessTilde', [8818]], ['lfisht', [10620]], ['lfloor', [8970]], ['Lfr', [120079]], ['lfr', [120105]], ['lg', [8822]], ['lgE', [10897]], ['lHar', [10594]], ['lhard', [8637]], ['lharu', [8636]], ['lharul', [10602]], ['lhblk', [9604]], ['LJcy', [1033]], ['ljcy', [1113]], ['llarr', [8647]], ['ll', [8810]], ['Ll', [8920]], ['llcorner', [8990]], ['Lleftarrow', [8666]], ['llhard', [10603]], ['lltri', [9722]], ['Lmidot', [319]], ['lmidot', [320]], ['lmoustache', [9136]], ['lmoust', [9136]], ['lnap', [10889]], ['lnapprox', [10889]], ['lne', [10887]], ['lnE', [8808]], ['lneq', [10887]], ['lneqq', [8808]], ['lnsim', [8934]], ['loang', [10220]], ['loarr', [8701]], ['lobrk', [10214]], ['longleftarrow', [10229]], ['LongLeftArrow', [10229]], ['Longleftarrow', [10232]], ['longleftrightarrow', [10231]], ['LongLeftRightArrow', [10231]], ['Longleftrightarrow', [10234]], ['longmapsto', [10236]], ['longrightarrow', [10230]], ['LongRightArrow', [10230]], ['Longrightarrow', [10233]], ['looparrowleft', [8619]], ['looparrowright', [8620]], ['lopar', [10629]], ['Lopf', [120131]], ['lopf', [120157]], ['loplus', [10797]], ['lotimes', [10804]], ['lowast', [8727]], ['lowbar', [95]], ['LowerLeftArrow', [8601]], ['LowerRightArrow', [8600]], ['loz', [9674]], ['lozenge', [9674]], ['lozf', [10731]], ['lpar', [40]], ['lparlt', [10643]], ['lrarr', [8646]], ['lrcorner', [8991]], ['lrhar', [8651]], ['lrhard', [10605]], ['lrm', [8206]], ['lrtri', [8895]], ['lsaquo', [8249]], ['lscr', [120001]], ['Lscr', [8466]], ['lsh', [8624]], ['Lsh', [8624]], ['lsim', [8818]], ['lsime', [10893]], ['lsimg', [10895]], ['lsqb', [91]], ['lsquo', [8216]], ['lsquor', [8218]], ['Lstrok', [321]], ['lstrok', [322]], ['ltcc', [10918]], ['ltcir', [10873]], ['lt', [60]], ['LT', [60]], ['Lt', [8810]], ['ltdot', [8918]], ['lthree', [8907]], ['ltimes', [8905]], ['ltlarr', [10614]], ['ltquest', [10875]], ['ltri', [9667]], ['ltrie', [8884]], ['ltrif', [9666]], ['ltrPar', [10646]], ['lurdshar', [10570]], ['luruhar', [10598]], ['lvertneqq', [8808, 65024]], ['lvnE', [8808, 65024]], ['macr', [175]], ['male', [9794]], ['malt', [10016]], ['maltese', [10016]], ['Map', [10501]], ['map', [8614]], ['mapsto', [8614]], ['mapstodown', [8615]], ['mapstoleft', [8612]], ['mapstoup', [8613]], ['marker', [9646]], ['mcomma', [10793]], ['Mcy', [1052]], ['mcy', [1084]], ['mdash', [8212]], ['mDDot', [8762]], ['measuredangle', [8737]], ['MediumSpace', [8287]], ['Mellintrf', [8499]], ['Mfr', [120080]], ['mfr', [120106]], ['mho', [8487]], ['micro', [181]], ['midast', [42]], ['midcir', [10992]], ['mid', [8739]], ['middot', [183]], ['minusb', [8863]], ['minus', [8722]], ['minusd', [8760]], ['minusdu', [10794]], ['MinusPlus', [8723]], ['mlcp', [10971]], ['mldr', [8230]], ['mnplus', [8723]], ['models', [8871]], ['Mopf', [120132]], ['mopf', [120158]], ['mp', [8723]], ['mscr', [120002]], ['Mscr', [8499]], ['mstpos', [8766]], ['Mu', [924]], ['mu', [956]], ['multimap', [8888]], ['mumap', [8888]], ['nabla', [8711]], ['Nacute', [323]], ['nacute', [324]], ['nang', [8736, 8402]], ['nap', [8777]], ['napE', [10864, 824]], ['napid', [8779, 824]], ['napos', [329]], ['napprox', [8777]], ['natural', [9838]], ['naturals', [8469]], ['natur', [9838]], ['nbsp', [160]], ['nbump', [8782, 824]], ['nbumpe', [8783, 824]], ['ncap', [10819]], ['Ncaron', [327]], ['ncaron', [328]], ['Ncedil', [325]], ['ncedil', [326]], ['ncong', [8775]], ['ncongdot', [10861, 824]], ['ncup', [10818]], ['Ncy', [1053]], ['ncy', [1085]], ['ndash', [8211]], ['nearhk', [10532]], ['nearr', [8599]], ['neArr', [8663]], ['nearrow', [8599]], ['ne', [8800]], ['nedot', [8784, 824]], ['NegativeMediumSpace', [8203]], ['NegativeThickSpace', [8203]], ['NegativeThinSpace', [8203]], ['NegativeVeryThinSpace', [8203]], ['nequiv', [8802]], ['nesear', [10536]], ['nesim', [8770, 824]], ['NestedGreaterGreater', [8811]], ['NestedLessLess', [8810]], ['nexist', [8708]], ['nexists', [8708]], ['Nfr', [120081]], ['nfr', [120107]], ['ngE', [8807, 824]], ['nge', [8817]], ['ngeq', [8817]], ['ngeqq', [8807, 824]], ['ngeqslant', [10878, 824]], ['nges', [10878, 824]], ['nGg', [8921, 824]], ['ngsim', [8821]], ['nGt', [8811, 8402]], ['ngt', [8815]], ['ngtr', [8815]], ['nGtv', [8811, 824]], ['nharr', [8622]], ['nhArr', [8654]], ['nhpar', [10994]], ['ni', [8715]], ['nis', [8956]], ['nisd', [8954]], ['niv', [8715]], ['NJcy', [1034]], ['njcy', [1114]], ['nlarr', [8602]], ['nlArr', [8653]], ['nldr', [8229]], ['nlE', [8806, 824]], ['nle', [8816]], ['nleftarrow', [8602]], ['nLeftarrow', [8653]], ['nleftrightarrow', [8622]], ['nLeftrightarrow', [8654]], ['nleq', [8816]], ['nleqq', [8806, 824]], ['nleqslant', [10877, 824]], ['nles', [10877, 824]], ['nless', [8814]], ['nLl', [8920, 824]], ['nlsim', [8820]], ['nLt', [8810, 8402]], ['nlt', [8814]], ['nltri', [8938]], ['nltrie', [8940]], ['nLtv', [8810, 824]], ['nmid', [8740]], ['NoBreak', [8288]], ['NonBreakingSpace', [160]], ['nopf', [120159]], ['Nopf', [8469]], ['Not', [10988]], ['not', [172]], ['NotCongruent', [8802]], ['NotCupCap', [8813]], ['NotDoubleVerticalBar', [8742]], ['NotElement', [8713]], ['NotEqual', [8800]], ['NotEqualTilde', [8770, 824]], ['NotExists', [8708]], ['NotGreater', [8815]], ['NotGreaterEqual', [8817]], ['NotGreaterFullEqual', [8807, 824]], ['NotGreaterGreater', [8811, 824]], ['NotGreaterLess', [8825]], ['NotGreaterSlantEqual', [10878, 824]], ['NotGreaterTilde', [8821]], ['NotHumpDownHump', [8782, 824]], ['NotHumpEqual', [8783, 824]], ['notin', [8713]], ['notindot', [8949, 824]], ['notinE', [8953, 824]], ['notinva', [8713]], ['notinvb', [8951]], ['notinvc', [8950]], ['NotLeftTriangleBar', [10703, 824]], ['NotLeftTriangle', [8938]], ['NotLeftTriangleEqual', [8940]], ['NotLess', [8814]], ['NotLessEqual', [8816]], ['NotLessGreater', [8824]], ['NotLessLess', [8810, 824]], ['NotLessSlantEqual', [10877, 824]], ['NotLessTilde', [8820]], ['NotNestedGreaterGreater', [10914, 824]], ['NotNestedLessLess', [10913, 824]], ['notni', [8716]], ['notniva', [8716]], ['notnivb', [8958]], ['notnivc', [8957]], ['NotPrecedes', [8832]], ['NotPrecedesEqual', [10927, 824]], ['NotPrecedesSlantEqual', [8928]], ['NotReverseElement', [8716]], ['NotRightTriangleBar', [10704, 824]], ['NotRightTriangle', [8939]], ['NotRightTriangleEqual', [8941]], ['NotSquareSubset', [8847, 824]], ['NotSquareSubsetEqual', [8930]], ['NotSquareSuperset', [8848, 824]], ['NotSquareSupersetEqual', [8931]], ['NotSubset', [8834, 8402]], ['NotSubsetEqual', [8840]], ['NotSucceeds', [8833]], ['NotSucceedsEqual', [10928, 824]], ['NotSucceedsSlantEqual', [8929]], ['NotSucceedsTilde', [8831, 824]], ['NotSuperset', [8835, 8402]], ['NotSupersetEqual', [8841]], ['NotTilde', [8769]], ['NotTildeEqual', [8772]], ['NotTildeFullEqual', [8775]], ['NotTildeTilde', [8777]], ['NotVerticalBar', [8740]], ['nparallel', [8742]], ['npar', [8742]], ['nparsl', [11005, 8421]], ['npart', [8706, 824]], ['npolint', [10772]], ['npr', [8832]], ['nprcue', [8928]], ['nprec', [8832]], ['npreceq', [10927, 824]], ['npre', [10927, 824]], ['nrarrc', [10547, 824]], ['nrarr', [8603]], ['nrArr', [8655]], ['nrarrw', [8605, 824]], ['nrightarrow', [8603]], ['nRightarrow', [8655]], ['nrtri', [8939]], ['nrtrie', [8941]], ['nsc', [8833]], ['nsccue', [8929]], ['nsce', [10928, 824]], ['Nscr', [119977]], ['nscr', [120003]], ['nshortmid', [8740]], ['nshortparallel', [8742]], ['nsim', [8769]], ['nsime', [8772]], ['nsimeq', [8772]], ['nsmid', [8740]], ['nspar', [8742]], ['nsqsube', [8930]], ['nsqsupe', [8931]], ['nsub', [8836]], ['nsubE', [10949, 824]], ['nsube', [8840]], ['nsubset', [8834, 8402]], ['nsubseteq', [8840]], ['nsubseteqq', [10949, 824]], ['nsucc', [8833]], ['nsucceq', [10928, 824]], ['nsup', [8837]], ['nsupE', [10950, 824]], ['nsupe', [8841]], ['nsupset', [8835, 8402]], ['nsupseteq', [8841]], ['nsupseteqq', [10950, 824]], ['ntgl', [8825]], ['Ntilde', [209]], ['ntilde', [241]], ['ntlg', [8824]], ['ntriangleleft', [8938]], ['ntrianglelefteq', [8940]], ['ntriangleright', [8939]], ['ntrianglerighteq', [8941]], ['Nu', [925]], ['nu', [957]], ['num', [35]], ['numero', [8470]], ['numsp', [8199]], ['nvap', [8781, 8402]], ['nvdash', [8876]], ['nvDash', [8877]], ['nVdash', [8878]], ['nVDash', [8879]], ['nvge', [8805, 8402]], ['nvgt', [62, 8402]], ['nvHarr', [10500]], ['nvinfin', [10718]], ['nvlArr', [10498]], ['nvle', [8804, 8402]], ['nvlt', [60, 8402]], ['nvltrie', [8884, 8402]], ['nvrArr', [10499]], ['nvrtrie', [8885, 8402]], ['nvsim', [8764, 8402]], ['nwarhk', [10531]], ['nwarr', [8598]], ['nwArr', [8662]], ['nwarrow', [8598]], ['nwnear', [10535]], ['Oacute', [211]], ['oacute', [243]], ['oast', [8859]], ['Ocirc', [212]], ['ocirc', [244]], ['ocir', [8858]], ['Ocy', [1054]], ['ocy', [1086]], ['odash', [8861]], ['Odblac', [336]], ['odblac', [337]], ['odiv', [10808]], ['odot', [8857]], ['odsold', [10684]], ['OElig', [338]], ['oelig', [339]], ['ofcir', [10687]], ['Ofr', [120082]], ['ofr', [120108]], ['ogon', [731]], ['Ograve', [210]], ['ograve', [242]], ['ogt', [10689]], ['ohbar', [10677]], ['ohm', [937]], ['oint', [8750]], ['olarr', [8634]], ['olcir', [10686]], ['olcross', [10683]], ['oline', [8254]], ['olt', [10688]], ['Omacr', [332]], ['omacr', [333]], ['Omega', [937]], ['omega', [969]], ['Omicron', [927]], ['omicron', [959]], ['omid', [10678]], ['ominus', [8854]], ['Oopf', [120134]], ['oopf', [120160]], ['opar', [10679]], ['OpenCurlyDoubleQuote', [8220]], ['OpenCurlyQuote', [8216]], ['operp', [10681]], ['oplus', [8853]], ['orarr', [8635]], ['Or', [10836]], ['or', [8744]], ['ord', [10845]], ['order', [8500]], ['orderof', [8500]], ['ordf', [170]], ['ordm', [186]], ['origof', [8886]], ['oror', [10838]], ['orslope', [10839]], ['orv', [10843]], ['oS', [9416]], ['Oscr', [119978]], ['oscr', [8500]], ['Oslash', [216]], ['oslash', [248]], ['osol', [8856]], ['Otilde', [213]], ['otilde', [245]], ['otimesas', [10806]], ['Otimes', [10807]], ['otimes', [8855]], ['Ouml', [214]], ['ouml', [246]], ['ovbar', [9021]], ['OverBar', [8254]], ['OverBrace', [9182]], ['OverBracket', [9140]], ['OverParenthesis', [9180]], ['para', [182]], ['parallel', [8741]], ['par', [8741]], ['parsim', [10995]], ['parsl', [11005]], ['part', [8706]], ['PartialD', [8706]], ['Pcy', [1055]], ['pcy', [1087]], ['percnt', [37]], ['period', [46]], ['permil', [8240]], ['perp', [8869]], ['pertenk', [8241]], ['Pfr', [120083]], ['pfr', [120109]], ['Phi', [934]], ['phi', [966]], ['phiv', [981]], ['phmmat', [8499]], ['phone', [9742]], ['Pi', [928]], ['pi', [960]], ['pitchfork', [8916]], ['piv', [982]], ['planck', [8463]], ['planckh', [8462]], ['plankv', [8463]], ['plusacir', [10787]], ['plusb', [8862]], ['pluscir', [10786]], ['plus', [43]], ['plusdo', [8724]], ['plusdu', [10789]], ['pluse', [10866]], ['PlusMinus', [177]], ['plusmn', [177]], ['plussim', [10790]], ['plustwo', [10791]], ['pm', [177]], ['Poincareplane', [8460]], ['pointint', [10773]], ['popf', [120161]], ['Popf', [8473]], ['pound', [163]], ['prap', [10935]], ['Pr', [10939]], ['pr', [8826]], ['prcue', [8828]], ['precapprox', [10935]], ['prec', [8826]], ['preccurlyeq', [8828]], ['Precedes', [8826]], ['PrecedesEqual', [10927]], ['PrecedesSlantEqual', [8828]], ['PrecedesTilde', [8830]], ['preceq', [10927]], ['precnapprox', [10937]], ['precneqq', [10933]], ['precnsim', [8936]], ['pre', [10927]], ['prE', [10931]], ['precsim', [8830]], ['prime', [8242]], ['Prime', [8243]], ['primes', [8473]], ['prnap', [10937]], ['prnE', [10933]], ['prnsim', [8936]], ['prod', [8719]], ['Product', [8719]], ['profalar', [9006]], ['profline', [8978]], ['profsurf', [8979]], ['prop', [8733]], ['Proportional', [8733]], ['Proportion', [8759]], ['propto', [8733]], ['prsim', [8830]], ['prurel', [8880]], ['Pscr', [119979]], ['pscr', [120005]], ['Psi', [936]], ['psi', [968]], ['puncsp', [8200]], ['Qfr', [120084]], ['qfr', [120110]], ['qint', [10764]], ['qopf', [120162]], ['Qopf', [8474]], ['qprime', [8279]], ['Qscr', [119980]], ['qscr', [120006]], ['quaternions', [8461]], ['quatint', [10774]], ['quest', [63]], ['questeq', [8799]], ['quot', [34]], ['QUOT', [34]], ['rAarr', [8667]], ['race', [8765, 817]], ['Racute', [340]], ['racute', [341]], ['radic', [8730]], ['raemptyv', [10675]], ['rang', [10217]], ['Rang', [10219]], ['rangd', [10642]], ['range', [10661]], ['rangle', [10217]], ['raquo', [187]], ['rarrap', [10613]], ['rarrb', [8677]], ['rarrbfs', [10528]], ['rarrc', [10547]], ['rarr', [8594]], ['Rarr', [8608]], ['rArr', [8658]], ['rarrfs', [10526]], ['rarrhk', [8618]], ['rarrlp', [8620]], ['rarrpl', [10565]], ['rarrsim', [10612]], ['Rarrtl', [10518]], ['rarrtl', [8611]], ['rarrw', [8605]], ['ratail', [10522]], ['rAtail', [10524]], ['ratio', [8758]], ['rationals', [8474]], ['rbarr', [10509]], ['rBarr', [10511]], ['RBarr', [10512]], ['rbbrk', [10099]], ['rbrace', [125]], ['rbrack', [93]], ['rbrke', [10636]], ['rbrksld', [10638]], ['rbrkslu', [10640]], ['Rcaron', [344]], ['rcaron', [345]], ['Rcedil', [342]], ['rcedil', [343]], ['rceil', [8969]], ['rcub', [125]], ['Rcy', [1056]], ['rcy', [1088]], ['rdca', [10551]], ['rdldhar', [10601]], ['rdquo', [8221]], ['rdquor', [8221]], ['rdsh', [8627]], ['real', [8476]], ['realine', [8475]], ['realpart', [8476]], ['reals', [8477]], ['Re', [8476]], ['rect', [9645]], ['reg', [174]], ['REG', [174]], ['ReverseElement', [8715]], ['ReverseEquilibrium', [8651]], ['ReverseUpEquilibrium', [10607]], ['rfisht', [10621]], ['rfloor', [8971]], ['rfr', [120111]], ['Rfr', [8476]], ['rHar', [10596]], ['rhard', [8641]], ['rharu', [8640]], ['rharul', [10604]], ['Rho', [929]], ['rho', [961]], ['rhov', [1009]], ['RightAngleBracket', [10217]], ['RightArrowBar', [8677]], ['rightarrow', [8594]], ['RightArrow', [8594]], ['Rightarrow', [8658]], ['RightArrowLeftArrow', [8644]], ['rightarrowtail', [8611]], ['RightCeiling', [8969]], ['RightDoubleBracket', [10215]], ['RightDownTeeVector', [10589]], ['RightDownVectorBar', [10581]], ['RightDownVector', [8642]], ['RightFloor', [8971]], ['rightharpoondown', [8641]], ['rightharpoonup', [8640]], ['rightleftarrows', [8644]], ['rightleftharpoons', [8652]], ['rightrightarrows', [8649]], ['rightsquigarrow', [8605]], ['RightTeeArrow', [8614]], ['RightTee', [8866]], ['RightTeeVector', [10587]], ['rightthreetimes', [8908]], ['RightTriangleBar', [10704]], ['RightTriangle', [8883]], ['RightTriangleEqual', [8885]], ['RightUpDownVector', [10575]], ['RightUpTeeVector', [10588]], ['RightUpVectorBar', [10580]], ['RightUpVector', [8638]], ['RightVectorBar', [10579]], ['RightVector', [8640]], ['ring', [730]], ['risingdotseq', [8787]], ['rlarr', [8644]], ['rlhar', [8652]], ['rlm', [8207]], ['rmoustache', [9137]], ['rmoust', [9137]], ['rnmid', [10990]], ['roang', [10221]], ['roarr', [8702]], ['robrk', [10215]], ['ropar', [10630]], ['ropf', [120163]], ['Ropf', [8477]], ['roplus', [10798]], ['rotimes', [10805]], ['RoundImplies', [10608]], ['rpar', [41]], ['rpargt', [10644]], ['rppolint', [10770]], ['rrarr', [8649]], ['Rrightarrow', [8667]], ['rsaquo', [8250]], ['rscr', [120007]], ['Rscr', [8475]], ['rsh', [8625]], ['Rsh', [8625]], ['rsqb', [93]], ['rsquo', [8217]], ['rsquor', [8217]], ['rthree', [8908]], ['rtimes', [8906]], ['rtri', [9657]], ['rtrie', [8885]], ['rtrif', [9656]], ['rtriltri', [10702]], ['RuleDelayed', [10740]], ['ruluhar', [10600]], ['rx', [8478]], ['Sacute', [346]], ['sacute', [347]], ['sbquo', [8218]], ['scap', [10936]], ['Scaron', [352]], ['scaron', [353]], ['Sc', [10940]], ['sc', [8827]], ['sccue', [8829]], ['sce', [10928]], ['scE', [10932]], ['Scedil', [350]], ['scedil', [351]], ['Scirc', [348]], ['scirc', [349]], ['scnap', [10938]], ['scnE', [10934]], ['scnsim', [8937]], ['scpolint', [10771]], ['scsim', [8831]], ['Scy', [1057]], ['scy', [1089]], ['sdotb', [8865]], ['sdot', [8901]], ['sdote', [10854]], ['searhk', [10533]], ['searr', [8600]], ['seArr', [8664]], ['searrow', [8600]], ['sect', [167]], ['semi', [59]], ['seswar', [10537]], ['setminus', [8726]], ['setmn', [8726]], ['sext', [10038]], ['Sfr', [120086]], ['sfr', [120112]], ['sfrown', [8994]], ['sharp', [9839]], ['SHCHcy', [1065]], ['shchcy', [1097]], ['SHcy', [1064]], ['shcy', [1096]], ['ShortDownArrow', [8595]], ['ShortLeftArrow', [8592]], ['shortmid', [8739]], ['shortparallel', [8741]], ['ShortRightArrow', [8594]], ['ShortUpArrow', [8593]], ['shy', [173]], ['Sigma', [931]], ['sigma', [963]], ['sigmaf', [962]], ['sigmav', [962]], ['sim', [8764]], ['simdot', [10858]], ['sime', [8771]], ['simeq', [8771]], ['simg', [10910]], ['simgE', [10912]], ['siml', [10909]], ['simlE', [10911]], ['simne', [8774]], ['simplus', [10788]], ['simrarr', [10610]], ['slarr', [8592]], ['SmallCircle', [8728]], ['smallsetminus', [8726]], ['smashp', [10803]], ['smeparsl', [10724]], ['smid', [8739]], ['smile', [8995]], ['smt', [10922]], ['smte', [10924]], ['smtes', [10924, 65024]], ['SOFTcy', [1068]], ['softcy', [1100]], ['solbar', [9023]], ['solb', [10692]], ['sol', [47]], ['Sopf', [120138]], ['sopf', [120164]], ['spades', [9824]], ['spadesuit', [9824]], ['spar', [8741]], ['sqcap', [8851]], ['sqcaps', [8851, 65024]], ['sqcup', [8852]], ['sqcups', [8852, 65024]], ['Sqrt', [8730]], ['sqsub', [8847]], ['sqsube', [8849]], ['sqsubset', [8847]], ['sqsubseteq', [8849]], ['sqsup', [8848]], ['sqsupe', [8850]], ['sqsupset', [8848]], ['sqsupseteq', [8850]], ['square', [9633]], ['Square', [9633]], ['SquareIntersection', [8851]], ['SquareSubset', [8847]], ['SquareSubsetEqual', [8849]], ['SquareSuperset', [8848]], ['SquareSupersetEqual', [8850]], ['SquareUnion', [8852]], ['squarf', [9642]], ['squ', [9633]], ['squf', [9642]], ['srarr', [8594]], ['Sscr', [119982]], ['sscr', [120008]], ['ssetmn', [8726]], ['ssmile', [8995]], ['sstarf', [8902]], ['Star', [8902]], ['star', [9734]], ['starf', [9733]], ['straightepsilon', [1013]], ['straightphi', [981]], ['strns', [175]], ['sub', [8834]], ['Sub', [8912]], ['subdot', [10941]], ['subE', [10949]], ['sube', [8838]], ['subedot', [10947]], ['submult', [10945]], ['subnE', [10955]], ['subne', [8842]], ['subplus', [10943]], ['subrarr', [10617]], ['subset', [8834]], ['Subset', [8912]], ['subseteq', [8838]], ['subseteqq', [10949]], ['SubsetEqual', [8838]], ['subsetneq', [8842]], ['subsetneqq', [10955]], ['subsim', [10951]], ['subsub', [10965]], ['subsup', [10963]], ['succapprox', [10936]], ['succ', [8827]], ['succcurlyeq', [8829]], ['Succeeds', [8827]], ['SucceedsEqual', [10928]], ['SucceedsSlantEqual', [8829]], ['SucceedsTilde', [8831]], ['succeq', [10928]], ['succnapprox', [10938]], ['succneqq', [10934]], ['succnsim', [8937]], ['succsim', [8831]], ['SuchThat', [8715]], ['sum', [8721]], ['Sum', [8721]], ['sung', [9834]], ['sup1', [185]], ['sup2', [178]], ['sup3', [179]], ['sup', [8835]], ['Sup', [8913]], ['supdot', [10942]], ['supdsub', [10968]], ['supE', [10950]], ['supe', [8839]], ['supedot', [10948]], ['Superset', [8835]], ['SupersetEqual', [8839]], ['suphsol', [10185]], ['suphsub', [10967]], ['suplarr', [10619]], ['supmult', [10946]], ['supnE', [10956]], ['supne', [8843]], ['supplus', [10944]], ['supset', [8835]], ['Supset', [8913]], ['supseteq', [8839]], ['supseteqq', [10950]], ['supsetneq', [8843]], ['supsetneqq', [10956]], ['supsim', [10952]], ['supsub', [10964]], ['supsup', [10966]], ['swarhk', [10534]], ['swarr', [8601]], ['swArr', [8665]], ['swarrow', [8601]], ['swnwar', [10538]], ['szlig', [223]], ['Tab', [9]], ['target', [8982]], ['Tau', [932]], ['tau', [964]], ['tbrk', [9140]], ['Tcaron', [356]], ['tcaron', [357]], ['Tcedil', [354]], ['tcedil', [355]], ['Tcy', [1058]], ['tcy', [1090]], ['tdot', [8411]], ['telrec', [8981]], ['Tfr', [120087]], ['tfr', [120113]], ['there4', [8756]], ['therefore', [8756]], ['Therefore', [8756]], ['Theta', [920]], ['theta', [952]], ['thetasym', [977]], ['thetav', [977]], ['thickapprox', [8776]], ['thicksim', [8764]], ['ThickSpace', [8287, 8202]], ['ThinSpace', [8201]], ['thinsp', [8201]], ['thkap', [8776]], ['thksim', [8764]], ['THORN', [222]], ['thorn', [254]], ['tilde', [732]], ['Tilde', [8764]], ['TildeEqual', [8771]], ['TildeFullEqual', [8773]], ['TildeTilde', [8776]], ['timesbar', [10801]], ['timesb', [8864]], ['times', [215]], ['timesd', [10800]], ['tint', [8749]], ['toea', [10536]], ['topbot', [9014]], ['topcir', [10993]], ['top', [8868]], ['Topf', [120139]], ['topf', [120165]], ['topfork', [10970]], ['tosa', [10537]], ['tprime', [8244]], ['trade', [8482]], ['TRADE', [8482]], ['triangle', [9653]], ['triangledown', [9663]], ['triangleleft', [9667]], ['trianglelefteq', [8884]], ['triangleq', [8796]], ['triangleright', [9657]], ['trianglerighteq', [8885]], ['tridot', [9708]], ['trie', [8796]], ['triminus', [10810]], ['TripleDot', [8411]], ['triplus', [10809]], ['trisb', [10701]], ['tritime', [10811]], ['trpezium', [9186]], ['Tscr', [119983]], ['tscr', [120009]], ['TScy', [1062]], ['tscy', [1094]], ['TSHcy', [1035]], ['tshcy', [1115]], ['Tstrok', [358]], ['tstrok', [359]], ['twixt', [8812]], ['twoheadleftarrow', [8606]], ['twoheadrightarrow', [8608]], ['Uacute', [218]], ['uacute', [250]], ['uarr', [8593]], ['Uarr', [8607]], ['uArr', [8657]], ['Uarrocir', [10569]], ['Ubrcy', [1038]], ['ubrcy', [1118]], ['Ubreve', [364]], ['ubreve', [365]], ['Ucirc', [219]], ['ucirc', [251]], ['Ucy', [1059]], ['ucy', [1091]], ['udarr', [8645]], ['Udblac', [368]], ['udblac', [369]], ['udhar', [10606]], ['ufisht', [10622]], ['Ufr', [120088]], ['ufr', [120114]], ['Ugrave', [217]], ['ugrave', [249]], ['uHar', [10595]], ['uharl', [8639]], ['uharr', [8638]], ['uhblk', [9600]], ['ulcorn', [8988]], ['ulcorner', [8988]], ['ulcrop', [8975]], ['ultri', [9720]], ['Umacr', [362]], ['umacr', [363]], ['uml', [168]], ['UnderBar', [95]], ['UnderBrace', [9183]], ['UnderBracket', [9141]], ['UnderParenthesis', [9181]], ['Union', [8899]], ['UnionPlus', [8846]], ['Uogon', [370]], ['uogon', [371]], ['Uopf', [120140]], ['uopf', [120166]], ['UpArrowBar', [10514]], ['uparrow', [8593]], ['UpArrow', [8593]], ['Uparrow', [8657]], ['UpArrowDownArrow', [8645]], ['updownarrow', [8597]], ['UpDownArrow', [8597]], ['Updownarrow', [8661]], ['UpEquilibrium', [10606]], ['upharpoonleft', [8639]], ['upharpoonright', [8638]], ['uplus', [8846]], ['UpperLeftArrow', [8598]], ['UpperRightArrow', [8599]], ['upsi', [965]], ['Upsi', [978]], ['upsih', [978]], ['Upsilon', [933]], ['upsilon', [965]], ['UpTeeArrow', [8613]], ['UpTee', [8869]], ['upuparrows', [8648]], ['urcorn', [8989]], ['urcorner', [8989]], ['urcrop', [8974]], ['Uring', [366]], ['uring', [367]], ['urtri', [9721]], ['Uscr', [119984]], ['uscr', [120010]], ['utdot', [8944]], ['Utilde', [360]], ['utilde', [361]], ['utri', [9653]], ['utrif', [9652]], ['uuarr', [8648]], ['Uuml', [220]], ['uuml', [252]], ['uwangle', [10663]], ['vangrt', [10652]], ['varepsilon', [1013]], ['varkappa', [1008]], ['varnothing', [8709]], ['varphi', [981]], ['varpi', [982]], ['varpropto', [8733]], ['varr', [8597]], ['vArr', [8661]], ['varrho', [1009]], ['varsigma', [962]], ['varsubsetneq', [8842, 65024]], ['varsubsetneqq', [10955, 65024]], ['varsupsetneq', [8843, 65024]], ['varsupsetneqq', [10956, 65024]], ['vartheta', [977]], ['vartriangleleft', [8882]], ['vartriangleright', [8883]], ['vBar', [10984]], ['Vbar', [10987]], ['vBarv', [10985]], ['Vcy', [1042]], ['vcy', [1074]], ['vdash', [8866]], ['vDash', [8872]], ['Vdash', [8873]], ['VDash', [8875]], ['Vdashl', [10982]], ['veebar', [8891]], ['vee', [8744]], ['Vee', [8897]], ['veeeq', [8794]], ['vellip', [8942]], ['verbar', [124]], ['Verbar', [8214]], ['vert', [124]], ['Vert', [8214]], ['VerticalBar', [8739]], ['VerticalLine', [124]], ['VerticalSeparator', [10072]], ['VerticalTilde', [8768]], ['VeryThinSpace', [8202]], ['Vfr', [120089]], ['vfr', [120115]], ['vltri', [8882]], ['vnsub', [8834, 8402]], ['vnsup', [8835, 8402]], ['Vopf', [120141]], ['vopf', [120167]], ['vprop', [8733]], ['vrtri', [8883]], ['Vscr', [119985]], ['vscr', [120011]], ['vsubnE', [10955, 65024]], ['vsubne', [8842, 65024]], ['vsupnE', [10956, 65024]], ['vsupne', [8843, 65024]], ['Vvdash', [8874]], ['vzigzag', [10650]], ['Wcirc', [372]], ['wcirc', [373]], ['wedbar', [10847]], ['wedge', [8743]], ['Wedge', [8896]], ['wedgeq', [8793]], ['weierp', [8472]], ['Wfr', [120090]], ['wfr', [120116]], ['Wopf', [120142]], ['wopf', [120168]], ['wp', [8472]], ['wr', [8768]], ['wreath', [8768]], ['Wscr', [119986]], ['wscr', [120012]], ['xcap', [8898]], ['xcirc', [9711]], ['xcup', [8899]], ['xdtri', [9661]], ['Xfr', [120091]], ['xfr', [120117]], ['xharr', [10231]], ['xhArr', [10234]], ['Xi', [926]], ['xi', [958]], ['xlarr', [10229]], ['xlArr', [10232]], ['xmap', [10236]], ['xnis', [8955]], ['xodot', [10752]], ['Xopf', [120143]], ['xopf', [120169]], ['xoplus', [10753]], ['xotime', [10754]], ['xrarr', [10230]], ['xrArr', [10233]], ['Xscr', [119987]], ['xscr', [120013]], ['xsqcup', [10758]], ['xuplus', [10756]], ['xutri', [9651]], ['xvee', [8897]], ['xwedge', [8896]], ['Yacute', [221]], ['yacute', [253]], ['YAcy', [1071]], ['yacy', [1103]], ['Ycirc', [374]], ['ycirc', [375]], ['Ycy', [1067]], ['ycy', [1099]], ['yen', [165]], ['Yfr', [120092]], ['yfr', [120118]], ['YIcy', [1031]], ['yicy', [1111]], ['Yopf', [120144]], ['yopf', [120170]], ['Yscr', [119988]], ['yscr', [120014]], ['YUcy', [1070]], ['yucy', [1102]], ['yuml', [255]], ['Yuml', [376]], ['Zacute', [377]], ['zacute', [378]], ['Zcaron', [381]], ['zcaron', [382]], ['Zcy', [1047]], ['zcy', [1079]], ['Zdot', [379]], ['zdot', [380]], ['zeetrf', [8488]], ['ZeroWidthSpace', [8203]], ['Zeta', [918]], ['zeta', [950]], ['zfr', [120119]], ['Zfr', [8488]], ['ZHcy', [1046]], ['zhcy', [1078]], ['zigrarr', [8669]], ['zopf', [120171]], ['Zopf', [8484]], ['Zscr', [119989]], ['zscr', [120015]], ['zwj', [8205]], ['zwnj', [8204]]];

	var alphaIndex = {};
	var charIndex = {};

	createIndexes(alphaIndex, charIndex);

	/**
	 * @constructor
	 */
	function Html5Entities() {}

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	Html5Entities.prototype.decode = function(str) {
	    if (str.length === 0) {
	        return '';
	    }
	    return str.replace(/&(#?[\w\d]+);?/g, function(s, entity) {
	        var chr;
	        if (entity.charAt(0) === "#") {
	            var code = entity.charAt(1) === 'x' ?
	                parseInt(entity.substr(2).toLowerCase(), 16) :
	                parseInt(entity.substr(1));

	            if (!(isNaN(code) || code < -32768 || code > 65535)) {
	                chr = String.fromCharCode(code);
	            }
	        } else {
	            chr = alphaIndex[entity];
	        }
	        return chr || s;
	    });
	};

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	 Html5Entities.decode = function(str) {
	    return new Html5Entities().decode(str);
	 };

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	Html5Entities.prototype.encode = function(str) {
	    var strLength = str.length;
	    if (strLength === 0) {
	        return '';
	    }
	    var result = '';
	    var i = 0;
	    while (i < strLength) {
	        var charInfo = charIndex[str.charCodeAt(i)];
	        if (charInfo) {
	            var alpha = charInfo[str.charCodeAt(i + 1)];
	            if (alpha) {
	                i++;
	            } else {
	                alpha = charInfo[''];
	            }
	            if (alpha) {
	                result += "&" + alpha + ";";
	                i++;
	                continue;
	            }
	        }
	        result += str.charAt(i);
	        i++;
	    }
	    return result;
	};

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	 Html5Entities.encode = function(str) {
	    return new Html5Entities().encode(str);
	 };

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	Html5Entities.prototype.encodeNonUTF = function(str) {
	    var strLength = str.length;
	    if (strLength === 0) {
	        return '';
	    }
	    var result = '';
	    var i = 0;
	    while (i < strLength) {
	        var c = str.charCodeAt(i);
	        var charInfo = charIndex[c];
	        if (charInfo) {
	            var alpha = charInfo[str.charCodeAt(i + 1)];
	            if (alpha) {
	                i++;
	            } else {
	                alpha = charInfo[''];
	            }
	            if (alpha) {
	                result += "&" + alpha + ";";
	                i++;
	                continue;
	            }
	        }
	        if (c < 32 || c > 126) {
	            result += '&#' + c + ';';
	        } else {
	            result += str.charAt(i);
	        }
	        i++;
	    }
	    return result;
	};

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	 Html5Entities.encodeNonUTF = function(str) {
	    return new Html5Entities().encodeNonUTF(str);
	 };

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	Html5Entities.prototype.encodeNonASCII = function(str) {
	    var strLength = str.length;
	    if (strLength === 0) {
	        return '';
	    }
	    var result = '';
	    var i = 0;
	    while (i < strLength) {
	        var c = str.charCodeAt(i);
	        if (c <= 255) {
	            result += str[i++];
	            continue;
	        }
	        result += '&#' + c + ';';
	        i++
	    }
	    return result;
	};

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	 Html5Entities.encodeNonASCII = function(str) {
	    return new Html5Entities().encodeNonASCII(str);
	 };

	/**
	 * @param {Object} alphaIndex Passed by reference.
	 * @param {Object} charIndex Passed by reference.
	 */
	function createIndexes(alphaIndex, charIndex) {
	    var i = ENTITIES.length;
	    var _results = [];
	    while (i--) {
	        var e = ENTITIES[i];
	        var alpha = e[0];
	        var chars = e[1];
	        var chr = chars[0];
	        var addChar = (chr < 32 || chr > 126) || chr === 62 || chr === 60 || chr === 38 || chr === 34 || chr === 39;
	        var charInfo;
	        if (addChar) {
	            charInfo = charIndex[chr] = charIndex[chr] || {};
	        }
	        if (chars[1]) {
	            var chr2 = chars[1];
	            alphaIndex[alpha] = String.fromCharCode(chr) + String.fromCharCode(chr2);
	            _results.push(addChar && (charInfo[chr2] = alpha));
	        } else {
	            alphaIndex[alpha] = String.fromCharCode(chr);
	            _results.push(addChar && (charInfo[''] = alpha));
	        }
	    }
	}

	module.exports = Html5Entities;


/***/ },
/* 42 */
/***/ function(module, exports) {


	var indexOf = [].indexOf;

	module.exports = function(arr, obj){
	  if (indexOf) return arr.indexOf(obj);
	  for (var i = 0; i < arr.length; ++i) {
	    if (arr[i] === obj) return i;
	  }
	  return -1;
	};

/***/ },
/* 43 */
/***/ function(module, exports) {

	/**
	 * Parses an URI
	 *
	 * @author Steven Levithan <stevenlevithan.com> (MIT license)
	 * @api private
	 */

	var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

	var parts = [
	    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
	];

	module.exports = function parseuri(str) {
	    var src = str,
	        b = str.indexOf('['),
	        e = str.indexOf(']');

	    if (b != -1 && e != -1) {
	        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
	    }

	    var m = re.exec(str || ''),
	        uri = {},
	        i = 14;

	    while (i--) {
	        uri[parts[i]] = m[i] || '';
	    }

	    if (b != -1 && e != -1) {
	        uri.source = src;
	        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
	        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
	        uri.ipv6uri = true;
	    }

	    return uri;
	};


/***/ },
/* 44 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":7,"e":"span","a":{"role":"button","class":["FlatButton FlatButton__",{"t":2,"x":{"r":[".size"],"s":"_0||\"medium\""}}," FlatButton__",{"t":2,"x":{"r":[".type"],"s":"_0||\"default\""}}," FlatButton__",{"t":2,"x":{"r":[".state"],"s":"_0||\"normal\""}}," ",{"t":4,"f":["FlatButton__no-text"],"n":50,"x":{"r":[".text"],"s":"!_0"}}," ",{"t":2,"r":".className"}],"title":[{"t":2,"r":".title"}]},"f":[{"t":4,"f":[{"t":7,"e":"span","a":{"class":"FlatButton--event"},"v":{"tap":{"n":[{"t":2,"r":".fire"}],"d":[{"t":2,"r":".event"}]}}}],"n":50,"r":".fire"},{"t":4,"n":51,"f":[{"t":4,"n":50,"x":{"r":[".mousedown",".mouseup",".touchstart",".touchend",".click"],"s":"_0||_1||_2||_3||_4"},"f":[{"t":7,"e":"span","a":{"class":"FlatButton--event"},"v":{"touchstart":{"n":[{"t":2,"r":".touchstart"}],"d":[{"t":2,"x":{"r":[".touchstartEvent",".event"],"s":"_0||_1"}}]},"touchend":{"n":[{"t":2,"r":".touchend"}],"d":[{"t":2,"x":{"r":[".touchendEvent",".event"],"s":"_0||_1"}}]},"mousedown":{"n":[{"t":2,"r":".mousedown"}],"d":[{"t":2,"x":{"r":[".mousedownEvent",".event"],"s":"_0||_1"}}]},"mouseup":{"n":[{"t":2,"r":".mouseup"}],"d":[{"t":2,"x":{"r":[".mouseupEvent",".event"],"s":"_0||_1"}}]},"click":{"n":[{"t":2,"r":".click"}],"d":[{"t":2,"x":{"r":[".clickEvent",".event"],"s":"_0||_1"}}]}}}]},{"t":4,"n":50,"x":{"r":[".mousedown",".mouseup",".touchstart",".touchend",".click",".set"],"s":"(!(_0||_1||_2||_3||_4))&&(_5)"},"f":[" ",{"t":7,"e":"span","a":{"class":"FlatButton--event"},"v":{"tap":{"m":"set","a":{"r":[".set",".value"],"s":"[_0,_1]"}}}}]}],"r":".fire"}," ",{"t":4,"f":[{"t":7,"e":"span","a":{"class":"FlatButton--icon","style":["top: ",{"t":2,"x":{"r":[".iconY"],"s":"_0+\"px\""}},"; left: ",{"t":2,"x":{"r":[".iconX"],"s":"_0+\"px\""}},"; width: ",{"t":2,"x":{"r":[".iconW"],"s":"_0+\"px\""}},"; height: ",{"t":2,"x":{"r":[".iconH"],"s":"_0+\"px\""}},"; transform: rotate(",{"t":2,"x":{"r":[".iconR"],"s":"_0||0"}},"deg);"]},"f":[{"t":7,"e":"svg","f":[{"t":7,"e":"use","a":{"xlink:href":[{"t":2,"r":".icon"}]}}]}]}],"n":50,"r":".icon"}," ",{"t":4,"f":[{"t":7,"e":"span","a":{"class":"FlatButton--wrapper"},"f":[{"t":7,"e":"span","a":{"class":["FlatButton--text ",{"t":4,"f":["FlatButton--text__short"],"n":50,"x":{"r":[".text.length"],"s":"_0<5"}}," ",{"t":4,"f":["FlatButton--text__long"],"n":50,"x":{"r":[".text.length"],"s":"_0>10"}}," ",{"t":4,"f":["FlatButton--text__extra-long"],"n":50,"x":{"r":[".text.length"],"s":"_0>15"}}]},"f":[{"t":2,"r":".text"}]}]}],"n":50,"r":".text"}]}],"e":{}};

/***/ },
/* 45 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":7,"e":"div","a":{"class":["FileBrowser FileBrowser__",{"t":2,"r":".type","s":true}]},"f":[{"t":7,"e":"div","a":{"class":"FileBrowser--drag-drop-overlay"},"f":[{"t":7,"e":"span","a":{"class":"FileBrowser--drag-drop-overlay-title"},"f":[{"t":2,"r":".uploadOverlayTitle"}]}," ",{"t":7,"e":"span","a":{"class":"FileBrowser--drag-drop-overlay-text"},"f":[{"t":2,"r":".uploadOverlayText"}]}]}," ",{"t":7,"e":"div","a":{"class":["FileBrowser--message ",{"t":4,"f":["FileBrowser--message__active"],"n":50,"r":".showMessage"}]},"f":[{"t":7,"e":"span","a":{"class":"FileBrowser--message-title"},"f":[{"t":2,"r":".messageTitle"}]}," ",{"t":7,"e":"span","a":{"class":"FileBrowser--message-text"},"f":[{"t":2,"r":".messageText"}]}]}," ",{"t":4,"f":[{"t":7,"e":"span","t0":"fade","a":{"class":"FileBrowser--loader FileBrowser--loader__directories"},"f":["(Načítá se...)"]}],"n":50,"x":{"r":[".directories.length"],"s":"!_0"}}," ",{"t":7,"e":"ul","a":{"class":"FileBrowser--directories"},"f":[{"t":4,"f":[{"t":7,"e":"li","a":{"class":["FileBrowser--directory ",{"t":4,"f":["FileBrowser--directory__opened"],"n":50,"x":{"r":["~/openDirectory","d"],"s":"_0===_1"}}]},"t1":"slide","f":[{"t":4,"f":[{"t":7,"e":"div","a":{"class":"FileBrowser--search"},"f":[{"t":7,"e":"span","a":{"class":"FileBrowser--icon FileBrowser--icon__search"},"v":{"tap":{"m":"set","a":{"r":["~/openDirectory","d"],"s":"[\"openDirectory\",_0===_1?null:_1]"}}},"f":[{"t":7,"e":"svg","a":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 24 24"},"f":[{"t":7,"e":"path","a":{"d":"M21.172 24l-7.387-7.387c-1.388.874-3.024 1.387-4.785 1.387-4.971 0-9-4.029-9-9s4.029-9 9-9 9 4.029 9 9c0 1.761-.514 3.398-1.387 4.785l7.387 7.387-2.828 2.828zm-12.172-8c3.859 0 7-3.14 7-7s-3.141-7-7-7-7 3.14-7 7 3.141 7 7 7z"}}]}]}," ",{"t":7,"e":"input","a":{"type":"text","class":"FileBrowser--search-input","name":"search","value":[{"t":2,"r":"~/searchText"}],"placeholder":[{"t":2,"r":".name"}]},"v":{"focus-touchend":{"m":"set","a":{"r":["d"],"s":"[\"openDirectory\",_0]"}}}}," ",{"t":4,"f":[{"t":7,"e":"span","t0":"fade","a":{"class":"FileBrowser--loader FileBrowser--loader__searching"},"f":["(Načítá se...)"]}],"n":50,"r":"~/searching"}]}],"n":50,"x":{"r":[".path","~/searchDirPath"],"s":"_0===_1"}},{"t":4,"n":51,"f":[{"t":7,"e":"span","a":{"class":"\r\n                            FileBrowser--directory-name\r\n                        "},"v":{"tap":{"m":"set","a":{"r":["~/openDirectory","d"],"s":"[\"openDirectory\",_0===_1?null:_1]"}}},"f":[{"t":7,"e":"span","a":{"class":"FileBrowser--icon FileBrowser--icon__directory"},"f":[{"t":7,"e":"svg","a":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 24 24"},"f":[{"t":7,"e":"path","a":{"d":"M7.972 2h-6.972l.714 5h2.021l-.429-3h3.694c1.112 1.388 1.952 2 4.277 2h9.283l-.2 1h2.04l.6-3h-11.723c-1.978 0-2.041-.417-3.305-2zm16.028 7h-24l2 13h20l2-13z"}}]}]}," ",{"t":7,"e":"span","a":{"class":"FileBrowser--directory-name-text"},"f":[{"t":2,"r":".name"}]}," ",{"t":4,"f":[{"t":7,"e":"span","a":{"class":"FileBrowser--upload-files"},"f":[{"t":7,"e":"svg","a":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 24 24"},"f":[{"t":7,"e":"path","a":{"d":"M24 9h-9v-9h-6v9h-9v6h9v9h6v-9h9z"}}]}]}],"n":50,"x":{"r":[".uploadable","~/uploadDirectory",".name"],"s":"_0&&_1===_2"}}," ",{"t":4,"f":[{"t":7,"e":"span","t0":"fade","a":{"class":"FileBrowser--loader FileBrowser--loader__directory"},"f":["(Načítá se...)"]}],"n":50,"x":{"r":["~/loadingDirectory","d","~/uploadDirectory",".name","~/uploading.length"],"s":"_0===_1||(_2===_3&&_4)"}}]}],"x":{"r":[".path","~/searchDirPath"],"s":"_0===_1"}}," ",{"t":4,"f":[{"t":4,"f":[{"t":7,"e":"ul","a":{"class":["FileBrowser--files ",{"t":4,"f":["FileBrowser--files__search"],"n":50,"x":{"r":[".path","~/searchDirPath"],"s":"_0===_1"}}," ",{"t":4,"f":["FileBrowser--files__init-dir-content"],"n":50,"r":".initDirContent"}]},"t0":"slide","f":[{"t":4,"f":[{"t":7,"e":"li","a":{"class":["FileBrowser--file FileBrowser--file__",{"t":2,"r":"~/filesType"}," ",{"t":4,"f":["FileBrowser--file__uploading"],"n":50,"r":".uploading"}," ",{"t":4,"f":["FileBrowser--file__svg"],"n":50,"r":".svg"}," ",{"t":4,"f":["FileBrowser--file__error"],"n":50,"r":".uploadError"}," ",{"t":4,"f":["FileBrowser--file__selected"],"n":50,"x":{"r":["~/selectedPath.length","~/selectedPath",".path"],"s":"_0&&_1===_2"}}]},"t0":{"n":"attr","a":[{"duration":450}]},"f":[{"t":4,"f":[{"t":4,"f":[{"t":7,"e":"span","t0":{"n":"fade","a":[{"duration":100}]},"a":{"class":"FileBrowser--delete-file-confirm"},"v":{"tap":{"n":"deleteFile","d":[{"t":2,"r":"."}]}},"f":[{"t":7,"e":"svg","a":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 24 24"},"f":[{"t":7,"e":"path","a":{"d":"M20.285 2l-11.285 11.567-5.286-5.011-3.714 3.716 9 8.728 15-15.285z"}}]}]}],"n":50,"x":{"r":["~/showRemoveConfirmation",".path"],"s":"_0===_1"}}," ",{"t":7,"e":"span","a":{"class":"FileBrowser--delete-file"},"v":{"tap":{"m":"set","a":{"r":["~/showRemoveConfirmation",".path"],"s":"[\"showRemoveConfirmation\",_0===_1?null:_1]"}}},"f":[{"t":7,"e":"svg","a":{"xmlns":"http://www.w3.org/2000/svg","viewBox":"0 0 24 24"},"f":[{"t":7,"e":"path","a":{"d":"M0 9h24v6h-24z"}}," ",{"t":7,"e":"path","a":{"d":"M0 9h24v6h-24z"}}]}]}],"n":50,"x":{"r":["deletable",".uploading",".uploadError"],"s":"_0&&!_1&&!_2"}}," ",{"t":4,"f":[{"t":7,"e":"span","t0":"fade","a":{"class":"FileBrowser--loader FileBrowser--loader__uploading"},"f":["(Nahrává se...)"]}],"n":50,"r":".uploading"}," ",{"t":4,"f":[{"t":7,"e":"span","a":{"class":"FileBrowser--overlay"}}],"n":50,"x":{"r":[".uploading",".uploadError"],"s":"_0||_1"}}," ",{"t":7,"e":"div","a":{"class":"FileBrowser--file-wrapper"},"v":{"tap":{"n":"selectFile","d":[{"t":2,"r":"."}]}},"f":[{"t":8,"x":{"r":["~/filesType"],"s":"_0+\"File\""}}]}]}],"n":52,"r":".files"}]}],"n":50,"r":".files.length"}],"n":50,"x":{"r":["~/openDirectory","d"],"s":"_0===_1"}}]}],"n":52,"i":"d","r":".directories"}]}," "]}," "],"p":{"imageFile":[{"t":4,"f":[{"t":7,"e":"img","a":{"src":[{"t":2,"r":".preview"}],"alt":"","title":[{"t":2,"r":".name"}]}}],"n":50,"r":".preview"}," ",{"t":4,"f":[{"t":7,"e":"img","a":{"src":[{"t":2,"x":{"r":["~/thumbsFullPath",".path"],"s":"_0(_1)"}}],"alt":"","title":[{"t":2,"r":".name"}]}}],"n":50,"x":{"r":[".uploadingId",".path"],"s":"!_0&&_1"}}],"iconFile":[{"t":4,"f":[{"t":3,"r":".svg"}],"n":50,"r":".svg"},{"t":4,"n":51,"f":[{"t":4,"f":[{"t":7,"e":"img","a":{"src":[{"t":2,"r":".preview"}],"alt":"","title":[{"t":2,"r":".name"}]}}],"n":50,"r":".preview"}," ",{"t":4,"f":[{"t":7,"e":"img","a":{"src":[{"t":2,"x":{"r":["~/thumbsFullPath",".path"],"s":"_1.match(/.svg$/)?_1:_0(_1)"}}],"alt":"","title":[{"t":2,"r":".name"}]}}],"n":50,"x":{"r":[".uploadingId",".path"],"s":"!_0&&_1"}}],"r":".svg"}]},"e":{}};

/***/ },
/* 46 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":7,"e":"span","a":{"role":"button","class":["Button Button__",{"t":2,"x":{"r":[".type"],"s":"_0||\"default\""}}," Button__",{"t":2,"x":{"r":[".size"],"s":"_0||\"medium\""}}," Button__",{"t":2,"x":{"r":[".state"],"s":"_0||\"normal\""}}," ",{"t":4,"f":["Button__no-icon"],"n":50,"x":{"r":[".icon"],"s":"!_0"}}," ",{"t":4,"f":["Button__no-text"],"n":50,"x":{"r":[".text"],"s":"!_0"}}," ",{"t":2,"r":".className"}],"title":[{"t":2,"r":".title"}]},"m":[{"t":4,"f":["tabindex=\"",{"t":2,"x":{"r":[".tabindex"],"s":"_0||0"}},"\""],"n":50,"x":{"r":[".fire",".set",".state"],"s":"!_0&&!_1&&_2!==\"disabled\""}}],"f":[{"t":4,"f":[{"t":7,"e":"span","a":{"class":"Button--event","tabindex":[{"t":2,"x":{"r":[".tabindex"],"s":"_0||0"}}]},"v":{"tap-enter-space":{"n":[{"t":2,"r":".fire"}],"d":[{"t":2,"r":".event"}]}}}],"n":50,"x":{"r":[".fire",".state"],"s":"_0&&_1!==\"disabled\""}},{"t":4,"n":51,"f":[{"t":4,"n":50,"x":{"r":[".set",".state"],"s":"_0&&_1!==\"disabled\""},"f":[{"t":7,"e":"span","a":{"class":"Button--event","tabindex":[{"t":2,"x":{"r":[".tabindex"],"s":"_0||0"}}]},"v":{"tap-enter-space":{"m":"set","a":{"r":[".set",".value"],"s":"[_0.replace(/^\\./,\"\"),_1]"}}}}]}],"x":{"r":[".fire",".state"],"s":"_0&&_1!==\"disabled\""}}," ",{"t":7,"e":"span","a":{"class":"Button--content"},"f":[{"t":4,"f":[{"t":7,"e":"span","a":{"class":"Button--icon","style":["top: ",{"t":2,"x":{"r":[".iconY"],"s":"typeof _0!==\"undefined\"?_0+\"px\":\"\""}},"; left: ",{"t":2,"x":{"r":[".iconX"],"s":"typeof _0!==\"undefined\"?_0+\"px\":\"\""}},"; width: ",{"t":2,"x":{"r":[".iconW"],"s":"typeof _0!==\"undefined\"?_0+\"px\":\"\""}},"; height: ",{"t":2,"x":{"r":[".iconH"],"s":"typeof _0!==\"undefined\"?_0+\"px\":\"\""}},"; transform: rotate(",{"t":2,"x":{"r":[".iconR"],"s":"_0||0"}},"deg);"]},"f":[{"t":7,"e":"svg","f":[{"t":7,"e":"use","a":{"xlink:href":[{"t":2,"r":".icon"}]}}]}]}],"n":50,"r":".icon"}," ",{"t":4,"f":[{"t":7,"e":"span","a":{"class":"Button--text"},"f":[{"t":2,"r":".text"}]}],"n":50,"r":".text"}]}]}],"e":{}};

/***/ },
/* 47 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":7,"e":"span","a":{"class":["Select Select__",{"t":2,"x":{"r":[".type"],"s":"_0||\"default\""}}," Select__",{"t":2,"x":{"r":[".size"],"s":"_0||\"medium\""}}," Select__",{"t":2,"x":{"r":[".state"],"s":"_0||\"normal\""}}," ",{"t":4,"f":["Select__adaptive"],"n":50,"r":".adaptive"}," ",{"t":2,"r":".className"}]},"f":[{"t":4,"f":[{"t":7,"e":"select","a":{"class":"Select--options","value":[{"t":2,"rx":{"r":"~/__Select","m":[{"t":30,"n":"._value"}]}}],"id":[{"t":2,"r":".id"}]},"m":[{"t":4,"f":["disabled"],"n":50,"x":{"r":[".data.state"],"s":"_0===\"disabled\""}}],"f":[{"t":4,"f":[{"t":7,"e":"option","a":{"value":[{"t":2,"r":".value"}]},"m":[{"t":4,"f":["disabled"],"n":50,"x":{"r":[".state"],"s":"_0===\"disabled\""}}],"f":[{"t":2,"r":".text"}]}],"n":52,"r":".data.options"}]}," ",{"t":7,"e":"div","a":{"class":"Select--icon"},"f":[{"t":7,"e":"svg","f":[{"t":7,"e":"use","a":{"xlink:href":[{"t":2,"x":{"r":[".icon"],"s":"_0||\"#icon-triangle\""}}]}}]}]}],"n":54,"x":{"r":[".id",".","@ractive",".value"],"s":"{id:_0||\"Select--\"+Date.now(),data:_1,link:_2.link(_3.replace(/^\\./,\"\"),\"__Select.\"+_3.replace(/\\./g,\"_\")),_value:_3.replace(/\\./g,\"_\")}"}}]}],"e":{}};

/***/ },
/* 48 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":7,"e":"span","a":{"class":["Text Text__",{"t":2,"x":{"r":[".type"],"s":"_0||\"text\""}}," Text__",{"t":2,"x":{"r":[".size"],"s":"_0||\"medium\""}}," Text__",{"t":2,"x":{"r":[".state"],"s":"_0||\"normal\""}}," ",{"t":4,"f":["Text__adaptive"],"n":50,"r":".adaptive"}," ",{"t":4,"f":["Text__has-units"],"n":50,"r":".units"}," ",{"t":2,"r":".className"}],"title":[{"t":2,"r":".title"}]},"f":[{"t":4,"f":[{"t":7,"e":"span","a":{"class":"Text--input-wrapper"},"f":[{"t":7,"e":"input","a":{"type":[{"t":2,"x":{"r":[".data.type"],"s":"_0||\"text\""}}],"class":"Text--input","id":[{"t":2,"r":".id"}],"value":[{"t":2,"rx":{"r":"~/__Text","m":[{"t":30,"n":"._value"}]}}],"placeholder":[{"t":2,"r":".placeholder"}],"title":[{"t":2,"r":".title"}]},"m":[{"t":4,"f":["disabled"],"n":50,"x":{"r":[".data.state"],"s":"_0===\"disabled\""}},{"t":4,"f":["required"],"n":50,"r":".data.required"},{"t":4,"f":["pattern=\"",{"t":2,"r":".data.pattern"},"\""],"n":50,"r":".data.pattern"}],"v":{"keydown":{"n":[{"t":2,"r":".data.keydown"}],"d":[{"t":2,"r":".data.keydownEvent"}]},"keyup":{"n":[{"t":2,"r":".data.keyup"}],"d":[{"t":2,"r":".data.keyupEvent"}]},"keypress":{"n":[{"t":2,"r":".data.keypress"}],"d":[{"t":2,"r":".data.keypressEvent"}]}}}," ",{"t":4,"f":[{"t":7,"e":"span","a":{"class":"Text--units-wrapper"},"f":[{"t":7,"e":"label","a":{"class":"Text--units","for":[{"t":2,"r":".id"}]},"f":[{"t":2,"r":".data.units"}]}]}],"n":50,"r":".data.units"}]}],"n":54,"x":{"r":[".id",".","@ractive",".value"],"s":"{id:_0||\"Text--\"+Date.now()+(Math.random()*1000000000).toFixed(),data:_1,link:_2.link(_3.replace(/^\\./,\"\"),\"__Text.\"+_3.replace(/\\./g,\"_\")),_value:_3.replace(/\\./g,\"_\")}"}}]}],"e":{}};

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {


	/**
	 * Module dependencies.
	 */

	var eio = __webpack_require__(109);
	var Socket = __webpack_require__(51);
	var Emitter = __webpack_require__(52);
	var parser = __webpack_require__(28);
	var on = __webpack_require__(50);
	var bind = __webpack_require__(37);
	var debug = __webpack_require__(7)('socket.io-client:manager');
	var indexOf = __webpack_require__(42);
	var Backoff = __webpack_require__(105);

	/**
	 * IE6+ hasOwnProperty
	 */

	var has = Object.prototype.hasOwnProperty;

	/**
	 * Module exports
	 */

	module.exports = Manager;

	/**
	 * `Manager` constructor.
	 *
	 * @param {String} engine instance or engine uri/opts
	 * @param {Object} options
	 * @api public
	 */

	function Manager(uri, opts){
	  if (!(this instanceof Manager)) return new Manager(uri, opts);
	  if (uri && ('object' == typeof uri)) {
	    opts = uri;
	    uri = undefined;
	  }
	  opts = opts || {};

	  opts.path = opts.path || '/socket.io';
	  this.nsps = {};
	  this.subs = [];
	  this.opts = opts;
	  this.reconnection(opts.reconnection !== false);
	  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
	  this.reconnectionDelay(opts.reconnectionDelay || 1000);
	  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
	  this.randomizationFactor(opts.randomizationFactor || 0.5);
	  this.backoff = new Backoff({
	    min: this.reconnectionDelay(),
	    max: this.reconnectionDelayMax(),
	    jitter: this.randomizationFactor()
	  });
	  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
	  this.readyState = 'closed';
	  this.uri = uri;
	  this.connecting = [];
	  this.lastPing = null;
	  this.encoding = false;
	  this.packetBuffer = [];
	  this.encoder = new parser.Encoder();
	  this.decoder = new parser.Decoder();
	  this.autoConnect = opts.autoConnect !== false;
	  if (this.autoConnect) this.open();
	}

	/**
	 * Propagate given event to sockets and emit on `this`
	 *
	 * @api private
	 */

	Manager.prototype.emitAll = function() {
	  this.emit.apply(this, arguments);
	  for (var nsp in this.nsps) {
	    if (has.call(this.nsps, nsp)) {
	      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
	    }
	  }
	};

	/**
	 * Update `socket.id` of all sockets
	 *
	 * @api private
	 */

	Manager.prototype.updateSocketIds = function(){
	  for (var nsp in this.nsps) {
	    if (has.call(this.nsps, nsp)) {
	      this.nsps[nsp].id = this.engine.id;
	    }
	  }
	};

	/**
	 * Mix in `Emitter`.
	 */

	Emitter(Manager.prototype);

	/**
	 * Sets the `reconnection` config.
	 *
	 * @param {Boolean} true/false if it should automatically reconnect
	 * @return {Manager} self or value
	 * @api public
	 */

	Manager.prototype.reconnection = function(v){
	  if (!arguments.length) return this._reconnection;
	  this._reconnection = !!v;
	  return this;
	};

	/**
	 * Sets the reconnection attempts config.
	 *
	 * @param {Number} max reconnection attempts before giving up
	 * @return {Manager} self or value
	 * @api public
	 */

	Manager.prototype.reconnectionAttempts = function(v){
	  if (!arguments.length) return this._reconnectionAttempts;
	  this._reconnectionAttempts = v;
	  return this;
	};

	/**
	 * Sets the delay between reconnections.
	 *
	 * @param {Number} delay
	 * @return {Manager} self or value
	 * @api public
	 */

	Manager.prototype.reconnectionDelay = function(v){
	  if (!arguments.length) return this._reconnectionDelay;
	  this._reconnectionDelay = v;
	  this.backoff && this.backoff.setMin(v);
	  return this;
	};

	Manager.prototype.randomizationFactor = function(v){
	  if (!arguments.length) return this._randomizationFactor;
	  this._randomizationFactor = v;
	  this.backoff && this.backoff.setJitter(v);
	  return this;
	};

	/**
	 * Sets the maximum delay between reconnections.
	 *
	 * @param {Number} delay
	 * @return {Manager} self or value
	 * @api public
	 */

	Manager.prototype.reconnectionDelayMax = function(v){
	  if (!arguments.length) return this._reconnectionDelayMax;
	  this._reconnectionDelayMax = v;
	  this.backoff && this.backoff.setMax(v);
	  return this;
	};

	/**
	 * Sets the connection timeout. `false` to disable
	 *
	 * @return {Manager} self or value
	 * @api public
	 */

	Manager.prototype.timeout = function(v){
	  if (!arguments.length) return this._timeout;
	  this._timeout = v;
	  return this;
	};

	/**
	 * Starts trying to reconnect if reconnection is enabled and we have not
	 * started reconnecting yet
	 *
	 * @api private
	 */

	Manager.prototype.maybeReconnectOnOpen = function() {
	  // Only try to reconnect if it's the first time we're connecting
	  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
	    // keeps reconnection from firing twice for the same reconnection loop
	    this.reconnect();
	  }
	};


	/**
	 * Sets the current transport `socket`.
	 *
	 * @param {Function} optional, callback
	 * @return {Manager} self
	 * @api public
	 */

	Manager.prototype.open =
	Manager.prototype.connect = function(fn){
	  debug('readyState %s', this.readyState);
	  if (~this.readyState.indexOf('open')) return this;

	  debug('opening %s', this.uri);
	  this.engine = eio(this.uri, this.opts);
	  var socket = this.engine;
	  var self = this;
	  this.readyState = 'opening';
	  this.skipReconnect = false;

	  // emit `open`
	  var openSub = on(socket, 'open', function() {
	    self.onopen();
	    fn && fn();
	  });

	  // emit `connect_error`
	  var errorSub = on(socket, 'error', function(data){
	    debug('connect_error');
	    self.cleanup();
	    self.readyState = 'closed';
	    self.emitAll('connect_error', data);
	    if (fn) {
	      var err = new Error('Connection error');
	      err.data = data;
	      fn(err);
	    } else {
	      // Only do this if there is no fn to handle the error
	      self.maybeReconnectOnOpen();
	    }
	  });

	  // emit `connect_timeout`
	  if (false !== this._timeout) {
	    var timeout = this._timeout;
	    debug('connect attempt will timeout after %d', timeout);

	    // set timer
	    var timer = setTimeout(function(){
	      debug('connect attempt timed out after %d', timeout);
	      openSub.destroy();
	      socket.close();
	      socket.emit('error', 'timeout');
	      self.emitAll('connect_timeout', timeout);
	    }, timeout);

	    this.subs.push({
	      destroy: function(){
	        clearTimeout(timer);
	      }
	    });
	  }

	  this.subs.push(openSub);
	  this.subs.push(errorSub);

	  return this;
	};

	/**
	 * Called upon transport open.
	 *
	 * @api private
	 */

	Manager.prototype.onopen = function(){
	  debug('open');

	  // clear old subs
	  this.cleanup();

	  // mark as open
	  this.readyState = 'open';
	  this.emit('open');

	  // add new subs
	  var socket = this.engine;
	  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
	  this.subs.push(on(socket, 'ping', bind(this, 'onping')));
	  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
	  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
	  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
	  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
	};

	/**
	 * Called upon a ping.
	 *
	 * @api private
	 */

	Manager.prototype.onping = function(){
	  this.lastPing = new Date;
	  this.emitAll('ping');
	};

	/**
	 * Called upon a packet.
	 *
	 * @api private
	 */

	Manager.prototype.onpong = function(){
	  this.emitAll('pong', new Date - this.lastPing);
	};

	/**
	 * Called with data.
	 *
	 * @api private
	 */

	Manager.prototype.ondata = function(data){
	  this.decoder.add(data);
	};

	/**
	 * Called when parser fully decodes a packet.
	 *
	 * @api private
	 */

	Manager.prototype.ondecoded = function(packet) {
	  this.emit('packet', packet);
	};

	/**
	 * Called upon socket error.
	 *
	 * @api private
	 */

	Manager.prototype.onerror = function(err){
	  debug('error', err);
	  this.emitAll('error', err);
	};

	/**
	 * Creates a new socket for the given `nsp`.
	 *
	 * @return {Socket}
	 * @api public
	 */

	Manager.prototype.socket = function(nsp){
	  var socket = this.nsps[nsp];
	  if (!socket) {
	    socket = new Socket(this, nsp);
	    this.nsps[nsp] = socket;
	    var self = this;
	    socket.on('connecting', onConnecting);
	    socket.on('connect', function(){
	      socket.id = self.engine.id;
	    });

	    if (this.autoConnect) {
	      // manually call here since connecting evnet is fired before listening
	      onConnecting();
	    }
	  }

	  function onConnecting() {
	    if (!~indexOf(self.connecting, socket)) {
	      self.connecting.push(socket);
	    }
	  }

	  return socket;
	};

	/**
	 * Called upon a socket close.
	 *
	 * @param {Socket} socket
	 */

	Manager.prototype.destroy = function(socket){
	  var index = indexOf(this.connecting, socket);
	  if (~index) this.connecting.splice(index, 1);
	  if (this.connecting.length) return;

	  this.close();
	};

	/**
	 * Writes a packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */

	Manager.prototype.packet = function(packet){
	  debug('writing packet %j', packet);
	  var self = this;

	  if (!self.encoding) {
	    // encode, then write to engine with result
	    self.encoding = true;
	    this.encoder.encode(packet, function(encodedPackets) {
	      for (var i = 0; i < encodedPackets.length; i++) {
	        self.engine.write(encodedPackets[i], packet.options);
	      }
	      self.encoding = false;
	      self.processPacketQueue();
	    });
	  } else { // add packet to the queue
	    self.packetBuffer.push(packet);
	  }
	};

	/**
	 * If packet buffer is non-empty, begins encoding the
	 * next packet in line.
	 *
	 * @api private
	 */

	Manager.prototype.processPacketQueue = function() {
	  if (this.packetBuffer.length > 0 && !this.encoding) {
	    var pack = this.packetBuffer.shift();
	    this.packet(pack);
	  }
	};

	/**
	 * Clean up transport subscriptions and packet buffer.
	 *
	 * @api private
	 */

	Manager.prototype.cleanup = function(){
	  debug('cleanup');

	  var sub;
	  while (sub = this.subs.shift()) sub.destroy();

	  this.packetBuffer = [];
	  this.encoding = false;
	  this.lastPing = null;

	  this.decoder.destroy();
	};

	/**
	 * Close the current socket.
	 *
	 * @api private
	 */

	Manager.prototype.close =
	Manager.prototype.disconnect = function(){
	  debug('disconnect');
	  this.skipReconnect = true;
	  this.reconnecting = false;
	  if ('opening' == this.readyState) {
	    // `onclose` will not fire because
	    // an open event never happened
	    this.cleanup();
	  }
	  this.backoff.reset();
	  this.readyState = 'closed';
	  if (this.engine) this.engine.close();
	};

	/**
	 * Called upon engine close.
	 *
	 * @api private
	 */

	Manager.prototype.onclose = function(reason){
	  debug('onclose');

	  this.cleanup();
	  this.backoff.reset();
	  this.readyState = 'closed';
	  this.emit('close', reason);

	  if (this._reconnection && !this.skipReconnect) {
	    this.reconnect();
	  }
	};

	/**
	 * Attempt a reconnection.
	 *
	 * @api private
	 */

	Manager.prototype.reconnect = function(){
	  if (this.reconnecting || this.skipReconnect) return this;

	  var self = this;

	  if (this.backoff.attempts >= this._reconnectionAttempts) {
	    debug('reconnect failed');
	    this.backoff.reset();
	    this.emitAll('reconnect_failed');
	    this.reconnecting = false;
	  } else {
	    var delay = this.backoff.duration();
	    debug('will wait %dms before reconnect attempt', delay);

	    this.reconnecting = true;
	    var timer = setTimeout(function(){
	      if (self.skipReconnect) return;

	      debug('attempting reconnect');
	      self.emitAll('reconnect_attempt', self.backoff.attempts);
	      self.emitAll('reconnecting', self.backoff.attempts);

	      // check again for the case socket closed in above events
	      if (self.skipReconnect) return;

	      self.open(function(err){
	        if (err) {
	          debug('reconnect attempt error');
	          self.reconnecting = false;
	          self.reconnect();
	          self.emitAll('reconnect_error', err.data);
	        } else {
	          debug('reconnect success');
	          self.onreconnect();
	        }
	      });
	    }, delay);

	    this.subs.push({
	      destroy: function(){
	        clearTimeout(timer);
	      }
	    });
	  }
	};

	/**
	 * Called upon successful reconnect.
	 *
	 * @api private
	 */

	Manager.prototype.onreconnect = function(){
	  var attempt = this.backoff.attempts;
	  this.reconnecting = false;
	  this.backoff.reset();
	  this.updateSocketIds();
	  this.emitAll('reconnect', attempt);
	};


/***/ },
/* 50 */
/***/ function(module, exports) {


	/**
	 * Module exports.
	 */

	module.exports = on;

	/**
	 * Helper for subscriptions.
	 *
	 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
	 * @param {String} event name
	 * @param {Function} callback
	 * @api public
	 */

	function on(obj, ev, fn) {
	  obj.on(ev, fn);
	  return {
	    destroy: function(){
	      obj.removeListener(ev, fn);
	    }
	  };
	}


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {


	/**
	 * Module dependencies.
	 */

	var parser = __webpack_require__(28);
	var Emitter = __webpack_require__(52);
	var toArray = __webpack_require__(203);
	var on = __webpack_require__(50);
	var bind = __webpack_require__(37);
	var debug = __webpack_require__(7)('socket.io-client:socket');
	var hasBin = __webpack_require__(120);

	/**
	 * Module exports.
	 */

	module.exports = exports = Socket;

	/**
	 * Internal events (blacklisted).
	 * These events can't be emitted by the user.
	 *
	 * @api private
	 */

	var events = {
	  connect: 1,
	  connect_error: 1,
	  connect_timeout: 1,
	  connecting: 1,
	  disconnect: 1,
	  error: 1,
	  reconnect: 1,
	  reconnect_attempt: 1,
	  reconnect_failed: 1,
	  reconnect_error: 1,
	  reconnecting: 1,
	  ping: 1,
	  pong: 1
	};

	/**
	 * Shortcut to `Emitter#emit`.
	 */

	var emit = Emitter.prototype.emit;

	/**
	 * `Socket` constructor.
	 *
	 * @api public
	 */

	function Socket(io, nsp){
	  this.io = io;
	  this.nsp = nsp;
	  this.json = this; // compat
	  this.ids = 0;
	  this.acks = {};
	  this.receiveBuffer = [];
	  this.sendBuffer = [];
	  this.connected = false;
	  this.disconnected = true;
	  if (this.io.autoConnect) this.open();
	}

	/**
	 * Mix in `Emitter`.
	 */

	Emitter(Socket.prototype);

	/**
	 * Subscribe to open, close and packet events
	 *
	 * @api private
	 */

	Socket.prototype.subEvents = function() {
	  if (this.subs) return;

	  var io = this.io;
	  this.subs = [
	    on(io, 'open', bind(this, 'onopen')),
	    on(io, 'packet', bind(this, 'onpacket')),
	    on(io, 'close', bind(this, 'onclose'))
	  ];
	};

	/**
	 * "Opens" the socket.
	 *
	 * @api public
	 */

	Socket.prototype.open =
	Socket.prototype.connect = function(){
	  if (this.connected) return this;

	  this.subEvents();
	  this.io.open(); // ensure open
	  if ('open' == this.io.readyState) this.onopen();
	  this.emit('connecting');
	  return this;
	};

	/**
	 * Sends a `message` event.
	 *
	 * @return {Socket} self
	 * @api public
	 */

	Socket.prototype.send = function(){
	  var args = toArray(arguments);
	  args.unshift('message');
	  this.emit.apply(this, args);
	  return this;
	};

	/**
	 * Override `emit`.
	 * If the event is in `events`, it's emitted normally.
	 *
	 * @param {String} event name
	 * @return {Socket} self
	 * @api public
	 */

	Socket.prototype.emit = function(ev){
	  if (events.hasOwnProperty(ev)) {
	    emit.apply(this, arguments);
	    return this;
	  }

	  var args = toArray(arguments);
	  var parserType = parser.EVENT; // default
	  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary
	  var packet = { type: parserType, data: args };

	  packet.options = {};
	  packet.options.compress = !this.flags || false !== this.flags.compress;

	  // event ack callback
	  if ('function' == typeof args[args.length - 1]) {
	    debug('emitting packet with ack id %d', this.ids);
	    this.acks[this.ids] = args.pop();
	    packet.id = this.ids++;
	  }

	  if (this.connected) {
	    this.packet(packet);
	  } else {
	    this.sendBuffer.push(packet);
	  }

	  delete this.flags;

	  return this;
	};

	/**
	 * Sends a packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */

	Socket.prototype.packet = function(packet){
	  packet.nsp = this.nsp;
	  this.io.packet(packet);
	};

	/**
	 * Called upon engine `open`.
	 *
	 * @api private
	 */

	Socket.prototype.onopen = function(){
	  debug('transport is open - connecting');

	  // write connect packet if necessary
	  if ('/' != this.nsp) {
	    this.packet({ type: parser.CONNECT });
	  }
	};

	/**
	 * Called upon engine `close`.
	 *
	 * @param {String} reason
	 * @api private
	 */

	Socket.prototype.onclose = function(reason){
	  debug('close (%s)', reason);
	  this.connected = false;
	  this.disconnected = true;
	  delete this.id;
	  this.emit('disconnect', reason);
	};

	/**
	 * Called with socket packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */

	Socket.prototype.onpacket = function(packet){
	  if (packet.nsp != this.nsp) return;

	  switch (packet.type) {
	    case parser.CONNECT:
	      this.onconnect();
	      break;

	    case parser.EVENT:
	      this.onevent(packet);
	      break;

	    case parser.BINARY_EVENT:
	      this.onevent(packet);
	      break;

	    case parser.ACK:
	      this.onack(packet);
	      break;

	    case parser.BINARY_ACK:
	      this.onack(packet);
	      break;

	    case parser.DISCONNECT:
	      this.ondisconnect();
	      break;

	    case parser.ERROR:
	      this.emit('error', packet.data);
	      break;
	  }
	};

	/**
	 * Called upon a server event.
	 *
	 * @param {Object} packet
	 * @api private
	 */

	Socket.prototype.onevent = function(packet){
	  var args = packet.data || [];
	  debug('emitting event %j', args);

	  if (null != packet.id) {
	    debug('attaching ack callback to event');
	    args.push(this.ack(packet.id));
	  }

	  if (this.connected) {
	    emit.apply(this, args);
	  } else {
	    this.receiveBuffer.push(args);
	  }
	};

	/**
	 * Produces an ack callback to emit with an event.
	 *
	 * @api private
	 */

	Socket.prototype.ack = function(id){
	  var self = this;
	  var sent = false;
	  return function(){
	    // prevent double callbacks
	    if (sent) return;
	    sent = true;
	    var args = toArray(arguments);
	    debug('sending ack %j', args);

	    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
	    self.packet({
	      type: type,
	      id: id,
	      data: args
	    });
	  };
	};

	/**
	 * Called upon a server acknowlegement.
	 *
	 * @param {Object} packet
	 * @api private
	 */

	Socket.prototype.onack = function(packet){
	  var ack = this.acks[packet.id];
	  if ('function' == typeof ack) {
	    debug('calling ack %s with %j', packet.id, packet.data);
	    ack.apply(this, packet.data);
	    delete this.acks[packet.id];
	  } else {
	    debug('bad ack %s', packet.id);
	  }
	};

	/**
	 * Called upon server connect.
	 *
	 * @api private
	 */

	Socket.prototype.onconnect = function(){
	  this.connected = true;
	  this.disconnected = false;
	  this.emit('connect');
	  this.emitBuffered();
	};

	/**
	 * Emit buffered events (received and emitted).
	 *
	 * @api private
	 */

	Socket.prototype.emitBuffered = function(){
	  var i;
	  for (i = 0; i < this.receiveBuffer.length; i++) {
	    emit.apply(this, this.receiveBuffer[i]);
	  }
	  this.receiveBuffer = [];

	  for (i = 0; i < this.sendBuffer.length; i++) {
	    this.packet(this.sendBuffer[i]);
	  }
	  this.sendBuffer = [];
	};

	/**
	 * Called upon server disconnect.
	 *
	 * @api private
	 */

	Socket.prototype.ondisconnect = function(){
	  debug('server disconnect (%s)', this.nsp);
	  this.destroy();
	  this.onclose('io server disconnect');
	};

	/**
	 * Called upon forced client/server side disconnections,
	 * this method ensures the manager stops tracking us and
	 * that reconnections don't get triggered for this.
	 *
	 * @api private.
	 */

	Socket.prototype.destroy = function(){
	  if (this.subs) {
	    // clean subscriptions to avoid reconnections
	    for (var i = 0; i < this.subs.length; i++) {
	      this.subs[i].destroy();
	    }
	    this.subs = null;
	  }

	  this.io.destroy(this);
	};

	/**
	 * Disconnects the socket manually.
	 *
	 * @return {Socket} self
	 * @api public
	 */

	Socket.prototype.close =
	Socket.prototype.disconnect = function(){
	  if (this.connected) {
	    debug('performing disconnect (%s)', this.nsp);
	    this.packet({ type: parser.DISCONNECT });
	  }

	  // remove socket from pool
	  this.destroy();

	  if (this.connected) {
	    // fire events
	    this.onclose('io client disconnect');
	  }
	  return this;
	};

	/**
	 * Sets the compress flag.
	 *
	 * @param {Boolean} if `true`, compresses the sending data
	 * @return {Socket} self
	 * @api public
	 */

	Socket.prototype.compress = function(compress){
	  this.flags = this.flags || {};
	  this.flags.compress = compress;
	  return this;
	};


/***/ },
/* 52 */
/***/ function(module, exports) {


	/**
	 * Expose `Emitter`.
	 */

	module.exports = Emitter;

	/**
	 * Initialize a new `Emitter`.
	 *
	 * @api public
	 */

	function Emitter(obj) {
	  if (obj) return mixin(obj);
	};

	/**
	 * Mixin the emitter properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */

	function mixin(obj) {
	  for (var key in Emitter.prototype) {
	    obj[key] = Emitter.prototype[key];
	  }
	  return obj;
	}

	/**
	 * Listen on the given `event` with `fn`.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.on =
	Emitter.prototype.addEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
	    .push(fn);
	  return this;
	};

	/**
	 * Adds an `event` listener that will be invoked a single
	 * time then automatically removed.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.once = function(event, fn){
	  function on() {
	    this.off(event, on);
	    fn.apply(this, arguments);
	  }

	  on.fn = fn;
	  this.on(event, on);
	  return this;
	};

	/**
	 * Remove the given callback for `event` or all
	 * registered callbacks.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.off =
	Emitter.prototype.removeListener =
	Emitter.prototype.removeAllListeners =
	Emitter.prototype.removeEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};

	  // all
	  if (0 == arguments.length) {
	    this._callbacks = {};
	    return this;
	  }

	  // specific event
	  var callbacks = this._callbacks['$' + event];
	  if (!callbacks) return this;

	  // remove all handlers
	  if (1 == arguments.length) {
	    delete this._callbacks['$' + event];
	    return this;
	  }

	  // remove specific handler
	  var cb;
	  for (var i = 0; i < callbacks.length; i++) {
	    cb = callbacks[i];
	    if (cb === fn || cb.fn === fn) {
	      callbacks.splice(i, 1);
	      break;
	    }
	  }
	  return this;
	};

	/**
	 * Emit `event` with the given args.
	 *
	 * @param {String} event
	 * @param {Mixed} ...
	 * @return {Emitter}
	 */

	Emitter.prototype.emit = function(event){
	  this._callbacks = this._callbacks || {};
	  var args = [].slice.call(arguments, 1)
	    , callbacks = this._callbacks['$' + event];

	  if (callbacks) {
	    callbacks = callbacks.slice(0);
	    for (var i = 0, len = callbacks.length; i < len; ++i) {
	      callbacks[i].apply(this, args);
	    }
	  }

	  return this;
	};

	/**
	 * Return array of callbacks for `event`.
	 *
	 * @param {String} event
	 * @return {Array}
	 * @api public
	 */

	Emitter.prototype.listeners = function(event){
	  this._callbacks = this._callbacks || {};
	  return this._callbacks['$' + event] || [];
	};

	/**
	 * Check if this emitter has `event` handlers.
	 *
	 * @param {String} event
	 * @return {Boolean}
	 * @api public
	 */

	Emitter.prototype.hasListeners = function(event){
	  return !! this.listeners(event).length;
	};


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	module.exports = isBuf;

	/**
	 * Returns true if obj is a buffer or an arraybuffer.
	 *
	 * @api private
	 */

	function isBuf(obj) {
	  return (global.Buffer && global.Buffer.isBuffer(obj)) ||
	         (global.ArrayBuffer && obj instanceof ArrayBuffer);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 54 */
/***/ function(module, exports) {

	"use strict";
	'use strict';

	var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
	  , length = 64
	  , map = {}
	  , seed = 0
	  , i = 0
	  , prev;

	/**
	 * Return a string representing the specified number.
	 *
	 * @param {Number} num The number to convert.
	 * @returns {String} The string representation of the number.
	 * @api public
	 */
	function encode(num) {
	  var encoded = '';

	  do {
	    encoded = alphabet[num % length] + encoded;
	    num = Math.floor(num / length);
	  } while (num > 0);

	  return encoded;
	}

	/**
	 * Return the integer value specified by the given string.
	 *
	 * @param {String} str The string to convert.
	 * @returns {Number} The integer value represented by the string.
	 * @api public
	 */
	function decode(str) {
	  var decoded = 0;

	  for (i = 0; i < str.length; i++) {
	    decoded = decoded * length + map[str.charAt(i)];
	  }

	  return decoded;
	}

	/**
	 * Yeast: A tiny growing id generator.
	 *
	 * @returns {String} A unique id.
	 * @api public
	 */
	function yeast() {
	  var now = encode(+new Date());

	  if (now !== prev) return seed = 0, prev = now;
	  return now +'.'+ encode(seed++);
	}

	//
	// Map each character to its index.
	//
	for (; i < length; i++) map[alphabet[i]] = i;

	//
	// Expose the `yeast`, `encode` and `decode` functions.
	//
	yeast.encode = encode;
	yeast.decode = decode;
	module.exports = yeast;


/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/*eslint-env browser*/
	/*global __resourceQuery*/

	var options = {
	  path: "/__webpack_hmr",
	  timeout: 20 * 1000,
	  overlay: true,
	  reload: false,
	  log: true,
	  warn: true
	};
	if (false) {
	  var querystring = require('querystring');
	  var overrides = querystring.parse(__resourceQuery.slice(1));
	  if (overrides.path) options.path = overrides.path;
	  if (overrides.timeout) options.timeout = overrides.timeout;
	  if (overrides.overlay) options.overlay = overrides.overlay !== 'false';
	  if (overrides.reload) options.reload = overrides.reload !== 'false';
	  if (overrides.noInfo && overrides.noInfo !== 'false') {
	    options.log = false;
	  }
	  if (overrides.quiet && overrides.quiet !== 'false') {
	    options.log = false;
	    options.warn = false;
	  }
	}

	if (typeof window === 'undefined') {
	  // do nothing
	} else if (typeof window.EventSource === 'undefined') {
	  console.warn(
	    "webpack-hot-middleware's client requires EventSource to work. " +
	    "You should include a polyfill if you want to support this browser: " +
	    "https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events#Tools"
	  );
	} else {
	  connect(window.EventSource);
	}

	function connect(EventSource) {
	  var source = new EventSource(options.path);
	  var lastActivity = new Date();

	  source.onopen = handleOnline;
	  source.onmessage = handleMessage;
	  source.onerror = handleDisconnect;

	  var timer = setInterval(function() {
	    if ((new Date() - lastActivity) > options.timeout) {
	      handleDisconnect();
	    }
	  }, options.timeout / 2);

	  function handleOnline() {
	    if (options.log) console.log("[HMR] connected");
	    lastActivity = new Date();
	  }

	  function handleMessage(event) {
	    lastActivity = new Date();
	    if (event.data == "\uD83D\uDC93") {
	      return;
	    }
	    try {
	      processMessage(JSON.parse(event.data));
	    } catch (ex) {
	      if (options.warn) {
	        console.warn("Invalid HMR message: " + event.data + "\n" + ex);
	      }
	    }
	  }

	  function handleDisconnect() {
	    clearInterval(timer);
	    source.close();
	    setTimeout(function() { connect(EventSource); }, options.timeout);
	  }

	}

	var strip = __webpack_require__(202);

	var overlay;
	if (typeof document !== 'undefined' && options.overlay) {
	  overlay = __webpack_require__(205);
	}

	function problems(type, obj) {
	  if (options.warn) {
	    console.warn("[HMR] bundle has " + type + ":");
	    obj[type].forEach(function(msg) {
	      console.warn("[HMR] " + strip(msg));
	    });
	  }
	  if (overlay && type !== 'warnings') overlay.showProblems(type, obj[type]);
	}

	function success() {
	  if (overlay) overlay.clear();
	}

	var processUpdate = __webpack_require__(206);

	var customHandler;
	function processMessage(obj) {
	  if (obj.action == "building") {
	    if (options.log) console.log("[HMR] bundle rebuilding");
	  } else if (obj.action == "built") {
	    if (options.log) console.log("[HMR] bundle " + (obj.name ? obj.name + " " : "") + "rebuilt in " + obj.time + "ms");
	    if (obj.errors.length > 0) {
	      problems('errors', obj);
	    } else {
	      if (obj.warnings.length > 0) problems('warnings', obj);
	      success();

	      processUpdate(obj.hash, obj.modules, options);
	    }
	  } else if (customHandler) {
	    customHandler(obj);
	  }
	}

	if (module) {
	  module.exports = {
	    subscribe: function subscribe(handler) {
	      customHandler = handler;
	    },
	    useCustomOverlay: function useCustomOverlay(customOverlay) {
	      overlay = customOverlay;
	    }
	  };
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(19)(module)))

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	/*globals window __webpack_hash__ */
	if(true) {
		var lastHash;
		var upToDate = function upToDate() {
			return lastHash.indexOf(__webpack_require__.h()) >= 0;
		};
		var check = function check() {
			module.hot.check(true).then(function(updatedModules) {
				if(!updatedModules) {
					console.warn("[HMR] Cannot find update. Need to do a full reload!");
					console.warn("[HMR] (Probably because of restarting the webpack-dev-server)");
					window.location.reload();
					return;
				}

				if(!upToDate()) {
					check();
				}

				__webpack_require__(209)(updatedModules, updatedModules);

				if(upToDate()) {
					console.log("[HMR] App is up to date.");
				}

			}).catch(function(err) {
				if(module.hot.status() in {
						abort: 1,
						fail: 1
					}) {
					console.warn("[HMR] Cannot apply update. Need to do a full reload!");
					console.warn("[HMR] " + err.stack || err.message);
					window.location.reload();
				} else {
					console.warn("[HMR] Update failed: " + err.stack || err.message);
				}
			});
		};
		var hotEmitter = __webpack_require__(208);
		hotEmitter.on("webpackHotUpdate", function(currentHash) {
			lastHash = currentHash;
			if(!upToDate() && module.hot.status() === "idle") {
				console.log("[HMR] Checking for updates on the server...");
				check();
			}
		});
		console.log("[HMR] Waiting for update signal from WDS...");
	} else {
		throw new Error("[HMR] Hot Module Replacement is disabled.");
	}


/***/ },
/* 57 */
/***/ function(module, exports) {

	(function ($) {
	    var START_EVENT = 'mousedown touchstart MSPointerDown pointerdown',
	        END_EVENT = 'mouseup touchend MSPointerUp pointerup',
	        MOVE_EVENT = 'mousemove touchmove MSPointerMove pointermove scroll';

	    function translate(el, x, y) {
	        vendorify('transform', el, 'translate(' + x + 'px, ' + y + 'px)')
	    }

	    function transition(el, val) {
	        vendorify('transition', el, val)
	    }

	    function getTouchPageX(e) {
	        e = e.originalEvent || e
	        return window.event && window.event.changedTouches && event.changedTouches[0].pageX || e.pageX
	    }

	    function getTouchPageY(e) {
	        e = e.originalEvent || e
	        return window.event && window.event.changedTouches && event.changedTouches[0].pageY || e.pageY
	    }

	    function vendorify(property, el, val) {
	        property = property.toLowerCase()
	        var titleCased = property.charAt(0).toUpperCase() + property.substr(1)
	        var vendorPrefixes = ['webkit', 'Moz', 'ms', 'O']
	        var properties = vendorPrefixes.map(function (prefix) {
	            return prefix + titleCased
	        }).concat('transform')
	        for (var i = 0, len = properties.length; i < len; ++i) {
	            if (properties[i] in el.style) {
	                if (val !== undefined) el.style[properties[i]] = val
	                else return el.style[properties[i]]
	                break
	            }
	        }
	    }

	    var eventProperties = [
	        'altKey', 'bubbles', 'button', 'cancelable', 'charCode', 'clientX',
	        'clientY', 'ctrlKey', 'currentTarget', 'data', 'detail', 'eventPhase',
	        'metaKey', 'offsetX', 'offsetY', 'originalTarget', 'pageX', 'pageY',
	        'relatedTarget', 'screenX', 'screenY', 'shiftKey', 'target', 'view',
	        'which'
	    ];

	    function trigger(el, name, originalEvent, arg) {
	        if (!el[0]) return

	        originalEvent = originalEvent.originalEvent || originalEvent
	        var props = {}
	        eventProperties.forEach(function (prop) {
	            props[prop] = originalEvent[prop]
	        })
	        props.currentTarget = props.target = el[0]

	        var win = (el[0].ownerDocument.defaultView || el[0].ownerDocument.parentWindow)

	        var e = win.$.Event(name, props)

	        win.$(el[0]).trigger(e, arg)
	        return e
	    }

	    var nextId = 0
	    var Dragging = function () {
	        this.eventHandler = $('<div />')
	        this.parent = this.el = this.handle = this.fixedX = this.fixedY = null;
	        this.origin = {
	            x: 0,
	            y: 0,
	            transition: null,
	            translate: null,
	            offset: {
	                x: 0,
	                y: 0
	            }
	        }
	        this.lastEntered = this.currentTarget = null
	        this.lastX = this.lastY = this.lastDirection = null
	        this.originalCss = {}
	        this.windows = [window]

	        var placeholder
	        Object.defineProperty(this, 'placeholder', {
	            get: function () {
	                return placeholder
	            },
	            set: function (val) {
	                if (placeholder === val) return
	                if (placeholder) placeholder.remove()
	                placeholder = val
	            }
	        })
	    }

	    Dragging.prototype.on = function () {
	        this.eventHandler.on.apply(this.eventHandler, Array.prototype.slice.call(arguments))
	        return this
	    }

	    Dragging.prototype.off = function () {
	        this.eventHandler.off.apply(this.eventHandler, Array.prototype.slice.call(arguments))
	        return this
	    }

	    Dragging.prototype.start = function (parent, el, e, handle) {
	        this.parent = parent
	        this.el = el
	        this.handle = handle
	        var el = this.handle || this.el

	        var lastOrigin = el.data("draggingOrigin");
	        if (lastOrigin) {
	            this.el.removeClass(this.parent.opts.stopClass);
	            transition(this.el[0], lastOrigin.transition || '');
	        };

	        this.origin.x = getTouchPageX(e)
	        this.origin.y = getTouchPageY(e)
	        this.origin.transform = vendorify('transform', this.el[0])
	        this.origin.transition = vendorify('transition', this.el[0])
	        var rect = this.el[0].getBoundingClientRect()
	        this.origin.offset.x = rect.left + (window.scrollX || window.pageXOffset) - this.origin.x
	        this.origin.offset.y = rect.top + (window.scrollY || window.pageYOffset) - this.origin.y
	        this.origin.scrollX = (window.scrollX || window.pageXOffset)
	        this.origin.scrollY = (window.scrollY || window.pageYOffset)
	            // the draged element is going to stick right under the cursor
	            // setting the css property `pointer-events` to `none` will let
	            // the pointer events fire on the elements underneath the helper
	        el[0].style.pointerEvents = 'none'
	        this.windows.forEach(function (win) {
	            $(win).on(MOVE_EVENT, $.proxy(this.move, this))
	            $(win).on(END_EVENT, $.proxy(this.stop, this))
	        }, this)
	        transition(el[0], '')
	        trigger(this.eventHandler, 'dragging:start', e)
	        return this.el
	    }

	    Dragging.prototype.hasParent = function (el, parent) {

	        if (!el || !parent) {

	            return false;
	        }

	        if (el.parentNode === parent) {

	            return true;
	        }

	        return Dragging.prototype.hasParent.call(this, el.parentNode, parent);

	    };

	    Dragging.prototype.stop = function (e) {
	        var dropEvent = null
	        var revert = true

	        if (this.last || this.mouseFromBottom < 0 || this.mouseFromTop < 0 || this.mouseFromLeft < 0 || this.mouseFromRight < 0) {
	            var last = this.last
	            this.last = null

	            if (this.parent instanceof Sortable && !this.hasParent(last, this.parent.el)) {

	                last = this.placeholder;
	            }

	            if (last) {
	                dropEvent = trigger($(last), 'dragging:drop', e)
	                revert = !dropEvent.isDefaultPrevented()
	            }
	        }

	        if (!this.el) {
	            return
	        }

	        for (var prop in this.originalCss) {
	            this.el.css(prop, this.originalCss[prop])
	            delete this.originalCss[prop]
	        }

	        trigger(this.eventHandler, 'dragging:stop', e, this.el)
	        if (!this.handle) {
	            this.adjustPlacement(e)
	        }
	        this.placeholder = null

	        var el = this.el
	        if (this.handle) {
	            this.handle.remove()
	        }

	        var opts = this.parent.opts;

	        opts.stopClass && el.addClass(opts.stopClass);

	        requestAnimationFrame(function (el, origin) {

	            transition(el[0], opts.transition ? opts.transition : 'all 0.35s ease-out 0s')
	            vendorify('transform', el[0], origin.transform || '')

	            el.data("draggingOrigin", origin);

	            var tDuration = el.css("transition-duration") || "0";

	            setTimeout(function () {

	                transition(el[0], origin.transition || '');

	                opts.stopClass && el.removeClass(opts.stopClass);
	                el.data("draggingOrigin", null);

	            }, tDuration.match(/ms$/) ? parseFloat(tDuration) : parseFloat(tDuration) * 1000);

	            el[0].style.pointerEvents = ''

	        }.bind(null, el, this.origin))

	        this.windows.forEach(function (win) {
	            $(win).off(MOVE_EVENT, this.move)
	            $(win).off(END_EVENT, this.stop)
	        }, this)
	        this.parent = this.el = this.handle = this.fixedX = this.fixedY = null
	        this.scrollBottomActivated = this.scrollTopActivated = false;
	    }

	    Dragging.prototype.getOver = function ($overs, counter) {

	        counter = counter || 0;

	        if (counter >= $overs.length) return null;

	        var closestItem = $overs.eq(counter).closest(this.parent.opts.items || this.parent.opts.connectWith)[0];

	        if (closestItem && closestItem !== this.el[0]) {

	            return $overs.get(counter);
	        }

	        return this.getOver($overs, ++counter);
	    };

	    Dragging.prototype.move = function (e) {
	        if (!this.el) return

	        var doc = this.el[0].ownerDocument
	        var win = doc.defaultView || doc.parentWindow

	        if (e.type !== 'scroll') {
	            var pageX = getTouchPageX(e)
	            var pageY = getTouchPageY(e)

	            if (e.view !== win && e.view.frameElement) {
	                pageX += e.view.frameElement.offsetLeft
	                pageY += e.view.frameElement.offsetTop
	            }

	            var clientX = e.clientX || (e.originalEvent && e.originalEvent.clientX) || window.event && window.event.touches && window.event.touches[0].clientX || 0,
	                clientY = e.clientY || (e.originalEvent && e.originalEvent.clientY) || window.event && window.event.touches && window.event.touches[0].clientY || 0

	            var doc = this.el[0].ownerDocument
	            var over = null;
	            if (!isOldIE) {
	                over = e.view.document.elementFromPoint(clientX, clientY)
	            } else {
	                try {
	                    over = e.view.document.msElementsFromPoint(clientX, clientY);
	                    over = over && this.getOver($(over));
	                } catch (e) {
	                    (this.handle || this.el).css("display", "none");
	                    over = ((e && e.view && e.view.document) || document).elementFromPoint(clientX, clientY);
	                    (this.handle || this.el).css("display", "");
	                }
	            }

	            var deltaX = this.lastX - pageX
	            var deltaY = this.lastY - pageY
	            var direction = !this.parent.opts.onlyXDir && deltaY > 0 && 'up' ||
	                !this.parent.opts.onlyXDir && deltaY < 0 && 'down' ||
	                !this.parent.opts.onlyYDir && deltaX > 0 && 'up' ||
	                !this.parent.opts.onlyYDir && deltaX < 0 && 'down' ||
	                this.lastDirection

	            if (!dragging.currentTarget) {
	                this.setCurrent(over)
	            }

	            trigger($(this.currentTarget), 'dragging:move', e, {
	                item: dragging.el
	            }, direction);

	            if (this.currentTarget) {

	                if (over !== this.last && this.lastEntered !== this.currentTarget) {

	                    trigger($(this.lastEntered), 'dragging:leave', e, direction)
	                    trigger($(this.currentTarget), 'dragging:enter', e, direction)
	                    this.lastEntered = this.currentTarget

	                } else if (direction !== this.lastDirection) {

	                    trigger($(this.currentTarget), 'dragging:diverted', e, direction)
	                }
	            }

	            this.last = over
	            this.currentTarget = null
	            this.lastDirection = direction
	            this.lastX = pageX
	            this.lastY = pageY
	            this.origin.scrollX = (window.scrollX || window.pageXOffset)
	            this.origin.scrollY = (window.scrollY || window.pageYOffset)

	        } else {
	            var pageX = this.lastX + ((window.scrollX || window.pageXOffset) - this.origin.scrollX),
	                pageY = this.lastY + ((window.scrollY || window.pageYOffset) - this.origin.scrollY)

	        }

	        // border scrolling only for root window
	        //        if (e.view !== win && e.view && e.view.frameElement) {
	        if (!(e.view && e.view.frameElement)) {

	            var bottom = (pageY - (window.scrollY || window.pageYOffset) - window.innerHeight) * -1
	            var right = (pageX - (window.scrollX || window.pageXOffset) - window.innerWidth) * -1
	            var bottomReached = document.documentElement.scrollHeight < (window.scrollY || window.pageYOffset) + window.innerHeight
	            var top = (pageY - (window.scrollY || window.pageYOffset))
	            var left = (pageX - (window.scrollX || window.pageXOffset))
	            var topReached = (window.scrollY || window.pageYOffset) <= 0

	            this.activationArea = e.type === "touchmove" ? 100 : 50;
	            this.mouseFromBottom = bottom;
	            this.mouseFromTop = top;
	            this.mouseFromLeft = left;
	            this.mouseFromRight = right;

	            if ((bottom > this.activationArea || bottomReached) && this.scrollBottomActivated) {

	                this.scrollBottomActivated = false;
	            }

	            if ((top > this.activationArea || topReached) && this.scrollTopActivated) {

	                this.scrollTopActivated = false;
	            }

	            if (bottom <= this.activationArea && !bottomReached && !this.scrollBottomActivated) {

	                this.scrollDirection = 1;
	                this.scrollTopActivated = false;
	                this.scrollBottomActivated = true;

	                requestAnimationFrame(this.scrollTo.bind(this));
	            }

	            if (top <= this.activationArea && !topReached && !this.scrollTopActivated) {

	                this.scrollDirection = -1;
	                this.scrollTopActivated = true;
	                this.scrollBottomActivated = false;

	                requestAnimationFrame(this.scrollTo.bind(this));
	            }
	        }

	        var deltaX = pageX - this.origin.x,
	            deltaY = pageY - this.origin.y
	        var el = this.handle || this.el

	        translate(el[0], this.parent.opts.fixedX ? this.fixedX : deltaX, this.parent.opts.fixedY ? this.fixedY : deltaY)
	    }

	    Dragging.prototype.scrollTo = function () {

	        var amount = 0;

	        if (this.scrollDirection === 1) {

	            amount = Math.ceil(Math.max(0, this.activationArea - Math.max(0, this.mouseFromBottom)) / 12);

	        } else {

	            amount = Math.ceil(Math.max(0, this.activationArea - Math.max(0, this.mouseFromTop)) / 12);
	        }

	        if (this.activationArea > 50) {

	            amount = amount / 2;
	        }

	        amount = amount * amount;

	        window.scrollBy(0, amount * this.scrollDirection);

	        if (this.scrollBottomActivated || this.scrollTopActivated) {

	            requestAnimationFrame(this.scrollTo.bind(this));
	        }
	    };

	    Dragging.prototype.setCurrent = function (target) {
	        this.currentTarget = target
	    }

	    Dragging.prototype.css = function (prop, val) {
	        if (!this.el) return
	        this.originalCss[prop] = this.el.css(prop)
	        this.el.css(prop, val)
	    }

	    Dragging.prototype.adjustPlacement = function (e) {
	        var el = this.handle && this.handle[0] || this.el[0]
	        translate(el, 0, 0)

	        var rect = el.getBoundingClientRect()
	        this.origin.x = rect.left + (window.scrollX || window.pageXOffset) - this.origin.offset.x
	        this.origin.y = rect.top + (window.scrollY || window.pageYOffset) - this.origin.offset.y
	        var pageX = getTouchPageX(e) || this.lastX,
	            pageY = getTouchPageY(e) || this.lastY,
	            deltaX = pageX - this.origin.x,
	            deltaY = pageY - this.origin.y;

	        this.lastX = pageX
	        this.lastY = pageY
	        this.origin.scrollX = (window.scrollX || window.pageXOffset)
	        this.origin.scrollY = (window.scrollY || window.pageYOffset)

	        this.fixedX = this.fixedX !== null ? this.fixedX : deltaX;
	        this.fixedY = this.fixedY !== null ? this.fixedY : deltaY;

	        translate(el, this.parent.opts.fixedX ? this.fixedX : deltaX, this.parent.opts.fixedY ? this.fixedY : deltaY)
	    }

	    var dragging
	    try {
	        if (parent.$ && parent.$.dragging) {
	            dragging = parent.$.dragging
	            dragging.windows.push(window)
	        }
	    } catch (e) {}

	    dragging = $.dragging = dragging || new Dragging()

	    // from https://github.com/rkusa/selector-observer
	    var MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver

	    function matches(el, selector) {
	        var fn = el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector
	        return fn ? fn.call(el, selector) : false
	    }

	    function toArr(nodeList) {
	        return Array.prototype.slice.call(nodeList)
	    }

	    // polyfill for IE < 11
	    var isOldIE = false
	    if (typeof MutationObserver === 'undefined') {
	        MutationObserver = function (callback) {
	            this.targets = []
	            this.onAdded = function (e) {
	                callback([{
	                    addedNodes: [e.target],
	                    removedNodes: []
	                }])
	            }
	            this.onRemoved = function (e) {
	                callback([{
	                    addedNodes: [],
	                    removedNodes: [e.target]
	                }])
	            }
	        }

	        MutationObserver.prototype.observe = function (target) {
	            target.addEventListener('DOMNodeInserted', this.onAdded)
	            target.addEventListener('DOMNodeRemoved', this.onRemoved)
	            this.targets.push(target)
	        }

	        MutationObserver.prototype.disconnect = function () {
	            var target
	            while (target = this.targets.shift()) {
	                target.removeEventListener('DOMNodeInserted', this.onAdded)
	                target.removeEventListener('DOMNodeRemoved', this.onRemoved)
	            }
	        }

	        //        isOldIE = !!~navigator.appName.indexOf('Internet Explorer')
	        isOldIE = navigator.userAgent.match(/MSIE ([0-9]{1,}[\.0-9]{0,})/);
	        if (isOldIE) {
	            isOldIE = parseFloat(isOldIE[1]) < 11;
	        }
	    }

	    var SelectorObserver = function (targets, selector, onAdded, onRemoved) {
	        var self = this
	        this.targets = targets instanceof NodeList ? Array.prototype.slice.call(targets) : [targets]

	        // support selectors starting with the childs only selector `>`
	        var childsOnly = selector[0] === '>'
	        var search = childsOnly ? selector.substr(1) : selector
	        var initialized = false

	        function query(nodes, deep) {
	            var result = []

	            toArr(nodes).forEach(function (node) {
	                //ignore non-element nodes
	                if (node.nodeType !== 1) return;

	                // if looking for childs only, the node's parentNode
	                // should be one of our targets
	                if (childsOnly && self.targets.indexOf(node.parentNode) === -1) {
	                    return
	                }

	                // test if the node itself matches the selector
	                if (matches(node, search)) {
	                    result.push(node)
	                }

	                if (childsOnly || !deep) {
	                    return
	                }

	                toArr(node.querySelectorAll(selector)).forEach(function (node) {
	                    result.push(node)
	                })
	            })

	            return result
	        }

	        function apply(nodes, deep, callback) {
	            if (!callback) {
	                return
	            }

	            // flatten
	            query(nodes, deep)
	                // filter unique nodes
	                .filter(function (node, i, self) {
	                    return self.indexOf(node) === i
	                })
	                // execute callback
	                .forEach(function (node) {
	                    callback.call(node)
	                })
	        }

	        var timeout = null
	        var addedNodes = []
	        var removedNodes = []

	        function handle() {
	            self.disconnect()

	            // filter moved elements (removed and re-added)
	            for (var i = 0, len = removedNodes.length; i < len; ++i) {
	                var index = addedNodes.indexOf(removedNodes[i])
	                if (index > -1) {
	                    addedNodes.splice(index, 1)
	                    removedNodes.splice(i--, 1)
	                }
	            }

	            //                ↓ IE workarounds ...
	            apply(addedNodes, !(initialized && isOldIE), onAdded)
	            apply(removedNodes, true, onRemoved)

	            addedNodes.length = 0
	            removedNodes.length = 0

	            self.observe()
	        }

	        this.observer = new MutationObserver(function (mutations) {
	            mutations.forEach(function (mutation) {
	                addedNodes.push.apply(addedNodes, mutation.addedNodes)
	                removedNodes.push.apply(removedNodes, mutation.removedNodes)
	            })

	            // IE < 10 fix: wait a cycle to gather all mutations
	            if (timeout) {
	                clearTimeout(timeout)
	            }
	            timeout = setTimeout(handle)
	        })

	        // call onAdded for existing elements
	        if (onAdded) {
	            this.targets.forEach(function (target) {
	                apply(target.children, true, onAdded)
	            })
	        }

	        initialized = true

	        this.observe()
	    }

	    SelectorObserver.prototype.disconnect = function () {
	        this.observer.disconnect()
	    }

	    SelectorObserver.prototype.observe = function () {
	        var self = this
	        this.targets.forEach(function (target) {
	            self.observer.observe(target, {
	                childList: true,
	                subtree: true
	            })
	        })
	    }

	    var Draggable = function (element, opts) {
	        this.id = nextId++
	            this.el = $(element)
	        this.opts = opts
	        this.cancel = opts.handle !== false
	    }

	    Draggable.prototype.create = function () {
	        this.el
	            .on(START_EVENT, $.proxy(this.start, this))
	            .css('touch-action', 'double-tap-zoom')
	            .css('-ms-touch-action', 'double-tap-zoom')

	        dragging.on('dragging:stop', $.proxy(this.reset, this))

	        var self = this
	        setTimeout(function () {
	            self.el.trigger('draggable:create', self)
	        })
	    }

	    Draggable.prototype.destroy = function () {
	        this.el.off(START_EVENT, this.start)

	        // Todo: Fix Zepto Bug
	        dragging.off('dragging:stop', this.reset)
	    }

	    Draggable.prototype.enable = function () {
	        this.opts.disabled = false
	    }

	    Draggable.prototype.disable = function () {
	        this.opts.disabled = true
	    }

	    Draggable.prototype.start = function (e) {
	        if (this.opts.disabled) {
	            return false
	        }
	        // only start on left mouse button
	        if (e.type === 'mousedown' && e.which !== 1) {
	            return false
	        }

	        e = e.originalEvent || e // zepto <> jquery compatibility

	        if (this.opts.cancel) {
	            var target = $(e.target)
	            while (target[0] !== this.el[0]) {
	                if (target.is(this.opts.cancel)) return
	                target = target.parent()
	            }
	        }

	        if (this.opts.handle) {
	            var target = $(e.target),
	                isHandle = false
	            while (target[0] !== this.el[0]) {
	                if (target.is(this.opts.handle)) {
	                    isHandle = true
	                    break
	                }
	                target = target.parent()
	            }
	            if (!isHandle) return
	        }

	        // prevent text selection
	        e.preventDefault()

	        var el = this.el,
	            helper
	        if (this.opts.clone) {
	            if (typeof this.opts.clone === 'function') {
	                helper = this.opts.clone.call(this.el)
	            } else {
	                helper = this.el.clone()
	                if (this.opts.cloneClass) {
	                    helper.addClass(this.opts.cloneClass)
	                }
	            }
	            var position = this.el.position()
	            helper.css('position', 'absolute')
	                .css('left', position.left).css('top', position.top)
	                .width(this.el.width()).height(this.el.height())
	            helper.insertAfter(this.el)
	        }

	        dragging.start(this, this.el, e, helper)

	        trigger(this.el, 'draggable:start', e, {
	            item: dragging.el
	        })
	    }

	    Draggable.prototype.reset = function(e, last) {
	        if (last === this.el[0]) {
	            trigger(this.el, 'draggable:stop', e, { item: dragging.el })
	        }
	    }

	    var Droppable = function (element, opts) {
	        this.id = nextId++
	            this.el = $(element)
	        this.opts = opts
	        this.accept = false
	    }

	    Droppable.prototype.create = function () {
	        this.el
	            .on('dragging:enter', $.proxy(this.enter, this))
	            .on('dragging:leave', $.proxy(this.leave, this))
	            .on('dragging:drop', $.proxy(this.drop, this))

	        dragging
	            .on('dragging:start', $.proxy(this.activate, this))
	            .on('dragging:stop', $.proxy(this.reset, this))

	        var self = this
	        setTimeout(function () {
	            self.el.trigger('droppable:create', self)
	        })
	    }

	    Droppable.prototype.destroy = function () {
	        this.el
	            .off('dragging:enter', this.enter)
	            .off('dragging:leave', this.leave)
	            .off('dragging:drop', this.drop)

	        // Todo: Fix Zepto Bug
	        // dragging
	        // .off('dragging:start', this.activate)
	        // .off('dragging:stop',  this.reset)
	    }

	    Droppable.prototype.enable = function () {
	        this.opts.disabled = false
	    }

	    Droppable.prototype.disable = function () {
	        this.opts.disabled = true
	    }

	    Droppable.prototype.activate = function (e) {
	        this.accept = dragging.parent.opts.connectWith && this.el.is(dragging.parent.opts.connectWith)

	        if (!this.accept) {
	            var accept = this.opts.accept === '*' || (typeof this.opts.accept === 'function' ? this.opts.accept.call(this.el[0], dragging.el) : dragging.el.is(this.opts.accept))
	            if (this.opts.scope !== 'default') {
	                this.accept = dragging.parent.opts.scope === this.opts.scope
	                if (!this.accept && this.opts.accept !== '*') this.accept = accept
	            } else this.accept = accept
	        }

	        if (!this.accept) return
	        if (this.opts.activeClass)
	            this.el.addClass(this.opts.activeClass)

	        trigger(this.el, 'droppable:activate', e, {
	            item: dragging.el
	        })
	    }

	    Droppable.prototype.reset = function (e) {
	        if (!this.accept) return
	        if (this.opts.activeClass) this.el.removeClass(this.opts.activeClass)
	        if (this.opts.hoverClass) this.el.removeClass(this.opts.hoverClass)

	        trigger(this.el, 'droppable:deactivate', e, {
	            item: dragging.el
	        })
	    }

	    Droppable.prototype.enter = function (e) {
	        if (this.opts.disabled) return false

	        e.stopPropagation()

	        // hide placeholder, if set (e.g. enter the droppable after
	        // entering a sortable)

	        if (!this.opts.alwaysShowPlaceholder) {

	            if (dragging.placeholder) dragging.placeholder.hide()

	        }

	        if (!this.accept) return

	        if (this.opts.hoverClass) {
	            this.el.addClass(this.opts.hoverClass)
	        }

	        trigger(this.el, 'droppable:over', e, {
	            item: dragging.el
	        })
	    }

	    Droppable.prototype.leave = function (e) {
	        if (this.opts.disabled) return false
	            // e.stopPropagation()

	        if (this.opts.hoverClass && this.accept) {
	            this.el.removeClass(this.opts.hoverClass)
	        }

	        trigger(this.el, 'droppable:out', e, {
	            item: dragging.el
	        })
	    }

	    Droppable.prototype.drop = function(e) {
	        if (this.opts.disabled || !this.accept) return false

	        if (!dragging.el) return

	        var el = dragging.el
	        var handler = typeof this.opts.receiveHandler === 'function' && this.opts.receiveHandler
	        var evtObj = { item: el }
	        var clone = null
	        if (dragging.handle) {
	            evtObj.helper = dragging.handle
	            if (!handler) {
	                clone = evtObj.clone = dragging.el.clone()
	            }
	        }

	        var drop = trigger(this.el, 'droppable:drop', e, evtObj)

	        if (!drop.isDefaultPrevented()) {
	            if (handler) {
	                handler.call(this.el, evtObj)
	            } else {
	                $(this.el).append(clone || dragging.el)
	            }
	        }
	    }

	    var Sortable = function (element, opts) {
	        this.id = nextId++
	            this.el = element
	        this.opts = opts

	        var tag = this.opts.placeholderTag
	        if (!tag) {
	            try {
	                tag = this.el.find(this.opts.items)[0].tagName
	            } catch (e) {
	                tag = /^ul|ol$/i.test(this.el[0].tagName) ? 'li' : 'div'
	            }
	        }

	        this.placeholder = $('<' + tag + ' id="__ph' + this.id + '" class="' + this.opts.placeholder + '" />')

	        this.accept = this.index = this.direction = null
	    }

	    Sortable.prototype.create = function () {
	        this.el
	            .on(START_EVENT, this.opts.items, $.proxy(this.start, this))
	            .on('dragging:enter', this.opts.items, $.proxy(this.enter, this))
	            .on('dragging:diverted', this.opts.items, $.proxy(this.diverted, this))
	            .on('dragging:drop', this.opts.items, $.proxy(this.drop, this))

	        $(this.el).attr("data-sortable", "1")
	            .find(this.opts.items)
	            .css('touch-action', 'double-tap-zoom')
	            .css('-ms-touch-action', 'double-tap-zoom')

	        this.el
	            .on('dragging:enter', $.proxy(this.enter, this))
	            .on('dragging:diverted', $.proxy(this.diverted, this))
	            .on('dragging:drop', $.proxy(this.drop, this))

	        dragging
	            .on('dragging:start', $.proxy(this.activate, this))
	            .on('dragging:stop', $.proxy(this.reset, this))

	        var self = this
	        setTimeout(function () {
	            self.el.trigger('sortable:create', self)
	        })

	        this.observer = new SelectorObserver(this.el[0], this.opts.items, function () {}, function () {
	            if (this === self.placeholder[0] || (dragging.el && this === dragging.el[0])) {
	                return
	            }
	            var item = $(this)
	            item.css('touch-action', 'double-tap-zoom')
	                .css('-ms-touch-action', 'double-tap-zoom')
	            self.el.trigger('sortable:change', {
	                item: item
	            })
	            self.el.trigger('sortable:update', {
	                item: item,
	                index: -1
	            })
	        })
	    }

	    Sortable.prototype.destroy = function () {
	        this.el
	            .off(START_EVENT, this.opts.items, this.start)
	            .off('dragging:enter', this.opts.items, this.enter)
	            .off('dragging:diverted', this.opts.items, this.diverted)
	            .off('dragging:drop', this.opts.items, this.drop)

	        this.el
	            .off('dragging:enter', this.enter)
	            .off('dragging:diverted', this.diverted)
	            .off('dragging:drop', this.drop)

	        // Todo: Fix Zepto Bug
	        // dragging
	        // .off('dragging:start', this.activate)
	        // .off('dragging:stop',  this.reset)

	        this.observer.disconnect()
	    }

	    Sortable.prototype.enable = function () {
	        this.opts.disabled = false
	    }

	    Sortable.prototype.disable = function () {
	        this.opts.disabled = true
	    }

	    Sortable.prototype.activate = function (e) {

	        this.isEmpty = this.el.find(this.opts.items).length === 0

	        this.accept = dragging.parent.id === this.id

	        if (!this.accept && dragging.parent.opts.connectWith) {
	            this.accept = this.el.is(dragging.parent.opts.connectWith)
	        }

	        if (!this.accept) return

	        this.accept = dragging.parent.id === this.id || this.opts.accept === '*' || (typeof this.opts.accept === 'function' ? this.opts.accept.call(this.el[0], dragging.el) : dragging.el.is(this.opts.accept))

	        if (!this.accept) return

	        if (this.opts.activeClass)
	            this.el.addClass(this.opts.activeClass)

	        trigger(this.el, 'sortable:activate', e, {
	            item: dragging.el
	        })
	    }

	    Sortable.prototype.reset = function (e) {
	        if (!this.accept) return
	        if (this.opts.activeClass) {
	            this.el.removeClass(this.opts.activeClass)
	        }

	        trigger(this.el, 'sortable:deactivate', e, {
	            item: dragging.el
	        })

	        if (this.index !== null) {
	            trigger(this.el, 'sortable:beforeStop', e, {
	                item: dragging.el
	            })
	            trigger(this.el, 'sortable:stop', e, {
	                item: dragging.el
	            })
	            this.index = null
	        }
	    }

	    Sortable.prototype.indexOf = function (el) {
	        return this.el.find(this.opts.items + ', #' + this.placeholder.attr('id')).index(el)
	    }

	    Sortable.prototype.start = function (e) {
	        if (this.opts.disabled || dragging.el) {
	            return
	        }

	        // only start on left mouse button
	        if (e.type === 'mousedown' && e.which !== 1) {
	            return false
	        }

	        if (this.opts.cancel) {
	            var target = $(e.target)
	            while (target[0] !== this.el[0]) {
	                if (target.is(this.opts.cancel)) return
	                target = target.parent()
	            }
	        }

	        if (this.opts.handle) {
	            var target = $(e.target),
	                isHandle = false
	            while (target[0] !== this.el[0]) {
	                if (target.is(this.opts.handle)) {
	                    isHandle = true
	                    break
	                }
	                target = target.parent()
	            }
	            if (!isHandle) return
	        }

	        e.stopPropagation()
	        e.preventDefault() // prevent text selection

	        // use e.currentTarget instead of e.target because we want the target
	        // the event is bound to, not the target (child) the event is triggered from
	        dragging.start(this, $(e.currentTarget), e)

	        this.index = this.indexOf(dragging.el)

	        dragging.el.before(dragging.placeholder = this.placeholder.show())

	        // if dragging an item that belongs to the current list, hide it while
	        // it is being dragged
	        if (this.index !== null) {
	            // zepto <> jquery compatibility
	            var height = dragging.el.outerHeight ? dragging.el.outerHeight() : dragging.el.height()
	            dragging.css('margin-bottom', -height)
	        }

	        if (this.opts.forcePlaceholderSize) {
	            this.placeholder.height(parseFloat(dragging.el.css('height')))
	            this.placeholder.width(parseFloat(dragging.el.css('width')))
	        }

	        dragging.adjustPlacement(e)

	        trigger(this.el, 'sortable:start', e, {
	            item: dragging.el
	        })
	    }

	    Sortable.prototype.enter = function (e, direction) {
	        if (!this.accept || this.opts.disabled) return

	        e.stopPropagation()

	        // stop if event is fired on the placeholder
	        var child = e.currentTarget,
	            isContainer = child === this.el[0]
	        if (child === this.placeholder[0]) return
	        child = $(child)

	        // the container fallback is only necessary for empty sortables
	        if (isContainer && !this.isEmpty && this.placeholder.parent().length) {
	            return
	        }

	        dragging.placeholder = this.placeholder

	        if (this.opts.forcePlaceholderSize) {
	            this.placeholder.height(parseFloat(dragging.el.css('height')))
	            this.placeholder.width(parseFloat(dragging.el.css('width')))
	        }
	        if (!isContainer) {
	            this.diverted(e, direction)
	        } else {
	            this.el.append(this.placeholder)
	            this.el.trigger('sortable:change', {
	                item: dragging.el
	            })
	        }
	    }

	    Sortable.prototype.diverted = function (e, direction) {

	        if (!this.accept || this.opts.disabled) return

	        e.stopPropagation()

	        var child = $(e.currentTarget),
	            isContainer = child[0] === this.el[0]

	        if (isContainer) return

	        if (child[direction === 'down' ? 'next' : 'prev']()[0] !== this.placeholder[0]) {
	            // insert the placeholder according to the dragging direction
	            dragging.placeholder = this.placeholder
	                //    this.direction = this.indexOf(this.placeholder.show()) < this.indexOf(child) ? 'down' : 'up'

	            //        child[this.direction === 'down' ? 'after' : 'before'](this.placeholder)

	            child[direction === 'down' ? 'after' : 'before'](this.placeholder)

	            dragging.adjustPlacement(e)

	            this.el.trigger('sortable:change', {
	                item: dragging.el,
	                direction: direction
	            })
	        }
	    }

	    Sortable.prototype.drop = function (e) {
	        if (!this.accept || this.opts.disabled) return

	        e.stopPropagation()
	        e.preventDefault()

	        if (!dragging.el) return
	        if (!this.placeholder.parent().length) return

	        trigger(this.el, 'sortable:beforeStop', e, {
	            item: dragging.el
	        })

	        this.observer.disconnect()

	        var newIndex = this.indexOf(this.placeholder)
	        if (newIndex > this.index) {
	            newIndex--
	        }

	        var handler

	        // dropped element belongs to another list
	        if (this.index === null) {
	            handler = this.opts.receiveHandler
	        }
	        // dopped element belongs to the same list
	        else {
	            // updatePosition cause backwards-compatibility
	            handler = this.opts.updateHandler || this.opts.updatePosition
	        }

	        var el = dragging.el
	        if (typeof handler === 'function') {
	            handler.call(this.el, {
	                item: dragging.el,
	                index: newIndex
	            })
	        } else {
	            if (dragging.handle) {
	                el = dragging.el.clone()
	            }
	            el.insertBefore(this.placeholder)
	        }

	        // if the dropped element belongs to another list, trigger the receive event
	        if (this.index === null) {
	            trigger(this.el, 'sortable:receive', e, {
	                item: el
	            })
	        }

	        // if the index changed, trigger the update event
	        if (newIndex !== this.index) {
	            this.el.trigger('sortable:update', {
	                item: el,
	                index: newIndex
	            })
	        }

	        trigger(this.el, 'sortable:stop', e, {
	            item: el
	        })
	        this.index = null
	        this.observer.observe()

	        dragging.stop(e)
	    }

	    Sortable.prototype.toArray = function (opts) {
	        if (!opts) opts = {}
	        var attr = opts.attribute || 'id',
	            attrs = []
	        this.el.find(this.opts.items).each(function () {
	            attrs.push($(this).prop(attr))
	        })
	        return attrs
	    }

	    function generic(constructor, identifier, defaults) {
	        return function (opts, name, value) {
	            var result = []
	            this.each(function () {
	                var instance = $(this).data(identifier)
	                if (typeof opts === 'string') {
	                    if (typeof instance === 'undefined')
	                        throw new Error(identifier + ' not defined')
	                    switch (opts) {
	                    case 'enable':
	                        instance.enable();
	                        break
	                    case 'disable':
	                        instance.disable();
	                        break
	                    case 'destroy':
	                        instance.destroy()
	                        $(this).removeData(identifier)
	                        break
	                    case 'option':
	                        // set
	                        if (value !== undefined)
	                            instance.opts[name] = value
	                        else if (typeof name === 'object')
	                            instance.opts = $.extend(instance.opts, name)
	                            // get
	                        else if (name)
	                            result.push(instance.opts[name])
	                        else
	                            result.push(instance.opts)
	                        break
	                        // case 'serialize':
	                        //   if (identifier !== 'sortable') return
	                        //   result.push(instance.serialize())
	                        //   break
	                    case 'toArray':
	                        if (identifier !== 'sortable') return
	                        result.push(instance.toArray(name))
	                        break
	                    }
	                } else {
	                    if (instance) {
	                        $.extend(instance.opts, opts) // merge options
	                        return this
	                    }
	                    instance = new constructor($(this), $.extend({}, defaults, opts))
	                    instance.create()
	                    $(this).data(identifier, instance)
	                }
	            })

	            if (result.length)
	                return result.length === 1 ? result[0] : result
	            else
	                return this
	        }
	    }

	    $.fn.draggable = generic(Draggable, 'draggable', {
	        cancel: 'input, textarea, button, select, option',
	        connectWith: false,
	        cursor: 'auto',
	        disabled: false,
	        handle: false,
	        initialized: false,
	        clone: false,
	        alwaysShowPlaceholder: false,
	        cloneClass: '',
	        scope: 'default',
	        stopClass: 'draggable-stop',
	        onlyXDir: false,
	        onlyYDir: false,
	        fixdX: false,
	        fixedY: false
	    })

	    $.fn.droppable = generic(Droppable, 'droppable', {
	        accept: '*',
	        activeClass: '',
	        disabled: false,
	        hoverClass: '',
	        initialized: false,
	        scope: 'default',
	        receiveHandler: null,
	        stopClass: 'draggable-stop',
	        alwaysShowPlaceholder: false,
	        onlyXDir: false,
	        onlyYDir: false,
	        fixdX: false,
	        fixedY: false
	    })

	    $.fn.sortable = generic(Sortable, 'sortable', {
	        accept: '*',
	        activeClass: '',
	        cancel: 'input, textarea, button, select, option',
	        connectWith: false,
	        disabled: false,
	        forcePlaceholderSize: false,
	        alwaysShowPlaceholder: false,
	        handle: false,
	        initialized: false,
	        items: 'li, div',
	        placeholder: 'placeholder',
	        placeholderTag: null,
	        updateHandler: null,
	        receiveHandler: null,
	        stopClass: 'draggable-stop',
	        onlyXDir: false,
	        onlyYDir: false,
	        fixdX: false,
	        fixedY: false
	    })
	})(window.Zepto || window.jQuery);


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	var Ractive = __webpack_require__(0),

	    ColorPicker = __webpack_require__(22),
	    ColorPickerPalette = __webpack_require__(14);

	module.exports = Ractive.extend({

	    template: __webpack_require__(148),

	    OPTIONS: {
	        ANIMATIONS: {

	        }
	    },

	    components: {
	        ColorPicker: ColorPicker,
	        ColorPickerPalette: ColorPickerPalette
	    },

	    partials: {
	        fontSettings: __webpack_require__(150),
	        colorPaletteSettings: __webpack_require__(149)
	    },

	    data: function () {

	        return {
	            fontTypes: __webpack_require__(83),

	            colorPalettes: __webpack_require__(82)
	        };
	    },

	    onrender: function () {

	    },

	    onconfig: function () {

	        this.on("ColorPicker.*", function (data) {

	            if (data && typeof data === "object" && data.key === "current") {

	                var state = !data.context.get("animate");

	                this.parent.forEachPageSection(function (section) {

	                    section.set("stopColorTransitions", state);
	                });
	            }
	        });

	        this.observe("settings.colorPalette", function (newValue, oldValue) {

	            if (newValue !== oldValue) {

	                this.parent.forEachPageSection(function (section) {

	                    section.set("stopColorTransitions", false);
	                });
	            }
	        }, {init: false});
	    },

	    oncomplete: function () {

	    },

	    onteardown: function () {

	    }

	});


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	var Ractive = __webpack_require__(0);

	module.exports = Ractive.extend({

	    template: __webpack_require__(152),

	    CLASS: {
	        self: "E_NewPageSectionSelector",

	        sectionThumb: "E_SectionThumb",
	        sectionThumbDisabled: "E_SectionThumb__disabled",
	        clone: "E_SectionThumb--clone",
	        cloneRemoved: "E_SectionThumb--clone__removed",
	        cancelAddSection: "E_SectionThumb--clone__cancel",
	        inserted: "E_SectionThumb__inserted"
	    },

	    components: {
	    },

	    partials: {
	        SectionThumb: __webpack_require__(151)
	    },

	    data: function () {

	        return {
	        };
	    },

	    onrender: function () {

	    },

	    onconfig: function () {

	    },

	    oncomplete: function () {
	    }

	});


/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	/*global $*/
	(function (root, factory) {

	    if (typeof module === 'object' && module.exports) {

	        var PageElement = __webpack_require__(20),
	            Ractive = __webpack_require__(0),

	            U = __webpack_require__(4),
	            on = __webpack_require__(1),

	            partials = {
	                pageElementEditUI: __webpack_require__(154),
	                pageElementContent: __webpack_require__(155)
	            };

	        module.exports = factory(
	            PageElement,
	            Ractive,
	            U,
	            partials,
	            on
	        );

	    } else {

	        root.PageElementTextContent = factory(
	            root.PageElement,
	            root.Ractive,
	            root.U,
	            {},
	            {client: true}
	        );
	    }

	}(this, function (PageElement, Ractive, U, partials, on) {

	    return PageElement.extend({

	        components: {
	        },

	        partials: partials,

	        data: function () {

	            return {
	                type: "text-content",
	                hasEditUI: true,
	                settingsTitle: "Nastavení textu"
	            };
	        },

	        onconfig: function () {

	            this.superOnconfig();

	            if (Ractive.EDIT_MODE) {

	                this.on("stateChange", function (state) {

	                    if (state && (this.hasFocusedEditor() || this.focusin)) {

	                        this.set("state", "active");

	                    } else {

	                        this.set("state", "inactive");
	                    }
	                });

	                this.on("activate", function (event) {

	                    event.original.preventDefault();

	                    setTimeout(function() {

	                        var editable = this.find("[data-medium-editor-element='true']");

	                        if (editable) {

	                            editable.focus();

	                            this.fire("stateChange", this.get("showOutline"));
	                        }

	                    }.bind(this), 0);
	                });
	            }
	        },

	        onrender: function () {

	            this.superOnrender();

	            if (Ractive.EDIT_MODE) {

	                this.Page = this.findParent("Page");

	                this.set("mostUsedColors", this.Page.findMostUsedColors());
	            }
	        },

	        oncomplete: function () {

	            this.superOncomplete();
	        },

	        onteardown: function () {

	            this.superOnteardown();
	        },

	        isEmpty: function () {

	            return (this.get("element.content") || "").replace(/(?:<[^>]*>)/g, "").match(/^\s*$/);
	        }

	    });

	}));



/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	/*global $*/
	(function (root, factory) {

	    if (typeof module === 'object' && module.exports) {

	        var PageElement = __webpack_require__(20),
	            Ractive = __webpack_require__(0),

	            U = __webpack_require__(4),
	            on = __webpack_require__(1),

	            partials = {
	                pageElementEditUI: __webpack_require__(156),
	                pageElementContent: __webpack_require__(157)
	            };

	        module.exports = factory(
	            PageElement,
	            Ractive,
	            U,
	            partials,
	            on
	        );

	    } else {

	        root.PageElementTitle = factory(
	            root.PageElement,
	            root.Ractive,
	            root.U,
	            {},
	            {client: true}
	        );
	    }

	}(this, function (PageElement, Ractive, U, partials, on) {

	    return PageElement.extend({

	        components: {
	        },

	        partials: partials,

	        data: function () {

	            return {
	                type: "title",
	                hasEditUI: true
	            };
	        },

	        onconfig: function () {

	            this.superOnconfig();

	            if (Ractive.EDIT_MODE) {

	                this.on("stateChange", function (state) {

	                    if (state && (this.hasFocusedEditor() || this.focusin)) {

	                        this.set("state", "active");

	                    } else {

	                        this.set("state", "inactive");
	                    }
	                });

	                this.on("activate", function (event) {

	                    event.original.preventDefault();

	                    setTimeout(function() {

	                        var editable = this.find("[data-medium-editor-element='true']");

	                        if (editable) {

	                            editable.focus();

	                            this.fire("stateChange", this.get("showOutline"));
	                        }

	                    }.bind(this), 0);
	                });
	            }

	        },

	        onrender: function () {

	            this.superOnrender();
	        },

	        oncomplete: function () {

	            this.superOncomplete();
	        },

	        onteardown: function () {

	            this.superOnteardown();
	        },

	        isEmpty: function () {

	            return (this.get("element.title") || "").replace(/(?:<[^>]*>)/g, "").match(/^\s*$/);
	        }

	    });

	}));



/***/ },
/* 62 */
/***/ function(module, exports) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	/*global $*/

	var ParallaxController = (function () {

	        var initialized = false,

	            instanceCounter = 0,
	            parallaxInstances = {},

	            $win,
	            winHeight = 0,
	            winWidth = 0,
	            winScrollTop = 0,

	            //v případě, že je sekce vidět, zavolá metodu transform příslušného Parallaxu
	            updateParallaxes = function (type, event) {

	                winScrollTop = $win.scrollTop();

	                $.each(parallaxInstances, function (i, parallax) {

	                    var backgroundOffsetTop = parallax.getOffset(),
	                        backgroundBottom = backgroundOffsetTop + parallax.getBackgroundHeight(),

	                        winBottom = winScrollTop + winHeight;

	                    if (winBottom > backgroundOffsetTop && winScrollTop < backgroundBottom) {

	                        parallax.transform(event);
	                    }
	                });
	            },

	            getWinScrollTop = function () {

	                return winScrollTop;
	            },

	            refresh = function () {

	                winHeight = $win.height();
	                winWidth = $win.width();
	                winScrollTop = $win.scrollTop();

	                $.each(parallaxInstances, function (i, parallax) {

	                    parallax.refresh();
	                });
	            },

	            init = function () {

	                if (initialized) {

	                    return;
	                }

	                $win = $(window);

	                winHeight = $win.height();
	                winWidth = $win.width();
	                winScrollTop = $win.scrollTop();

	                $win.on("scroll.ParallaxController", updateParallaxes.bind(this))
	                    .on("resize.ParallaxController", refresh);

	                initialized = true;
	            },

	            destroy = function () {

	                $win.off("scroll.ParallaxController")
	                    .off("resize.ParallaxController");

	                initialized = false;
	            },

	            add = function (parallax) {

	                if (!parallaxInstances[parallax.id]) {

	                    instanceCounter++;

	                    parallaxInstances[parallax.id] = parallax;
	                }
	            },

	            remove = function (parallax) {

	                if (parallaxInstances[parallax.id]) {

	                    instanceCounter--;

	                    delete parallaxInstances[parallax.id];

	                    if (!instanceCounter) {

	                        destroy();
	                    }
	                }
	            },

	            getWinHeight = function () {

	                return winHeight;
	            },

	            getWinWidth = function () {

	                return winWidth;
	            };

	        return {
	            init: init,
	            destroy: destroy,
	            refresh: refresh,

	            add: add,
	            remove: remove,

	            getWinHeight: getWinHeight,
	            getWinWidth: getWinWidth,
	            getWinScrollTop: getWinScrollTop
	        };

	    }());


	var instanceCounter = 0,

	    Parallax = function Parallax(backgroundImageComponent) {

	        this.id = "Parallax-" + (instanceCounter++);

	        this.BackgroundImage = backgroundImageComponent;
	        this.CLASS = backgroundImageComponent.CLASS;

	        this.refresh(true, backgroundImageComponent);
	    };

	Parallax.prototype.destroy = function () {

	    if (this.$image) {

	        this.$image.css({
	            transform: ""
	        });
	    }

	    this.$background = null;
	    this.$image = null;

	    ParallaxController.remove(this);

	    this.initialized = false;
	};

	Parallax.prototype.refresh = function (elements) {

	    ParallaxController.init();
	    ParallaxController.add(this);

	    if (elements || !this.$background || !this.$image) {

	        this.$background = $(this.BackgroundImage.find("." + this.CLASS.self));
	        this.$image = this.$background.find("." + this.CLASS.image);
	    }

	    this.backgroundHeight = this.$background.outerHeight();
	    this.imageHeight = this.$image.outerHeight();

	    this.getOffset();

	    //velikost zvětšení sekce (polovina)
	    this.parallaxExtention = (this.imageHeight - this.backgroundHeight) / 2;
	    //rozsah parallaxu -> kolik pixelů bude efekt viditelný
	    this.parallaxOuterRange = this.backgroundHeight + ParallaxController.getWinHeight();

	    this.initialized = true;

	    this.transform();
	};

	Parallax.prototype.getOffset = function () {

	    this.offsetTop = this.$background.offset().top;

	    return this.offsetTop;
	};

	Parallax.prototype.transform = function () {

	    if (!this.initialized) {

	        return;
	    }

	    var backgroundBottom = this.offsetTop + this.backgroundHeight,

	        //kolik procent efektu již bylo provedeno (násobí se dvěma pro následující výpočty)
	        parallaxProgression = ((backgroundBottom - ParallaxController.getWinScrollTop()) / this.parallaxOuterRange) * 2,
	        //přepočet "parallaxProgression" od středu na rozsah mezi -1 a 1 (označující o kolik % "parallaxExtention" se má obrázek posunout)
	        progressionFromCenter = parallaxProgression > 1 ? (parallaxProgression - 1) * -1: 1 - parallaxProgression,

	        //odčítá se (this.backgroundHeight / 2), protože obrázek má top: 50%.
	        transform = (this.parallaxExtention * progressionFromCenter) - this.parallaxExtention - (this.backgroundHeight / 2);

	    this.$image.css({
	        transform: "translateY(" + transform + "px)"
	    });
	};

	Parallax.prototype.getBackgroundHeight = function () {

	    return this.backgroundHeight;
	};

	Parallax.prototype.getImageHeight = function () {

	    return this.imageHeight;
	};

	module.exports = Parallax;



/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	/*global $*/

	(function (root, factory) {

	    if (typeof module === 'object' && module.exports) {

	        var on = __webpack_require__(1);
	        var EventEmitter = __webpack_require__(6)();

	        var Ractive = __webpack_require__(0),

	            Dropzone = on.client ? __webpack_require__(38) : function () { return {}; },

	            Parallax = __webpack_require__(62),

	            template = __webpack_require__(159);

	        module.exports = factory(Ractive, Dropzone, Parallax, template, on);

	    } else {

	        root.BackgroundImage = factory(root.Ractive, root.Dropzone, root.Parallax, null, {client: true});
	    }

	}(this, function (Ractive, Dropzone, Parallax, template, on) {

	    return Ractive.extend({

	        template: template || "",

	        CLASS: {
	            self: "P_BackgroundImage",

	            image: "P_BackgroundImage--image",

	            parallax: "P_BackgroundImage__parallax",
	            fixed: "P_BackgroundImage__fixed",

	            notFileDragged: "dz-not-file"
	        },

	        OPTIONS: {
	            PARALLAX_MAX_EXT: 320,
	            PARALLAX_MIN_EXT: 80,

	            EFFECTS_STRENGTH_DEF: 35,

	            DROPZONE: function () {

	                return {
	                    url: "/upload-image",
	                    paramName: "image",

	                    acceptedFiles: "image/jpg,image/jpeg,image/png",
	                    maxFilesize: 1,
	                    uploadMultiple: false,

	                    clickable: false,

	                    thumbnailWidth: null,
	                    thumbnailHeight: null,

	                    dictInvalidFileType: "Nepodporovaný formát. Soubor musí být formátu .jpg, .png.",
	                    dictFileTooBig: "Soubor je příliš velký ({{filesize}} MB). Velikost souboru může být maximálně {{maxFilesize}} MB.",
	                    dictResponseError: "Soubor se nepodařilo nahrát (chyba: {{statusCode}})"
	                };
	            }
	        },

	        components: {
	        },

	        partials: {
	        },

	        data: function () {

	            return {
	                editMode: Ractive.EDIT_MODE,

	                backgroundSize: "cover",
	                backgroundRepeat: "no-repeat",

	                parallax: false,
	                parallaxExtention: this.getParallaxExtention(this.OPTIONS.EFFECTS_STRENGTH_DEF),
	                fixed: false,

	                data: {
	                    src: "",

	                    display: "cover",
	                    effects: [],
	                    effectsStrength: this.OPTIONS.EFFECTS_STRENGTH_DEF
	                }
	            };
	        },

	        onconfig: function () {

	            this.observe("data.src", function (src) {

	                if (!src) {

	                    this.set("parallax", false);
	                    this.set("fixed", false);

	                } else {

	                    this.update("data.effects");
	                }

	            }, {init: false});

	            this.observe("data.effectsStrength", function (value) {

	                if (typeof value === "undefined") {

	                    return;
	                }

	                var insertedValue = value;

	                if (!parseInt(insertedValue) && +insertedValue !== 0) {

	                    value = this.OPTIONS.EFFECTS_STRENGTH_DEF;

	                } else {

	                    value = Math.max(Math.min(100, insertedValue), 0);

	                }

	                if (value !== insertedValue) {

	                    this.set("data.effectsStrength", value);
	                }

	                this.set("parallaxExtention", this.getParallaxExtention(value));
	            });

	            this.observe("data.display", function (display) {

	                switch (display) {

	                    case "cover": {

	                        this.set("backgroundSize", "cover");
	                        this.set("backgroundRepeat", "no-repeat");

	                        break;
	                    }

	                    case "repeat": {

	                        this.set("backgroundSize", "auto");
	                        this.set("backgroundRepeat", "repeat");

	                        break;
	                    }
	                }
	            });

	            this.observe("data.effects", function (effects) {

	                if (this.torndown) {

	                    return;
	                }

	                if (!effects || this.skipEffectsObserver || this.torndown) {

	                    return;
	                }

	                var parallax = ~effects.indexOf("parallax"),
	                    fixed = ~effects.indexOf("fixed");

	                this.skipEffectsObserver = true;

	                //uživatel přepnul na parallax -> zrušit fixed, pokud byl nastaven
	                if (parallax && fixed && !this.get("parallax")) {

	                    fixed = false;

	                    this.splice("data.effects", fixed, 1);

	                //uživatel přepnul na fixed -> zušit parallax, pokud byl nastaven
	                } else if (parallax && fixed && !this.get("fixed")) {

	                    parallax = false;

	                    this.splice("data.effects", parallax, 1);
	                }

	                this.skipEffectsObserver = false;

	                if (!this.get("data.src")) {

	                    return;
	                }

	                this.set("parallax", !!parallax);
	                this.set("fixed", !!fixed);
	            });

	        },

	        onrender: function () {

	            if (on.client) {

	                this.self = this.find("." + this.CLASS.self);
	                this.$self = $(this.self);

	                this.PageSection = this.getPageSection();
	                this.Page = this.findParent("Page");

	                this.initParallax();

	                if (Ractive.EDIT_MODE) {

	                    this.initDragDropUpload();

	                    this.PageSection.on("BackgroundImageBrowser.selectFile", function (e, file) {

	                        this.guessDisplayFromSize(file);

	                    }.bind(this));

	                    this.Page.on("BackgroundImageBrowser.deleteFile", function (e, file) {

	                        var src = this.get("data.src");

	                        if (src && file.path.replace(/^\//, "") === src.replace(/^\//, "")) {

	                            this.set("data.src", "");
	                        }

	                    }.bind(this));
	                }
	            }
	        },

	        guessDisplayFromSize: function (file) {

	            if (file && file.width && file.height) {

	                //je-li obrázek čtverec nebo jsou obě strany menší jak 512px nebo je jedna ze stran
	                //menší jak 128px nebo je poměr stran menší jak 0.4 (= úzký),
	                //pak je obrázek pravděpodobně textura -> nastavit opakování
	                if (file.width === file.height || file.width <= 128 || file.height <= 128 || (file.width <= 512 && file.height <= 512) || file.width / file.height < 0.4) {

	                    this.set("data.display", "repeat");

	                    return;
	                }

	                this.set("data.display", "cover");
	            }
	        },

	        initDragDropUpload: function () {

	            Dropzone.autoDiscover = false;

	            var options = this.OPTIONS.DROPZONE();

	            //element pro uložení náhledů (nelze v Dropzone zrušit)
	            this.$dropzonePreview = $("<div/>");
	            options.previewsContainer = this.$dropzonePreview[0];

	            options.addedfile = this.handleAddedfile.bind(this);
	            options.thumbnail = this.handleThumbnail.bind(this);
	            options.uploadprogress = this.handleUploadProgress.bind(this);
	            options.success = this.handleUploadSuccess.bind(this);
	            options.error = this.handleUploadError.bind(this);

	            this.dropzone = this.$self.dropzone(options);

	            this.dropzone.on("dragenter", function (event) {

	                if (!event.originalEvent.dataTransfer.types[0] ||
	                    !event.originalEvent.dataTransfer.types[0].match(/file/i)) {

	                    event.target.classList.add(this.CLASS.notFileDragged);

	                    return;
	                }

	                event.target.classList.remove(this.CLASS.notFileDragged);

	                this.fire("pageSectionMessage", {
	                    title: "Nahrát obrázek",
	                    text: "Maximální velikost souboru: " + options.maxFilesize + " MB. Podporované formáty: .jpg, .png."
	                });

	            }.bind(this));

	            this.dropzone.on("dragleave dragend", function () {

	                this.fire("pageSectionMessage", null);

	            }.bind(this));
	        },

	        handleAddedfile: function () {

	            //uložit původní nastavení, kdyby se nepodařilo obrázek nahrát (-> vrátit)
	            this.prevDisplay = this.get("data.display");
	            this.prevSrc = this.get("data.src");

	            this.fire("pageSectionMessage", {
	                title: "Nahrát obrázek",
	                text: "Počkejte prosím...",
	                status: "info"
	            });
	        },

	        handleThumbnail: function (file, imageData) {

	            if (this.torndown || !file.accepted) {

	                return;
	            }

	            //obrázek by se mohl nahrát dříve než se vytvoří thumnail -> zkontrolovat, jestli už obrázek nebyl nahrazen
	            if (this.prevSrc === this.get("data.src")) {

	                this.set("data.src", imageData);
	            }

	            this.guessDisplayFromSize(file);
	        },

	        handleUploadProgress: function (file, progress) {

	            if (this.torndown) {

	                return;
	            }

	            this.fire("progressBarProgress", {
	                id: file.name.replace(".", "_"),
	                progress: progress
	            });

	            this.fire("pageSectionMessage", {
	                title: "Soubor se nahrává...",
	                text: progress.toFixed() + " %",
	                status: "info"
	            });
	        },

	        handleUploadSuccess: function (file, res) {

	            var path = res.path.replace(/^public/, "").replace(/\\/g, "/");

	            this.set("data.src", path);

	            this.fire("pageSectionMessage", {
	                title: "Nahrát obrázek",
	                text: "Obrázek (" + file.name + ") se podařilo úspěšně nahrát.",
	                timeout: 2000,
	                status: "success"
	            });

	            var browsers = this.Page.findAllComponents("BackgroundImageBrowser"),
	                b = browsers.length - 1;

	            if (browsers.length) {

	                for (b; b >= 0; b--) {

	                    browsers[b].addFileToUploadDirectory(res.name, path);
	                }
	            }
	        },

	        handleUploadError: function (file, error) {

	            if (this.torndown) {

	                return;
	            }

	            this.fire("progressBarError", {
	                id: file.name.replace(".", "_")
	            });

	            this.fire("pageSectionMessage", {
	                title: "Nahrát obrázek",
	                text: error,
	                timeout: 3000,
	                status: "error"
	            });

	            if (this.prevDisplay) {

	                this.set("data.display", this.prevDisplay);
	            }

	            if (this.prevSrc || this.prevSrc === "") {

	                this.set("data.src", this.prevSrc);
	            }
	        },

	        initParallax: function () {

	            this.observe("parallax", function () {

	                if (this.PageSection.get("isRemoved")) {

	                    clearTimeout(this.sectionChangeThrottle);

	                    if (this.parallax) {

	                        this.parallax.destroy();

	                        this.parallax = null;
	                    }

	                    return;
	                }

	                if (this.torndown) {

	                    return;
	                }

	                if (this.get("parallax")) {

	                    if (this.parallax) {

	                        return this.parallax.refresh();
	                    }

	                    this.parallax = new Parallax(this);

	                    return;
	                }

	                if (!this.get("parallax") && this.parallax) {

	                    this.parallax.destroy();
	                }

	            }, {defer: true});

	            this.PageSection.observe("section", this.handleSectionChange.bind(this), {init: false, defer: true});
	            this.PageSection.on("sectionOrderChanged", this.handleSectionChange.bind(this), {init: false, defer: true});
	        },

	        onteardown: function () {

	            this.torndown = true;

	            clearTimeout(this.sectionChangeThrottle);

	            if (this.dropzone) {

	                this.dropzone.off("dragenter dragleave dragend drop");

	                Dropzone.forElement(this.self).removeAllFiles(true);
	                Dropzone.forElement(this.self).destroy();

	                this.$dropzonePreview.remove();
	                this.$dropzonePreview = null;
	            }

	            if (this.parallax) {

	                this.parallax.destroy();

	                this.parallax = null;
	            }
	        },

	        getParallaxExtention: function (strength) {

	            var range = this.OPTIONS.PARALLAX_MAX_EXT - this.OPTIONS.PARALLAX_MIN_EXT;

	            return (range * (strength / 100)) + this.OPTIONS.PARALLAX_MIN_EXT;
	        },

	        handleSectionChange: function () {

	            clearTimeout(this.sectionChangeThrottle);

	            this.sectionChangeThrottle = setTimeout(function() {

	                if (this.parallax && this.get("parallax")) {

	                    this.parallax.refresh();
	                }
	            }.bind(this), 350);
	        }
	    });

	}));


/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	var Ractive = __webpack_require__(0);

	/*
	 * PageSectionMessage zobrazí zprávu u příslušné sekce stránky,
	 * pokud nastane událost pageSectionMessage. Objekt události může obshovat:
	 * {
	 *     title: "title",
	 *     text: "text",
	 *     status: "success",
	 *     timeout: 1000 //doba za jakou zpráva zmizí (v případě neuvedení se musí zajistit
	 *                   //odstranění zprávy jinak -> odeslat událost s hodnotou null)
	 * }
	 */

	module.exports = Ractive.extend({

	    template: __webpack_require__(166),

	    CLASS: {
	        self: "E_PageSectionMessage",

	        message: "E_PageSectionMessage--message",
	        title: "E_PageSectionMessage--title",
	        text: "E_PageSectionMessage--text",

	        success: "E_PageSectionMessage--message__success",
	        error: "E_PageSectionMessage--message__error",
	        info: "E_PageSectionMessage--message__info",
	        warn: "E_PageSectionMessage--message__warn"
	    },

	    components: {
	    },

	    partials: {
	    },

	    data: function () {

	        return {
	            messageStatusClass: "",

	            message: null
	        };
	    },

	    onrender: function () {

	    },

	    onconfig: function () {

	        this.observe("message", function (message) {

	            if (!message) {

	                return;
	            }

	            clearTimeout(this.messageTimeout);

	            if (message.timeout) {

	                this.messageTimeout = setTimeout(function() {

	                    this.set("message", null);

	                }.bind(this), message.timeout);
	            }

	            switch (message.status) {
	                case "success": this.set("messageStatusClass", this.CLASS.success);
	                    break;
	                case "error": this.set("messageStatusClass", this.CLASS.error);
	                    break;
	                case "warn": this.set("messageStatusClass", this.CLASS.warn);
	                    break;
	                case "info": this.set("messageStatusClass", this.CLASS.info);
	                    break;
	                default: this.set("messageStatusClass", "");
	            }
	        });

	        this.PageSection = this.getPageSection();

	        this.PageSection.on("pageSectionMessage *.pageSectionMessage", function (message) {

	            this.set("message", message);

	        }.bind(this));
	    },

	    oncomplete: function () {
	    }

	});


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	(function (root, factory) {

	    if (typeof module === 'object' && module.exports) {

	        var PageSectionSettings = __webpack_require__(12);

	        module.exports = factory(PageSectionSettings);

	    } else {

	        root.BackgroundImageSettings = factory(root.PageSectionSettings);
	    }

	}(this, function (PageSectionSettings) {

	    return PageSectionSettings.extend({

	//        template: require("./index.tpl"),

	        data: {
	            data: {}
	        },

	        components: {
	            BackgroundImageBrowser: __webpack_require__(94)
	        },

	        partials: {
	            pageSectionSettingsContent: __webpack_require__(167)
	        },

	        onconfig: function () {

	            this.superOnconfig();

	        },

	        oncomplete: function () {

	            this.superOncomplete();

	        },

	        onteardown: function () {

	            this.superOnteardown();

	        },

	        onrender: function () {

	            this.superOnrender();

	            this.on("BackgroundImageBrowser.selectFile", function (event, file) {

	                if (file && file.path) {

	                    this.set("data.backgroundImage.src", file.path);
	                }

	            }, {context: this});

	        }

	    });

	}));



/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	(function (root, factory) {

	    if (typeof module === 'object' && module.exports) {

	        var PageSectionSettings = __webpack_require__(12),
	            ColorPicker = __webpack_require__(22),
	            ColorPickerPalette = __webpack_require__(14),

	            template = __webpack_require__(170);

	        module.exports = factory(PageSectionSettings, ColorPicker, ColorPickerPalette, template);

	    } else {

	        root.ColorSettings = factory(root.PageSectionSettings, root.ColorPicker, root.ColorPickerPalette, "");
	    }

	}(this, function (PageSectionSettings, ColorPicker, ColorPickerPalette, template) {

	    return PageSectionSettings.extend({

	//        template: template,

	        components: {
	            ColorPickerPalette: ColorPickerPalette,
	            ColorPicker: ColorPicker
	        },

	        partials: {
	            pageSectionSettingsContent: template,
	            ColorSettingsNavItem: __webpack_require__(168),
	            ColorSettingsTab:  __webpack_require__(169)
	        },

	        data: function () {

	            return {
	                openTab: 1,

	                imageColors: {}
	            };
	        },

	        onrender: function () {

	            this.superOnrender();

	            this.observe("openTab", function () {

	                this.toggle("toggleTab");

	                this.cancelImageColorsObservers();

	            }, {init: false});

	            this.observe("openTab", function () {

	                this.saveColorsFromImage();

	            }, {init: false, defer: true});

	            this.saveColorsFromImage();
	        },

	        onconfig: function () {

	            this.superOnconfig();

	            this.Page = this.findParent("Page");

	            this.set("mostUsedColors", this.Page.findMostUsedColors());

	            this.imageColorsObservers = [];
	        },

	        oncomplete: function () {

	            this.superOncomplete();

	        },

	        onteardown: function () {

	            this.superOnteardown();

	            this.cancelImageColorsObservers();
	        },

	        //Uloží nalezené barvy z obrázků, aby se při každém přepnutí tabu, nehledaly znovu.
	        //ColorPickerPalette musí mít atribut id, pomocí kterého se zjistí v datech "imageColors",
	        //jestli už barvy pro danou paletu existují.
	        saveColorsFromImage: function () {

	            var colorSettings = this;

	            this.findAllComponents("ColorPickerPalette").forEach(function (palette) {

	                var image = palette.get("image");

	                if (image && image !== "none") {

	                    var observer = palette.observe("colors", function (colors) {

	                        if (colors && colors.length) {

	                            colorSettings.set("imageColors." + palette.get("id"), {
	                                title: palette.get("title"),
	                                colors: colors
	                            });
	                        }
	                    }, {init: false});

	                    colorSettings.imageColorsObservers.push(observer);
	                }
	            });
	        },

	        cancelImageColorsObservers: function () {

	            var o = this.imageColorsObservers.length - 1;

	            for (o; o >= 0; o--) {

	                this.imageColorsObservers[o].cancel();

	                this.imageColorsObservers.splice(o, 1);
	            }
	        }
	    });

	}));



/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	(function (root, factory) {

	    if (typeof module === 'object' && module.exports) {

	        var PageSectionSettings = __webpack_require__(12),

	            template = __webpack_require__(171);

	        module.exports = factory(PageSectionSettings, template);

	    } else {

	        root.ColorSettings = factory(root.PageSectionSettings, root.ColorPicker, root.ColorPickerPalette, "");
	    }

	}(this, function (PageSectionSettings, template) {

	    return PageSectionSettings.extend({

	//        template: template,

	        components: {
	        },

	        partials: {
	            pageSectionSettingsContent: template
	        },

	        data: function () {

	            return {
	            };
	        },

	        onrender: function () {
	            this.superOnrender();
	        },

	        onconfig: function () {
	            this.superOnconfig();
	        },

	        oncomplete: function () {
	            this.superOncomplete();
	        },

	        onteardown: function () {
	            this.superOnteardown();
	        }
	    });

	}));



/***/ },
/* 68 */
/***/ function(module, exports) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/

	module.exports = function () {

	    return {
	        type: "PageSectionA",
	        name: "Sekce A",
	        title: "Titulek",
	        content: "obsah"
	    };
	};


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	var PageSection = __webpack_require__(13);

	module.exports = PageSection.extend({

	    partials: {
	        pageSectionContent: __webpack_require__(173),
	        pageSectionSettings: __webpack_require__(174),
	        pageSectionEditUI: "<BasicEditUI section='{{.section}}' />"
	    },

	    components: {
	        BasicEditUI: __webpack_require__(21)
	    },

	    onrender: function () {
	        this.superOnrender();
	    },

	    onteardown: function () {
	        this.superOnteardown();
	    },

	    oncomplete: function () {
	        this.superOncomplete();
	    },

	    onconfig: function () {
	        this.superOnconfig();
	    }

	});


/***/ },
/* 70 */
/***/ function(module, exports) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/

	module.exports = function () {

	    return {
	        type: "PageSectionB",
	        name: "Sekce B",
	        title: "Titulek",
	        content: "obsah"
	    };
	};


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	var PageSection = __webpack_require__(13);

	module.exports = PageSection.extend({

	    //    template: require("./index.tpl"),

	    partials: {
	        pageSectionContent: __webpack_require__(175),
	        pageSectionSettings: __webpack_require__(176),
	        pageSectionEditUI: "<BasicEditUI section='{{.section}}' />"
	    },

	    components: {
	        BasicEditUI: __webpack_require__(21)
	    },

	    onrender: function () {
	        this.superOnrender();
	    },

	    onteardown: function () {
	        this.superOnteardown();
	    },

	    oncomplete: function () {
	        this.superOncomplete();
	    },

	    onconfig: function () {
	        this.superOnconfig();
	    }

	});


/***/ },
/* 72 */
/***/ function(module, exports) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/

	module.exports = function () {

	    return {
	        type: "PageSectionC",
	        name: "Sekce C",
	        title: "Titulek",
	        content: "obsah"
	    };
	};


/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	var PageSection = __webpack_require__(13);

	module.exports = PageSection.extend({

	    partials: {
	        pageSectionContent: __webpack_require__(177),
	        pageSectionSettings: __webpack_require__(178),
	        pageSectionEditUI: "<BasicEditUI section='{{.section}}' />"
	    },

	    components: {
	        BasicEditUI: __webpack_require__(21)
	    },

	    onrender: function () {
	        this.superOnrender();
	    },

	    onteardown: function () {
	        this.superOnteardown();
	    },

	    oncomplete: function () {
	        this.superOncomplete();
	    },

	    onconfig: function () {
	        this.superOnconfig();
	    }

	});



/***/ },
/* 74 */
/***/ function(module, exports) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	module.exports = function () {

	    return {
	        color: "",
	        background: ""
	    };
	};


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/

	var Spectra = __webpack_require__(29);

	var BLACK  = new Spectra("#000000"),
	    BLACK2 = new Spectra("#222222"),
	    BLACK3 = new Spectra("#424242"),
	    WHITE  = new Spectra("#ffffff"),
	    WHITE2 = new Spectra("#f0f0f0"),
	    WHITE3 = new Spectra("#e5e5e5"),

	    BLACK_RGB  = BLACK.rgbaString().replace(/\s*,[0-9]+\)/i, ")").replace(/rgba/i, "rgb"),
	    BLACK2_RGB = BLACK2.rgbaString().replace(/\s*,[0-9]+\)/i, ")").replace(/rgba/i, "rgb"),
	    BLACK3_RGB = BLACK3.rgbaString().replace(/\s*,[0-9]+\)/i, ")").replace(/rgba/i, "rgb"),
	    WHITE_RGB  = WHITE.rgbaString().replace(/\s*,[0-9]+\)/i, ")").replace(/rgba/i, "rgb"),
	    WHITE2_RGB = WHITE2.rgbaString().replace(/\s*,[0-9]+\)/i, ")").replace(/rgba/i, "rgb"),
	    WHITE3_RGB = WHITE3.rgbaString().replace(/\s*,[0-9]+\)/i, ")").replace(/rgba/i, "rgb"),

	    WHITE_INDEX  = -2,
	    WHITE2_INDEX = -3,
	    WHITE3_INDEX = -4,
	    BLACK_INDEX  = -5,
	    BLACK2_INDEX = -6,
	    BLACK3_INDEX = -7,

	    MIN_BLACK = 68,
	    MIN_WHITE = 224,
	    MAX_DIFF  = 9,

	    TEXT_COLOR_MIN_CONTRAST                =  9,
	    TEXT_COLOR_MAX_CONTRAST                = 17,
	    COLOR_TEXT_COLOR_MIN_CONTRAST          =  6,
	    ON_BLACK_COLOR_TEXT_COLOR_MAX_CONTRAST = 14,
	    SPECIAL_COLOR_MIN_CONTRAST             =  5,
	    SPECIAL_COLOR_MAX_CONTRAST             = 17,
	    ON_BLACK_SPECIAL_COLOR_MAX_CONTRAST    = 14,

	    getRgbString = function (color) {
	        return  "rgb(" + color.red() + ", " + color.green() + ", " + color.blue() + ")";
	    },

	    getLuminance = function (color) {

	        var rgba = [
	                color.color.r,
	                color.color.g,
	                color.color.b
	            ],

	            i = 0;

	        for (i; i < 3; i++) {

	            var rgb = rgba[i];

	            rgb /= 255;

	            rgb = rgb < 0.03928 ? rgb / 12.92 : Math.pow((rgb + 0.055) / 1.055, 2.4);

	            rgba[i] = rgb;
	        }

	        return 0.2126 * rgba[0] + 0.7152 * rgba[1] + 0.0722 * rgba[2];
	    },

	    calcContrastRatio = function (color1, color2) {

	        var l1 = getLuminance(color1) + 0.05,
	            l2 = getLuminance(color2) + 0.05,

	            ratio = l1 / l2;

	        if (l2 > l1) {

	            ratio = 1 / ratio;
	        }

	        return Math.round(ratio * 100) / 100;
	    },

	    //najde barvu s dostatečným kontrastem k dané barvě (i)
	    //minContrast (number) + random (number) se použijí pro "náhodné" vyhledledání barvy, která má dostatečný kontrast
	    //fn (<- boolean) slouží k určení, jestli se má nalezená barva použít (true)
	    findColorWithGoodContrast = function (i, minContrast, maxContrast, random, fn) {

	        maxContrast = maxContrast || 21;

	        random = random || 0;

	        var colors = this.currentPalette.colors[i].sorted,
	            c2 = colors.length - 1,

	            contrast = 0,
	            colorIndex = -1,

	            goodContrastColorsCount = 0;

	        for (c2; c2 >= 0; c2--) {

	            if (!fn || fn.call(this, i, colors[c2])) {

	                var thisContrast = this.currentPalette.colors[i]["contrastWith" + colors[c2]];

	                if (thisContrast >= minContrast && thisContrast <= maxContrast) {

	                    this.currentPalette.colors[i].hue        = typeof this.currentPalette.colors[i].hue          !== "undefined" ? this.currentPalette.colors[i].hue : this.currentPalette.colors[i].color.hue();
	                    this.currentPalette.colors[i].saturation = typeof this.currentPalette.colors[i].saturation          !== "undefined" ? this.currentPalette.colors[i].saturation : this.currentPalette.colors[i].color.saturation();

	                    this.currentPalette.colors[colors[c2]].hue        = typeof this.currentPalette.colors[colors[c2]].hue !== "undefined" ? this.currentPalette.colors[colors[c2]].hue : this.currentPalette.colors[colors[c2]].color.hue();
	                    this.currentPalette.colors[colors[c2]].saturation = typeof this.currentPalette.colors[colors[c2]].saturation !== "undefined" ? this.currentPalette.colors[colors[c2]].saturation : this.currentPalette.colors[colors[c2]].color.saturation();

	                    var iHue = this.currentPalette.colors[i].hue,
	                        cHue = this.currentPalette.colors[colors[c2]].hue,
	                        iSat = this.currentPalette.colors[i].saturation,
	                        cSat = this.currentPalette.colors[colors[c2]].saturation;

	                    //odstranit červenou na zelené
	                    if (iSat > 0.05 && cSat > 0.05 && ((iHue > 75 && iHue < 145) || (cHue > 75 && cHue < 145)) && ((iHue > 325 || iHue < 25) || (cHue > 325 || cHue < 25))) {

	                        if (!(this.currentPalette.colors[i].isDark || this.currentPalette.colors[colors[c2]].isDark)) {

	                            continue;
	                        }
	                    }

	                    contrast = thisContrast;
	                    colorIndex = colors[c2];

	                    if (Math.abs(random + i) % 4 === goodContrastColorsCount) {

	                        break;
	                    }

	                    goodContrastColorsCount++;
	                }
	            }
	        }

	        return {
	            contrast: contrast,
	            index: colorIndex
	        };
	    },

	    //najde kontrast barvy k bílé a černé
	    addBlackWhiteContrast = function (i) {

	        this.currentPalette.colors[i].contrastWithBlack       = calcContrastRatio(BLACK, this.currentPalette.colors[i].color);
	        this.currentPalette.colors[i].contrastWithBlackColor  = BLACK_RGB;
	        this.currentPalette.colors[i].contrastWithBlackIndex  = BLACK_INDEX;
	        this.currentPalette.colors[i].contrastWithBlackOk     = this.currentPalette.colors[i].contrastWithBlack >= TEXT_COLOR_MIN_CONTRAST;

	        if (this.currentPalette.colors[i].contrastWithBlack > TEXT_COLOR_MIN_CONTRAST) {

	            this.currentPalette.colors[i].contrastWithBlack2      = calcContrastRatio(BLACK2, this.currentPalette.colors[i].color);
	            this.currentPalette.colors[i].contrastWithBlack2Color = BLACK2_RGB;
	            this.currentPalette.colors[i].contrastWithBlack2Index = BLACK2_INDEX;
	            this.currentPalette.colors[i].contrastWithBlack2Ok    = this.currentPalette.colors[i].contrastWithBlack2 >= TEXT_COLOR_MIN_CONTRAST;

	            if (this.currentPalette.colors[i].contrastWithBlack2 > TEXT_COLOR_MIN_CONTRAST) {

	                this.currentPalette.colors[i].contrastWithBlack3      = calcContrastRatio(BLACK3, this.currentPalette.colors[i].color);
	                this.currentPalette.colors[i].contrastWithBlack3Color = BLACK3_RGB;
	                this.currentPalette.colors[i].contrastWithBlack3Index = BLACK3_INDEX;
	                this.currentPalette.colors[i].contrastWithBlack3Ok    = this.currentPalette.colors[i].contrastWithBlack3 >= TEXT_COLOR_MIN_CONTRAST;
	            }
	        }

	        this.currentPalette.colors[i].contrastWithWhite       = calcContrastRatio(WHITE, this.currentPalette.colors[i].color);
	        this.currentPalette.colors[i].contrastWithWhiteColor  = WHITE_RGB;
	        this.currentPalette.colors[i].contrastWithWhiteIndex  = WHITE_INDEX;
	        this.currentPalette.colors[i].contrastWithWhiteOk     = this.currentPalette.colors[i].contrastWithWhite >= TEXT_COLOR_MIN_CONTRAST;

	        if (this.currentPalette.colors[i].contrastWithWhite > TEXT_COLOR_MIN_CONTRAST) {

	            this.currentPalette.colors[i].contrastWithWhite2      = calcContrastRatio(WHITE2, this.currentPalette.colors[i].color);
	            this.currentPalette.colors[i].contrastWithWhite2Color = WHITE2_RGB;
	            this.currentPalette.colors[i].contrastWithWhite2Index = WHITE2_INDEX;
	            this.currentPalette.colors[i].contrastWithWhite2Ok    = this.currentPalette.colors[i].contrastWithWhite2 >= TEXT_COLOR_MIN_CONTRAST;

	            if (this.currentPalette.colors[i].contrastWithWhite2 > TEXT_COLOR_MIN_CONTRAST) {

	                this.currentPalette.colors[i].contrastWithWhite3      = calcContrastRatio(WHITE3, this.currentPalette.colors[i].color);
	                this.currentPalette.colors[i].contrastWithWhite3Color = WHITE3_RGB;
	                this.currentPalette.colors[i].contrastWithWhite3Index = WHITE3_INDEX;
	                this.currentPalette.colors[i].contrastWithWhite3Ok    = this.currentPalette.colors[i].contrastWithWhite3 >= TEXT_COLOR_MIN_CONTRAST;
	            }
	        }
	    },

	    addTextColor = function (i) {

	        //pokud je barva bílá (= pozadí je bílé) a nemá se automaticky použít černá
	        //nebo pokud je barva černá a nemá se automaticky použít bílá
	        //vyhledá se barva s nejvyšším kontrastem
	        if ((this.currentPalette.colors[i].isWhite && (i + 1) % this.useBlackTextForWhite > 1) || (this.currentPalette.colors[i].isBlack && (i + 1) % this.useColorTextForBlack > 1)) {

	            var highestContrastColor = findColorWithGoodContrast.call(this, i, COLOR_TEXT_COLOR_MIN_CONTRAST, this.currentPalette.colors[i].isBlack || this.currentPalette.colors[i].isDark ? ON_BLACK_COLOR_TEXT_COLOR_MAX_CONTRAST : TEXT_COLOR_MAX_CONTRAST, this.randomTextColorFactor);

	            //pokud nejvyšší kontrast není dostatečný, použije se černá/bílá
	            if (highestContrastColor.contrast >= COLOR_TEXT_COLOR_MIN_CONTRAST) {

	                this.currentPalette.colors[i].textColor    = this.currentPalette.colors[highestContrastColor.index].self;
	                this.currentPalette.colors[i].textColorRef = highestContrastColor.index;

	                return;
	            }
	        }

	        //pokud je černá kontrastnější než bílá, použije se "nejsvětlejší černá"
	        var black = (this.currentPalette.colors[i].contrastWithBlack3Ok && 3) || (this.currentPalette.colors[i].contrastWithBlack2Ok && 2) || "",
	            white = (this.currentPalette.colors[i].contrastWithWhite3Ok && 3) || (this.currentPalette.colors[i].contrastWithWhite2Ok && 2) || "",

	            blackContrast = this.currentPalette.colors[i]["contrastWithBlack" + black],
	            whiteContrast = this.currentPalette.colors[i]["contrastWithWhite" + white],
	            blackColor    = this.currentPalette.colors[i]["contrastWithBlack" + black + "Color"],
	            whiteColor    = this.currentPalette.colors[i]["contrastWithWhite" + white + "Color"],
	            blackIndex    = this.currentPalette.colors[i]["contrastWithBlack" + black + "Index"],
	            whiteIndex    = this.currentPalette.colors[i]["contrastWithWhite" + white + "Index"];

	        this.currentPalette.colors[i].textColor    = blackContrast > whiteContrast ? blackColor : whiteColor;
	        this.currentPalette.colors[i].textColorRef = blackContrast > whiteContrast ? blackIndex : whiteIndex;
	    },

	    //vzájemný kontrast barev (ignoruje se přidaná bílá, jinak by měla vždy nejvyšší kontrast)
	    addColorContrast = function (i, colors) {

	        var c2 = colors.length - 1;

	        for (c2; c2 >= 0; c2--) {

	            if ((i !== c2 && c2 !== colors.length - 1) || !this.whiteAdded) {

	                this.currentPalette.colors[i]["contrastWith" + c2] = calcContrastRatio(
	                    this.currentPalette.colors[c2].color, this.currentPalette.colors[i].color
	                );
	            }
	        }
	    },

	    addSpecialColor = function (i) {

	        //najít barvu s nejvyšším kontrastem; jinou než použitou pro text
	        var highestContrastColor = findColorWithGoodContrast.call(this, i, SPECIAL_COLOR_MIN_CONTRAST, this.currentPalette.colors[i].isBlack || this.currentPalette.colors[i].isDark ? ON_BLACK_SPECIAL_COLOR_MAX_CONTRAST : SPECIAL_COLOR_MAX_CONTRAST, this.randomSpecialColorFactor, function (i, i2) {
	            return this.currentPalette.colors[i2].self !== this.currentPalette.colors[i].textColor;
	        });

	        if (highestContrastColor.contrast < SPECIAL_COLOR_MIN_CONTRAST) {

	            this.currentPalette.colors[i].specialColor    = this.currentPalette.colors[i].textColor;
	            this.currentPalette.colors[i].specialColorRef = this.currentPalette.colors[i].textColorRef;

	        } else {

	            this.currentPalette.colors[i].specialColor    = this.currentPalette.colors[highestContrastColor.index].self;
	            this.currentPalette.colors[i].specialColorRef = highestContrastColor.index;
	        }
	    },

	    sortColorContrastByContrast = function (i) {

	        var keys = Object.keys(this.currentPalette.colors[i]);

	        keys.sort(function (a, b) {

	            if (!a.match(/contrastWith[0-9]+/)) {

	                return 1;
	            }

	            if (!b.match(/contrastWith[0-9]+/)) {

	                return -1;
	            }

	            return this.currentPalette.colors[i][b] - this.currentPalette.colors[i][a];

	        }.bind(this));

	        this.currentPalette.colors[i].sorted = [];

	        var k = 0;

	        for (k; k < keys.length; k++) {

	            var prop = keys[k].match(/contrastWith([0-9])+/);

	            if (prop) {

	                this.currentPalette.colors[i].sorted.push(+prop[1]);

	            } else {

	                break;
	            }
	        }
	    },

	    addWhiteToPalette = function (colors) {

	        var c = colors.length - 1;

	        this.whiteAdded = true;

	        for (c; c >= 0; c--) {

	            if (this.equals(colors[c], WHITE_RGB)) {

	                this.whiteAdded = false;

	                break;
	            }
	        }

	        if (this.whiteAdded) {

	            colors.push(WHITE_RGB);
	        }
	    },

	    findInOldColors = function (color) {

	        var oC = this.oldCount - 1;

	        for (oC; oC >= 0; oC--) {

	            if (color === this.oldColors[oC].self) {

	                return oC;
	            }
	        }

	        return false;
	    },

	    copyOldColorData = function (o, c) {

	        this.currentPalette.colors[c].color   = this.oldColors[o].color;
	        this.currentPalette.colors[c].self    = this.oldColors[o].self;
	        this.currentPalette.colors[c].isBlack = this.oldColors[o].isBlack;
	        this.currentPalette.colors[c].isWhite = this.oldColors[o].isWhite;
	        this.currentPalette.colors[c].isDark  = this.oldColors[o].isDark;

	        this.currentPalette.colors[c].contrastWithBlack       = this.oldColors[o].contrastWithBlack;
	        this.currentPalette.colors[c].contrastWithBlackColor  = this.oldColors[o].contrastWithBlackColor;
	        this.currentPalette.colors[c].contrastWithBlackIndex  = this.oldColors[o].contrastWithBlackIndex;
	        this.currentPalette.colors[c].contrastWithBlackOk     = this.oldColors[o].contrastWithBlackOk;

	        this.currentPalette.colors[c].contrastWithBlack2      = this.oldColors[o].contrastWithBlack2;
	        this.currentPalette.colors[c].contrastWithBlack2Color = this.oldColors[o].contrastWithBlack2Color;
	        this.currentPalette.colors[c].contrastWithBlack2Index = this.oldColors[o].contrastWithBlack2Index;
	        this.currentPalette.colors[c].contrastWithBlack2Ok    = this.oldColors[o].contrastWithBlack2Ok;

	        this.currentPalette.colors[c].contrastWithBlack3      = this.oldColors[o].contrastWithBlack3;
	        this.currentPalette.colors[c].contrastWithBlack3Color = this.oldColors[o].contrastWithBlack3Color;
	        this.currentPalette.colors[c].contrastWithBlack3Index = this.oldColors[o].contrastWithBlack3Index;
	        this.currentPalette.colors[c].contrastWithBlack3Ok    = this.oldColors[o].contrastWithBlack3Ok;

	        this.currentPalette.colors[c].contrastWithWhite       = this.oldColors[o].contrastWithWhite;
	        this.currentPalette.colors[c].contrastWithWhiteColor  = this.oldColors[o].contrastWithWhiteColor;
	        this.currentPalette.colors[c].contrastWithWhiteIndex  = this.oldColors[o].contrastWithWhiteIndex;
	        this.currentPalette.colors[c].contrastWithWhiteOk     = this.oldColors[o].contrastWithWhiteOk;

	        this.currentPalette.colors[c].contrastWithWhite2      = this.oldColors[o].contrastWithWhite2;
	        this.currentPalette.colors[c].contrastWithWhite2Color = this.oldColors[o].contrastWithWhite2Color;
	        this.currentPalette.colors[c].contrastWithWhite2Index = this.oldColors[o].contrastWithWhite2Index;
	        this.currentPalette.colors[c].contrastWithWhite2Ok    = this.oldColors[o].contrastWithWhite2Ok;

	        this.currentPalette.colors[c].contrastWithWhite3      = this.oldColors[o].contrastWithWhite3;
	        this.currentPalette.colors[c].contrastWithWhite3Color = this.oldColors[o].contrastWithWhite3Color;
	        this.currentPalette.colors[c].contrastWithWhite3Index = this.oldColors[o].contrastWithWhite3Index;
	        this.currentPalette.colors[c].contrastWithWhite3Ok    = this.oldColors[o].contrastWithWhite3Ok;

	        this.currentPalette.colors[c].hue        = this.oldColors[o].hue;
	        this.currentPalette.colors[c].saturation = this.oldColors[o].saturation;
	    },

	    createNewColorBase = function (i, color) {

	        this.currentPalette.colors[i].color   = new Spectra(color);
	        //textová reprezentace barvy
	        this.currentPalette.colors[i].self    = getRgbString(this.currentPalette.colors[i].color);

	        var rgb = [this.currentPalette.colors[i].color.red(), this.currentPalette.colors[i].color.green(), this.currentPalette.colors[i].color.blue()];

	        this.currentPalette.colors[i].isBlack = typeof this.currentPalette.colors[i].isBlack !== "undefined" ? this.currentPalette.colors[i].isBlack : (rgb[0] <= MIN_BLACK && rgb[1] <= MIN_BLACK && rgb[2] <= MIN_BLACK && Math.abs(rgb[0] - rgb[1]) <= MAX_DIFF && Math.abs(rgb[0] - rgb[2]) <= MAX_DIFF) || this.currentPalette.colors[i].color.near(BLACK, 10) || this.currentPalette.colors[i].color.near(BLACK2, 10);
	        this.currentPalette.colors[i].isWhite = typeof this.currentPalette.colors[i].isWhite !== "undefined" ? this.currentPalette.colors[i].isWhite : (rgb[0] >= MIN_WHITE && rgb[1] >= MIN_WHITE && rgb[2] >= MIN_WHITE && Math.abs(rgb[0] - rgb[1]) <= MAX_DIFF && Math.abs(rgb[0] - rgb[2]) <= MAX_DIFF) || this.currentPalette.colors[i].color.near(WHITE, 10) || this.currentPalette.colors[i].color.near(WHITE2, 10) || this.currentPalette.colors[i].color.near(WHITE3, 10);
	        this.currentPalette.colors[i].isDark  = typeof this.currentPalette.colors[i].isDark  !== "undefined" ? this.currentPalette.colors[i].isDark  : this.currentPalette.colors[i].color.near(BLACK, 25);
	    },

	    processPalette = function (palette, doNotRewrite, singleColorChanged) {

	        var colors = palette.colors.slice();

	        //přidání bílé barvy, aby mohly vznikat i sekce s bílým pozadím
	        addWhiteToPalette.call(this, colors);

	        this.oldColors = this.currentPalette.colors || [];
	        this.oldCount = Object.keys(this.oldColors).length;

	        var c = colors.length - 1;

	        this.currentPalette.colors = {};

	        for (c; c >= 0; c--) {

	            this.currentPalette.colors[c] = {};

	            var inOld = findInOldColors.call(this, colors[c]);

	            if (inOld === false) {

	                createNewColorBase.call(this, c, colors[c]);

	                addBlackWhiteContrast.call(this, c);

	            } else {

	                copyOldColorData.call(this, inOld, c);
	            }
	        }

	        c = colors.length - 1;

	        for (c; c >= 0; c--) {

	            addColorContrast.call(this, c, colors);

	            sortColorContrastByContrast.call(this, c);
	        }

	        c = colors.length - 1;

	        for (c; c >= 0; c--) {

	            addTextColor.call(this, c);
	        }

	        c = colors.length - 1;

	        for (c; c >= 0; c--) {

	            addSpecialColor.call(this, c);
	        }

	        if (!doNotRewrite) {

	            var prevSection = null;

	            this.page.forEachPageSectionByIndex(function (section) {

	                section.handleDefaultColorsChanged(this, !!singleColorChanged, prevSection);

	                prevSection = section;

	            }.bind(this));
	        }
	    },

	    DefaultColorsGenerator = function DefaultColorsGenerator(pageComponent, initPalette) {

	        this.page = pageComponent;

	        this.initPalette = initPalette;

	        this.init();
	    };

	DefaultColorsGenerator.prototype.reset = function () {

	    this.destroy();

	    this.init();
	};

	DefaultColorsGenerator.prototype.destroy = function () {

	    this.currentPalette = null;

	    this.colorsSettingsObserver.cancel();
	};

	DefaultColorsGenerator.prototype.init = function () {

	    this.currentPalette = {};

	    this.useBlackTextForWhite     = this.page.get("page.settings.colorPalette.useBlackTextForWhite");
	    this.useColorTextForBlack     = this.page.get("page.settings.colorPalette.useColorTextForBlack");
	    this.randomTextColorFactor    = this.page.get("page.settings.colorPalette.randomTextColorFactor");
	    this.randomSpecialColorFactor = this.page.get("page.settings.colorPalette.randomSpecialColorFactor");

	    this.useBlackTextForWhite     = typeof this.useBlackTextForWhite     === "number" ? this.useBlackTextForWhite     : 1;
	    this.useColorTextForBlack     = typeof this.useColorTextForBlack     === "number" ? this.useColorTextForBlack     : 1;
	    this.randomTextColorFactor    = typeof this.randomTextColorFactor    === "number" ? this.randomTextColorFactor    : 0;
	    this.randomSpecialColorFactor = typeof this.randomSpecialColorFactor === "number" ? this.randomSpecialColorFactor : 3;

	    processPalette.call(this, this.initPalette, true);

	    this.colorsSettingsObserver = this.page.observe("page.settings.colorPalette", function (newValue, oldValue) {

	        if (!oldValue || this.skipObserver) {

	            return;
	        }

	        var singleColorChanged = newValue === oldValue;

	        if (!singleColorChanged) {

	            this.useBlackTextForWhite     = Math.round(Math.random() * 3) + 2; //plus 2, protože index se zvyžuje o 1, aby nebyl vždy 0
	            this.useColorTextForBlack     = Math.round(Math.random() * 3) + 2; //plus 2, protože index se zvyžuje o 1, aby nebyl vždy 0
	            this.randomTextColorFactor    = Math.round(Math.random() * 3);
	            this.randomSpecialColorFactor = Math.round(Math.random() * 3);

	            this.skipObserver = true;

	            this.page.set("page.settings.colorPalette.useBlackTextForWhite",    this.useBlackTextForWhite);
	            this.page.set("page.settings.colorPalette.useColorTextForBlack",    this.useColorTextForBlack);
	            this.page.set("page.settings.colorPalette.randomTextColorFactor",   this.randomTextColorFactor);
	            this.page.set("page.settings.colorPalette.randomSpecialColorFactor",this.randomSpecialColorFactor);

	            this.skipObserver = false;
	        }

	        processPalette.call(this, newValue, false, singleColorChanged);


	    }.bind(this), {init: false});
	};

	//vrátí náhodou (nebo podle indexu) skupinu paletu
	DefaultColorsGenerator.prototype.getColors = function (index) {

	    if (!this.currentPalette.colors) {

	        processPalette.call(this, this.initPalette, true);
	    }

	    index = typeof index !== "undefined" ? index : Math.round(Math.random() * (Object.keys(this.currentPalette.colors).length - 1));

	    var colors = this.currentPalette.colors[index];

	    return {
	        backgroundColor   : colors.self,
	        textColor         : colors.textColor,
	        specialColor      : colors.specialColor,
	        backgroundColorRef: index
	    };
	};

	//vrátí barvu podle indexu
	DefaultColorsGenerator.prototype.getColor = function (index) {

	    if (!this.currentPalette.colors) {

	        processPalette.call(this, this.initPalette, true);
	    }

	    switch (index) {
	        case WHITE_INDEX : return WHITE_RGB;
	        case WHITE2_INDEX: return WHITE2_RGB;
	        case WHITE3_INDEX: return WHITE3_RGB;
	        case BLACK_INDEX : return BLACK_RGB;
	        case BLACK2_INDEX: return BLACK2_RGB;
	        case BLACK3_INDEX: return BLACK3_RGB;
	        default: return this.currentPalette.colors[index] ? this.currentPalette.colors[index].self : this.currentPalette.colors[this.indexOf(WHITE_RGB)].self;
	    }
	};

	//vrátí barvu textu k dané barvě (index)
	DefaultColorsGenerator.prototype.getTextColor = function (index) {

	    if (!this.currentPalette.colors) {

	        processPalette.call(this, this.initPalette, true);
	    }

	    return this.currentPalette.colors[index] ? this.currentPalette.colors[index].textColor : this.currentPalette.colors[this.indexOf(WHITE_RGB)].textColor;
	};

	//vrátí speciální barvu k dané barvě (index)
	DefaultColorsGenerator.prototype.getSpecialColor = function (index) {

	    if (!this.currentPalette.colors) {

	        processPalette.call(this, this.initPalette, true);
	    }

	    return this.currentPalette.colors[index] ? this.currentPalette.colors[index].specialColor : this.currentPalette.colors[this.indexOf(WHITE_RGB)].specialColor;
	};

	//najde index barvy (color)
	DefaultColorsGenerator.prototype.indexOf = function (color) {

	    if (!this.currentPalette.colors || typeof color !== "string") {

	        return -1;
	    }

	    var c = Object.keys(this.currentPalette.colors).length - 1;

	    for (c; c >= 0; c--) {

	        if (this.equals(this.currentPalette.colors[c].self, color)) {

	            return c;
	        }
	    }

	    return -1;
	};

	//zjistí, jestli jsou barvy shodné | barvy musí být ve formátu: rgb(0, 0, 0)
	DefaultColorsGenerator.prototype.equals = function (color1, color2) {

	    return color1.replace(/\s/g, "") === color2.replace(/\s/g, "");
	};

	module.exports = DefaultColorsGenerator;


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	/*global $*/
	var U = __webpack_require__(4);
	var CLASS = __webpack_require__(30);

	var SuperEditor = __webpack_require__(33);

	var ContentEditor = function ContentEditor() {

	    SuperEditor.apply(this, arguments);
	};

	U.extend(ContentEditor, SuperEditor);

	ContentEditor.prototype.configure = function () {

	    this.options = {

	        anchor: {
	            linkValidation: true
	        },
	        anchorPreview: false,

	        disableExtraSpaces: true,
	        disableDoubleReturn: true,

	        imageDragging: false,
	        placeholder: false,
	        keyboardCommands: false,

	        buttonLabels: "fontawesome",

	        toolbar: {
	            buttons: [
	                SuperEditor.BUTTONS.H2,
	                SuperEditor.BUTTONS.OL,
	                SuperEditor.BUTTONS.UL,
	                SuperEditor.BUTTONS.B,
	                SuperEditor.BUTTONS.I,
	                SuperEditor.BUTTONS.A,
	                SuperEditor.BUTTONS.SUB,
	                SuperEditor.BUTTONS.SUP
	            ]
	        }
	    };
	};

	ContentEditor.prototype.init = function () {

	    SuperEditor.prototype.init.apply(this, arguments);

	    if (!this.editor.elements.length) {

	        return;
	    }

	    this.editor.subscribe("editableKeydownEnter", function () {
	        this.editableKeydownEnter = true;
	    }.bind(this));

	    this.editor.subscribe("editableInput", function (e, editorElement) {

	        this.cleanPInH2AndH2InP.apply(this, arguments);

	        if (!this.editableKeydownEnter) {

	            return;
	        }

	        this.editableKeydownEnter = false;

	        setTimeout(function() {

	            try {

	                var data = this.checkIfListShouldBeCreated.apply(this, arguments);

	                if (data) {

	                    this.createList(data, editorElement);
	                }
	            } catch (e) {}
	        }.bind(this), 0);

	    }.bind(this));
	};

	ContentEditor.prototype.checkIfListShouldBeCreated = function () {

	    var anchor = document.getSelection().anchorNode;

	    anchor = SuperEditor.MediumEditor.util.getClosestBlockContainer(anchor);

	    var testedElement,
	        removeNext; //smazat element ("enter"), který následuje po testovaném

	    //Chrome fix - někdy se může text nacházet v <div />
	    if (anchor && anchor !== this.editor.getFocusedElement() && anchor.querySelector("div")) {

	        anchor =  anchor.querySelector("div");

	        testedElement = "self";

	        removeNext = true;

	    } else if (anchor === this.editor.getFocusedElement() && anchor.children[0] && !anchor.children[0].tagName.match(/h2/i) && !anchor.children[0].querySelector("h2")) {

	        testedElement = "self";

	    } else if (anchor.previousElementSibling && !anchor.previousElementSibling.tagName.match(/li|h2/i) && !anchor.previousElementSibling.querySelector("li, h2")) {

	        testedElement = "prev";
	    }

	    if (!testedElement) {

	        return false;
	    }

	    var testedText = (testedElement === "self" ? anchor : anchor.previousElementSibling).innerText.trim(),

	        matchesUl = testedText.match(/^-/),
	        matchesOl = testedText.match(/^[0-9]+(?:\. ?\)?| ?\))/);/*1., 1.), 1. ), 1), 1 )*/

	    return matchesUl || matchesOl ? {
	        ul: matchesUl,
	        ol: matchesOl,
	        anchor: anchor,
	        testedElement: testedElement,
	        removeNext: removeNext
	    } : false;
	};

	ContentEditor.prototype.createList = function (data, editorElement) {

	    this.$toolbar.css({
	        animationDuration: "0s"
	    });

	    //označit předchozí text
	    this.editor.selectElement((data.testedElement === "self" ? data.anchor : data.anchor.previousElementSibling));

	    //vložit seznam
	    this.editor.execAction(data.ul ? "insertunorderedlist" : "insertorderedlist");

	    //najít vytvořený li
	    var li = (data.testedElement === "self" ? data.anchor : data.anchor.previousElementSibling || editorElement).querySelector("li:last-child");

	    //odstranit znak určiující, že jde o seznam
	    li.innerText = li.innerText.replace(data.ul ? /^\s*-\s*/ : /^\s*[0-9]+(?:\. ?\)?| ?\))\s*/, "");

	    //přidat nový li
	    if ((data.testedElement === "self" ? data.anchor : data.anchor.previousElementSibling || editorElement).querySelectorAll("li").length === 1) {

	        li.outerHTML += "<li></li>";
	    }

	    //vybrat poslední li
	    this.editor.selectElement((data.testedElement === "self" ? data.anchor : data.anchor.previousElementSibling || editorElement).querySelector("li:last-child"));

	    var selected = this.editor.getSelectedParentElement();

	    //přesunout kurzor na konec posledního li
	    document.getSelection().collapse(selected, selected.innerText.length ? 1 : 0);

	    //smazat polední enter
	    if (data.anchor !== this.editor.getFocusedElement()) {

	        (data.testedElement === "self" ? data.anchor : data.anchor.previousElementSibling || editorElement).parentNode.removeChild(data.removeNext ? data.anchor.nextElementSibling : data.anchor);
	    }

	    this.$toolbar.css({
	        animationDuration: ""
	    });

	};

	ContentEditor.prototype.cleanPInH2AndH2InP = function (e, editorElement) {

	    var $editorElement = $(editorElement),

	        $pInH2 = $editorElement.find("h2 p");

	    if ($pInH2.length) {

	        $pInH2.unwrap();

	        this.editor.selectElement($pInH2[0]);

	        return;
	    }

	    var $h2InP = $editorElement.find("p h2");

	    if ($h2InP.length) {

	        $h2InP.unwrap();

	        this.editor.selectElement($h2InP[0]);

	        return;
	    }

	};

	module.exports = ContentEditor;


/***/ },
/* 77 */
/***/ function(module, exports) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	/*global $, PerfectScrollbar*/

	(function (root, factory) {

	    if (typeof module === 'object' && module.exports) {

	        module.exports = factory();

	    } else {

	        root.MediumEditorAnchor = factory();
	    }

	}(this, function () {

	    return function (MediumEditor) {

	        MediumEditor.extensions.anchor.prototype.getTemplate = function () {

	            var template = [];

	            /*Přepínač tabů*/
	            var hideFormElement = "position: absolute; top: 0px; left: 0px; opacity: 0; z-index: -1;";

	            template.push(
	                '<input type="radio" checked style="', hideFormElement, '" id="medium-editor-open-tab-1-', this.base.id, '" name="medium-editor-open-tab-', this.base.id ,'"/>',
	                '<input type="radio" style="', hideFormElement, '" id="medium-editor-open-tab-2-', this.base.id, '" name="medium-editor-open-tab-', this.base.id, '"/>',
	                '<div class="medium-editor-form-nav">',
	                    '<label class="medium-editor-form-open-tab" for="medium-editor-open-tab-1-', this.base.id, '">Odkaz</label>',
	                    '<label class="medium-editor-form-open-tab" for="medium-editor-open-tab-2-', this.base.id, '">Sekce</label>',
	                    '<a class="medium-editor-form-nav-close" href="#"><svg><use xlink:href="#icon-x"></use></svg></a>',
	                '</div>'
	            );

	            /*Taby*/
	            template.push(
	                '<div class="medium-editor-form-tabs">'
	            );

	            /*Vložení odkazu*/
	            template.push(
	                '<div class="medium-editor-form-tab medium-editor-form-tab-anchor">'
	            );

	            var inputId = "medium-editor-toolbar-input-" + this.base.id;

	            template.push(
	                '<label for="', inputId, '">Odkaz, email, telefon:</label>',
	                '<input type="text" id="', inputId, '" class="medium-editor-toolbar-input" placeholder="blog.cz, email@web.cz, &hellip;">'
	            );

	            /*Tlačítka*/
	            template.push(
	                '<div class="medium-editor-form-btns">'
	            );

	            //uložit
	            template.push(
	                '<span class="medium-editor-toolbar-save">',
	                    '<span class="Button Button__small Button__ok Button__normal" tabindex="1" role="button">',
	                        '<span class="Button--content">',
	                            '<span class="Button--icon">',
	                                '<svg><use xlink:href="#icon-check-mark"></use></svg>',
	                            '</span>',
	                            '<span class="Button--text">Použít</span> ',
	                        '</span>',
	                    '</span>',
	                '</span>'
	            );

	            //zavřít
	            template.push(
	                '<span class="medium-editor-toolbar-close">',
	                    '<span class="Button Button__small Button__danger Button__normal" tabindex="2" role="button">',
	                        '<span class="Button--content">',
	                            '<span class="Button--icon" style="width: 14px; height: 14px;">',
	                                '<svg><use xlink:href="#icon-x"></use></svg>',
	                            '</span>',
	                            '<span class="Button--text">Zavřít</span> ',
	                        '</span>',
	                    '</span>',
	                '</span>'
	            );

	            template.push(
	                '</div>'//form-btns
	            );

	            template.push(
	                '</div>'//tab-anchor
	            );

	            /*Výběr sekcí*/
	            template.push(
	                '<div class="medium-editor-form-tab medium-editor-form-tab-section">'
	            );


	            this.selectId = "medium-editor-toolbar-section-select-" + this.base.id;
	            this.customSelectorId = "medium-editor-form-selector-" + this.base.id;

	            //získání sekcí stránky
	            var options = this.getSections ? this.getSections() : [],

	                optionsTemplate = [
	                    '<option value="">nevybráno...</option>'
	                ],

	                customSelectorTemplate = [
	                    '<div id="', this.customSelectorId, '" class="medium-editor-form-selector">'
	                ];


	            options.forEach(function (section) {

	                optionsTemplate.push(
	                    '<option value="#', section.internalId, '">', section.name, '</option>'
	                );

	                customSelectorTemplate.push(
	                    '<div class="medium-editor-form-selector-option" data-value="#', section.internalId, '">', $("<span>").html(section.name).text(), '</div>'
	                );
	            });

	            customSelectorTemplate.push(
	                "</div>"//selector
	            );

	            //přidání výběru sekcí do templatu
	            template.push(
	                '<select style="', hideFormElement, '" class="medium-editor-toolbar-section-select" id="', this.selectId, '">',
	                    optionsTemplate.join(""),
	                '</select>',
	                customSelectorTemplate.join("")
	            );

	            template.push(
	                '</div>'//tab-section
	            );

	            template.push(
	                '</div>'//tabs
	            );

	            return template.join('');
	        };


	        MediumEditor.extensions.anchor.prototype._getFormOpts = MediumEditor.extensions.anchor.prototype.getFormOpts;

	        MediumEditor.extensions.anchor.prototype.getFormOpts = function () {

	            var opts = MediumEditor.extensions.anchor.prototype._getFormOpts.apply(this, arguments);

	            //pokud není zadán odkaz použije se hodnota selektu
	            if (!this.getInput().value.trim()) {

	                opts.url = this.getSelect().value;

	                this.getSelect().value = "";

	            } else {

	                //odkazy, které se neodkazují na interní sekce, se otevírají v novém okně (tabu)
	                opts.target = '_blank';
	            }

	            return opts;
	        };

	        //vrátí se <select /> sekcí stránky
	        MediumEditor.extensions.anchor.prototype.getSelect = function () {

	            return this.getForm().querySelector('select.medium-editor-toolbar-section-select');
	        };

	        MediumEditor.extensions.anchor.prototype._destroy = MediumEditor.extensions.anchor.prototype.destroy;

	        MediumEditor.extensions.anchor.prototype.destroy = function () {

	            var original = MediumEditor.extensions.anchor.prototype._destroy.apply(this, arguments);

	            if (this.customSelectorEventNames) {

	                this.$customSelector.off(this.customSelectorEventNames);

	                this.$customSelector = null;
	                this.$select = null;
	            }

	            return original;
	        };

	        MediumEditor.extensions.anchor.prototype._showForm = MediumEditor.extensions.anchor.prototype.showForm;

	        MediumEditor.extensions.anchor.prototype.showForm = function () {

	            MediumEditor.extensions.anchor.prototype._showForm.apply(this, arguments);

	            var self = this;

	            this.customSelectorEventNames = "click.medium-editor-form-selector-" + this.base.id + " touchend.medium-editor-form-selector-" + this.base.id + " touchmove.medium-editor-form-selector-" + this.base.id;
	            this.formNavCloseEventNames = "click.medium-editor-form-nav-close-" + this.base.id + " touchend.medium-editor-form-nav-close-" + this.base.id;
	            this.$customSelector = this.$customSelector || $("#" + this.customSelectorId);
	            this.$firstTabOpen = this.$firstTabOpen || $(this.getForm()).find("[id*='medium-editor-open-tab-1']");
	            this.$formNavClose = this.$formNavClose || $(this.getForm()).find(".medium-editor-form-nav-close");

	            //otevřít první tab
	            this.$firstTabOpen.prop("checked", "checked");

	            //vlastní zavírací tlačítko
	            this.$formNavClose.on(this.formNavCloseEventNames, function (e) {

	                self.doFormCancel();

	                e.preventDefault();
	                return false;
	            });

	            var moved = false;

	            //aktivace vlastního selektrou sekcí
	            this.$customSelector.on(this.customSelectorEventNames, ".medium-editor-form-selector-option", function (e) {

	                if (e.type === "touchmove") {

	                    moved = true;

	                    return;
	                }

	                if (moved) {

	                    moved = false;

	                    return;
	                }

	                self.handleSectionSelection.call(self, this);

	                e.preventDefault();
	                return false;
	            });

	            this.$customSelector.perfectScrollbar("destroy").perfectScrollbar();

	            this.getForm().classList.add("medium-editor-action-createLink-displayed");
	        };

	        MediumEditor.extensions.anchor.prototype.handleSectionSelection = function (option) {

	            var $option = $(option),
	                value = $option.data("value");

	            this.$select = this.$select || $("#" + this.selectId);

	            this.$select.val(value);

	            this.getInput().value = "";

	            this.doFormSave();
	        };

	        MediumEditor.extensions.anchor.prototype._hideForm = MediumEditor.extensions.anchor.prototype.hideForm;

	        MediumEditor.extensions.anchor.prototype.hideForm = function () {

	            MediumEditor.extensions.anchor.prototype._hideForm.apply(this, arguments);

	            if (this.customSelectorEventNames) {

	                this.$customSelector.perfectScrollbar("destroy");

	                this.$customSelector.off(this.customSelectorEventNames);
	            }

	            if (this.formNavCloseEventNames) {

	                this.$formNavClose.off(this.formNavCloseEventNames);
	            }

	            this.getForm().classList.remove("medium-editor-action-createLink-displayed");
	        };

	        MediumEditor.extensions.anchor.prototype.isDisplayed = function () {

	            return this.getForm().classList.contains("medium-editor-action-createLink-displayed");
	        };
	    };
	}));


/***/ },
/* 78 */
/***/ function(module, exports) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	/*global $*/

	(function (root, factory) {

	    if (typeof module === 'object' && module.exports) {

	        module.exports = factory();

	    } else {

	        root.MediumEditorEnhence = factory();
	    }

	}(this, function () {

	    return function (MediumEditor) {

	        MediumEditor.prototype._execAction = MediumEditor.prototype.execAction;

	        MediumEditor.prototype.execAction = function () {

	            var original = MediumEditor.prototype._execAction.apply(this, arguments);

	            return original;
	        };

	    };

	}));


/***/ },
/* 79 */
/***/ function(module, exports) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	/*global $*/

	(function (root, factory) {

	    if (typeof module === 'object' && module.exports) {

	        module.exports = factory();

	    } else {

	        root.MediumEditorToolbar = factory();
	    }

	}(this, function () {

	    function getSelectionHtml() {
	        var html = "";
	        if (typeof window.getSelection !== "undefined") {
	            var sel = window.getSelection();
	            if (sel.rangeCount) {
	                var container = document.createElement("div");
	                for (var i = 0, len = sel.rangeCount; i < len; ++i) {
	                    container.appendChild(sel.getRangeAt(i).cloneContents());
	                }
	                html = container.innerHTML;
	            }
	        } else if (typeof document.selection != "undefined") {
	            if (document.selection.type == "Text") {
	                html = document.selection.createRange().htmlText;
	            }
	        }
	        return html;
	    }

	    return function (MediumEditor, FixedElement) {

	        MediumEditor.extensions.toolbar.prototype._init = MediumEditor.extensions.toolbar.prototype.init;

	        MediumEditor.extensions.toolbar.prototype.init = function () {

	            this.$win = $(window);

	            this.base.toolbar = this;

	            MediumEditor.extensions.toolbar.prototype._init.apply(this, arguments);

	            this.getToolbarActionsElement().classList.add("medium-editor-default-actions-displayed");
	            this.toolbar.classList.add("medium-editor-default-actions-displayed");

	            //výchozí pozice
	            this.toolbar.classList.add("medium-editor-force-left");
	            this.toolbar.classList.add("medium-editor-force-top");

	            //elementy zajišťující přesun editoru (<ul />), pokud je menší než root element
	            this.beforeFill = document.createElement("div");
	            this.beforeFill.classList.add("medium-editor-before-fill");

	            this.afterFill = document.createElement("div");
	            this.afterFill.classList.add("medium-editor-after-fill");

	            this.toolbar.appendChild(this.afterFill);
	            this.toolbar.insertBefore(this.beforeFill, this.toolbar.children[0]);

	            //přiřazení tlačítkům touchend
	            this.forEachExtension(function (extenstion) {

	                if (extenstion.button) {

	                    $(extenstion.button).on("touchend.medium-editor-button", function (e) {

	                        if (e.originalEvent.changedTouches.length === 1) {

	                            if (!$(e.target).closest("button").prop("disabled")) {

	                                this.handleClick.apply(this, arguments);
	                            }

	                            e.preventDefault();
	                            return false;
	                        }
	                    }.bind(extenstion));
	                }
	            });
	        };

	        MediumEditor.extensions.toolbar.prototype._destroy = MediumEditor.extensions.toolbar.prototype.destroy;

	        MediumEditor.extensions.toolbar.prototype.destroy = function () {

	            var original = MediumEditor.extensions.toolbar.prototype._destroy.apply(this, arguments);

	            //odsranění touchendu z tlačítek
	            this.forEachExtension(function (extenstion) {

	                if (extenstion.button) {

	                    $(extenstion.button).off("touchend.medium-editor-button");
	                }
	            });

	            if (this.fixedElement) {

	                this.fixedElement.destroy();
	            }

	            return original;
	        };

	        MediumEditor.extensions.toolbar.prototype._createToolbarButtons = MediumEditor.extensions.toolbar.prototype.createToolbarButtons;

	        MediumEditor.extensions.toolbar.prototype.createToolbarButtons = function () {

	            var actionElement = MediumEditor.extensions.toolbar.prototype._createToolbarButtons.apply(this, arguments),
	                buttons = actionElement.querySelectorAll("button[class*='medium-editor-action']"),
	                b = buttons.length - 1;

	            //předání tříd položkám (<li />) tlačítek
	            for (b; b >= 0; b--) {

	                var actionClass = buttons[b].className.match(/(^medium-editor-action-|\ medium-editor-action-)[^ ]*/)[0];
	                buttons[b].parentNode.className = actionClass.replace("editor-action", "editor-has-action");

	                //třída více než b tlačítek
	                actionElement.classList.add("medium-editor-has-more-then-" + b + "-actions");
	            }

	            //celkový počet tlačítek
	            actionElement.classList.add("medium-editor-has-" + buttons.length + "-actions");

	            return actionElement;
	        };

	        MediumEditor.extensions.toolbar.prototype._checkActiveButtons = MediumEditor.extensions.toolbar.prototype.checkActiveButtons;

	        MediumEditor.extensions.toolbar.prototype.checkActiveButtons = function () {

	            var original = MediumEditor.extensions.toolbar.prototype._checkActiveButtons.apply(this, arguments);

	            var actionElement = this.getToolbarActionsElement(),
	                buttons = actionElement.querySelectorAll("button[class*='medium-editor-action']"),
	                b = buttons.length - 1;

	            //předání aktivního stavu tlačítek položkám (<li />)
	            for (b; b >= 0; b--) {

	                if (buttons[b].classList.contains("medium-editor-button-active")) {

	                    buttons[b].parentNode.classList.add("medium-editor-has-button-active");

	                } else {

	                    buttons[b].parentNode.classList.remove("medium-editor-has-button-active");
	                }
	            }

	            //zablokování h2, pokud je označen seznam, a zablokování seznamů, pokud je označen h2
	            var selection = getSelectionHtml(),

	                ordered = this.base.getExtensionByName("orderedlist"),
	                unordered = this.base.getExtensionByName("unorderedlist"),
	                h2 = this.base.getExtensionByName("h2");

	            if (ordered && ordered.button && unordered && unordered.button && h2 && h2.button) {

	                ordered.button.disabled = !!h2.button.className.match("-active") || selection.match(/<\/?h2>/i);
	                unordered.button.disabled = !!h2.button.className.match("-active") || selection.match(/<\/?h2>/i);
	                h2.button.disabled = !!ordered.button.className.match("-active") || unordered.button.className.match("-active") || selection.match(/<\/?(?:ul|ol|li)>/i);
	            }

	            return original;
	        };

	        MediumEditor.extensions.toolbar.prototype._showToolbar = MediumEditor.extensions.toolbar.prototype.showToolbar;

	        MediumEditor.extensions.toolbar.prototype.showToolbar = function () {

	            if (!this.isDisplayed()) {

	                //třída označující první zobrazení toolbaru (poté je pouze přesouván, dokud není opět skryt)
	                this.$win.off("mousedown.medium-editor-first-show-" + this.base.id);
	                this.$win.off("touchstart.medium-editor-first-show-" + this.base.id);

	                this.$win.one("mousedown.medium-editor-first-show-" + this.base.id + " " + "touchstart.medium-editor-first-show-" + this.base.id, function () {

	                    this.toolbar.classList.remove("medium-editor-first-show");

	                }.bind(this));

	                this.toolbar.classList.add("medium-editor-first-show");

	                if (this.fixedElement) {

	                    this.fixedElement.wake();
	                }
	            }

	            return MediumEditor.extensions.toolbar.prototype._showToolbar.apply(this, arguments);
	        };

	        MediumEditor.extensions.toolbar.prototype._hideToolbar = MediumEditor.extensions.toolbar.prototype.hideToolbar;

	        MediumEditor.extensions.toolbar.prototype.hideToolbar = function () {

	            if (this.isDisplayed()) {

	                this.$win.off("mousedown.medium-editor-first-show-" + this.base.id);
	                this.$win.off("touchstart.medium-editor-first-show-" + this.base.id);

	                this.toolbar.classList.remove("medium-editor-first-show");

	                this.hideExtensionForms();
	                this.showToolbarDefaultActions(true);

	                if (this.fixedElement) {

	                    this.fixedElement.sleep();
	                }
	            }

	           return MediumEditor.extensions.toolbar.prototype._hideToolbar.apply(this, arguments);
	        };

	        MediumEditor.extensions.toolbar.prototype.isToolbarDefaultActionsDisplayed = function () {

	            return this.getToolbarActionsElement().classList.contains("medium-editor-default-actions-displayed");
	        };

	        MediumEditor.extensions.toolbar.prototype.hideToolbarDefaultActions = function () {

	            if (this.isToolbarDefaultActionsDisplayed()) {

	                this.getToolbarActionsElement().classList.add("medium-editor-default-actions-hidden");
	                this.getToolbarActionsElement().classList.remove("medium-editor-default-actions-displayed");
	                this.toolbar.classList.add("medium-editor-default-actions-hidden");
	                this.toolbar.classList.remove("medium-editor-default-actions-displayed");
	            }
	        };

	        MediumEditor.extensions.toolbar.prototype.showToolbarDefaultActions = function (dontShowToolbar) {

	            this.hideExtensionForms();

	            if (!this.isToolbarDefaultActionsDisplayed()) {

	                this.getToolbarActionsElement().classList.remove("medium-editor-default-actions-hidden");
	                this.getToolbarActionsElement().classList.add("medium-editor-default-actions-displayed");
	                this.toolbar.classList.remove("medium-editor-default-actions-hidden");
	                this.toolbar.classList.add("medium-editor-default-actions-displayed");
	            }

	            //při zavření toolbaru se tlačítka zobrazí zpět, pokud byl otevřen anchor; toolbar ale musí zůstat skrytý
	            if (dontShowToolbar) {

	                return;
	            }

	            // Using setTimeout + options.delay because:
	            // We will actually be displaying the toolbar, which should be controlled by options.delay
	            this.delayShowTimeout = this.base.delay(function () {
	                this.showToolbar();
	            }.bind(this));
	        };

	        MediumEditor.extensions.toolbar.prototype.hideExtensionForms = function () {

	            // Hide all extension forms
	            this.forEachExtension(function (extension) {

	                if (extension.action === "createLink") {

	                    if (extension.isDisplayed()) {

	                        //reset formuláře z anchoru
	                        extension.getForm().classList.remove("medium-editor-action-createLink-displayed");

	                        extension.getInput().value = "";
	                    }

	                    return;
	                }
	                if (extension.hasForm && extension.isDisplayed()) {
	                    extension.hideForm();
	                }
	            });
	        };

	        MediumEditor.extensions.toolbar.prototype.setFillGrow = function (before, after) {
	            this.beforeFill.style.webkitFlexGrow = before;
	            this.beforeFill.style.mozFlexGrow = before;
	            this.beforeFill.style.msFlexGrow = before;
	            this.beforeFill.style.oFlexGrow = before;
	            this.beforeFill.style.flexGrow = before;
	            this.afterFill.style.webkitFlexGrow = after;
	            this.afterFill.style.mozFlexGrow = after;
	            this.afterFill.style.msFlexGrow = after;
	            this.afterFill.style.oFlexGrow = after;
	            this.afterFill.style.flexGrow = after;
	        };

	        MediumEditor.extensions.toolbar.prototype.positionTouchToolbar = function () {

	            var toolbarElement = this.getToolbarElement(),
	                anchorFormElement = this.base.getExtensionByName("anchor").form;

	            toolbarElement.style.top = '';
	            toolbarElement.style.left = '';
	            anchorFormElement.style.left = '';

	            if (this.base.events.touchSupport.used) {

	                toolbarElement.classList.remove("medium-editor-force-left");
	                toolbarElement.classList.remove("medium-editor-force-right");
	                toolbarElement.classList.remove("medium-editor-force-bottom");
	                toolbarElement.classList.remove("medium-editor-force-top");

	                if (MediumEditor.TouchSupport.forceDirectionX !== "right") {

	                    toolbarElement.classList.add("medium-editor-force-left");

	                } else {

	                    toolbarElement.classList.add("medium-editor-force-right");
	                }

	                if (MediumEditor.TouchSupport.forceDirectionY !== "bottom") {

	                    toolbarElement.classList.add("medium-editor-force-top");

	                } else {

	                    toolbarElement.classList.add("medium-editor-force-bottom");
	                }

	                this.fixedElement = this.fixedElement || new FixedElement(this.toolbar);

	                //pokud se pozice změní je potřeba zresetovat fixní pozici toolbaru
	                if ((MediumEditor.TouchSupport.forceDirectionY !== MediumEditor.TouchSupport.lastForceDirectionY) ||
	                    (MediumEditor.TouchSupport.forceDirectionX !== MediumEditor.TouchSupport.lastForceDirectionX)) {

	                    this.fixedElement.fix(true, MediumEditor.TouchSupport.forceDirectionY !== MediumEditor.TouchSupport.lastForceDirectionY);
	                }

	                MediumEditor.TouchSupport.lastForceDirectionX = MediumEditor.TouchSupport.forceDirectionX;
	                MediumEditor.TouchSupport.lastForceDirectionY = MediumEditor.TouchSupport.forceDirectionY;
	            }
	        };

	        MediumEditor.extensions.toolbar.prototype.positionToolbar = function (selection) {

	            var toolbarElement = this.getToolbarElement(),
	                anchorFormElement = this.base.getExtensionByName("anchor").form;

	            //dotykové zařízení
	            if (toolbarElement.classList.contains("medium-editor-use-touch")) {

	                this.positionTouchToolbar.apply(this, arguments);

	                return;
	            }

	            toolbarElement.classList.remove('medium-editor-left-edge');
	            toolbarElement.classList.remove('medium-editor-right-edge');

	            var range = selection.getRangeAt(0),
	                boundary = range.getBoundingClientRect();

	            // Handle selections with just images
	            if (!boundary || ((boundary.height === 0 && boundary.width === 0) && range.startContainer === range.endContainer)) {
	                // If there's a nested image, use that for the bounding rectangle
	                if (range.startContainer.nodeType === 1 && range.startContainer.querySelector('img')) {
	                    boundary = range.startContainer.querySelector('img').getBoundingClientRect();
	                } else {
	                    boundary = range.startContainer.getBoundingClientRect();
	                }
	            }

	            var windowWidth = document.documentElement.clientWidth < this.window.innerWidth ? document.documentElement.clientWidth : this.window.innerWidth,
	                middleBoundary = (boundary.left + boundary.right) / 2,
	                toolbarHeight = toolbarElement.offsetHeight,
	                toolbarWidth = toolbarElement.offsetWidth,

	                //velikost volného prostoru mezi formulářem anchoru a root elementem
	                anchorOffsetWidth = (toolbarWidth - anchorFormElement.offsetWidth) / 2,

	                toolbarActionsElement = this.getToolbarActionsElement(),

	                //velikost fillafter a fillbefore elementů pro přesun toolbaru až ke kraji
	                fillWidth = (toolbarWidth - toolbarActionsElement.offsetWidth) / 2,

	                halfOffsetWidth = toolbarWidth / 2,
	                defaultLeft = this.diffLeft - halfOffsetWidth;

	            //uložení velikosti výplně a formuláře anchoru (u anchoru asi zbytečné),
	            //protože velikost toolbaru se mění při otevření formuláře anchoru
	            if (this.isToolbarDefaultActionsDisplayed() && this.savedFillWidth) {

	                fillWidth = this.savedFillWidth;
	                anchorOffsetWidth = this.savedAnchorOffsetWidth;

	                this.savedFillWidth = null;
	                this.savedAnchorOffsetWidth = null;

	            } else if (!this.isToolbarDefaultActionsDisplayed()) {

	                fillWidth = this.savedFillWidth || fillWidth;
	                anchorOffsetWidth = this.savedAnchorOffsetWidth || anchorOffsetWidth;

	                this.savedFillWidth = fillWidth;
	                this.savedAnchorOffsetWidth = anchorOffsetWidth;
	            }

	            //vertikální zarovnání
	            if (boundary.top < toolbarHeight) {

	                toolbarElement.classList.add('medium-toolbar-arrow-over');
	                toolbarElement.classList.remove('medium-toolbar-arrow-under');
	                toolbarElement.style.top = toolbarHeight + boundary.bottom - this.diffTop + this.window.pageYOffset - toolbarHeight + 'px';

	            } else {

	                toolbarElement.classList.add('medium-toolbar-arrow-under');
	                toolbarElement.classList.remove('medium-toolbar-arrow-over');
	                toolbarElement.style.top = boundary.top + this.diffTop + this.window.pageYOffset - toolbarHeight + 'px';
	            }

	            //horizontální zarovnání
	            var fillGrow = 1;

	            //přesahuje levý okraj
	            if (middleBoundary < halfOffsetWidth) {

	                toolbarElement.classList.add('medium-editor-left-edge');
	                toolbarElement.style.left = defaultLeft + halfOffsetWidth + 'px';

	                fillGrow = !fillWidth ? 0 : 1 - (Math.max(0, Math.min(fillWidth, halfOffsetWidth - middleBoundary)) / fillWidth);

	                this.setFillGrow(fillGrow, 2 - fillGrow);

	                anchorFormElement.style.left = (anchorOffsetWidth * fillGrow) + "px";

	            //přesahuje pravý okraj
	            } else if ((windowWidth - middleBoundary) < halfOffsetWidth) {

	                toolbarElement.classList.add('medium-editor-right-edge');
	                toolbarElement.style.left = windowWidth - toolbarWidth + "px";

	                fillGrow = !fillWidth ? 0 : 1 - (Math.min(fillWidth, Math.max(0, ((halfOffsetWidth + middleBoundary) - windowWidth))) / fillWidth);

	                this.setFillGrow(2 - fillGrow, fillGrow);

	                anchorFormElement.style.left = (anchorOffsetWidth * (2 - fillGrow)) + "px";

	            } else {

	                toolbarElement.style.left = (defaultLeft + middleBoundary) + 'px';
	                anchorFormElement.style.left = anchorOffsetWidth + "px";

	                this.setFillGrow(1, 1);
	            }
	        };
	    };

	}));


/***/ },
/* 80 */
/***/ function(module, exports) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	/*global $*/

	(function (root, factory) {

	    if (typeof module === 'object' && module.exports) {

	        module.exports = factory();

	    } else {

	        root.MediumEditorTouchSupport = factory();
	    }

	}(this, function () {

	    return function (MediumEditor) {

	        MediumEditor.TouchSupport = {};

	        MediumEditor.Events.prototype._handleBodyMousedown = MediumEditor.Events.prototype.handleBodyMousedown;

	        MediumEditor.Events.prototype.handleBodyMousedown = function () {

	            if (this.touchSupport.bodyTouchstart) {

	                this.touchSupport.bodyTouchstart = false;

	                return;
	            }

	            this._handleBodyMousedown.apply(this, arguments);
	        };

	        MediumEditor.Events.prototype._handleBodyClick = MediumEditor.Events.prototype.handleBodyClick;

	        MediumEditor.Events.prototype.handleBodyClick = function () {

	            if (this.touchSupport.bodyTouchend) {

	                this.touchSupport.bodyTouchend = false;

	                return;
	            }

	            this._handleBodyClick.apply(this, arguments);
	        };

	        MediumEditor.Events.prototype._setupListener = MediumEditor.Events.prototype.setupListener;

	        MediumEditor.Events.prototype.setupListener = function (name) {

	            this.touchSupport = this.touchSupport || {
	                touches: 0
	            };

	            if (name === "externalInteraction" && !this.touchSupport.attachedExternalInteraction) {

	                this.attachDOMEvent(this.options.ownerDocument.body, 'touchstart', function (e) {

	                    if (!this.base.toolbar.toolbar.classList.contains("medium-editor-use-touch")) {

	                        this.base.toolbar.toolbar.classList.add("medium-editor-use-touch");
	                    }

	                    this.touchSupport.used = true;
	                    this.touchSupport.touches = e.touches.length > this.touchSupport.touches ? e.touches.length : this.touchSupport.touches;
	                    this.touchSupport.zoom = document.documentElement.clientWidth / window.innerWidth;

	                    if (e.touches.length === 3) {

	                        this.touchSupport.startX = e.touches[2].clientX;
	                        this.touchSupport.startY = e.touches[2].clientY;
	                    }

	                    if (e.touches.length === 1) {

	                        this.touchSupport.bodyTouchstart = false;

	                        this.handleBodyMousedown.apply(this, arguments);

	                        this.touchSupport.bodyTouchstart = true;
	                    }

	                }.bind(this), true);

	                this.attachDOMEvent(this.options.ownerDocument.body, 'touchmove', function (e) {

	                    this.touchSupport.bodyTouchmove = true;

	                    var directionChanged = false;

	                    if (!MediumEditor.TouchSupport.toolbarSwitched && e.touches[2] && this.base.getFocusedElement()) {

	                        if (this.base.toolbar.toolbar.classList.contains("medium-editor-toolbar-active")) {

	                            e.preventDefault();

	                            if (Math.abs(this.touchSupport.startY - e.touches[2].clientY) > 40 / this.touchSupport.zoom) {

	                                if (this.touchSupport.startY - e.touches[2].clientY > 0) {

	                                    MediumEditor.TouchSupport.forceDirectionY = "top";

	                                } else {

	                                    MediumEditor.TouchSupport.forceDirectionY = "bottom";
	                                }

	                                directionChanged = true;
	                            }
	                        }
	                    }

	                    if (!MediumEditor.TouchSupport.toolbarSwitched && e.touches[2] && this.base.getFocusedElement()) {

	                        if (this.base.toolbar.toolbar.classList.contains("medium-editor-toolbar-active")) {

	                            e.preventDefault();

	                            if (Math.abs(this.touchSupport.startX - e.touches[2].clientX) > 40 / this.touchSupport.zoom) {

	                                if (this.touchSupport.startX - e.touches[2].clientX > 0) {

	                                    MediumEditor.TouchSupport.forceDirectionX = "left";

	                                } else {

	                                    MediumEditor.TouchSupport.forceDirectionX = "right";
	                                }

	                                directionChanged = true;
	                            }
	                        }
	                    }

	                    if (directionChanged) {

	                        MediumEditor.TouchSupport.toolbarSwitched = true;

	                        this.base.toolbar.setToolbarPosition();
	                    }

	                }.bind(this), true);

	                this.attachDOMEvent(this.options.ownerDocument.body, 'touchend', function (e) {

	                    clearTimeout(this.touchSupport.touchesTimeout);

	                    this.touchSupport.touchesTimeout = setTimeout(function () {

	                        this.touchSupport.touches = 0;
	                        MediumEditor.TouchSupport.toolbarSwitched = false;

	                    }.bind(this), 75);

	                    if (this.touchSupport.touches > 1) {

	                        return;
	                    }

	                    if (e.touches.length === 0) {

	                        this.touchSupport.bodyTouchend = false;

	                        var $target = $(e.target),
	                            $closestEditor = $target.closest("[data-medium-editor-element]"),
	                            $closestToolbar = $target.closest(".medium-editor-toolbar"),
	                            focusedEditor = this.base.getFocusedElement();

	                        this.touchSupport.onToolbarTouchend = $closestToolbar.length;

	                        if (!this.touchSupport.bodyTouchmove && (!focusedEditor || focusedEditor !== $closestEditor[0])) {

	                            $closestEditor.focus();
	                        }

	                        if (!this.touchSupport.bodyTouchmove && focusedEditor && !$closestToolbar.length && !$closestEditor.length) {

	                            MediumEditor.TouchSupport.forceDirectionY = MediumEditor.TouchSupport.forceDirectionY || "top";

	                            $(focusedEditor).blur();
	                        }

	                        if (!this.touchSupport.bodyTouchmove) {

	                            this.handleBodyClick.apply(this, arguments);
	                        }

	                        MediumEditor.TouchSupport.toolbarSwitched = false;
	                        this.touchSupport.bodyTouchstart = false;
	                        this.touchSupport.bodyTouchmove = false;
	                        this.touchSupport.bodyTouchend = true;
	                    }

	                }.bind(this), true);

	                this.touchSupport.attachedExternalInteraction = true;

	            } else if (name === "editableClick" && !this.touchSupport.attachedEditableClick) {

	                this.attachDOMEvent(this.options.ownerDocument, 'selectionchange', function () {

	                    if (!this.touchSupport.used || !this.base.getFocusedElement()) {

	                        return;
	                    }

	                    if (!this.touchSupport.onToolbarTouchend) {

	                        this.base.toolbar.checkState();
	                    }

	                    var args = arguments;

	                    clearTimeout(this.touchSupport.selectionTimeout);

	                    this.touchSupport.selectionTimeout = setTimeout(function () {

	                        if (this.touchSupport.onToolbarTouchend) {

	                            return;
	                        }

	                        this.base.toolbar.checkState();

	                        this.handleClick.apply(this, args);

	                    }.bind(this), 300);

	                }.bind(this));

	                this.touchSupport.attachedEditableClick = true;
	            }

	            this._setupListener.apply(this, arguments);
	        };
	    };

	}));


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	var U = __webpack_require__(4);
	var CLASS = __webpack_require__(30);

	var SuperEditor = __webpack_require__(33);

	var TitleEditor = function TitleEditor() {

	    SuperEditor.apply(this, arguments);
	};

	U.extend(TitleEditor, SuperEditor);

	TitleEditor.prototype.configure = function () {

	    this.options = {

	        anchor: {
	            linkValidation: true
	        },
	        anchorPreview: false,

	        disableReturn: true,
	        disableExtraSpaces: true,

	        imageDragging: false,
	        placeholder: false,
	        keyboardCommands: false,

	        buttonLabels: "fontawesome",

	        toolbar: {
	            buttons: [
	                SuperEditor.BUTTONS.B,
	                SuperEditor.BUTTONS.I,
	                SuperEditor.BUTTONS.A,
	                SuperEditor.BUTTONS.SUB,
	                SuperEditor.BUTTONS.SUP
	            ]
	        }
	    };
	};

	module.exports = TitleEditor;


/***/ },
/* 82 */
/***/ function(module, exports) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/

	module.exports = [
	    {
	        colors: [
	            "rgb(13, 51, 15)",
	            "rgb(1, 114, 1)",
	            "rgb(134, 174, 34)",
	            "rgb(188, 201, 0)",
	            "rgb(55, 41, 33)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(17, 23, 40)",
	            "rgb(41, 75, 119)",
	            "rgb(131, 151, 167)",
	            "rgb(137, 171, 173)",
	            "rgb(221, 221, 219)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(219, 96, 93)",
	            "rgb(230, 131, 43)",
	            "rgb(248, 221, 93)",
	            "rgb(243, 232, 229)",
	            "rgb(88, 187, 137)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(68, 57, 41)",
	            "rgb(143, 91, 58)",
	            "rgb(232, 218, 204)",
	            "rgb(73, 109, 131)",
	            "rgb(41, 62, 79)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(116,0,1)",
	            "rgb(174,0,1)",
	            "rgb(238,186,48)",
	            "rgb(211,166,37)",
	            "rgb(0,0,0)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(54,76,74)",
	            "rgb(73,124,127)",
	            "rgb(146,197,192)",
	            "rgb(133,129,104)",
	            "rgb(204,188,165)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(31,112,10)",
	            "rgb(121,204,60)",
	            "rgb(212,225,120)",
	            "rgb(230,213,195)",
	            "rgb(172,135,93)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(216,181,151)",
	            "rgb(140,64,6)",
	            "rgb(182,105,15)",
	            "rgb(227,197,127)",
	            "rgb(255,237,190)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(239, 244, 244)",
	            "rgb(248, 233, 217)",
	            "rgb(239, 201, 205)",
	            "rgb(202, 173, 182)",
	            "rgb(104, 113, 127)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(209, 237, 211)",
	            "rgb(180, 215, 195)",
	            "rgb(59, 68, 42)",
	            "rgb(105, 105, 68)",
	            "rgb(238, 151, 182)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(255, 200, 87)",
	            "rgb(233, 114, 76)",
	            "rgb(197, 40, 61)",
	            "rgb(72, 29, 36)",
	            "rgb(37, 95, 133)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(158,158,158)",
	            "rgb(96,125,139)",
	            "rgb(255,87,34)",
	            "rgb(255,255,255)",
	            "rgb(0,0,0)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(246,31,86)",
	            "rgb(190,19,63)",
	            "rgb(43,40,40)",
	            "rgb(26,22,22)",
	            "rgb(6,0,0)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(236,205,156)",
	            "rgb(177,112,112)",
	            "rgb(117,40,44)",
	            "rgb(73,4,21)",
	            "rgb(6,0,0)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(225,178,65)",
	            "rgb(219,133,3)",
	            "rgb(212,44,69)",
	            "rgb(126,7,61)",
	            "rgb(34,2,33)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(204,182,214)",
	            "rgb(154,148,182)",
	            "rgb(40,38,80)",
	            "rgb(5,26,52)",
	            "rgb(0,2,19)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(251,214,62)",
	            "rgb(255,165,53)",
	            "rgb(244,118,13)",
	            "rgb(225,65,10)",
	            "rgb(45,43,60)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(160,208,185)",
	            "rgb(189,214,183)",
	            "rgb(208,219,179)",
	            "rgb(222,229,184)",
	            "rgb(249,255,198)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(156,145,140)",
	            "rgb(176,164,151)",
	            "rgb(191,170,150)",
	            "rgb(255,252,181)",
	            "rgb(116,110,105)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(231,76,60)",
	            "rgb(33,47,60)",
	            "rgb(19,180,148)",
	            "rgb(255,255,255)",
	            "rgb(203,203,203)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(31,31,31)",
	            "rgb(243,40,40)",
	            "rgb(11,71,89)",
	            "rgb(235,235,235)",
	            "rgb(164,155,98)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(250, 234, 149)",
	            "rgb(252, 184, 95)",
	            "rgb(236, 168, 175)",
	            "rgb(194, 234, 214)",
	            "rgb(16, 18, 13)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(55, 33, 24)",
	            "rgb(136, 80, 23)",
	            "rgb(249, 233, 54)",
	            "rgb(188, 205, 156)",
	            "rgb(103, 143, 87)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(241, 52, 1)",
	            "rgb(250, 122, 51)",
	            "rgb(254, 166, 108)",
	            "rgb(96, 113, 59)",
	            "rgb(45, 57, 35)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(0, 14, 23)",
	            "rgb(1, 65, 95)",
	            "rgb(83, 209, 238)",
	            "rgb(254, 210, 12)",
	            "rgb(195, 119, 64)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(206, 73, 128)",
	            "rgb(245, 192, 203)",
	            "rgb(246, 233, 224)",
	            "rgb(82, 117, 30)",
	            "rgb(0, 0, 0)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(62, 108, 2)",
	            "rgb(150, 221, 30)",
	            "rgb(221, 255, 60)",
	            "rgb(128, 127, 107)",
	            "rgb(59, 58, 50)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(42, 41, 42)",
	            "rgb(98, 103, 130)",
	            "rgb(201, 180, 206)",
	            "rgb(236, 217, 192)",
	            "rgb(196, 157, 77)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(205, 61, 139)",
	            "rgb(255, 171, 207)",
	            "rgb(33, 164, 162)",
	            "rgb(1, 100, 76)",
	            "rgb(104, 167, 40)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(30, 32, 17)",
	            "rgb(158, 36, 61)",
	            "rgb(231, 104, 124)",
	            "rgb(255, 204, 0)",
	            "rgb(225, 150, 0)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(255, 219, 211)",
	            "rgb(255, 236, 219)",
	            "rgb(198, 181, 191)",
	            "rgb(113, 123, 142)",
	            "rgb(45, 52, 49)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(39, 9, 15)",
	            "rgb(92, 46, 61)",
	            "rgb(169, 86, 94)",
	            "rgb(138, 119, 131)",
	            "rgb(167, 145, 157)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(62, 31, 22)",
	            "rgb(148, 2, 20)",
	            "rgb(221, 57, 90)",
	            "rgb(232, 192, 1)",
	            "rgb(1, 92, 122)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(4, 2, 3)",
	            "rgb(1, 10, 61)",
	            "rgb(70, 123, 141)",
	            "rgb(67, 189, 142)",
	            "rgb(225, 254, 164)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(30, 40, 42)",
	            "rgb(147, 229, 242)",
	            "rgb(230, 239, 236)",
	            "rgb(177, 0, 21)",
	            "rgb(80, 0, 9)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(224, 197, 97)",
	            "rgb(240, 225, 186)",
	            "rgb(244, 245, 249)",
	            "rgb(222, 131, 91)",
	            "rgb(144, 35, 10)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(166, 24, 26)",
	            "rgb(234, 150, 124)",
	            "rgb(237, 200, 148)",
	            "rgb(241, 241, 207)",
	            "rgb(127, 125, 51)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(210, 177, 63)",
	            "rgb(182, 162, 96)",
	            "rgb(197, 189, 166)",
	            "rgb(165, 161, 155)",
	            "rgb(89, 86, 82)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(182, 49, 107)",
	            "rgb(206, 118, 157)",
	            "rgb(206, 173, 175)",
	            "rgb(232, 224, 220)",
	            "rgb(255, 255, 255)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(150, 72, 43)",
	            "rgb(253, 162, 121)",
	            "rgb(231, 221, 200)",
	            "rgb(135, 132, 96)",
	            "rgb(102, 105, 102)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(89, 14, 24)",
	            "rgb(79, 57, 56)",
	            "rgb(252, 248, 243)",
	            "rgb(224, 237, 245)",
	            "rgb(199, 202, 204)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(0, 0, 63)",
	            "rgb(1, 0, 142)",
	            "rgb(144, 1, 245)",
	            "rgb(254, 0, 234)",
	            "rgb(255, 1, 120)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(241,188,255)",
	            "rgb(169,238,233)",
	            "rgb(236,255,164)",
	            "rgb(255,220,166)",
	            "rgb(242,174,174)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(176,20,104)",
	            "rgb(122,0,115)",
	            "rgb(98,0,190)",
	            "rgb(229,0,255)",
	            "rgb(255,0,155)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(251,223,180)",
	            "rgb(216,201,163)",
	            "rgb(176,171,125)",
	            "rgb(98,101,61)",
	            "rgb(45,49,10)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(197,112,176)",
	            "rgb(253,252,252)",
	            "rgb(217,255,187)",
	            "rgb(187,255,135)",
	            "rgb(0,10,26)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(220,246,183)",
	            "rgb(198,221,164)",
	            "rgb(176,196,146)",
	            "rgb(44,49,36)",
	            "rgb(22,24,18)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(38,115,156)",
	            "rgb(91,152,185)",
	            "rgb(214,43,106)",
	            "rgb(255,240,118)",
	            "rgb(0,0,0)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(81,81,81)",
	            "rgb(249,245,245)",
	            "rgb(255,181,162)",
	            "rgb(223,157,140)",
	            "rgb(50,67,81)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(241,191,197)",
	            "rgb(236,171,179)",
	            "rgb(178,116,133)",
	            "rgb(142,92,106)",
	            "rgb(89,58,66)"
	        ],
	        headerImg: ""
	    },
	    {
	        colors: [
	            "rgb(84,81,58)",
	            "rgb(152,132,84)",
	            "rgb(219,192,109)",
	            "rgb(253,243,146)",
	            "rgb(255,245,203)"
	        ],
	        headerImg: ""
	    }
	];


/***/ },
/* 83 */
/***/ function(module, exports) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/

	module.exports = {
	    "P_font-type-1" : {
	        title: "Serif",
	        body: "Serif"
	    },
	    "P_font-type-2" : {
	        title: "Sans Serif",
	        body: "Sans Serif"
	    },
	    "P_font-type-3" : {
	        title: "Serif",
	        body: "Serif"
	    },
	    "P_font-type-4" : {
	        title: "Sans Serif",
	        body: "Sans Serif"
	    }
	};


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	/*global $*/
	var InlineWidget = __webpack_require__(35);

	module.exports = InlineWidget.extend({

	    components: {
	    },

	    partials: {
	    },

	    decorators: {
	    },

	    data: function () {

	        return {
	            type: "PageMenu"
	        };
	    },

	    onconfig: function () {

	        if (this.parent) {

	            var connectWith = this.get("connectWith");

	            if (connectWith) {

	                this.connectWithObserver = this.parent.observe(connectWith.opener, function (current) {

	                    this.parent.set("__InlineWidget." + connectWith.id, !!current);

	                }.bind(this), {init: false});

	                this.set("delayOpening", !!this.parent.get("__InlineWidget." + connectWith.id));

	            } else  {

	                this.parent.set("__InlineWidget", {});
	            }
	        }
	    },

	    onrender: function () {
	    },

	    oncomplete: function () {
	    },

	    onteardown: function () {

	        if (this.connectWithObserver) {

	            this.connectWithObserver.cancel();
	        }
	    }

	});


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	/*global $*/

	var FixedElement = __webpack_require__(24),
	    U = __webpack_require__(4),
	    EventEmitter = __webpack_require__(6)();

	var instaceCounter = 0,

	    CLASS = {
	        self: "E_PageMenu",

	        cssFixed: "E_PageMenu__css-fixed",
	        hidden: "E_PageMenu__hidden",
	        visible: "E_PageMenu__visible",

	        showPage: "E_PageMenu--show-page",
	        showPageActive: "E_PageMenu__show-page",

	        showContent: "E_PageMenu--item__show-content",
	        unsavedChanges: "E_PageMenu--save__unsaved",

	        fixedTop: "E_PageMenu__fixed-top",
	        fixedBottom: "E_PageMenu__fixed-bottom",

	        item: "E_PageMenu--item",
	        content: "E_PageMenu--content",
	        contentWrapper: "E_PageMenu--content-wrapper",

	        resizer: "E_PageMenu--resizer",
	        resizerActive: "E_PageMenu--resizer__active"
	    },

	    draggableActiveTimeout = null,
	    resizeTimeout = null,
	    ensureVisibilityTimeout = null,

	    shouldBeHidden = false,

	    //sníží (nebo vrátí zpět) opacity menu, aby bylo vidět stránku
	    toggleShowPage = function (e) {

	        this.$pageMenu.toggleClass(CLASS.showPageActive, e.original.type.match(/enter|start|over/));

	        e.original.preventDefault();
	        e.original.stopPropagation();
	    },

	    //nastaví maximální velikost položky podle velikosti okna (položka má v CSS 100vh, ale např. na iPadu může být větší)
	    setMaxHeight = function () {

	        this.$pageMenu
	            .find("." + CLASS.item + ", ." + CLASS.contentWrapper)
	            .css({
	                maxHeight: window.innerHeight
	            });
	    },

	    getZoom = function () {

	        return document.documentElement.clientWidth / window.innerWidth;
	    },

	    handleTouchstart = function (e) {

	        //použít FixedElement, pokud se jedná o dotykové zařízení
	        if (!this.pageMenuLeft && !this.pageMenuRight) {

	            this.$pageMenu
	                .removeClass(CLASS.cssFixed)
	                .css({
	                    position: "absolute"
	                });

	            this.pageMenuLeft  = new FixedElement(this.$pageMenu[0], { zoom: false });
	            this.pageMenuRight = new FixedElement(this.$pageMenu[1], { zoom: false });
	        }

	        if (this.hidden) {

	            return;
	        }

	        this.touch.touches = e.originalEvent.touches.length > this.touch.touches ? e.originalEvent.touches.length : this.touch.touches;
	        this.touch.zoom = getZoom();

	        //gesto: 3 prsty nohoru/dolu -> změna pozice menu
	        if (e.originalEvent.touches.length === 3) {

	            this.touch.startX = e.originalEvent.touches[0].clientX;
	            this.touch.startY = e.originalEvent.touches[0].clientY;
	        }
	    },

	    handleTouchmove = function (e) {

	        if (!this.hidden && !this.touch.switched && e.originalEvent.touches[2]) {

	            e.preventDefault();

	            if (Math.abs(this.touch.startY - e.originalEvent.touches[0].clientY) > 40 / this.touch.zoom) {

	                this.touch.switched = true;

	                if (this.touch.startY - e.originalEvent.touches[0].clientY > 0) {

	                    this.changePosition("top");

	                } else {

	                    this.changePosition("bottom");
	                }
	            }
	        }
	    },

	    handleTouchend = function () {

	        clearTimeout(this.touch.touchesTimeout);

	        this.touch.touchesTimeout = setTimeout(function () {

	            //skrýt/zobrazit menu při zoomu
	            if (this.touch.touches === 2) {

	                this[getZoom() > 1 ? "hide": "show"]();
	            }

	            this.touch.touches = 0;
	            this.touch.switched = false;

	        }.bind(this), 75);
	    },

	    handleWinResize = function () {

	        clearTimeout(resizeTimeout);

	        //změnit velikost položky, pokud se změní velikost okna a stránka není přiblížena
	        if (getZoom() <= 1) {

	            resizeTimeout = setTimeout(setMaxHeight.bind(this), 50);
	        }

	        //skrýt/zobrazit menu při zoomu
	        this[getZoom() > 1 ? "hide": "show"]();
	    },

	    //viz ensureVisibility
	    checkIfShoudBeHidden = function() {

	        shouldBeHidden = this.Page.get("sortableActive") && !this.Page.get("draggableActive");

	        if (!shouldBeHidden) {

	            this.Page.forEachPageSection(function () {

	                if (this.get("hasSettings") || this.get("hasOutline")) {

	                    shouldBeHidden = true;

	                    return false;
	                }
	            });
	        }
	    },

	    //zajistí skrytí/zobrazení menu
	    //menu se skryje pokud uživatel přeřazuje sekce, edituje PageElement nebo má otevřené nastavení sekce
	    ensureVisibility = function () {

	        clearTimeout(ensureVisibilityTimeout);

	        ensureVisibilityTimeout = setTimeout(function () {

	            checkIfShoudBeHidden.call(this);

	            this[shouldBeHidden ? "hide": "show"]();

	        }.bind(this), 250);
	    },

	    activateResizer = function (e) {

	        var eventData = U.eventData(e);

	        if (eventData.pointers > 1) {

	            return;
	        }

	        var $item = $(eventData.target).closest("." + CLASS.item),
	            $contentWrapper = $item.find("." + CLASS.contentWrapper),

	            initX = eventData.clientX,
	            initWidth = $item.width();

	        eventData.target.classList.add(CLASS.resizerActive);

	        $item.css({
	            transition: "none"
	        });

	        this.$win
	            .off("mousemove.resizer-" + this.EVENT_NS + " touchmove.resizer-" + this.EVENT_NS)
	            .on("mousemove.resizer-" + this.EVENT_NS + " touchmove.resizer-" + this.EVENT_NS, function (e) {

	                var eventData = U.eventData(e);

	                if (eventData.pointers > 1) {

	                    return;
	                }

	                $item.css({
	                    width: initWidth + eventData.clientX - initX
	                });

	                $contentWrapper.css({
	                    width: initWidth + eventData.clientX - initX
	                });

	                e.preventDefault();
	                return false;

	            }.bind(this))
	            .one("mouseup.resizer-" + this.EVENT_NS + " touchend.resizer-" + this.EVENT_NS, function (e) {

	                eventData.target.classList.remove(CLASS.resizerActive);

	                $item.css({
	                        width: $item.width(),

	                        transition: ""
	                    })
	                    .perfectScrollbar("update");

	                $contentWrapper.css({
	                    width: $item.width(),

	                    transition: ""
	                });

	                this.$win.off("mousemove.resizer-" + this.EVENT_NS + " touchmove.resizer-" + this.EVENT_NS);

	                EventEmitter.trigger("change.ResizableBox");

	                e.preventDefault();
	                return false;

	            }.bind(this));

	        eventData.preventDefault();
	        return false;
	    },

	    //odstraní scrollbar při zavření a odstraní uživatelem nastavenou velikost
	    resetCurrentItem = function () {

	        var $openedItem = this.$pageMenu.find("." + CLASS.showContent),
	            $openedContentWrapper = $openedItem.find("." + CLASS.contentWrapper),

	            cancelContentObserver = $openedContentWrapper.data("contentObserver." + this.EVENT_NS);

	        if (cancelContentObserver) {

	            cancelContentObserver();

	            $openedContentWrapper.data("contentObserver." + this.EVENT_NS, null);
	        }

	        $openedContentWrapper.perfectScrollbar("destroy");

	        $openedItem.on("transitionend." + this.EVENT_NS, function (e) {

	            //odstranit velikost až poté, co se skryje obsah
	            if (e.originalEvent.propertyName === "visibility" && e.target.classList.contains(CLASS.content)) {

	                $openedItem
	                    .off("transitionend." + this.EVENT_NS)
	                    .css({
	                        width: ""
	                    });

	                $openedContentWrapper.css({
	                    width: ""
	                });
	            }
	        });
	    },

	    updateScrollbar = function ($contentWrapper, contentObserverTimeout) {

	        var wrapperRect = $contentWrapper[0].getBoundingClientRect(),
	            contentRect = $contentWrapper[0].firstChild.getBoundingClientRect(),

	            wrapperPadding = parseFloat($contentWrapper.css("padding-bottom")) + parseFloat($contentWrapper.css("padding-top"));

	        if (wrapperRect.bottom - wrapperPadding > contentRect.bottom) {

	            $contentWrapper
	                .stop()
	                .animate({
	                    scrollTop: $contentWrapper[0].firstChild.offsetHeight + wrapperPadding - $contentWrapper[0].offsetHeight
	                }, {
	                    duration: 200,

	                    progress: function () {
	                        clearTimeout(contentObserverTimeout);
	                    },

	                    complete: function () {
	                        $contentWrapper.perfectScrollbar("update");
	                    }
	                });

	        } else if (wrapperRect.bottom - wrapperPadding < contentRect.bottom) {

	            $contentWrapper.stop().perfectScrollbar("update");
	        }
	    },

	    addScrollbar = function () {

	        var $openedContentWrapper = this.$pageMenu.find("." + CLASS.showContent + " ." + CLASS.contentWrapper);

	        $openedContentWrapper.perfectScrollbar({
	            swipePropagation: false, //Odstranit? Při přiblízení nelze posouvat stránkou.,
	            wheelPropagation: false
	        });

	        if (!$openedContentWrapper.data("contentObserver." + this.EVENT_NS)) {

	            var contentObserverTimeout = null,

	                contentObserver = new MutationObserver(function () {

	                    clearTimeout(contentObserverTimeout);

	                    contentObserverTimeout = setTimeout(updateScrollbar.bind(this, $openedContentWrapper, contentObserverTimeout), 50);
	                }),

	                cancelContentObserver = function () {

	                    clearTimeout(contentObserverTimeout);

	                    contentObserver.disconnect();

	                    $openedContentWrapper.stop();
	                };

	            contentObserver.observe($openedContentWrapper[0], { attributes: true, childList: true, characterData: true, subtree: true });

	            $openedContentWrapper.data("contentObserver." + this.EVENT_NS, cancelContentObserver);
	        }
	    },

	    init = function ($selectable) {

	        this.touch = {};

	        this.init$selectable = $selectable;

	        this.$pageMenu = $($selectable);

	        this.$pageMenu
	            .addClass(CLASS.cssFixed + " " + CLASS.visible);

	        this.changePosition("top");

	        this.$win
	            .on("resize."     + this.EVENT_NS, handleWinResize.bind(this))
	            .on("touchstart." + this.EVENT_NS, handleTouchstart.bind(this))
	            .on("touchmove."  + this.EVENT_NS, handleTouchmove.bind(this))
	            .on("touchend."   + this.EVENT_NS, handleTouchend.bind(this));

	        this.Page.on("*.showPage showPage", toggleShowPage.bind(this));

	        //skryje menu s výběrem sekcí, pokud uživatel přetáhně nějakou sekci do stránky
	        this.draggableActiveObserver = this.Page.observe("draggableActive", function (state) {

	            clearTimeout(draggableActiveTimeout);

	            if (state) {

	                draggableActiveTimeout = setTimeout(this.set.bind(this, "openPageMenu", null), 100);
	            }
	        }, {init: false});

	        this.openPageMenuObserver = this.Page.observe("openPageMenu", function (type) {

	            if (type) {

	                //při otevření nasavit maximální výšku podle okna
	                setMaxHeight.call(this);

	            } else {

	                //při zavření ostranit uživatelem nastavenou velkost a odstranit scrollbar
	                resetCurrentItem.call(this);

	                //při přiblížení sktrýt
	                if (getZoom() > 1) {

	                    this.hide();
	                }
	            }

	        }, {init: false, context: this});

	        //přidá scrollbar při otevření položky
	        this.openPageMenuObserverDefer = this.Page.observe("openPageMenu", function (type) {

	            if (type) {

	                addScrollbar.call(this);
	            }

	        }, {init: false, context: this, defer: true});

	        //skrýt/zobrazit při úpravě stránky
	        this.sortableActiveObserver = this.Page.observe("sortableActive", ensureVisibility.bind(this), {init: false});
	        this.Page.on("*.sectionHasOutline", ensureVisibility.bind(this));
	        this.Page.on("*.openPageSectionSettings *.closeThisSettings", ensureVisibility.bind(this));

	        this.Page.on("activateResizer", activateResizer.bind(this));

	        //změna pozice menu (tlačítkem) - nahoře/dole
	        this.Page.on("switchPosition", function (event, position) {

	            event.original.srcEvent.stopPropagation();
	            event.original.srcEvent.preventDefault();

	            this.changePosition(position);

	        }.bind(this));
	    },

	    PageMenu = function PageMenu($selectable, pageComponent) {

	        this.Page = pageComponent;

	        this.EVENT_NS = "PageMenu-" + (instaceCounter++);
	        this.$win = $(window);

	        init.call(this, $selectable);
	    };

	PageMenu.prototype.destroy = function () {

	    clearTimeout(draggableActiveTimeout);

	    if (this.pageMenuLeft) {

	        this.pageMenuLeft.destroy();
	    }

	    if (this.pageMenuRight) {

	        this.pageMenuRight.destroy();
	    }

	    this.openPageMenuObserver.cancel();
	    this.openPageMenuObserverDefer.cancel();
	    this.sortableActiveObserver.cancel();
	    this.draggableActiveObserver.cancel();

	    this.Page.off("*.sectionHasOutline");
	    this.Page.off("*.openPageSectionSettings");
	    this.Page.off("addingSectionCanceled");
	    this.Page.off("switchPosition");
	    this.Page.off("*.showPage");

	    this.$pageMenu
	        .find("." + CLASS.contentWrapper)
	        .perfectScrollbar("destroy")
	        .each(function (i, wrapper) {

	            var cancelContentObserver = $(wrapper).data("contentObserver." + this.EVENT_NS);

	            if (cancelContentObserver) {

	                cancelContentObserver();
	            }
	        }.bind(this));

	    this.pageMenuLeft  = null;
	    this.pageMenuRight = null;
	    this.$pageMenu = null;
	    this.touch = null;

	    this.$win
	        .off("." + this.EVENT_NS)
	        .off(".resizer-" + this.EVENT_NS);

	    return this;
	};

	//změní pozici menu -> nahoře/dole
	PageMenu.prototype.changePosition = function (position) {

	    this.touch.lastPositionY = this.touch.positionY;

	    this.touch.positionY = position;

	    if (this.touch.positionY === this.touch.lastPositionY) {

	        return this;
	    }

	    var $items = this.$pageMenu.find("." + CLASS.item),
	        savedDisplay;

	    //pokud není použit FixedElement (= desktop), je potřeba zajistit spuštění animací (display: none)
	    if (!this.pageMenuLeft && !this.pageMenuRight) {

	        savedDisplay = this.$pageMenu.css("display");

	        this.$pageMenu.css({
	            display: "none"
	        });

	        $items.css({
	            transition: "none"
	        });
	    }

	    this.$pageMenu[this.touch.positionY === "bottom" ? "removeClass" : "addClass"](CLASS.fixedTop);
	    this.$pageMenu[this.touch.positionY === "bottom" ? "addClass" : "removeClass"](CLASS.fixedBottom);

	    if (this.pageMenuLeft && this.pageMenuRight) {

	        this.pageMenuLeft.fix(true, this.touch.positionY !== this.touch.lastPositionY);
	        this.pageMenuRight.fix(true, this.touch.positionY !== this.touch.lastPositionY);

	        return this; //--->
	    }

	    setTimeout(function() {

	        this.$pageMenu.css({
	            display: savedDisplay
	        });

	        $items.css({
	            transition: ""
	        });

	    }.bind(this), 0);

	    return this;
	};

	PageMenu.prototype.reset = function ($selectable) {

	    this.destroy();

	    init.call(this, $selectable || this.init$selectable);
	};

	//Zobrazí menu. Pokud není použito vynucení (force), menu se zobrazí pouze, pokud je zoom 1 a stránka se needituje
	PageMenu.prototype.show = function (force) {

	    if (force) {

	        this.hidden = false;

	    } else {

	        if (shouldBeHidden) {

	            checkIfShoudBeHidden.call(this);
	        }

	        this.hidden = getZoom() > 1 || shouldBeHidden;
	    }

	    this.$pageMenu[this.hidden ? "addClass" : "removeClass"](CLASS.hidden);
	    this.$pageMenu[this.hidden ? "removeClass" : "addClass"](CLASS.visible);

	    if (this.pageMenuLeft && this.pageMenuRight) {

	        this.pageMenuLeft.fix();
	        this.pageMenuRight.fix();
	    }

	    return this;
	};

	//Skryje menu. Pokud není použito vynucení (force), menu se skryje pouze, pokud není otevřená žádná položka
	PageMenu.prototype.hide = function (force) {

	    if (force) {

	        this.hidden = true;

	    } else {

	        this.hidden = !this.hasOpenedItem();
	    }

	    this.$pageMenu[this.hidden ? "addClass" : "removeClass"](CLASS.hidden);
	    this.$pageMenu[this.hidden ? "removeClass" : "addClass"](CLASS.visible);

	    return this;
	};

	PageMenu.prototype.hasOpenedItem = function () {

	    return this.Page.get("openPageMenu");
	};

	PageMenu.CLASS = CLASS;

	module.exports = PageMenu;


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	/*global $*/

	var slug = __webpack_require__(197);

	var DEF_SECTION_NAME = "sekce";
	var DEF_SECTION_INT_ID_PREFIX = "section-";

	module.exports = (function () {

	    var page,

	        counter = 0,

	        generateId = function (name, counter) {

	            name = name || DEF_SECTION_NAME;

	            var id = slug(counter ? name + "-" + counter : name),

	                sections = page.findAllPageSections(),
	                s = sections.length - 1;

	            counter = counter || 1;

	            for (s; s >= 0; s--) {

	                if (sections[s].get("id") === id) {

	                    return generateId(name, ++counter);
	                }
	            }

	            return id;
	        },

	        generateName = function (name, counter, originalName) {

	            var sections = page.findAllPageSections(),
	                s = sections.length - 1;

	            counter = counter || 2;

	            for (s; s >= 0; s--) {

	                if (sections[s].get("name") === name) {

	                    return generateName((originalName || name) + " " + counter, ++counter, originalName || name);
	                }
	            }

	            return name;
	        },

	        generateInternalId = function () {

	            return DEF_SECTION_INT_ID_PREFIX + Date.now() + (counter++);
	        },

	        create = function (type, rewriteData) {

	            var superDataTemplate = __webpack_require__(74)(),
	                dataTemplate = __webpack_require__(32)("./" + type + "/dataTemplate.js")();

	            dataTemplate.name = generateName(dataTemplate.name);

	            var base = {
	                id: generateId(dataTemplate.name),
	                internalId: generateInternalId()
	            };

	            return $.extend(true, base, superDataTemplate, dataTemplate, rewriteData);
	        },

	        getDefaultName = function (sectionType) {

	            var dataTemplate = __webpack_require__(32)("./" + sectionType + "/dataTemplate.js")();

	            return generateName(dataTemplate.name);
	        };

	    return function PageSectionBuilder(_page) {

	        page = _page;

	        return {
	            create: create,
	            generateId: generateId,
	            getDefaultName: getDefaultName
	        };
	    };

	}());


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/clearInterval
	/*global $, requestAnimationFrame, cancelAnimationFrame*/

	var SUPPORT = __webpack_require__(90),
	    EventEmitter = __webpack_require__(6)();

	module.exports = (function () {

	    var OPTIONS = {
	            DRAGGED_SECTION_HEIGHT: 48,
	            SECTION_SPEED: "0.35s",
	            SECTION_SPEED_JQ: 350,
	            SECTION_EASING: "cubic-bezier(0, 0, .58, 1)",
	            SECTION_EASING_JQ: $.bez([0, 0, 0.58, 1])
	        },

	        CLASS = {
	            fakePlaceholder: "P_PageSection--fake-placeholder",
	            cursorGrabbing: "cursor-grabbing"
	        },

	        page,
	        pageSectionBuilder,

	        $scrollWin,
	        $body,

	        $sortable,
	        $draggable,
	        $droppable,

	        $placeholder,
	        $placeholderTransitions = $("<div></div>"),
	        $fakePlaceholder = $("<div></div>"),

	        $sectionThumb,

	        getSectionsSortedByIndex = function (asComponents) {

	            var pageSections = page.findAllPageSections(),

	                sections = [],
	                pageSectionHeader = null,
	                pageSectionFooter = null,

	                s = pageSections.length - 1;

	            for (s; s >= 0; s--) {

	                if (pageSections[s].get("section.type") === "PageSectionHeader") {

	                    pageSectionHeader = asComponents ? pageSections[s] : pageSections[s].get("section");

	                } else if (pageSections[s].get("section.type") === "PageSectionFooter") {

	                    pageSectionFooter = asComponents ? pageSections[s] : pageSections[s].get("section");

	                } else {

	                    sections[pageSections[s].getCurrentIndex()] = asComponents ? pageSections[s] : pageSections[s].get("section");
	                }
	            }

	            if (pageSectionHeader) {

	                sections.unshift(pageSectionHeader);
	            }

	            if (pageSectionFooter) {

	                sections.push(pageSectionFooter);
	            }

	            //odstranit null (kvůli placeholderu indexy mohou obsahovat mezeru)
	            var s2 = sections.length - 1;

	            for (s2; s2 >= 0; s2--) {

	                if (!sections[s2]) {

	                    sections.splice(s2, 1);
	                }
	            }

	            return sections;
	        },

	        insertSection = function (type, rewriteData, customAnimationProvided) {

	            var data = pageSectionBuilder.create(type, rewriteData),

	                pageSection;

	            page.push("page.sections", data).then(function () {

	                pageSection.generateRandomColors(true, true);
	            });

	            pageSection = page.findAllPageSections().pop();

	            if (!customAnimationProvided) {

	                var $pageSection = $(pageSection.getSectionElement());

	                $scrollWin.stop().animate({
	                    scrollTop: $pageSection.offset().top
	                }, OPTIONS.SECTION_SPEED_JQ, OPTIONS.SECTION_EASING_JQ);

	                $pageSection
	                    .hide()
	                    .addClass([
	                        CLASS.PageSection.placedSection,
	                        CLASS.PageSection.newSection,
	                        CLASS.PageSection.insertedByTap
	                    ].join(" "))
	                    .css({
	                        transition: "none"
	                    })
	                    .slideDown(OPTIONS.SECTION_SPEED_JQ, OPTIONS.SECTION_EASING_JQ, function () {

	                        $pageSection.removeClass([
	                            CLASS.PageSection.placedSection,
	                            CLASS.PageSection.newSection,
	                            CLASS.PageSection.insertedByTap
	                        ].join(" "));

	                        page.set("sortableActive", "");

	                        //spoždění zapnutí transition kvůli iOS
	                        requestAnimationFrame(function () {

	                            $pageSection.css({
	                                transition: ""
	                            });
	                        });
	                    });
	            }

	            page.fire("sectionInserted", pageSection);

	            pageSection.once("complete", function () {

	                page.fire("sectionInserted.complete", pageSection);
	            });

	            return pageSection;
	        },

	        removeSection = function (e) {

	            var pageSection = e.component.getPageSection(),
	                $sectionElement = pageSection.get$SectionElement();

	            pageSection.set("isRemoved", true);

	            page.fire("sectionRemoved", pageSection);

	            $sectionElement
	                .addClass(CLASS.PageSection.removedSection)
	                .slideUp(OPTIONS.SECTION_SPEED_JQ, OPTIONS.SECTION_EASING_JQ, function () {

	                    var sections = page.findAllPageSections(),
	                        s = sections.length - 1;

	                    for (s; s >= 0; s--) {

	                        if (sections[s] === pageSection) {

	                            page.splice("page.sections", s, 1);

	                            break;
	                        }
	                    }

	                    page.fire("sectionRemoved.complete", pageSection);

	                    $placeholderTransitions.remove();
	                });
	        },

	        getIndexFor = function ($section) {

	            var index = -1;

	            $("." + CLASS.PageSection.self).each(function (i, section) {

	                if (section === $section[0]) {

	                    index = i;

	                    return false;
	                }
	            });

	            return index;
	        },

	        onSortableActivate = function (e, ui) {

	            page.set("sortableActive", CLASS.Page.sortableActive);

	            if (ui.item.hasClass(CLASS.NewPageSectionSelector.sectionThumb)) {

	                return;
	            }

	            var sectionHeight = ui.item[0].getBoundingClientRect().height;

	            //Placeholder pro transitions se nastaví na velikost sekce mínus velikost velikost
	            //"umisťovacího" placeholderu (velikost sekce při přetahování)
	            $placeholderTransitions.css({
	                height: sectionHeight - OPTIONS.DRAGGED_SECTION_HEIGHT
	            });

	            ui.item
	                .data("height", sectionHeight)
	                .css({
	                    position: "absolute",
	                    top: 0,

	                    height: sectionHeight,

	                    //vypnutí transition kvůli iOS
	                    transition: "none"
	                })
	                .data("index.PageSectionManager", getIndexFor(ui.item))
	                .addClass(CLASS.PageSection.draggedSection)
	                .after($placeholderTransitions);

	            $fakePlaceholder.remove();

	            EventEmitter.trigger("sortPageSection.PageSectionManager");

	            $body.addClass(CLASS.cursorGrabbing);
	        },

	        onSortableStart = function (e, ui) {

	            if (ui.item.hasClass(CLASS.NewPageSectionSelector.sectionThumb)) {

	                return;
	            }

	            //Sekce se zmenší
	            ui.item.css({
	                height: OPTIONS.DRAGGED_SECTION_HEIGHT,

	                //opětovné zapnutí transition kvůli iOS
	                transition: ""
	            });

	            //Placeholder pro transitions se zmenší na nulu, aby zůstal vidět jen přeřazovací
	            $placeholderTransitions.css({
	                height: 0
	            });

	            $placeholder = $placeholder && $placeholder.length ? $placeholder : $sortable.find("." + CLASS.PageSection.placeholder);

	            //nastavit výchozí stav placeholderu (<- nemusí být nastaven, pokud uživatel předtím vrátil sekce zpět)
	            $placeholder.css({
	                height: OPTIONS.DRAGGED_SECTION_HEIGHT,

	                display: "block",
	                transition: "none"
	            });

	            ui.item.data("inSortable.PageSectionsManager", true);
	        },

	        onSortableChange = function (e, ui) {

	            $placeholder = $placeholder && $placeholder.length ? $placeholder : $sortable.find("." + CLASS.PageSection.placeholder);

	            //nová sekce (zástupce) přetažena zpět do stránky -> zvětšit placeholder
	            if (!ui.item.data("inSortable.PageSectionsManager")) {

	                page.set("cancelAddSection", false);
	                if ($sectionThumb) {

	                    $sectionThumb.removeClass(CLASS.NewPageSectionSelector.cancelAddSection);
	                }

	                $placeholder.css({
	                    height: 0,

	                    display: "block",
	                    transition: "none"
	                });

	                requestAnimationFrame(function () {
	                    $placeholder.css({
	                        height: OPTIONS.DRAGGED_SECTION_HEIGHT,

	                        transition: ""
	                    });
	                });
	            }

	            //označení, že sekce se nachází uvnit stránky - důležité pro přidávání nových sekcí,
	            //aby se zjistilo, jestli je sekce ve stránce nebo ve výběru sekcí (pro odsranění)
	            ui.item.data("inSortable.PageSectionsManager", true);

	            if (ui.item.hasClass(CLASS.NewPageSectionSelector.sectionThumb) && !ui.item.hasClass(CLASS.NewPageSectionSelector.inserted)) {

	                ui.item.addClass(CLASS.NewPageSectionSelector.inserted);

	                //zvětšení placeholdru, když uživatel přetáhne poprvé novou sekce do stránky
	                $placeholder.css({
	                    height: 0,

	                    transition: "none"
	                });

	                $placeholderTransitions.css({
	                    height: 0,

	                    transition: "none"
	                });

	                requestAnimationFrame(function() {

	                    $placeholder.css({
	                        height: OPTIONS.DRAGGED_SECTION_HEIGHT,

	                        transition: ""
	                    });

	                    $placeholderTransitions.css({
	                        transition: ""
	                    });
	                });

	                return;
	            }

	            ui.item.data("positionChanged.PageSectionsManager", true);
	        },

	        onSortableStop = function (e, ui) {

	            $body.removeClass(CLASS.cursorGrabbing);

	            page.set("sortableActive", "");
	            page.set("draggableActive", false);

	            //Placeholder pro transitions je potřeba vložit za "umisťovací" placehloder,
	            //protože ho bude potřeba na chvíli zobrazit při umístění sekce
	            if (ui.item.data("positionChanged.PageSectionsManager")) {

	                $placeholder.before($placeholderTransitions);

	                ui.item.data("positionChanged.PageSectionsManager", false);
	            }

	            if (ui.item.hasClass(CLASS.NewPageSectionSelector.sectionThumb)) {

	                $("." + CLASS.NewPageSectionSelector.inserted).removeClass(CLASS.NewPageSectionSelector.inserted);

	                //klon přetahované sekce
	                var $itemOffsetParent = ui.item.offsetParent(),
	                    itemParentOffset = $itemOffsetParent.offset(),
	                    //pozice vložené sekce = zástupce sekce
	                    itemOffset = ui.item.offset(),

	                    //pozice klonu, na kterou se přesune zástupce sekce kvůli animaci
	                    cloneWidth = $sectionThumb.outerWidth(),
	                    cloneHeight = $sectionThumb.outerHeight(),
	                    cloneOffset = $sectionThumb.offset(),

	                    //vygeneruje se nová sekce a vloží se do stránky
	                    newPageSection = insertSection(ui.item.data("page-section-type"), {}, true),
	                    $newPageSection = $(newPageSection.getSectionElement()),
	                    //vnitřní obalovací element sekce
	                    $inner = $newPageSection.find("." + CLASS.PageSection.innerWrapper);

	                //sekce se přesune na místo zástupce
	                ui.item.after($newPageSection);

	                var newSectionHeight = $newPageSection.outerHeight(),
	                    newSectionWidth = $newPageSection.outerWidth();

	                //zafixují se rozměry vnitřního obalovacího elementu a element se přesune ke kraji stránky
	                $inner.css({
	                    width: $inner.outerWidth(),

	                    transform: "translate(" + ((cloneOffset.left - itemOffset.left) * -1) + "px, 0px)",

	                    transition: "none"
	                });

	                $newPageSection
	                    .addClass(CLASS.PageSection.placedSection)
	                    .addClass(CLASS.PageSection.newSection)
	                    .css({
	                        //zástupce, podle kterého se nastaví i velikost sekce, je větší než DRAGGED_SECTION_HEIGHT,
	                        //proto je potřeba použit negativní margin, aby následující sekce neskočily dolů.
	                        marginBottom: -cloneHeight + OPTIONS.DRAGGED_SECTION_HEIGHT,

	                        height: cloneHeight,
	                        width: cloneWidth,

	                        //přesunutí na místo klonu zástupce
	                        transform: "translate(" + (cloneOffset.left - itemOffset.left) + "px, " + (cloneOffset.top - itemOffset.top) + "px)",

	                        transition: "none"
	                    });

	                //zástupce se přesune na místo klonu
	                ui.item.css({
	                    zIndex: 110,
	                    position: "absolute",
	                    top: -itemParentOffset.top,
	                    left: -itemParentOffset.left,

	                    height: cloneHeight,
	                    width: cloneWidth,

	                    opacity: 1,

	                    transform: "translate(" + cloneOffset.left + "px, " + cloneOffset.top + "px)",

	                    transition: "none"
	                });

	                //Zobrazit fake-placeholder
	                $fakePlaceholder
	                    .css({
	                        height: OPTIONS.DRAGGED_SECTION_HEIGHT,

	                        transition: "none"
	                    })
	                    .appendTo("#page")
	                    .offset(itemOffset);

	                //spuštění animace
	                //pokud se použije rAF, Webkit dělá chyby
	                setTimeout(function() {

	                    //fake-placeholder se zvětší na velikost nové sekce
	                    $fakePlaceholder
	                        .css({
	                            height: newSectionHeight,

	                            transition: ""
	                        });

	                    //zástupce se přesune a zvětší, podle nové sekce
	                    ui.item
	                        .css({
	                            height: newSectionHeight,
	                            width: newSectionWidth,

	                            opacity: 0,

	                            transform: "translate(" + itemOffset.left + "px, " + itemOffset.top + "px)",

	                            transition: "all " + OPTIONS.SECTION_SPEED + " " + OPTIONS.SECTION_EASING
	                        })
	                        .off(SUPPORT.TRANSITIONEND)
	                        .on(SUPPORT.TRANSITIONEND, function (e) {

	                            if (e.originalEvent.propertyName === "transform") {

	                                //zástupce se po provedení animace smaže
	                                ui.item.off(SUPPORT.TRANSITIONEND).remove();
	                            }
	                        });

	                    //vnitřní element se vrátí na nulovou pozici
	                    $inner
	                        .css({
	                            transform: "translate(0px, 0px)",

	                            transition: "all " + OPTIONS.SECTION_SPEED + " " + OPTIONS.SECTION_EASING
	                        })
	                        .one(SUPPORT.TRANSITIONEND, function () {

	                            $inner.css({
	                                transform: "",

	                                transition: ""
	                            });
	                        });

	                    //sekce se roztáhne a přesuna na konečné místo
	                    $newPageSection
	                        .css({
	                            marginBottom: 0,

	                            height: newSectionHeight,
	                            width: newSectionWidth,

	                            transform: "translate(0px, 0px)",

	                            transition: "all " + OPTIONS.SECTION_SPEED + " " + OPTIONS.SECTION_EASING
	                        })
	                        .one(SUPPORT.TRANSITIONEND, function () {

	                            $fakePlaceholder.remove();

	                            $inner.css({
	                                width: ""
	                            });

	                            $newPageSection
	                                .removeClass(CLASS.PageSection.placedSection)
	                                .removeClass(CLASS.PageSection.newSection)
	                                .css({
	                                    marginBottom: "",

	                                    width: "",
	                                    height: "",

	                                    transform: "",

	                                    //vypnutí a zapnutí transition kvůli iOS
	                                    transition: "none"
	                                });

	                            //vypnutí a zapnutí transition kvůli iOS
	                            requestAnimationFrame(function () {
	                                $newPageSection.css({
	                                    transition: ""
	                                });
	                            });
	                        });
	                }, 0);

	                $sectionThumb = null;

	                return;
	            }

	            var placeholderOffset = $placeholder.offset();

	            $placeholder.remove();

	            //Zobrazí se placeholder pro transitions, protože umisťovací je odstraněn
	            //a sekce se vloží až v následujícím cyklu prohlížeče.
	            $placeholderTransitions.css({
	                height: OPTIONS.DRAGGED_SECTION_HEIGHT,
	                transition: "none"
	            });

	            ui.item.css({
	                top: "auto"
	            });

	            //Zobrazit fake-placeholder
	            $fakePlaceholder
	                .css({
	                    height: OPTIONS.DRAGGED_SECTION_HEIGHT,

	                    transition: "none"
	                })
	                .appendTo("#page")
	                .offset(placeholderOffset);

	            requestAnimationFrame(function() {

	                var beforeIndex = ui.item.data("index.PageSectionManager"),
	                    currentIndex = getIndexFor(ui.item);

	                if (beforeIndex !== currentIndex) {

	                    page.getPageSectionByElement(ui.item)
	                        .fire("sectionOrderChanged", currentIndex, beforeIndex);
	                }

	                ui.item.data("index.PageSectionManager", null);

	                //Placeholder pro transitions se zmenší na nulu a vrátí se zpět transition.
	                //Protože sekce je již vložena a má velikost jako placeholder.
	                requestAnimationFrame(function() {

	                    $placeholderTransitions.css({
	                        transition: ""
	                    });
	                });

	                //fake-placehoder se zvětší na původní velkost sekce
	                $fakePlaceholder
	                    .css({
	                        height: ui.item.data("height"),

	                        transition: ""
	                    });

	                $placeholderTransitions
	                    .css({
	                        height: 0
	                    })
	                    .one(SUPPORT.TRANSITIONEND, function () {
	                        $placeholderTransitions.remove();
	                    });

	                ui.item
	                    .one(SUPPORT.TRANSITIONEND, function () {

	                        $fakePlaceholder.remove();

	                        ui.item
	                            //odstraní se přiřazená velikost pro transition
	                            .css({
	                                top: "",
	                                height: "",
	                                transition: "none"
	                            })
	                            .removeClass(CLASS.PageSection.placedSection);

	                        requestAnimationFrame(function() {
	                            ui.item.css({
	                                transition: ""
	                            });
	                        });
	                    })
	                    .css({
	                        position: "relative",
	                        //sekce se roztáhne na svou původní velikost
	                        height: ui.item.data("height")
	                    })
	                    .addClass(CLASS.PageSection.placedSection)
	                    .removeClass(CLASS.PageSection.draggedSection);
	            });

	            $sectionThumb = null;
	        },

	        onDraggableStart = function (e, ui) {

	            if (ui.item.hasClass(CLASS.NewPageSectionSelector.sectionThumb)) {

	                page.set("sortableActive", CLASS.Page.sortableActive);
	                page.set("draggableActive", true);

	                //přesunutí klonu do "<body />", protože pozice klonu není přesně na klonovaném elemenu
	                //a je posunut daleko od šipky
	                $sectionThumb = ui.item.siblings("." + CLASS.NewPageSectionSelector.clone);

	                $body
	                    .append($sectionThumb)
	                    .addClass(CLASS.cursorGrabbing);

	                var offset = ui.item.offset();

	                $sectionThumb.css({
	                    top: offset.top,
	                    left: offset.left,
	                    transform: "translate(0px, 0px)"
	                });
	            }
	        },

	        onDraggableStop = function () {

	            $body.removeClass(CLASS.cursorGrabbing);

	            page.set("sortableActive", "");
	            page.set("draggableActive", false);
	        },

	        onDroppableOver = function (e, ui) {

	            //zmenší placeholder na nulu, když uživatel přetáhne sekci zpět do výběru ("koše")
	            if ($placeholder && ui.item.data("inSortable.PageSectionsManager")) {

	                $placeholder.css({
	                    height: 0,

	                    display: "block",
	                    transition: ""
	                });

	                if ($sectionThumb) {

	                    $sectionThumb.addClass(CLASS.NewPageSectionSelector.cancelAddSection);
	                }

	                page.set("cancelAddSection", true);
	            }

	            //události "out" a "over" se spouští příliš často -> zajištění, aby se vše provedlo jen jednou
	            ui.item.data("inSortable.PageSectionsManager", false);
	        },

	        onDroppableDrop = function (e, ui) {

	            page.set("sortableActive", "");
	            page.set("draggableActive", false);
	            page.set("cancelAddSection", false);

	            //vytvoření klonu kvůli animaci, protože přetahovaný element zmizí
	            var $clone = ui.helper.clone();

	            $body.append($clone);

	            $clone
	                .addClass(CLASS.NewPageSectionSelector.cloneRemoved)
	                .fadeOut(OPTIONS.SECTION_SPEED_JQ, function () {
	                    $clone.remove();
	                });

	            $placeholderTransitions.remove();

	            $sectionThumb = null;

	            //zabránění vložení klonu
	            e.preventDefault();
	        },

	        init = function () {

	            $droppable = $("." + CLASS.Page.PageMenu.self + ", ." + CLASS.PageSection.parentOfNonSortable).droppable({
	                accept: ".___XXX",

	                alwaysShowPlaceholder: true
	            });

	            $droppable
	                .on("droppable:over", onDroppableOver)
	                .on("droppable:drop", onDroppableDrop);

	            $draggable = $("." + CLASS.NewPageSectionSelector.sectionThumb).draggable({
	                connectWith: "." + CLASS.PageSection.parentOfSortable + ", ." + CLASS.Page.PageMenu.self + ", ." + CLASS.PageSection.parentOfNonSortable,
	                cancel: "." + CLASS.NewPageSectionSelector.sectionThumbDisabled,
	                placeholder: CLASS.PageSection.placeholder,
	                cloneClass: CLASS.NewPageSectionSelector.clone,

	                clone: true,
	                onlyYDir: true
	            });

	            $draggable
	                .on("draggable:start", onDraggableStart)
	                .on("draggable:stop", onDraggableStop)
	                .on("touchstart.PageSectionManager", function (e) {
	                    e.stopPropagation();
	                });

	            $sortable = $("." + CLASS.PageSection.parentOfSortable).sortable({
	                items: "." + CLASS.PageSection.self,
	                handle: "." + CLASS.PageSection.sortHandle,
	                placeholder: CLASS.PageSection.placeholder,

	                transition: [
	                    "height " + OPTIONS.SECTION_SPEED + " " + OPTIONS.SECTION_EASING,
	                    "transform " + OPTIONS.SECTION_SPEED + " " + OPTIONS.SECTION_EASING
	                ].join(","),

	                onlyYDir: true,
	                fixedX: true
	            });

	            $sortable
	                .on("sortable:activate", onSortableActivate)
	                .on("sortable:start", onSortableStart)
	                .on("sortable:change", onSortableChange)
	                .on("sortable:stop", onSortableStop);

	            page.on("*.removeSection", removeSection);
	            page.on("NewPageSectionSelector.insertSection", function (event) {
	                insertSection(event.node.dataset.pageSectionType);
	            });
	        },

	        destroy = function () {

	            if ($sortable) {

	                $sortable.sortable("destroy");
	            }

	            if ($draggable) {

	                $draggable
	                    .draggable("destroy")
	                    .off("touchstart.PageSectionManager");
	            }

	            if ($droppable) {

	                $droppable.droppable("destroy");
	            }

	            $placeholderTransitions.remove();

	            page.off("*.removeSection");
	            page.off("NewPageSectionSelector.insertSection");
	        },

	        reset = function () {

	            destroy();
	            init();
	        };

	    return function PageSectionManager(pageComponent, _pageSectionBuilder, deferInit) {

	        page = pageComponent;

	        CLASS.Page = page.CLASS;
	        CLASS.PageSection = page.components.PageSection.prototype.CLASS;
	        CLASS.NewPageSectionSelector = page.components.NewPageSectionSelector.prototype.CLASS;

	        pageSectionBuilder = _pageSectionBuilder;

	        $placeholderTransitions.addClass(CLASS.PageSection.placeholderTransitions);
	        $fakePlaceholder.addClass(CLASS.fakePlaceholder);

	        $body = $("body");
	        $scrollWin = $("html, body");

	        if (!deferInit) {

	            init();
	        }

	        return {
	            insertSection: insertSection,
	            removeSection: removeSection,
	            getSectionsSortedByIndex: getSectionsSortedByIndex,
	            destroy: destroy,
	            reset: reset
	        };
	    };

	}());


/***/ },
/* 88 */
/***/ function(module, exports) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	/*global $*/

	var MODES = {
	        PAGE: 0,
	        EDIT: 1,
	        ADMIN: 2
	    },

	    EVENT_NS = "ScrollToSection",

	    $scrollElement,
	    $eventElement;

	var getAnchorSelector = function (prefix) {

	    prefix = prefix || "";

	    return "a[href^='#" + prefix + "'], " + "a[href^='" + window.location.origin.replace(/\/$|\\$/, "") + "/#" + prefix + "']";
	};

	var rewriteInternalRefs = function () {

	    var selector = getAnchorSelector(this.internalSectionPrefix);

	    $(selector).each(function () {

	        var sectionInternalId = this.href.split("#")[1],
	            sectionId = $("[data-page-section-internal-id='" + sectionInternalId + "']").attr("id");

	        this.href = "#" + sectionId;
	    });
	};

	var initScrollAnim = function (requireCtrl) {

	    var selector = getAnchorSelector(),
	        events = "click." + EVENT_NS + " touchend." + EVENT_NS;

	    $eventElement.on(events, selector, function (e) {

	        if (requireCtrl && !e.ctrlKey) {

	            return true;
	        }

	        var id = this.getIdFromURL(e.target.href);

	        if (this.scrollToSectionById(id)) {

	            e.preventDefault();
	            return false;
	        }

	    }.bind(this));
	};

	var initMouseOver = function () {

	    var selector = getAnchorSelector(),
	        mouseEvents = "mouseover." + EVENT_NS + " mouseout." + EVENT_NS,
	        keyEvents = "keydown." + EVENT_NS + " keyup." + EVENT_NS,

	        $a = null;

	    $eventElement
	        .on(mouseEvents, selector, function (e) {

	            if (e.type === "mouseover") {

	                $a = $(e.target);

	                $a.css({
	                    cursor: e.ctrlKey ? "pointer": ""
	                });

	            } else if (e.type === "mouseout") {

	                $a.css({
	                    cursor: ""
	                });

	                $a = null;
	            }
	        })
	        .on(keyEvents, function (e) {

	            if (e.which === 17 /*CTRL*/ && $a) {

	                $a.css({
	                    cursor: $a && e.ctrlKey ? "pointer": ""
	                });
	            }
	        });
	};

	var init = function () {

	    if (this.mode === MODES.PAGE) {

	        rewriteInternalRefs.call(this);
	    }

	    if (this.mode >= MODES.EDIT) {

	        initMouseOver.call(this);
	    }

	    initScrollAnim.call(this, this.mode >= MODES.EDIT);
	};

	var ScrollToSection = function ScrollToSection(mode, internalSectionPrefix, duration, easing) {

	    this.mode = mode || MODES.PAGE;
	    this.internalSectionPrefix = internalSectionPrefix || "section-";
	    this.duration = duration || 300;
	    this.easing = easing || $.easing.easeOutSine ? "easeOutSine" : "swing";

	    $scrollElement = $("html, body");
	    $eventElement = $("body");

	    init.call(this);
	};

	ScrollToSection.MODES = MODES;

	ScrollToSection.prototype.getIdFromURL = function (URL) {

	    return URL.split("#")[1];
	};

	ScrollToSection.prototype.isInternalId = function (hash) {

	    return hash.indexOf(this.internalSectionPrefix) === 0;
	};

	ScrollToSection.prototype.findSectionById = function (id) {

	    return $("#" + id);
	};

	ScrollToSection.prototype.findSectionByInternalId = function (id) {

	    return $("[data-page-section-internal-id='" + id + "']");
	};

	ScrollToSection.prototype.scrollToSectionById = function (id, cb) {

	    var $section;

	    if (this.isInternalId(id)) {

	        $section = this.findSectionByInternalId(id);

	        id = $section.attr("id");

	    } else {

	        $section = this.findSectionById(id);
	    }

	    if (this.scrollToSection($section, cb)) {

	        return true;
	    }

	    return false;
	};

	ScrollToSection.prototype.scrollToSection = function ($section, cb) {

	    if ($section.length) {

	         var id = $section.attr("id");
	         $section.attr("id", "");

	         $scrollElement.stop().animate({
	             scrollTop: Math.min(document.documentElement.scrollHeight - window.innerHeight, $section.offset().top)
	         }, this.duration, this.easing, cb);

	         window.location.href = "#" + id;
	         $section.attr("id", id);

	         return true;
	    }

	    return false;
	};

	ScrollToSection.prototype.destroy = function () {

	    $eventElement.off([
	        "click.", EVENT_NS,
	        " touchend.", EVENT_NS,
	        " mouseover.", EVENT_NS,
	        " mouseout.", EVENT_NS,
	        " keydown.", EVENT_NS,
	        " keyup.", EVENT_NS
	    ].join(""));
	};

	ScrollToSection.prototype.refresh = function () {

	    this.destroy();

	    init.call(this);
	};

	module.exports = ScrollToSection;


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	/*global $*/

	var on = __webpack_require__(1);
	var Ractive = __webpack_require__(0);

	var EventEmitter = __webpack_require__(6)();

	var FixedElement;
	var PageMenu;

	if (on.client) {

	    FixedElement = __webpack_require__(24);
	    PageMenu = __webpack_require__(85);
	}

	Ractive.defaults.getPageSection = function () {

	    if (this.PAGE_SECTION) {

	        return this;
	    }

	    if (this.parent) {

	        return Ractive.defaults.getPageSection.apply(this.parent, arguments);
	    }

	    return null;
	};

	module.exports = Ractive.extend({

	    template: __webpack_require__(182),

	    CLASS: {
	        titleEditor: "E_Editor__title",
	        contentEditor: "E_Editor__content",

	        sortableActive: "E_Page__sortable-active",

	        PageMenu: {
	            self: "E_PageMenu"
	        }
	    },

	    components: {
	        PageSection: __webpack_require__(13),

	        PageSectionA: __webpack_require__(69),
	        PageSectionB: __webpack_require__(71),
	        PageSectionC: __webpack_require__(73),

	        NewPageSectionSelector: Ractive.EDIT_MODE ? __webpack_require__(59) : null,
	        GlobalPageSettings: Ractive.EDIT_MODE ? __webpack_require__(58) : null,

	        InlineWidget: Ractive.EDIT_MODE ? __webpack_require__(35) : null,
	        PageMenuInlineWidget: Ractive.EDIT_MODE ? __webpack_require__(84) : null
	    },

	    partials: {
	        PageSectionA: "<PageSectionA section='{{this}}' />",
	        PageSectionB: "<PageSectionB section='{{this}}' />",
	        PageSectionC: "<PageSectionC section='{{this}}' />",

	        pageMenu: Ractive.EDIT_MODE ? __webpack_require__(181) : null,

	        FlatButton: Ractive.EDIT_MODE ? __webpack_require__(44) : null,
	        Button: Ractive.EDIT_MODE ? __webpack_require__(46) : null,
	        Switch: Ractive.EDIT_MODE ? __webpack_require__(189) : null,
	        Slider: Ractive.EDIT_MODE ? __webpack_require__(188) : null,
	        Select: Ractive.EDIT_MODE ? __webpack_require__(47) : null,
	        Toggle: Ractive.EDIT_MODE ? __webpack_require__(191) : null,
	        ToggleField: Ractive.EDIT_MODE ? __webpack_require__(190) : null
	    },

	    data: function () {

	        return {
	            sortableActive: "",
	            draggableActive: "",
	            openPageMenu: null,
	            cancelAddSection: false,
	            unsavedChanges: false,

	            defaults: {
	                settings: {
	                    animations: 10,
	                    roundness: 0,
	                    fontType: "P_font-type-1",
	                    colorPalette: {
	                        colors: [
	                            "rgb(255, 200, 87)",
	                            "rgb(233, 114, 76)",
	                            "rgb(197, 40, 61)",
	                            "rgb(72, 29, 36)",
	                            "rgb(37, 95, 133)"
	                        ],
	                        headerImg: ""
	                    }
	                }
	            }
	        };
	    },

	    onconfig: function () {

	        if (this.get("isAdmin")) {

	            if (!this.root.get("unsavedPages")) {

	                this.root.set("unsavedPages", []);
	            }

	            this.Admin = this.root.findComponent("Admin");

	            var pageId = this.get("pageId");

	            if (this.isCurrentPage(pageId)) {

	                this.alreadyLoaded = true;

	                this.checkUnsavedChanges(pageId);

	                return;
	            }

	            this.loadPage(pageId);
	        }
	    },

	    onrender: function () {

	        if (this.Admin) {

	            var $el = $("#pageWrapper");

	            $el.css("margin-top", -$el.offset().top);
	        }

	        Ractive.$win = Ractive.$win || $(window);

	        if (Ractive.EDIT_MODE) {

	            //zablokovat funkci zpět při backspacu
	            Ractive.$win.on("keydown.Page", function (e) {

	                if (e.which === 8) /*Backspace*/ {

	                    if (e.target && e.target.tagName.toLowerCase().match(/body|html/)) {

	                        return false;
	                    }
	                }
	            });
	        }
	    },

	    oncomplete: function () {

	        if (Ractive.EDIT_MODE && (!this.Admin || this.alreadyLoaded)) {

	            this.initPage();
	        }

	        if (!Ractive.EDIT_MODE && !this.Admin) {

	            this.initScrollToSection();
	        }

	        console.timeEnd("pageLoaded");
	    },

	    onteardown: function () {

	        if (Ractive.EDIT_MODE) {

	            Ractive.$win.off(".Page");

	            this.contentEditor.destroy();
	            this.titleEditor.destroy();

	            this.pageSectionsManager.destroy();

	            this.scrollToSection.destroy();

	            this.pageMenu.destroy();

	            clearTimeout(this.unsavedChangesTimeout);
	        }
	    },

	    checkUnsavedChanges: function (pageId) {

	        if (~this.root.get("unsavedPages").indexOf(pageId)) {

	            this.set("unsavedChanges", true);
	        }
	    },

	    initEditors: function () {

	        var TitleEditor = __webpack_require__(81);
	        var ContentEditor = __webpack_require__(76);

	        this.titleEditor = new TitleEditor(
	            "." + this.CLASS.titleEditor,
	            this.get.bind(this, "page.sections")
	        );
	        this.contentEditor = new ContentEditor(
	            "." + this.CLASS.contentEditor,
	            this.get.bind(this, "page.sections")
	        );

	        this.off("sectionInserted.complete").on("sectionInserted.complete", this.refreshEditors.bind(this, true));
	        this.off("sectionRemoved.complete").on("sectionRemoved.complete", this.refreshEditors.bind(this, true));

	        this.editorsLoaded = true;
	    },

	    initScrollToSection: function () {

	        var ScrollToSection = __webpack_require__(88),

	            mode = Ractive.EDIT_MODE ? ScrollToSection.MODES.EDIT : ScrollToSection.MODES.PAGE;

	        this.scrollToSection = new ScrollToSection(mode, "section-");
	    },

	    refreshEditors: function (elementsOnly) {

	        this.titleEditor.refresh(elementsOnly === true);
	        this.contentEditor.refresh(elementsOnly === true);
	    },

	    isCurrentPage: function (pageId) {

	        return pageId === this.root.get("page._id");
	    },

	    initPage: function () {

	        if (!this.pageSectionsManager) {

	            var PageSectionBuilder = __webpack_require__(86);

	            this.pageSectionBuilder = new PageSectionBuilder(this);

	            this.pageSectionsManager = __webpack_require__(87)(
	                this, this.pageSectionBuilder, !this.get("page._id")
	            );

	        } else {

	            this.pageSectionsManager.reset();
	        }

	        this[this.editorsLoaded ? "refreshEditors" : "initEditors"]();

	        if (!this.scrollToSection) {

	            this.initScrollToSection();
	        }

	        this.pageMenuElements = this.findAll("." + this.CLASS.PageMenu.self);

	        if (!this.pageMenu) {

	            this.pageMenu = new PageMenu(this.pageMenuElements, this);

	        } else {

	            this.pageMenu.reset();
	        }

	        if (!this.defaultColorsGenerator) {

	            if (!this.get("page.settings.colorPalette")) {

	                this.set("page.settings.colorPalette", this.get("defaults.settings.colorPalette"));
	            }

	            var DefaultColorsGenerator = __webpack_require__(75);

	            this.defaultColorsGenerator = new DefaultColorsGenerator(this, this.get("page.settings.colorPalette"));

	        } else {

	            this.defaultColorsGenerator.reset();
	        }

	        //sledovat změny stránky -> označit jako neuložené
	        this.observe("page.settings page.sections", this.handlePageChanged, {init: false});
	        this.on("*.sectionOrderChanged", this.handlePageChanged, {init: false});
	        this.on("savePage", this.savePage);
	        this.on("closePage", this.closePage);
	    },

	    handlePageChanged: function () {

	        clearTimeout(this.unsavedChangesTimeout);

	        if (this.get("pageIsSaving")) {

	            return;
	        }

	        this.unsavedChangesTimeout = setTimeout(
	            this.set.bind(this, "unsavedChanges", true), 500
	        );
	    },

	    loadPage: function (pageId) {

	        var loadReq = this.req("page", {
	            _id: pageId
	        });

	        loadReq.then(function (page) {

	            this.root.set("page.name", page.name);
	            this.root.set("page.settings", page.settings);
	            this.root.set("page.sections", page.sections);
	            this.root.set("page._id", page._id);

	        }.bind(this));

	        loadReq.then(this.initPage.bind(this));
	    },

	    savePage: function (skipDialog) {

	        clearTimeout(this.changesSavedTimeout);

	        if (skipDialog !== true) {

	            this.fire("showDialog", {
	                type: "warn",
	                title: "Uložit změny",
	                text: "Chcete uložit a publikovat provedené změny?",
	                confirm: {
	                    text: "Uložit",
	                    exec: this.savePage.bind(this, true)
	                },
	                dismiss: {
	                    active: 1
	                }
	            });

	            return;
	        }

	        this.set("changesSaved", false);
	        this.set("pageIsSaving", true);

	        var sortedSections = this.pageSectionsManager.getSectionsSortedByIndex(),

	            params = {
	                name: this.get("page.name"),
	                settings: this.get("page.settings"),
	                sections: sortedSections,
	                _id: this.get("page._id")
	            };

	        this.merge("page.sections", sortedSections);

	        var saveReq = this.req("page.save", params);

	        saveReq.then(function (res) {

	            if (res.saved) {

	                this.set("pageIsSaving", false);
	                this.set("unsavedChanges", false);
	                this.set("changesSaved", true);

	                var pageId = this.get("pageId"),

	                    inUnsavedPages = (this.root.get("unsavedPages") || []).indexOf(pageId);

	                if (~inUnsavedPages) {

	                    this.root.splice("unsavedPages", inUnsavedPages, 1);
	                }

	                clearTimeout(this.changesSavedTimeout);

	                this.changesSavedTimeout = setTimeout(this.set.bind(this, "changesSaved", false), 3000);

	                console.log("Uloženo!");
	            }
	        }.bind(this));
	    },

	    closePage: function () {

	        if (this.get("unsavedChanges")) {

	            this.fire("showDialog", {
	                title: "Zavřít editaci",
	                text: "Některé změny nebyly uloženy. Chcete přesto eidtaci zavřít?",
	                type: "warn",
	                confirm: {
	                    exec: function () {

	                        if (this.Admin) {

	                            if (this.get("unsavedChanges")) {

	                                this.merge("page.sections", this.pageSectionsManager.getSectionsSortedByIndex());

	                                this.root.push("unsavedPages", this.get("pageId"));
	                            }

	                            this.Admin.set("editPage", null);
	                        }
	                    },
	                    context: this,
	                    text: "Ano"
	                },
	                dismiss: {
	                    text: "Ne"
	                }
	            });

	            return;
	        }

	        if (this.Admin) {

	            this.Admin.set("editPage", null);
	        }
	    },

	    getPageElement: function () {

	        this.self = this.self || this.find("#page");

	        return this.self;
	    },

	    get$PageElement: function () {

	        this.$self = this.$self || $(this.self);

	        return this.$self;
	    },

	    findSiblingSections: function (section) {

	        var allSections = this.findAllPageSections(),
	            s = allSections.length - 1,

	            siblings = [];

	        for (s; s >= 0; s--) {

	            if (allSections[s] !== section) {

	                siblings.unshift(allSections[s]);
	            }
	        }

	        return siblings;
	    },

	    findAllPageSections: function () {

	        var components = this.findAllComponents(),
	            c = components.length - 1,

	            pageSections = [];

	        for (c; c >= 0; c--) {

	            if (components[c].PAGE_SECTION) {

	                pageSections.unshift(components[c]);
	            }
	        }

	        return pageSections;
	    },

	    findPageSections: function () {

	        return this.findAllPageSections();
	    },

	    getPageSectionByElement: function (element) {

	        element = element.jquery ? element[0]: element;

	        var pageSection = null;

	        this.forEachPageSection(function () {

	            if (this.getSectionElement() === element) {

	                pageSection = this;

	                return false;
	            }
	        });

	        return pageSection;
	    },

	    forEachPageSection: function (/*fn, args...*/) {

	        var args = Array.prototype.slice.call(arguments),

	            sections = $.isArray(args[0]) ? args.shift() : this.findPageSections(),
	            s = sections.length - 1,

	            fn = args.shift();

	        for (s; s >= 0; s--) {

	            if (typeof fn === "string" && sections[s][fn]) {

	                sections[s][fn].apply(sections[s], args);

	            } else if (typeof fn === "function") {

	                var returnValue = fn.call(sections[s], sections[s]);

	                if (returnValue === false) {

	                    break;
	                }
	            }
	        }
	    },

	    forEachPageSectionByIndex: function (/*fn, args...*/) {

	        var args = Array.prototype.slice.call(arguments);

	        args.unshift(this.pageSectionsManager.getSectionsSortedByIndex(true));

	        this.forEachPageSection.apply(this, args);
	    },

	    forEachEditor: function (fn/*, args*/) {

	        var editors = ["titleEditor", "contentEditor"],
	            e = editors.length - 1,

	            args = Array.prototype.slice.call(arguments);

	        args.shift();

	        for (e; e >= 0; e--) {

	            if (typeof fn === "string" && this[editors[e]].editor && this[editors[e]].editor[fn]) {

	                this[editors[e]].editor[fn].apply(this[editors[e]].editor, args);

	            } else if (typeof fn === "function" && this[editors[e]].editor) {

	                var returnValue = fn.call(this[editors[e]].editor, this[editors[e]].editor);

	                if (returnValue === false) {

	                    break;
	                }
	            }
	        }
	    },

	    findMostUsedColors: function (maxCount) {

	        var colorUsed = {};

	        this.forEachPageSection(function (pageSection) {

	            var colors = pageSection.getColors(),

	                c = colors.length - 1,
	                colorTemp;

	            for (c; c >= 0; c--) {

	                colorTemp = colors[c].replace(" ", "");

	                colorUsed[colorTemp] = colorUsed[colorTemp] ? colorUsed[colorTemp] + 1: 1;
	            }
	        });

	        return Object.keys(colorUsed).sort(function (a, b) {

	            return colorUsed[b] - colorUsed[a];

	        }).splice(0, maxCount || 5);
	    }

	});


/***/ },
/* 90 */
/***/ function(module, exports) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	var SUPPORT = {

	    TRANSITIONEND: (function () {

	        var el = document.createElement("div"),

	            transitions = [
	                "transition"      , "transitionend"      ,
	                "OTransition"     , "otransitionend"     ,
	                "MozTransition"   , "transitionend"      ,
	                "WebkitTransition", "webkitTransitionEnd"
	            ],

	            i = 0, length = transitions.length;

	        for (i; i < length; i += 2) {

	            if (el.style[transitions[i]] !== undefined) {

	                return transitions[i + 1];
	            }
	        }

	        return null;

	    }())
	};

	module.exports = SUPPORT;


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true, node: true*/
	/*global jQuery, $*/

	var Ractive = __webpack_require__(0);
	var io = __webpack_require__(198);

	Ractive.defaults.findSiblingComponents = function (name) {

	    var components = this.parent.findAllComponents(name),
	        c = components.length - 1;

	    for (c; c > -1; c--) {

	        if (components[c] === this || components[c].parent !== this.parent) {

	            components.splice(c, 1);
	        }
	    }

	    return components;
	};

	Ractive.$win = Ractive.$win || $(window);
	Ractive.$scrollingElement = Ractive.$scrollingElement || $("html, body");

	var loadLibs = function () {

	    __webpack_require__(192);

	    __webpack_require__(125);

	    __webpack_require__(129)(jQuery);
	};

	var initPolyfills = function () {

	    if (!window.Promise) {

	        window.Promise = Ractive.Promise;
	    }

	    __webpack_require__(145);

	    __webpack_require__(196)("native");
	};

	var connectToSocketIO = function (config, databaseName, userId) {

	    var socket = io("http://" + window.location.hostname + ":" + config.websocket.port);

	    Ractive.defaults.req = __webpack_require__(210)(socket);

	    socket.on("connect", function () {

	        socket.emit("databaseName", {
	            databaseName: databaseName,
	            userId: userId
	        });
	    });

	    return socket;
	};

	module.exports = function (ractive, ractiveData, config) {

	    var App;

	    (function (ns) {

	        initPolyfills();

	        loadLibs();

	        connectToSocketIO(config, ractiveData.databaseName, ractiveData.userId);

	        console.time("pageLoaded");

	        var ractiveKeyEvents = __webpack_require__(147),
	            ractiveWindowEvents = __webpack_require__(96);

	        App = ractive({

	            el: "#app",

	            partials: {
	            },

	            components: {
	            },

	            data: ractiveData,

	            events: {
	                hover: __webpack_require__(146),
	                enter: ractiveKeyEvents.enter,
	                space: ractiveKeyEvents.space,
	                escape: ractiveKeyEvents.escape,
	                windowMousedown: ractiveWindowEvents.windowMousedown,
	                windowMousemove: ractiveWindowEvents.windowMousemove,
	                windowMouseup: ractiveWindowEvents.windowMouseup,
	                windowTouchstart: ractiveWindowEvents.windowTouchstart,
	                windowTouchmove: ractiveWindowEvents.windowTouchmove,
	                windowTouchend: ractiveWindowEvents.windowTouchend
	            },

	            transitions: {
	                slide: __webpack_require__(195),
	                fade: __webpack_require__(194),
	                attr: __webpack_require__(193)
	            }
	        });

	        if (typeof ns.env !== "undefined" && ns.env === "dev") {

	            ns.App = App;
	        }

	    }(window));

	    return App;

	};


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*//*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	/*global $*/

	(function (root, factory) {

	    if (typeof module === 'object' && module.exports) {

	        var Ractive = __webpack_require__(0),
	            EventEmitter = __webpack_require__(6)(),
	            on = __webpack_require__(1),

	            template = __webpack_require__(185),
	            Button = __webpack_require__(46);

	        module.exports = factory(Ractive, EventEmitter, template, Button, on);

	    } else {

	        root.Dialog = factory(root.Ractive, $({}), "", root.Button, {client: true});
	    }

	}(this, function (Ractive, EventEmitter, template, Button, on) {

	    return Ractive.extend({

	        CLASS: {
	            box: "Dialog--box",
	            overlay: "Dialog--overlay"
	        },

	        template: template,

	        components: {
	        },

	        partials: {
	            Button: Button
	        },

	        decorators: {
	        },

	        data: function () {

	            return {
	                messages: []
	            };
	        },

	        onconfig: function () {

	            if (on.client) {

	                EventEmitter.on("show.Dialog", function (e, message) {
	                    this.handleNewDialog.call(this, message);
	                }.bind(this));

	                window.EE = EventEmitter;
	            }

	            this.root.on("showDialog *.showDialog", this.handleNewDialog.bind(this));

	            this.on("handleUserInput", this.handleUserInput);
	            this.on("closeDialog", this.closeDialog);
	        },

	        onrender: function () {

	            Ractive.$win = Ractive.$win || $(window);
	            Ractive.$scrollingElement = Ractive.$scrollingElement || $("html, body");
	        },

	        oncomplete: function () {
	        },

	        onteardown: function () {

	            clearTimeout(this.nextMessageTimeout);
	            clearTimeout(this.closeDialogTimeout);
	            clearTimeout(this.closeDialogCounterTimeout);

	            this.root.off("showDialog");

	            Ractive.$win.off(".Dialog");
	            Ractive.$scrollingElement.off(".Dialog");

	            if (this.$overlay) {

	                this.$overlay.off(".Dialog");
	            }

	            EventEmitter.off(".Dialog");
	        },

	        handleNewDialog: function (message) {

	            this.push("messages", message);

	            if (this.get("messages").length === 1) {

	                this.handleNextMessage();
	            }
	        },

	        handleUserInput: function (event, data) {

	            clearTimeout(this.closeDialogTimeout);
	            clearTimeout(this.closeDialogCounterTimeout);

	            //data[0] - název události
	            //data[1] - objekt události
	            //data[2] - kontext události
	            //data[3] - funkce

	            if (data && data[3]) {

	                data[3].call(data[2], data[1]);

	            } else if (data && data[0]) {

	                if (data[2]) {

	                    data[2].fire(data[0], data[1]);

	                } else {

	                    EventEmitter.trigger(data[0], data[1]);
	                }
	            }

	            this.closeDialog();
	        },

	        closeDialog: function () {

	            clearTimeout(this.closeDialogTimeout);
	            clearTimeout(this.closeDialogCounterTimeout);

	            this.shift("messages");

	            if (this.get("messages").length) {

	                this.handleNextMessage();

	            } else {

	                this.$lastBox = null;
	                this.$lastBoxFocus = null;

	                Ractive.$win.off(".Dialog");
	                Ractive.$scrollingElement.off(".Dialog");
	            }
	        },

	        handleNextMessage: function () {

	            if (this.$lastBox) {

	                Ractive.$win.off(".Dialog");
	                Ractive.$scrollingElement.off(".Dialog");
	            }

	            clearTimeout(this.closeDialogTimeout);
	            clearTimeout(this.closeDialogCounterTimeout);
	            clearTimeout(this.nextMessageTimeout);

	            this.nextMessageTimeout = setTimeout(function() {

	                var currentMessage = this.get("messages[0]");

	                if (currentMessage.timeout) {

	                    this.activateAutoClose(currentMessage);

	                }

	                this.$lastBox = $("." + this.CLASS.box + ":not([data-ractive-transition^='outro'])");

	                this.$lastBoxFocus = this.$lastBox.find("[tabindex='1001']").focus();

	                Ractive.$win
	                    .on("scroll.Dialog mousewheel.Dialog DOMMouseScroll.Dialog keydown.Dialog", function (e) {

	                        if (e.type === "keydown" && (e.which < 33 || e.which > 40)) {

	                            return true;
	                        }

	                        return false;
	                    });

	            }.bind(this), 0);

	            this.$overlay = this.$overlay || $("." + this.CLASS.overlay).on("touchmove.Dialog touchstart.Dialog mousedown.Dialog", function () {

	                return false;
	            });
	        },

	        activateAutoClose: function (currentMessage) {

	            var action = currentMessage.close ? "close" : "dismiss";

	            this.closeDialogTimeout = setTimeout(function() {

	                clearTimeout(this.closeDialogCounterTimeout);

	                this.handleUserInput(null, [
	                    currentMessage[action].fire,
	                    currentMessage[action].event,
	                    currentMessage[action].context,
	                    currentMessage[action].exec
	                ]);

	            }.bind(this), currentMessage.timeout + 100);

	            var textPath = "messages[0]." + action + ".text",
	                text = this.get(textPath) || "Zavřít",

	                remaining = Math.round(Math.max(0, currentMessage.timeout) / 1000);

	            this.set(textPath, text + " (" + remaining + ")");

	            this.closeDialogCounterTimeout = setInterval(function () {

	                currentMessage.timeout -= 1000;

	                remaining = Math.round(Math.max(0, currentMessage.timeout) / 1000);

	                this.set(textPath, text + " (" + remaining + ")");

	            }.bind(this), 1000);
	        }
	    });
	}));


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	/*global $*/
	(function (root, factory) {

	    if (typeof module === 'object' && module.exports) {

	        var FileBrowser = __webpack_require__(34);

	        module.exports = factory(FileBrowser);

	    } else {

	        root.FileBrowser = factory(root.FileBrowser);
	    }

	}(this, function (FileBrowser) {

	    return FileBrowser.extend({

	        components: {

	        },

	        partials: {

	        },

	        data: function () {

	            return {

	                type: "icon",

	                //název requestu odesílaného na server
	                reqName: "icons",

	                filesType: this.OPTIONS.FILETYPE_ICON,

	                uploadDirectory: "Moje ikony",

	                uploadOverlayTitle: "Nahrát ikony",
	                uploadOverlayText: "Maximální velikost souboru: 64 KB. Podporované formáty: .png, .svg.",

	                searchable: true
	            };
	        },

	        onconstruct: function () {

	            this.superOnconstruct();
	        },

	        onconfig: function () {

	            this.superOnconfig();

	            this.OPTIONS.DROPZONE = function () {

	                return {
	                    url: "/upload-icons",
	                    paramName: "icons",

	                    uploadMultiple: true,
	                    acceptedFiles: "image/png,image/svg+xml",
	                    maxFilesize: 0.064,
	                    parallelUploads: 8,

	                    clickable: false,

	                    thumbnailWidth: 40,
	                    thumbnailHeight: 40,

	                    dictInvalidFileType: "Nepodporovaný formát. Soubor musí být formátu png nebo svg.",
	                    dictFileTooBig: "Soubor je příliš velký ({{filesize}} MB). Velikost souboru může být maximálně {{maxFilesize}} MB.",
	                    dictResponseError: "Soubor se nepodařilo nahrát (chyba: {{statusCode}})"
	                };
	            };
	        },

	        onrender: function () {

	            this.superOnrender();
	        },

	        oncomplete: function () {

	            this.superOncomplete();
	        },

	        onteardown: function () {

	            this.superOnteardown();
	        }

	    });

	}));



/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	/*global $*/
	(function (root, factory) {

	    if (typeof module === 'object' && module.exports) {

	        var FileBrowser = __webpack_require__(34),

	            template = __webpack_require__(45);

	        module.exports = factory(FileBrowser);

	    } else {

	        root.FileBrowser = factory(root.FileBrowser);
	    }

	}(this, function (FileBrowser) {

	    return FileBrowser.extend({

	        components: {

	        },

	        partials: {

	        },

	        data: function () {

	            return {
	                type: "images",

	                //název requestu odesílaného na server
	                reqName: "images",

	                filesType: this.OPTIONS.FILETYPE_IMAGE,

	                uploadDirectory: "Moje obrázky",

	                uploadOverlayTitle: "Nahrát obrázky",
	                uploadOverlayText: "Maximální velikost souboru: 1 MB. Podporované formáty: .jpg, .png, .svg."
	            };
	        },

	        onconstruct: function () {

	            this.superOnconstruct();
	        },

	        onconfig: function () {

	            this.superOnconfig();

	            this.OPTIONS.DROPZONE = function () {

	                return {
	                    url: "/upload-images",
	                    paramName: "images",

	                    uploadMultiple: true,
	                    acceptedFiles: "image/jpg,image/jpeg,image/png",
	                    maxFilesize: 1,
	                    parallelUploads: 4,

	                    clickable: false,

	                    thumbnailWidth: 100,
	                    thumbnailHeight: 100,

	                    dictInvalidFileType: "Nepodporovaný formát. Soubor musí být formátu .jpg nebo .png.",
	                    dictFileTooBig: "Soubor je příliš velký ({{filesize}} MB). Velikost souboru může být maximálně {{maxFilesize}} MB.",
	                    dictResponseError: "Soubor se nepodařilo nahrát (chyba: {{statusCode}})"
	                };
	            };
	        },

	        onrender: function () {

	            this.superOnrender();
	        },

	        oncomplete: function () {

	            this.superOncomplete();
	        },

	        onteardown: function () {

	            this.superOnteardown();
	        }

	    });

	}));



/***/ },
/* 95 */
/***/ function(module, exports) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	(function (root, factory) {

	    if (typeof module === 'object' && module.exports) {

	        module.exports = factory();

	    } else {

	        root.Vibrant = factory();
	    }

	}(this, function () {

	    /*
	      Vibrant.js
	      by Jari Zwarts

	      Color algorithm class that finds variations on colors in an image.

	      Credits
	      --------
	      Lokesh Dhakar (http://www.lokeshdhakar.com) - Created ColorThief
	      Google - Palette support library in Android
	     */

	    var Vibrant;

	    (function () {

	        var CanvasImage, Swatch,
	            bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	            slice = [].slice;

	        Swatch = (function() {
	            Swatch.prototype.hsl = void 0;

	            Swatch.prototype.rgb = void 0;

	            Swatch.prototype.population = 1;

	            Swatch.yiq = 0;

	            function Swatch(rgb, population) {
	                this.rgb = rgb;
	                this.population = population;
	            }

	            Swatch.prototype.getHsl = function() {
	                if (!this.hsl) {
	                    return this.hsl = Vibrant.rgbToHsl(this.rgb[0], this.rgb[1], this.rgb[2]);
	                } else {
	                    return this.hsl;
	                }
	            };

	            Swatch.prototype.getPopulation = function() {
	                return this.population;
	            };

	            Swatch.prototype.getRgb = function() {
	                return this.rgb;
	            };

	            Swatch.prototype.getHex = function() {
	                return "#" + ((1 << 24) + (this.rgb[0] << 16) + (this.rgb[1] << 8) + this.rgb[2]).toString(16).slice(1, 7);
	            };

	            Swatch.prototype.getTitleTextColor = function() {
	                this._ensureTextColors();
	                if (this.yiq < 200) {
	                    return "#fff";
	                } else {
	                    return "#000";
	                }
	            };

	            Swatch.prototype.getBodyTextColor = function() {
	                this._ensureTextColors();
	                if (this.yiq < 150) {
	                    return "#fff";
	                } else {
	                    return "#000";
	                }
	            };

	            Swatch.prototype._ensureTextColors = function() {
	                if (!this.yiq) {
	                    return this.yiq = (this.rgb[0] * 299 + this.rgb[1] * 587 + this.rgb[2] * 114) / 1000;
	                }
	            };

	            return Swatch;

	        })();

	        Vibrant = (function() {
	            Vibrant.prototype.quantize = {};

	            Vibrant.prototype._swatches = [];

	            Vibrant.prototype.TARGET_DARK_LUMA = 0.26;

	            Vibrant.prototype.MAX_DARK_LUMA = 0.45;

	            Vibrant.prototype.MIN_LIGHT_LUMA = 0.55;

	            Vibrant.prototype.TARGET_LIGHT_LUMA = 0.74;

	            Vibrant.prototype.MIN_NORMAL_LUMA = 0.3;

	            Vibrant.prototype.TARGET_NORMAL_LUMA = 0.5;

	            Vibrant.prototype.MAX_NORMAL_LUMA = 0.7;

	            Vibrant.prototype.TARGET_MUTED_SATURATION = 0.3;

	            Vibrant.prototype.MAX_MUTED_SATURATION = 0.4;

	            Vibrant.prototype.TARGET_VIBRANT_SATURATION = 1;

	            Vibrant.prototype.MIN_VIBRANT_SATURATION = 0.35;

	            Vibrant.prototype.WEIGHT_SATURATION = 3;

	            Vibrant.prototype.WEIGHT_LUMA = 6;

	            Vibrant.prototype.WEIGHT_POPULATION = 1;

	            Vibrant.prototype.VibrantSwatch = void 0;

	            Vibrant.prototype.MutedSwatch = void 0;

	            Vibrant.prototype.DarkVibrantSwatch = void 0;

	            Vibrant.prototype.DarkMutedSwatch = void 0;

	            Vibrant.prototype.LightVibrantSwatch = void 0;

	            Vibrant.prototype.LightMutedSwatch = void 0;

	            Vibrant.prototype.HighestPopulation = 0;

	            function Vibrant(sourceImage, colorCount, quality, unprocessed) {
	                this.swatches = bind(this.swatches, this);
	                var a, allPixels, b, cmap, g, i, image, imageData, offset, pixelCount, pixels, r, worker;
	                if (typeof colorCount === 'undefined') {
	                    colorCount = 64;
	                }
	                if (typeof quality === 'undefined') {
	                    quality = 5;
	                }
	                image = new CanvasImage(sourceImage);
	                imageData = image.getImageData();
	                pixels = imageData.data;
	                pixelCount = image.getPixelCount();

	                worker = new Worker(Vibrant.workerPath || 'js/VibrantWorker.js');

	                worker.postMessage({
	                    imageData: imageData,
	                    pixelCount: pixelCount,
	                    quality: quality,
	                    pixels: pixels,
	                    colorCount: colorCount
	                });

	                if (unprocessed) {

	                    return {
	                        promise: new Promise(function (resolve) {

	                            worker.onmessage = function (message) {

	                                this._swatches = [];

	                                for (var s = message.data.length - 1; s >= 0; s--) {

	                                    this._swatches.push(new Swatch(message.data[s].rgb, message.data[s].population));
	                                }

	                                image.removeCanvas();

	                                resolve(this._swatches);

	                            }.bind(this);

	                        }.bind(this)),

	                        stop: function () {

	                            if (image.iframe.parentNode) {

	                                image.iframe.parentNode.removeChild(image.iframe);
	                            }

	                            worker.terminate();
	                        }
	                    };
	                }

	                return {
	                    promise: new Promise(function (resolve) {

	                        worker.onmessage = function (message) {

	                            this._swatches = message.data;

	                            this.maxPopulation = this.findMaxPopulation;
	                            this.generateVarationColors();
	                            this.generateEmptySwatches();

	                            image.removeCanvas();

	                            resolve(this);

	                        }.bind(this);

	                    }.bind(this)),

	                    stop: function () {

	                        if (image.iframe.parentNode) {

	                            image.iframe.parentNode.removeChild(image.iframe);
	                        }

	                        worker.terminate();
	                    }
	                };

	            }

	            Vibrant.prototype.generateVarationColors = function() {
	                this.VibrantSwatch = this.findColorVariation(this.TARGET_NORMAL_LUMA, this.MIN_NORMAL_LUMA, this.MAX_NORMAL_LUMA, this.TARGET_VIBRANT_SATURATION, this.MIN_VIBRANT_SATURATION, 1);
	                this.LightVibrantSwatch = this.findColorVariation(this.TARGET_LIGHT_LUMA, this.MIN_LIGHT_LUMA, 1, this.TARGET_VIBRANT_SATURATION, this.MIN_VIBRANT_SATURATION, 1);
	                this.DarkVibrantSwatch = this.findColorVariation(this.TARGET_DARK_LUMA, 0, this.MAX_DARK_LUMA, this.TARGET_VIBRANT_SATURATION, this.MIN_VIBRANT_SATURATION, 1);
	                this.MutedSwatch = this.findColorVariation(this.TARGET_NORMAL_LUMA, this.MIN_NORMAL_LUMA, this.MAX_NORMAL_LUMA, this.TARGET_MUTED_SATURATION, 0, this.MAX_MUTED_SATURATION);
	                this.LightMutedSwatch = this.findColorVariation(this.TARGET_LIGHT_LUMA, this.MIN_LIGHT_LUMA, 1, this.TARGET_MUTED_SATURATION, 0, this.MAX_MUTED_SATURATION);
	                return this.DarkMutedSwatch = this.findColorVariation(this.TARGET_DARK_LUMA, 0, this.MAX_DARK_LUMA, this.TARGET_MUTED_SATURATION, 0, this.MAX_MUTED_SATURATION);
	            };

	            Vibrant.prototype.generateEmptySwatches = function() {
	                var hsl;
	                if (this.VibrantSwatch === void 0) {
	                    if (this.DarkVibrantSwatch !== void 0) {
	                        hsl = this.DarkVibrantSwatch.getHsl();
	                        hsl[2] = this.TARGET_NORMAL_LUMA;
	                        this.VibrantSwatch = new Swatch(Vibrant.hslToRgb(hsl[0], hsl[1], hsl[2]), 0);
	                    }
	                }
	                if (this.DarkVibrantSwatch === void 0) {
	                    if (this.VibrantSwatch !== void 0) {
	                        hsl = this.VibrantSwatch.getHsl();
	                        hsl[2] = this.TARGET_DARK_LUMA;
	                        return this.DarkVibrantSwatch = new Swatch(Vibrant.hslToRgb(hsl[0], hsl[1], hsl[2]), 0);
	                    }
	                }
	            };

	            Vibrant.prototype.findMaxPopulation = function() {
	                var j, len, population, ref, swatch;
	                population = 0;
	                ref = this._swatches;
	                for (j = 0, len = ref.length; j < len; j++) {
	                    swatch = ref[j];
	                    population = Math.max(population, swatch.getPopulation());
	                }
	                return population;
	            };

	            Vibrant.prototype.findColorVariation = function(targetLuma, minLuma, maxLuma, targetSaturation, minSaturation, maxSaturation) {
	                var j, len, luma, max, maxValue, ref, sat, swatch, value;
	                max = void 0;
	                maxValue = 0;
	                ref = this._swatches;

	                for (j = 0, len = ref.length; j < len; j++) {
	                    swatch = ref[j];
	                    sat = Swatch.prototype.getHsl.call(swatch)[1];
	                    luma = Swatch.prototype.getHsl.call(swatch)[2];
	                    if (sat >= minSaturation && sat <= maxSaturation && luma >= minLuma && luma <= maxLuma && !this.isAlreadySelected(swatch)) {
	                        value = this.createComparisonValue(sat, targetSaturation, luma, targetLuma, Swatch.prototype.getPopulation.call(swatch), this.HighestPopulation);
	                        if (max === void 0 || value > maxValue) {
	                            max = swatch;
	                            maxValue = value;
	                        }
	                    }
	                }

	                if (!max) {
	                    return max;
	                }

	                var realSwatch = new Swatch(max.rgb, max.population);
	                realSwatch.hsl = max.hsl;

	                return realSwatch;
	            };

	            Vibrant.prototype.createComparisonValue = function(saturation, targetSaturation, luma, targetLuma, population, maxPopulation) {
	                return this.weightedMean(this.invertDiff(saturation, targetSaturation), this.WEIGHT_SATURATION, this.invertDiff(luma, targetLuma), this.WEIGHT_LUMA, population / maxPopulation, this.WEIGHT_POPULATION);
	            };

	            Vibrant.prototype.invertDiff = function(value, targetValue) {
	                return 1 - Math.abs(value - targetValue);
	            };

	            Vibrant.prototype.weightedMean = function() {
	                var i, sum, sumWeight, value, values, weight;
	                values = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	                sum = 0;
	                sumWeight = 0;
	                i = 0;
	                while (i < values.length) {
	                    value = values[i];
	                    weight = values[i + 1];
	                    sum += value * weight;
	                    sumWeight += weight;
	                    i += 2;
	                }
	                return sum / sumWeight;
	            };

	            Vibrant.prototype.swatches = function() {
	                return {
	                    Vibrant: this.VibrantSwatch,
	                    Muted: this.MutedSwatch,
	                    DarkVibrant: this.DarkVibrantSwatch,
	                    DarkMuted: this.DarkMutedSwatch,
	                    LightVibrant: this.LightVibrantSwatch,
	                    LightMuted: this.LightMuted
	                };
	            };

	            Vibrant.prototype.isAlreadySelected = function(swatch) {
	                return this.VibrantSwatch === swatch || this.DarkVibrantSwatch === swatch || this.LightVibrantSwatch === swatch || this.MutedSwatch === swatch || this.DarkMutedSwatch === swatch || this.LightMutedSwatch === swatch;
	            };

	            Vibrant.rgbToHsl = function(r, g, b) {
	                var d, h, l, max, min, s;
	                r /= 255;
	                g /= 255;
	                b /= 255;
	                max = Math.max(r, g, b);
	                min = Math.min(r, g, b);
	                h = void 0;
	                s = void 0;
	                l = (max + min) / 2;
	                if (max === min) {
	                    h = s = 0;
	                } else {
	                    d = max - min;
	                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
	                    switch (max) {
	                        case r:
	                            h = (g - b) / d + (g < b ? 6 : 0);
	                            break;
	                        case g:
	                            h = (b - r) / d + 2;
	                            break;
	                        case b:
	                            h = (r - g) / d + 4;
	                    }
	                    h /= 6;
	                }
	                return [h, s, l];
	            };

	            Vibrant.hslToRgb = function(h, s, l) {
	                var b, g, hue2rgb, p, q, r;
	                r = void 0;
	                g = void 0;
	                b = void 0;
	                hue2rgb = function(p, q, t) {
	                    if (t < 0) {
	                        t += 1;
	                    }
	                    if (t > 1) {
	                        t -= 1;
	                    }
	                    if (t < 1 / 6) {
	                        return p + (q - p) * 6 * t;
	                    }
	                    if (t < 1 / 2) {
	                        return q;
	                    }
	                    if (t < 2 / 3) {
	                        return p + (q - p) * (2 / 3 - t) * 6;
	                    }
	                    return p;
	                };
	                if (s === 0) {
	                    r = g = b = l;
	                } else {
	                    q = l < 0.5 ? l * (1 + s) : l + s - (l * s);
	                    p = 2 * l - q;
	                    r = hue2rgb(p, q, h + 1 / 3);
	                    g = hue2rgb(p, q, h);
	                    b = hue2rgb(p, q, h - (1 / 3));
	                }
	                return [r * 255, g * 255, b * 255];
	            };

	            return Vibrant;

	        })();


	        /*
	    CanvasImage Class
	    Class that wraps the html image element and canvas.
	    It also simplifies some of the canvas context manipulation
	    with a set of helper functions.
	    Stolen from https://github.com/lokesh/color-thief
	   */

	        CanvasImage = (function() {
	            function CanvasImage(image) {
	                this.iframe = document.createElement('iframe');
	                this.iframe.className = 'VibrantCanvas';
	                document.body.appendChild(this.iframe);

	                var doc = this.iframe.contentWindow.document;


	                //      this.canvas = document.createElement('canvas');
	                this.canvas = doc.createElement('canvas');
	                this.context = this.canvas.getContext('2d');
	                doc.body.appendChild(this.canvas);
	                //      document.body.appendChild(this.canvas);
	                this.width = this.canvas.width = image.width;
	                this.height = this.canvas.height = image.height;
	                this.context.drawImage(image, 0, 0, this.width, this.height);
	            }

	            CanvasImage.prototype.clear = function() {
	                return this.context.clearRect(0, 0, this.width, this.height);
	            };

	            CanvasImage.prototype.update = function(imageData) {
	                return this.context.putImageData(imageData, 0, 0);
	            };

	            CanvasImage.prototype.getPixelCount = function() {
	                return this.width * this.height;
	            };

	            CanvasImage.prototype.getImageData = function() {
	                return this.context.getImageData(0, 0, this.width, this.height);
	            };

	            CanvasImage.prototype.removeCanvas = function() {
	                this.iframe.parentNode.removeChild(this.iframe);
	                return this.canvas.parentNode.removeChild(this.canvas);
	            };

	            return CanvasImage;

	        })();

	    }());

	    return Vibrant;

	}));


/***/ },
/* 96 */
/***/ function(module, exports) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	/*global Ractive*/
	(function (root, factory) {

	    if (typeof module === 'object' && module.exports) {

	        module.exports = factory();

	    } else {

	        var events = factory();

	        Ractive.defaults.events.windowMousedown = events.windowMousedown;
	        Ractive.defaults.events.windowMousemove = events.windowMousemove;
	        Ractive.defaults.events.windowMouseup = events.windowMouseup;
	        Ractive.defaults.events.windowTouchstart = events.windowTouchstart;
	        Ractive.defaults.events.windowTouchmove = events.windowTouchmove;
	        Ractive.defaults.events.windowTouchend = events.windowTouchend;
	    }

	}(this, function () {

	    return {
	        windowMousedown: function (node, fire) {

	            var eventHandler = function (e) {

	                fire({
	                    node: node,
	                    original: e,
	                    clientX: e.clientX,
	                    clientY: e.clientY
	                });
	            };

	            window.addEventListener("mousedown", eventHandler, false);

	            return {
	                teardown: function () {
	                    window.removeEventListener("mousedown", eventHandler);
	                }
	            };
	        },
	        windowMousemove: function (node, fire) {

	            var eventHandler = function (e) {

	                fire({
	                    node: node,
	                    original: e,
	                    clientX: e.clientX,
	                    clientY: e.clientY
	                });
	            };

	            window.addEventListener("mousemove", eventHandler, false);

	            return {
	                teardown: function () {
	                    window.removeEventListener("mousemove", eventHandler);
	                }
	            };
	        },
	        windowMouseup: function (node, fire) {

	            var eventHandler = function (e) {

	                fire({
	                    node: node,
	                    original: e,
	                    clientX: e.clientX,
	                    clientY: e.clientY
	                });
	            };

	            window.addEventListener("mouseup", eventHandler, false);

	            return {
	                teardown: function () {
	                    window.removeEventListener("mouseup", eventHandler);
	                }
	            };
	        },

	        windowTouchstart: function (node, fire) {

	            var eventHandler = function (e) {

	                fire({
	                    node: node,
	                    original: e,
	                    clientX: e.changedTouches[0].clientX,
	                    clientY: e.changedTouches[0].clientY
	                });
	            };

	            window.addEventListener("touchstart", eventHandler, false);

	            return {
	                teardown: function () {
	                    window.removeEventListener("touchstart", eventHandler);
	                }
	            };
	        },
	        windowTouchmove: function (node, fire) {

	            var eventHandler = function (e) {

	                fire({
	                    node: node,
	                    original: e,
	                    clientX: e.changedTouches[0].clientX,
	                    clientY: e.changedTouches[0].clientY
	                });
	            };

	            window.addEventListener("touchmove", eventHandler, false);

	            return {
	                teardown: function () {
	                    window.removeEventListener("touchmove", eventHandler);
	                }
	            };
	        },
	        windowTouchend: function (node, fire) {

	            var eventHandler = function (e) {

	                fire({
	                    node: node,
	                    original: e,
	                    clientX: e.changedTouches[0].clientX,
	                    clientY: e.changedTouches[0].clientY
	                });
	            };

	            window.addEventListener("touchend", eventHandler, false);

	            return {
	                teardown: function () {
	                    window.removeEventListener("touchend", eventHandler);
	                }
	            };
	        }
	    };

	}));


/***/ },
/* 97 */
/***/ function(module, exports) {

	module.exports = {

	};


/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true, node: true*/

	var extend = __webpack_require__(118);
	var on = __webpack_require__(1);

	module.exports = extend(true, {}, __webpack_require__(100), on.server ? __webpack_require__(99) : __webpack_require__(97));


/***/ },
/* 99 */
/***/ function(module, exports) {

	module.exports = {
	    Db: {
	        global: {
	            name: "global",
	            host: "localhost"
	        },
	        users: {
	            host: "localhost"
	        }
	    },

	    websocket: {
	        dbTimeout: 60 * 1000
	    },

	    appHostname: "app.dev"
	};


/***/ },
/* 100 */
/***/ function(module, exports) {

	module.exports = {
	    websocket: {
	        port: 5000
	    },

	    upload: {
	        images: {
	            path: "uploads/users/{{userId}}/images",
	            thumbPath: "uploads/users/{{userId}}/images/thumbs",
	            thumbRelPath: "/thumbs",
	            thumbQuality: 65,
	            thumbWidth: 100,
	            thumbHeight: 100,
	            name: "Moje obrázky"
	        },
	        icons: {
	            path: "uploads/users/{{userId}}/icons",
	            thumbPath: "uploads/users/{{userId}}/icons/thumbs",
	            thumbRelPath: "/thumbs",
	            thumbQuality: 65,
	            thumbWidth: 40,
	            thumbHeight: 40,
	            name: "Moje ikony"
	        }
	    },
	    library: {
	        path: "library",
	        images: {
	            path: "library/images",
	            thumbPath: "library/images/thumbs",
	            thumbRelPath: "/thumbs"
	        },
	        icons: {
	            path: "db://"
	        }
	    }
	};


/***/ },
/* 101 */
/***/ function(module, exports) {

	module.exports = after

	function after(count, callback, err_cb) {
	    var bail = false
	    err_cb = err_cb || noop
	    proxy.count = count

	    return (count === 0) ? callback() : proxy

	    function proxy(err, result) {
	        if (proxy.count <= 0) {
	            throw new Error('after called too many times')
	        }
	        --proxy.count

	        // after first error, rest are passed to err_cb
	        if (err) {
	            bail = true
	            callback(err)
	            // future error callbacks will go to error handler
	            callback = err_cb
	        } else if (proxy.count === 0 && !bail) {
	            callback(null, result)
	        }
	    }
	}

	function noop() {}


/***/ },
/* 102 */
/***/ function(module, exports) {

	module.exports = ansiHTML;

	// Reference to https://github.com/sindresorhus/ansi-regex
	var re_ansi = /(?:(?:\u001b\[)|\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\u001b[A-M]/;

	var _defColors = {
	  reset: ['fff', '000'], // [FOREGROUD_COLOR, BACKGROUND_COLOR]
	  black: '000',
	  red: 'ff0000',
	  green: '209805',
	  yellow: 'e8bf03',
	  blue: '0000ff',
	  magenta: 'ff00ff',
	  cyan: '00ffee',
	  lightgrey: 'f0f0f0',
	  darkgrey: '888'
	};
	var _styles = {
	  30: 'black',
	  31: 'red',
	  32: 'green',
	  33: 'yellow',
	  34: 'blue',
	  35: 'magenta',
	  36: 'cyan',
	  37: 'lightgrey'
	};
	var _openTags = {
	  '1': 'font-weight:bold', // bold
	  '2': 'opacity:0.8', // dim
	  '3': '<i>', // italic
	  '4': '<u>', // underscore
	  '8': 'display:none', // hidden
	  '9': '<del>', // delete
	};
	var _closeTags = {
	  '23': '</i>', // reset italic
	  '24': '</u>', // reset underscore
	  '29': '</del>' // reset delete
	};
	[0, 21, 22, 27, 28, 39, 49].forEach(function (n) {
	  _closeTags[n] = '</span>';
	});

	/**
	 * Converts text with ANSI color codes to HTML markup.
	 * @param {String} text
	 * @returns {*}
	 */
	function ansiHTML(text) {
	  // Returns the text if the string has no ANSI escape code.
	  if (!re_ansi.test(text)) {
	    return text;
	  }

	  // Cache opened sequence.
	  var ansiCodes = [];
	  // Replace with markup.
	  var ret = text.replace(/\033\[(\d+)*m/g, function (match, seq) {
	    var ot = _openTags[seq];
	    if (ot) {
	      // If current sequence has been opened, close it.
	      if (!!~ansiCodes.indexOf(seq)) {
	        ansiCodes.pop();
	        return '</span>';
	      }
	      // Open tag.
	      ansiCodes.push(seq);
	      return ot[0] == '<' ? ot : '<span style="' + ot + ';">';
	    }

	    var ct = _closeTags[seq];
	    if (ct) {
	      // Pop sequence
	      ansiCodes.pop();
	      return ct;
	    }
	    return '';
	  });

	  // Make sure tags are closed.
	  var l = ansiCodes.length;
	  (l > 0) && (ret += Array(l + 1).join('</span>'));

	  return ret;
	}

	/**
	 * Customize colors.
	 * @param {Object} colors reference to _defColors
	 */
	ansiHTML.setColors = function (colors) {
	  if (typeof colors != 'object') {
	    throw new Error('`colors` parameter must be an Object.');
	  }

	  var _finalColors = {};
	  for (var key in _defColors) {
	    var hex = colors.hasOwnProperty(key) ? colors[key] : null;
	    if (!hex) {
	      _finalColors[key] = _defColors[key];
	      continue;
	    }
	    if ('reset' == key) {
	    	if(typeof hex == 'string'){
	    		hex = [hex];
	    	}
	      if (!Array.isArray(hex) || hex.length == 0 || hex.some(function (h) {
	          return typeof h != 'string';
	        })) {
	        throw new Error('The value of `' + key + '` property must be an Array and each item could only be a hex string, e.g.: FF0000');
	      }
	      var defHexColor = _defColors[key];
	      if(!hex[0]){
	      	hex[0] = defHexColor[0];
	      }
	      if (hex.length == 1 || !hex[1]) {
	      	hex = [hex[0]];
	        hex.push(defHexColor[1]);
	      }

	      hex = hex.slice(0, 2);
	    } else if (typeof hex != 'string') {
	      throw new Error('The value of `' + key + '` property must be a hex string, e.g.: FF0000');
	    }
	    _finalColors[key] = hex;
	  }
	  _setTags(_finalColors);
	};

	/**
	 * Reset colors.
	 */
	ansiHTML.reset = function(){
		_setTags(_defColors);
	};

	/**
	 * Expose tags, including open and close.
	 * @type {Object}
	 */
	ansiHTML.tags = {
	  get open() {
	    return _openTags;
	  },
	  get close() {
	    return _closeTags;
	  }
	};

	function _setTags(colors) {
	  // reset all
	  _openTags['0'] = 'font-weight:normal;opacity:1;color:#' + colors.reset[0] + ';background:#' + colors.reset[1];
	  // inverse
	  _openTags['7'] = 'color:#' + colors.reset[1] + ';background:#' + colors.reset[0];
	  // dark grey
	  _openTags['90'] = 'color:#' + colors.darkgrey;

	  for (var code in _styles) {
	    var color = _styles[code];
	    var oriColor = colors[color] || '000';
	    _openTags[code] = 'color:#' + oriColor;
	    code = parseInt(code);
	    _openTags[(code + 10).toString()] = 'background:#' + oriColor;
	  }
	}

	ansiHTML.reset();


/***/ },
/* 103 */
/***/ function(module, exports) {

	"use strict";
	'use strict';
	module.exports = function () {
		return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g;
	};


/***/ },
/* 104 */
/***/ function(module, exports) {

	/**
	 * An abstraction for slicing an arraybuffer even when
	 * ArrayBuffer.prototype.slice is not supported
	 *
	 * @api public
	 */

	module.exports = function(arraybuffer, start, end) {
	  var bytes = arraybuffer.byteLength;
	  start = start || 0;
	  end = end || bytes;

	  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

	  if (start < 0) { start += bytes; }
	  if (end < 0) { end += bytes; }
	  if (end > bytes) { end = bytes; }

	  if (start >= bytes || start >= end || bytes === 0) {
	    return new ArrayBuffer(0);
	  }

	  var abv = new Uint8Array(arraybuffer);
	  var result = new Uint8Array(end - start);
	  for (var i = start, ii = 0; i < end; i++, ii++) {
	    result[ii] = abv[i];
	  }
	  return result.buffer;
	};


/***/ },
/* 105 */
/***/ function(module, exports) {


	/**
	 * Expose `Backoff`.
	 */

	module.exports = Backoff;

	/**
	 * Initialize backoff timer with `opts`.
	 *
	 * - `min` initial timeout in milliseconds [100]
	 * - `max` max timeout [10000]
	 * - `jitter` [0]
	 * - `factor` [2]
	 *
	 * @param {Object} opts
	 * @api public
	 */

	function Backoff(opts) {
	  opts = opts || {};
	  this.ms = opts.min || 100;
	  this.max = opts.max || 10000;
	  this.factor = opts.factor || 2;
	  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
	  this.attempts = 0;
	}

	/**
	 * Return the backoff duration.
	 *
	 * @return {Number}
	 * @api public
	 */

	Backoff.prototype.duration = function(){
	  var ms = this.ms * Math.pow(this.factor, this.attempts++);
	  if (this.jitter) {
	    var rand =  Math.random();
	    var deviation = Math.floor(rand * this.jitter * ms);
	    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
	  }
	  return Math.min(ms, this.max) | 0;
	};

	/**
	 * Reset the number of attempts.
	 *
	 * @api public
	 */

	Backoff.prototype.reset = function(){
	  this.attempts = 0;
	};

	/**
	 * Set the minimum duration
	 *
	 * @api public
	 */

	Backoff.prototype.setMin = function(min){
	  this.ms = min;
	};

	/**
	 * Set the maximum duration
	 *
	 * @api public
	 */

	Backoff.prototype.setMax = function(max){
	  this.max = max;
	};

	/**
	 * Set the jitter
	 *
	 * @api public
	 */

	Backoff.prototype.setJitter = function(jitter){
	  this.jitter = jitter;
	};



/***/ },
/* 106 */
/***/ function(module, exports) {

	/*
	 * base64-arraybuffer
	 * https://github.com/niklasvh/base64-arraybuffer
	 *
	 * Copyright (c) 2012 Niklas von Hertzen
	 * Licensed under the MIT license.
	 */
	(function(chars){
	  "use strict";

	  exports.encode = function(arraybuffer) {
	    var bytes = new Uint8Array(arraybuffer),
	    i, len = bytes.length, base64 = "";

	    for (i = 0; i < len; i+=3) {
	      base64 += chars[bytes[i] >> 2];
	      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
	      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
	      base64 += chars[bytes[i + 2] & 63];
	    }

	    if ((len % 3) === 2) {
	      base64 = base64.substring(0, base64.length - 1) + "=";
	    } else if (len % 3 === 1) {
	      base64 = base64.substring(0, base64.length - 2) + "==";
	    }

	    return base64;
	  };

	  exports.decode =  function(base64) {
	    var bufferLength = base64.length * 0.75,
	    len = base64.length, i, p = 0,
	    encoded1, encoded2, encoded3, encoded4;

	    if (base64[base64.length - 1] === "=") {
	      bufferLength--;
	      if (base64[base64.length - 2] === "=") {
	        bufferLength--;
	      }
	    }

	    var arraybuffer = new ArrayBuffer(bufferLength),
	    bytes = new Uint8Array(arraybuffer);

	    for (i = 0; i < len; i+=4) {
	      encoded1 = chars.indexOf(base64[i]);
	      encoded2 = chars.indexOf(base64[i+1]);
	      encoded3 = chars.indexOf(base64[i+2]);
	      encoded4 = chars.indexOf(base64[i+3]);

	      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
	      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
	      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
	    }

	    return arraybuffer;
	  };
	})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Create a blob builder even when vendor prefixes exist
	 */

	var BlobBuilder = global.BlobBuilder
	  || global.WebKitBlobBuilder
	  || global.MSBlobBuilder
	  || global.MozBlobBuilder;

	/**
	 * Check if Blob constructor is supported
	 */

	var blobSupported = (function() {
	  try {
	    var a = new Blob(['hi']);
	    return a.size === 2;
	  } catch(e) {
	    return false;
	  }
	})();

	/**
	 * Check if Blob constructor supports ArrayBufferViews
	 * Fails in Safari 6, so we need to map to ArrayBuffers there.
	 */

	var blobSupportsArrayBufferView = blobSupported && (function() {
	  try {
	    var b = new Blob([new Uint8Array([1,2])]);
	    return b.size === 2;
	  } catch(e) {
	    return false;
	  }
	})();

	/**
	 * Check if BlobBuilder is supported
	 */

	var blobBuilderSupported = BlobBuilder
	  && BlobBuilder.prototype.append
	  && BlobBuilder.prototype.getBlob;

	/**
	 * Helper function that maps ArrayBufferViews to ArrayBuffers
	 * Used by BlobBuilder constructor and old browsers that didn't
	 * support it in the Blob constructor.
	 */

	function mapArrayBufferViews(ary) {
	  for (var i = 0; i < ary.length; i++) {
	    var chunk = ary[i];
	    if (chunk.buffer instanceof ArrayBuffer) {
	      var buf = chunk.buffer;

	      // if this is a subarray, make a copy so we only
	      // include the subarray region from the underlying buffer
	      if (chunk.byteLength !== buf.byteLength) {
	        var copy = new Uint8Array(chunk.byteLength);
	        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
	        buf = copy.buffer;
	      }

	      ary[i] = buf;
	    }
	  }
	}

	function BlobBuilderConstructor(ary, options) {
	  options = options || {};

	  var bb = new BlobBuilder();
	  mapArrayBufferViews(ary);

	  for (var i = 0; i < ary.length; i++) {
	    bb.append(ary[i]);
	  }

	  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
	};

	function BlobConstructor(ary, options) {
	  mapArrayBufferViews(ary);
	  return new Blob(ary, options || {});
	};

	module.exports = (function() {
	  if (blobSupported) {
	    return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;
	  } else if (blobBuilderSupported) {
	    return BlobBuilderConstructor;
	  } else {
	    return undefined;
	  }
	})();

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {


	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = debug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(127);

	/**
	 * The currently active debug mode names, and names to skip.
	 */

	exports.names = [];
	exports.skips = [];

	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lowercased letter, i.e. "n".
	 */

	exports.formatters = {};

	/**
	 * Previously assigned color.
	 */

	var prevColor = 0;

	/**
	 * Previous log timestamp.
	 */

	var prevTime;

	/**
	 * Select a color.
	 *
	 * @return {Number}
	 * @api private
	 */

	function selectColor() {
	  return exports.colors[prevColor++ % exports.colors.length];
	}

	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */

	function debug(namespace) {

	  // define the `disabled` version
	  function disabled() {
	  }
	  disabled.enabled = false;

	  // define the `enabled` version
	  function enabled() {

	    var self = enabled;

	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;

	    // add the `color` if not set
	    if (null == self.useColors) self.useColors = exports.useColors();
	    if (null == self.color && self.useColors) self.color = selectColor();

	    var args = Array.prototype.slice.call(arguments);

	    args[0] = exports.coerce(args[0]);

	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %o
	      args = ['%o'].concat(args);
	    }

	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);

	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });

	    if ('function' === typeof exports.formatArgs) {
	      args = exports.formatArgs.apply(self, args);
	    }
	    var logFn = enabled.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	  enabled.enabled = true;

	  var fn = exports.enabled(namespace) ? enabled : disabled;

	  fn.namespace = namespace;

	  return fn;
	}

	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */

	function enable(namespaces) {
	  exports.save(namespaces);

	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;

	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}

	/**
	 * Disable debug output.
	 *
	 * @api public
	 */

	function disable() {
	  exports.enable('');
	}

	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */

	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */

	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}


/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {


	module.exports =  __webpack_require__(110);


/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {


	module.exports = __webpack_require__(111);

	/**
	 * Exports parser
	 *
	 * @api public
	 *
	 */
	module.exports.parser = __webpack_require__(11);


/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module dependencies.
	 */

	var transports = __webpack_require__(39);
	var Emitter = __webpack_require__(15);
	var debug = __webpack_require__(7)('engine.io-client:socket');
	var index = __webpack_require__(42);
	var parser = __webpack_require__(11);
	var parseuri = __webpack_require__(43);
	var parsejson = __webpack_require__(128);
	var parseqs = __webpack_require__(27);

	/**
	 * Module exports.
	 */

	module.exports = Socket;

	/**
	 * Noop function.
	 *
	 * @api private
	 */

	function noop(){}

	/**
	 * Socket constructor.
	 *
	 * @param {String|Object} uri or options
	 * @param {Object} options
	 * @api public
	 */

	function Socket(uri, opts){
	  if (!(this instanceof Socket)) return new Socket(uri, opts);

	  opts = opts || {};

	  if (uri && 'object' == typeof uri) {
	    opts = uri;
	    uri = null;
	  }

	  if (uri) {
	    uri = parseuri(uri);
	    opts.hostname = uri.host;
	    opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';
	    opts.port = uri.port;
	    if (uri.query) opts.query = uri.query;
	  } else if (opts.host) {
	    opts.hostname = parseuri(opts.host).host;
	  }

	  this.secure = null != opts.secure ? opts.secure :
	    (global.location && 'https:' == location.protocol);

	  if (opts.hostname && !opts.port) {
	    // if no port is specified manually, use the protocol default
	    opts.port = this.secure ? '443' : '80';
	  }

	  this.agent = opts.agent || false;
	  this.hostname = opts.hostname ||
	    (global.location ? location.hostname : 'localhost');
	  this.port = opts.port || (global.location && location.port ?
	       location.port :
	       (this.secure ? 443 : 80));
	  this.query = opts.query || {};
	  if ('string' == typeof this.query) this.query = parseqs.decode(this.query);
	  this.upgrade = false !== opts.upgrade;
	  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
	  this.forceJSONP = !!opts.forceJSONP;
	  this.jsonp = false !== opts.jsonp;
	  this.forceBase64 = !!opts.forceBase64;
	  this.enablesXDR = !!opts.enablesXDR;
	  this.timestampParam = opts.timestampParam || 't';
	  this.timestampRequests = opts.timestampRequests;
	  this.transports = opts.transports || ['polling', 'websocket'];
	  this.readyState = '';
	  this.writeBuffer = [];
	  this.policyPort = opts.policyPort || 843;
	  this.rememberUpgrade = opts.rememberUpgrade || false;
	  this.binaryType = null;
	  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
	  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;

	  if (true === this.perMessageDeflate) this.perMessageDeflate = {};
	  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
	    this.perMessageDeflate.threshold = 1024;
	  }

	  // SSL options for Node.js client
	  this.pfx = opts.pfx || null;
	  this.key = opts.key || null;
	  this.passphrase = opts.passphrase || null;
	  this.cert = opts.cert || null;
	  this.ca = opts.ca || null;
	  this.ciphers = opts.ciphers || null;
	  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;

	  // other options for Node.js client
	  var freeGlobal = typeof global == 'object' && global;
	  if (freeGlobal.global === freeGlobal) {
	    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
	      this.extraHeaders = opts.extraHeaders;
	    }
	  }

	  this.open();
	}

	Socket.priorWebsocketSuccess = false;

	/**
	 * Mix in `Emitter`.
	 */

	Emitter(Socket.prototype);

	/**
	 * Protocol version.
	 *
	 * @api public
	 */

	Socket.protocol = parser.protocol; // this is an int

	/**
	 * Expose deps for legacy compatibility
	 * and standalone browser access.
	 */

	Socket.Socket = Socket;
	Socket.Transport = __webpack_require__(25);
	Socket.transports = __webpack_require__(39);
	Socket.parser = __webpack_require__(11);

	/**
	 * Creates transport of the given type.
	 *
	 * @param {String} transport name
	 * @return {Transport}
	 * @api private
	 */

	Socket.prototype.createTransport = function (name) {
	  debug('creating transport "%s"', name);
	  var query = clone(this.query);

	  // append engine.io protocol identifier
	  query.EIO = parser.protocol;

	  // transport name
	  query.transport = name;

	  // session id if we already have one
	  if (this.id) query.sid = this.id;

	  var transport = new transports[name]({
	    agent: this.agent,
	    hostname: this.hostname,
	    port: this.port,
	    secure: this.secure,
	    path: this.path,
	    query: query,
	    forceJSONP: this.forceJSONP,
	    jsonp: this.jsonp,
	    forceBase64: this.forceBase64,
	    enablesXDR: this.enablesXDR,
	    timestampRequests: this.timestampRequests,
	    timestampParam: this.timestampParam,
	    policyPort: this.policyPort,
	    socket: this,
	    pfx: this.pfx,
	    key: this.key,
	    passphrase: this.passphrase,
	    cert: this.cert,
	    ca: this.ca,
	    ciphers: this.ciphers,
	    rejectUnauthorized: this.rejectUnauthorized,
	    perMessageDeflate: this.perMessageDeflate,
	    extraHeaders: this.extraHeaders
	  });

	  return transport;
	};

	function clone (obj) {
	  var o = {};
	  for (var i in obj) {
	    if (obj.hasOwnProperty(i)) {
	      o[i] = obj[i];
	    }
	  }
	  return o;
	}

	/**
	 * Initializes transport to use and starts probe.
	 *
	 * @api private
	 */
	Socket.prototype.open = function () {
	  var transport;
	  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {
	    transport = 'websocket';
	  } else if (0 === this.transports.length) {
	    // Emit error on next tick so it can be listened to
	    var self = this;
	    setTimeout(function() {
	      self.emit('error', 'No transports available');
	    }, 0);
	    return;
	  } else {
	    transport = this.transports[0];
	  }
	  this.readyState = 'opening';

	  // Retry with the next transport if the transport is disabled (jsonp: false)
	  try {
	    transport = this.createTransport(transport);
	  } catch (e) {
	    this.transports.shift();
	    this.open();
	    return;
	  }

	  transport.open();
	  this.setTransport(transport);
	};

	/**
	 * Sets the current transport. Disables the existing one (if any).
	 *
	 * @api private
	 */

	Socket.prototype.setTransport = function(transport){
	  debug('setting transport %s', transport.name);
	  var self = this;

	  if (this.transport) {
	    debug('clearing existing transport %s', this.transport.name);
	    this.transport.removeAllListeners();
	  }

	  // set up transport
	  this.transport = transport;

	  // set up transport listeners
	  transport
	  .on('drain', function(){
	    self.onDrain();
	  })
	  .on('packet', function(packet){
	    self.onPacket(packet);
	  })
	  .on('error', function(e){
	    self.onError(e);
	  })
	  .on('close', function(){
	    self.onClose('transport close');
	  });
	};

	/**
	 * Probes a transport.
	 *
	 * @param {String} transport name
	 * @api private
	 */

	Socket.prototype.probe = function (name) {
	  debug('probing transport "%s"', name);
	  var transport = this.createTransport(name, { probe: 1 })
	    , failed = false
	    , self = this;

	  Socket.priorWebsocketSuccess = false;

	  function onTransportOpen(){
	    if (self.onlyBinaryUpgrades) {
	      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
	      failed = failed || upgradeLosesBinary;
	    }
	    if (failed) return;

	    debug('probe transport "%s" opened', name);
	    transport.send([{ type: 'ping', data: 'probe' }]);
	    transport.once('packet', function (msg) {
	      if (failed) return;
	      if ('pong' == msg.type && 'probe' == msg.data) {
	        debug('probe transport "%s" pong', name);
	        self.upgrading = true;
	        self.emit('upgrading', transport);
	        if (!transport) return;
	        Socket.priorWebsocketSuccess = 'websocket' == transport.name;

	        debug('pausing current transport "%s"', self.transport.name);
	        self.transport.pause(function () {
	          if (failed) return;
	          if ('closed' == self.readyState) return;
	          debug('changing transport and sending upgrade packet');

	          cleanup();

	          self.setTransport(transport);
	          transport.send([{ type: 'upgrade' }]);
	          self.emit('upgrade', transport);
	          transport = null;
	          self.upgrading = false;
	          self.flush();
	        });
	      } else {
	        debug('probe transport "%s" failed', name);
	        var err = new Error('probe error');
	        err.transport = transport.name;
	        self.emit('upgradeError', err);
	      }
	    });
	  }

	  function freezeTransport() {
	    if (failed) return;

	    // Any callback called by transport should be ignored since now
	    failed = true;

	    cleanup();

	    transport.close();
	    transport = null;
	  }

	  //Handle any error that happens while probing
	  function onerror(err) {
	    var error = new Error('probe error: ' + err);
	    error.transport = transport.name;

	    freezeTransport();

	    debug('probe transport "%s" failed because of error: %s', name, err);

	    self.emit('upgradeError', error);
	  }

	  function onTransportClose(){
	    onerror("transport closed");
	  }

	  //When the socket is closed while we're probing
	  function onclose(){
	    onerror("socket closed");
	  }

	  //When the socket is upgraded while we're probing
	  function onupgrade(to){
	    if (transport && to.name != transport.name) {
	      debug('"%s" works - aborting "%s"', to.name, transport.name);
	      freezeTransport();
	    }
	  }

	  //Remove all listeners on the transport and on self
	  function cleanup(){
	    transport.removeListener('open', onTransportOpen);
	    transport.removeListener('error', onerror);
	    transport.removeListener('close', onTransportClose);
	    self.removeListener('close', onclose);
	    self.removeListener('upgrading', onupgrade);
	  }

	  transport.once('open', onTransportOpen);
	  transport.once('error', onerror);
	  transport.once('close', onTransportClose);

	  this.once('close', onclose);
	  this.once('upgrading', onupgrade);

	  transport.open();

	};

	/**
	 * Called when connection is deemed open.
	 *
	 * @api public
	 */

	Socket.prototype.onOpen = function () {
	  debug('socket open');
	  this.readyState = 'open';
	  Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;
	  this.emit('open');
	  this.flush();

	  // we check for `readyState` in case an `open`
	  // listener already closed the socket
	  if ('open' == this.readyState && this.upgrade && this.transport.pause) {
	    debug('starting upgrade probes');
	    for (var i = 0, l = this.upgrades.length; i < l; i++) {
	      this.probe(this.upgrades[i]);
	    }
	  }
	};

	/**
	 * Handles a packet.
	 *
	 * @api private
	 */

	Socket.prototype.onPacket = function (packet) {
	  if ('opening' == this.readyState || 'open' == this.readyState) {
	    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

	    this.emit('packet', packet);

	    // Socket is live - any packet counts
	    this.emit('heartbeat');

	    switch (packet.type) {
	      case 'open':
	        this.onHandshake(parsejson(packet.data));
	        break;

	      case 'pong':
	        this.setPing();
	        this.emit('pong');
	        break;

	      case 'error':
	        var err = new Error('server error');
	        err.code = packet.data;
	        this.onError(err);
	        break;

	      case 'message':
	        this.emit('data', packet.data);
	        this.emit('message', packet.data);
	        break;
	    }
	  } else {
	    debug('packet received with socket readyState "%s"', this.readyState);
	  }
	};

	/**
	 * Called upon handshake completion.
	 *
	 * @param {Object} handshake obj
	 * @api private
	 */

	Socket.prototype.onHandshake = function (data) {
	  this.emit('handshake', data);
	  this.id = data.sid;
	  this.transport.query.sid = data.sid;
	  this.upgrades = this.filterUpgrades(data.upgrades);
	  this.pingInterval = data.pingInterval;
	  this.pingTimeout = data.pingTimeout;
	  this.onOpen();
	  // In case open handler closes socket
	  if  ('closed' == this.readyState) return;
	  this.setPing();

	  // Prolong liveness of socket on heartbeat
	  this.removeListener('heartbeat', this.onHeartbeat);
	  this.on('heartbeat', this.onHeartbeat);
	};

	/**
	 * Resets ping timeout.
	 *
	 * @api private
	 */

	Socket.prototype.onHeartbeat = function (timeout) {
	  clearTimeout(this.pingTimeoutTimer);
	  var self = this;
	  self.pingTimeoutTimer = setTimeout(function () {
	    if ('closed' == self.readyState) return;
	    self.onClose('ping timeout');
	  }, timeout || (self.pingInterval + self.pingTimeout));
	};

	/**
	 * Pings server every `this.pingInterval` and expects response
	 * within `this.pingTimeout` or closes connection.
	 *
	 * @api private
	 */

	Socket.prototype.setPing = function () {
	  var self = this;
	  clearTimeout(self.pingIntervalTimer);
	  self.pingIntervalTimer = setTimeout(function () {
	    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
	    self.ping();
	    self.onHeartbeat(self.pingTimeout);
	  }, self.pingInterval);
	};

	/**
	* Sends a ping packet.
	*
	* @api private
	*/

	Socket.prototype.ping = function () {
	  var self = this;
	  this.sendPacket('ping', function(){
	    self.emit('ping');
	  });
	};

	/**
	 * Called on `drain` event
	 *
	 * @api private
	 */

	Socket.prototype.onDrain = function() {
	  this.writeBuffer.splice(0, this.prevBufferLen);

	  // setting prevBufferLen = 0 is very important
	  // for example, when upgrading, upgrade packet is sent over,
	  // and a nonzero prevBufferLen could cause problems on `drain`
	  this.prevBufferLen = 0;

	  if (0 === this.writeBuffer.length) {
	    this.emit('drain');
	  } else {
	    this.flush();
	  }
	};

	/**
	 * Flush write buffers.
	 *
	 * @api private
	 */

	Socket.prototype.flush = function () {
	  if ('closed' != this.readyState && this.transport.writable &&
	    !this.upgrading && this.writeBuffer.length) {
	    debug('flushing %d packets in socket', this.writeBuffer.length);
	    this.transport.send(this.writeBuffer);
	    // keep track of current length of writeBuffer
	    // splice writeBuffer and callbackBuffer on `drain`
	    this.prevBufferLen = this.writeBuffer.length;
	    this.emit('flush');
	  }
	};

	/**
	 * Sends a message.
	 *
	 * @param {String} message.
	 * @param {Function} callback function.
	 * @param {Object} options.
	 * @return {Socket} for chaining.
	 * @api public
	 */

	Socket.prototype.write =
	Socket.prototype.send = function (msg, options, fn) {
	  this.sendPacket('message', msg, options, fn);
	  return this;
	};

	/**
	 * Sends a packet.
	 *
	 * @param {String} packet type.
	 * @param {String} data.
	 * @param {Object} options.
	 * @param {Function} callback function.
	 * @api private
	 */

	Socket.prototype.sendPacket = function (type, data, options, fn) {
	  if('function' == typeof data) {
	    fn = data;
	    data = undefined;
	  }

	  if ('function' == typeof options) {
	    fn = options;
	    options = null;
	  }

	  if ('closing' == this.readyState || 'closed' == this.readyState) {
	    return;
	  }

	  options = options || {};
	  options.compress = false !== options.compress;

	  var packet = {
	    type: type,
	    data: data,
	    options: options
	  };
	  this.emit('packetCreate', packet);
	  this.writeBuffer.push(packet);
	  if (fn) this.once('flush', fn);
	  this.flush();
	};

	/**
	 * Closes the connection.
	 *
	 * @api private
	 */

	Socket.prototype.close = function () {
	  if ('opening' == this.readyState || 'open' == this.readyState) {
	    this.readyState = 'closing';

	    var self = this;

	    if (this.writeBuffer.length) {
	      this.once('drain', function() {
	        if (this.upgrading) {
	          waitForUpgrade();
	        } else {
	          close();
	        }
	      });
	    } else if (this.upgrading) {
	      waitForUpgrade();
	    } else {
	      close();
	    }
	  }

	  function close() {
	    self.onClose('forced close');
	    debug('socket closing - telling transport to close');
	    self.transport.close();
	  }

	  function cleanupAndClose() {
	    self.removeListener('upgrade', cleanupAndClose);
	    self.removeListener('upgradeError', cleanupAndClose);
	    close();
	  }

	  function waitForUpgrade() {
	    // wait for upgrade to finish since we can't send packets while pausing a transport
	    self.once('upgrade', cleanupAndClose);
	    self.once('upgradeError', cleanupAndClose);
	  }

	  return this;
	};

	/**
	 * Called upon transport error
	 *
	 * @api private
	 */

	Socket.prototype.onError = function (err) {
	  debug('socket error %j', err);
	  Socket.priorWebsocketSuccess = false;
	  this.emit('error', err);
	  this.onClose('transport error', err);
	};

	/**
	 * Called upon transport close.
	 *
	 * @api private
	 */

	Socket.prototype.onClose = function (reason, desc) {
	  if ('opening' == this.readyState || 'open' == this.readyState || 'closing' == this.readyState) {
	    debug('socket close with reason: "%s"', reason);
	    var self = this;

	    // clear timers
	    clearTimeout(this.pingIntervalTimer);
	    clearTimeout(this.pingTimeoutTimer);

	    // stop event from firing again for transport
	    this.transport.removeAllListeners('close');

	    // ensure transport won't stay open
	    this.transport.close();

	    // ignore further transport communication
	    this.transport.removeAllListeners();

	    // set ready state
	    this.readyState = 'closed';

	    // clear session id
	    this.id = null;

	    // emit close event
	    this.emit('close', reason, desc);

	    // clean buffers after, so users can still
	    // grab the buffers on `close` event
	    self.writeBuffer = [];
	    self.prevBufferLen = 0;
	  }
	};

	/**
	 * Filters upgrades, returning only those matching client transports.
	 *
	 * @param {Array} server upgrades
	 * @api private
	 *
	 */

	Socket.prototype.filterUpgrades = function (upgrades) {
	  var filteredUpgrades = [];
	  for (var i = 0, j = upgrades.length; i<j; i++) {
	    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
	  }
	  return filteredUpgrades;
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/**
	 * Module requirements.
	 */

	var Polling = __webpack_require__(40);
	var inherit = __webpack_require__(16);

	/**
	 * Module exports.
	 */

	module.exports = JSONPPolling;

	/**
	 * Cached regular expressions.
	 */

	var rNewline = /\n/g;
	var rEscapedNewline = /\\n/g;

	/**
	 * Global JSONP callbacks.
	 */

	var callbacks;

	/**
	 * Callbacks count.
	 */

	var index = 0;

	/**
	 * Noop.
	 */

	function empty () { }

	/**
	 * JSONP Polling constructor.
	 *
	 * @param {Object} opts.
	 * @api public
	 */

	function JSONPPolling (opts) {
	  Polling.call(this, opts);

	  this.query = this.query || {};

	  // define global callbacks array if not present
	  // we do this here (lazily) to avoid unneeded global pollution
	  if (!callbacks) {
	    // we need to consider multiple engines in the same page
	    if (!global.___eio) global.___eio = [];
	    callbacks = global.___eio;
	  }

	  // callback identifier
	  this.index = callbacks.length;

	  // add callback to jsonp global
	  var self = this;
	  callbacks.push(function (msg) {
	    self.onData(msg);
	  });

	  // append to query string
	  this.query.j = this.index;

	  // prevent spurious errors from being emitted when the window is unloaded
	  if (global.document && global.addEventListener) {
	    global.addEventListener('beforeunload', function () {
	      if (self.script) self.script.onerror = empty;
	    }, false);
	  }
	}

	/**
	 * Inherits from Polling.
	 */

	inherit(JSONPPolling, Polling);

	/*
	 * JSONP only supports binary as base64 encoded strings
	 */

	JSONPPolling.prototype.supportsBinary = false;

	/**
	 * Closes the socket.
	 *
	 * @api private
	 */

	JSONPPolling.prototype.doClose = function () {
	  if (this.script) {
	    this.script.parentNode.removeChild(this.script);
	    this.script = null;
	  }

	  if (this.form) {
	    this.form.parentNode.removeChild(this.form);
	    this.form = null;
	    this.iframe = null;
	  }

	  Polling.prototype.doClose.call(this);
	};

	/**
	 * Starts a poll cycle.
	 *
	 * @api private
	 */

	JSONPPolling.prototype.doPoll = function () {
	  var self = this;
	  var script = document.createElement('script');

	  if (this.script) {
	    this.script.parentNode.removeChild(this.script);
	    this.script = null;
	  }

	  script.async = true;
	  script.src = this.uri();
	  script.onerror = function(e){
	    self.onError('jsonp poll error',e);
	  };

	  var insertAt = document.getElementsByTagName('script')[0];
	  if (insertAt) {
	    insertAt.parentNode.insertBefore(script, insertAt);
	  }
	  else {
	    (document.head || document.body).appendChild(script);
	  }
	  this.script = script;

	  var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);

	  if (isUAgecko) {
	    setTimeout(function () {
	      var iframe = document.createElement('iframe');
	      document.body.appendChild(iframe);
	      document.body.removeChild(iframe);
	    }, 100);
	  }
	};

	/**
	 * Writes with a hidden iframe.
	 *
	 * @param {String} data to send
	 * @param {Function} called upon flush.
	 * @api private
	 */

	JSONPPolling.prototype.doWrite = function (data, fn) {
	  var self = this;

	  if (!this.form) {
	    var form = document.createElement('form');
	    var area = document.createElement('textarea');
	    var id = this.iframeId = 'eio_iframe_' + this.index;
	    var iframe;

	    form.className = 'socketio';
	    form.style.position = 'absolute';
	    form.style.top = '-1000px';
	    form.style.left = '-1000px';
	    form.target = id;
	    form.method = 'POST';
	    form.setAttribute('accept-charset', 'utf-8');
	    area.name = 'd';
	    form.appendChild(area);
	    document.body.appendChild(form);

	    this.form = form;
	    this.area = area;
	  }

	  this.form.action = this.uri();

	  function complete () {
	    initIframe();
	    fn();
	  }

	  function initIframe () {
	    if (self.iframe) {
	      try {
	        self.form.removeChild(self.iframe);
	      } catch (e) {
	        self.onError('jsonp polling iframe removal error', e);
	      }
	    }

	    try {
	      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
	      var html = '<iframe src="javascript:0" name="'+ self.iframeId +'">';
	      iframe = document.createElement(html);
	    } catch (e) {
	      iframe = document.createElement('iframe');
	      iframe.name = self.iframeId;
	      iframe.src = 'javascript:0';
	    }

	    iframe.id = self.iframeId;

	    self.form.appendChild(iframe);
	    self.iframe = iframe;
	  }

	  initIframe();

	  // escape \n to prevent it from being converted into \r\n by some UAs
	  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
	  data = data.replace(rEscapedNewline, '\\\n');
	  this.area.value = data.replace(rNewline, '\\n');

	  try {
	    this.form.submit();
	  } catch(e) {}

	  if (this.iframe.attachEvent) {
	    this.iframe.onreadystatechange = function(){
	      if (self.iframe.readyState == 'complete') {
	        complete();
	      }
	    };
	  } else {
	    this.iframe.onload = complete;
	  }
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module requirements.
	 */

	var XMLHttpRequest = __webpack_require__(26);
	var Polling = __webpack_require__(40);
	var Emitter = __webpack_require__(15);
	var inherit = __webpack_require__(16);
	var debug = __webpack_require__(7)('engine.io-client:polling-xhr');

	/**
	 * Module exports.
	 */

	module.exports = XHR;
	module.exports.Request = Request;

	/**
	 * Empty function
	 */

	function empty(){}

	/**
	 * XHR Polling constructor.
	 *
	 * @param {Object} opts
	 * @api public
	 */

	function XHR(opts){
	  Polling.call(this, opts);

	  if (global.location) {
	    var isSSL = 'https:' == location.protocol;
	    var port = location.port;

	    // some user agents have empty `location.port`
	    if (!port) {
	      port = isSSL ? 443 : 80;
	    }

	    this.xd = opts.hostname != global.location.hostname ||
	      port != opts.port;
	    this.xs = opts.secure != isSSL;
	  } else {
	    this.extraHeaders = opts.extraHeaders;
	  }
	}

	/**
	 * Inherits from Polling.
	 */

	inherit(XHR, Polling);

	/**
	 * XHR supports binary
	 */

	XHR.prototype.supportsBinary = true;

	/**
	 * Creates a request.
	 *
	 * @param {String} method
	 * @api private
	 */

	XHR.prototype.request = function(opts){
	  opts = opts || {};
	  opts.uri = this.uri();
	  opts.xd = this.xd;
	  opts.xs = this.xs;
	  opts.agent = this.agent || false;
	  opts.supportsBinary = this.supportsBinary;
	  opts.enablesXDR = this.enablesXDR;

	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;

	  // other options for Node.js client
	  opts.extraHeaders = this.extraHeaders;

	  return new Request(opts);
	};

	/**
	 * Sends data.
	 *
	 * @param {String} data to send.
	 * @param {Function} called upon flush.
	 * @api private
	 */

	XHR.prototype.doWrite = function(data, fn){
	  var isBinary = typeof data !== 'string' && data !== undefined;
	  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
	  var self = this;
	  req.on('success', fn);
	  req.on('error', function(err){
	    self.onError('xhr post error', err);
	  });
	  this.sendXhr = req;
	};

	/**
	 * Starts a poll cycle.
	 *
	 * @api private
	 */

	XHR.prototype.doPoll = function(){
	  debug('xhr poll');
	  var req = this.request();
	  var self = this;
	  req.on('data', function(data){
	    self.onData(data);
	  });
	  req.on('error', function(err){
	    self.onError('xhr poll error', err);
	  });
	  this.pollXhr = req;
	};

	/**
	 * Request constructor
	 *
	 * @param {Object} options
	 * @api public
	 */

	function Request(opts){
	  this.method = opts.method || 'GET';
	  this.uri = opts.uri;
	  this.xd = !!opts.xd;
	  this.xs = !!opts.xs;
	  this.async = false !== opts.async;
	  this.data = undefined != opts.data ? opts.data : null;
	  this.agent = opts.agent;
	  this.isBinary = opts.isBinary;
	  this.supportsBinary = opts.supportsBinary;
	  this.enablesXDR = opts.enablesXDR;

	  // SSL options for Node.js client
	  this.pfx = opts.pfx;
	  this.key = opts.key;
	  this.passphrase = opts.passphrase;
	  this.cert = opts.cert;
	  this.ca = opts.ca;
	  this.ciphers = opts.ciphers;
	  this.rejectUnauthorized = opts.rejectUnauthorized;

	  // other options for Node.js client
	  this.extraHeaders = opts.extraHeaders;

	  this.create();
	}

	/**
	 * Mix in `Emitter`.
	 */

	Emitter(Request.prototype);

	/**
	 * Creates the XHR object and sends the request.
	 *
	 * @api private
	 */

	Request.prototype.create = function(){
	  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;

	  var xhr = this.xhr = new XMLHttpRequest(opts);
	  var self = this;

	  try {
	    debug('xhr open %s: %s', this.method, this.uri);
	    xhr.open(this.method, this.uri, this.async);
	    try {
	      if (this.extraHeaders) {
	        xhr.setDisableHeaderCheck(true);
	        for (var i in this.extraHeaders) {
	          if (this.extraHeaders.hasOwnProperty(i)) {
	            xhr.setRequestHeader(i, this.extraHeaders[i]);
	          }
	        }
	      }
	    } catch (e) {}
	    if (this.supportsBinary) {
	      // This has to be done after open because Firefox is stupid
	      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
	      xhr.responseType = 'arraybuffer';
	    }

	    if ('POST' == this.method) {
	      try {
	        if (this.isBinary) {
	          xhr.setRequestHeader('Content-type', 'application/octet-stream');
	        } else {
	          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
	        }
	      } catch (e) {}
	    }

	    // ie6 check
	    if ('withCredentials' in xhr) {
	      xhr.withCredentials = true;
	    }

	    if (this.hasXDR()) {
	      xhr.onload = function(){
	        self.onLoad();
	      };
	      xhr.onerror = function(){
	        self.onError(xhr.responseText);
	      };
	    } else {
	      xhr.onreadystatechange = function(){
	        if (4 != xhr.readyState) return;
	        if (200 == xhr.status || 1223 == xhr.status) {
	          self.onLoad();
	        } else {
	          // make sure the `error` event handler that's user-set
	          // does not throw in the same tick and gets caught here
	          setTimeout(function(){
	            self.onError(xhr.status);
	          }, 0);
	        }
	      };
	    }

	    debug('xhr data %s', this.data);
	    xhr.send(this.data);
	  } catch (e) {
	    // Need to defer since .create() is called directly fhrom the constructor
	    // and thus the 'error' event can only be only bound *after* this exception
	    // occurs.  Therefore, also, we cannot throw here at all.
	    setTimeout(function() {
	      self.onError(e);
	    }, 0);
	    return;
	  }

	  if (global.document) {
	    this.index = Request.requestsCount++;
	    Request.requests[this.index] = this;
	  }
	};

	/**
	 * Called upon successful response.
	 *
	 * @api private
	 */

	Request.prototype.onSuccess = function(){
	  this.emit('success');
	  this.cleanup();
	};

	/**
	 * Called if we have data.
	 *
	 * @api private
	 */

	Request.prototype.onData = function(data){
	  this.emit('data', data);
	  this.onSuccess();
	};

	/**
	 * Called upon error.
	 *
	 * @api private
	 */

	Request.prototype.onError = function(err){
	  this.emit('error', err);
	  this.cleanup(true);
	};

	/**
	 * Cleans up house.
	 *
	 * @api private
	 */

	Request.prototype.cleanup = function(fromError){
	  if ('undefined' == typeof this.xhr || null === this.xhr) {
	    return;
	  }
	  // xmlhttprequest
	  if (this.hasXDR()) {
	    this.xhr.onload = this.xhr.onerror = empty;
	  } else {
	    this.xhr.onreadystatechange = empty;
	  }

	  if (fromError) {
	    try {
	      this.xhr.abort();
	    } catch(e) {}
	  }

	  if (global.document) {
	    delete Request.requests[this.index];
	  }

	  this.xhr = null;
	};

	/**
	 * Called upon load.
	 *
	 * @api private
	 */

	Request.prototype.onLoad = function(){
	  var data;
	  try {
	    var contentType;
	    try {
	      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];
	    } catch (e) {}
	    if (contentType === 'application/octet-stream') {
	      data = this.xhr.response;
	    } else {
	      if (!this.supportsBinary) {
	        data = this.xhr.responseText;
	      } else {
	        try {
	          data = String.fromCharCode.apply(null, new Uint8Array(this.xhr.response));
	        } catch (e) {
	          var ui8Arr = new Uint8Array(this.xhr.response);
	          var dataArray = [];
	          for (var idx = 0, length = ui8Arr.length; idx < length; idx++) {
	            dataArray.push(ui8Arr[idx]);
	          }

	          data = String.fromCharCode.apply(null, dataArray);
	        }
	      }
	    }
	  } catch (e) {
	    this.onError(e);
	  }
	  if (null != data) {
	    this.onData(data);
	  }
	};

	/**
	 * Check if it has XDomainRequest.
	 *
	 * @api private
	 */

	Request.prototype.hasXDR = function(){
	  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
	};

	/**
	 * Aborts the request.
	 *
	 * @api public
	 */

	Request.prototype.abort = function(){
	  this.cleanup();
	};

	/**
	 * Aborts pending requests when unloading the window. This is needed to prevent
	 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
	 * emitted.
	 */

	if (global.document) {
	  Request.requestsCount = 0;
	  Request.requests = {};
	  if (global.attachEvent) {
	    global.attachEvent('onunload', unloadHandler);
	  } else if (global.addEventListener) {
	    global.addEventListener('beforeunload', unloadHandler, false);
	  }
	}

	function unloadHandler() {
	  for (var i in Request.requests) {
	    if (Request.requests.hasOwnProperty(i)) {
	      Request.requests[i].abort();
	    }
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module dependencies.
	 */

	var Transport = __webpack_require__(25);
	var parser = __webpack_require__(11);
	var parseqs = __webpack_require__(27);
	var inherit = __webpack_require__(16);
	var yeast = __webpack_require__(54);
	var debug = __webpack_require__(7)('engine.io-client:websocket');
	var BrowserWebSocket = global.WebSocket || global.MozWebSocket;

	/**
	 * Get either the `WebSocket` or `MozWebSocket` globals
	 * in the browser or try to resolve WebSocket-compatible
	 * interface exposed by `ws` for Node-like environment.
	 */

	var WebSocket = BrowserWebSocket;
	if (!WebSocket && typeof window === 'undefined') {
	  try {
	    WebSocket = __webpack_require__(211);
	  } catch (e) { }
	}

	/**
	 * Module exports.
	 */

	module.exports = WS;

	/**
	 * WebSocket transport constructor.
	 *
	 * @api {Object} connection options
	 * @api public
	 */

	function WS(opts){
	  var forceBase64 = (opts && opts.forceBase64);
	  if (forceBase64) {
	    this.supportsBinary = false;
	  }
	  this.perMessageDeflate = opts.perMessageDeflate;
	  Transport.call(this, opts);
	}

	/**
	 * Inherits from Transport.
	 */

	inherit(WS, Transport);

	/**
	 * Transport name.
	 *
	 * @api public
	 */

	WS.prototype.name = 'websocket';

	/*
	 * WebSockets support binary
	 */

	WS.prototype.supportsBinary = true;

	/**
	 * Opens socket.
	 *
	 * @api private
	 */

	WS.prototype.doOpen = function(){
	  if (!this.check()) {
	    // let probe timeout
	    return;
	  }

	  var self = this;
	  var uri = this.uri();
	  var protocols = void(0);
	  var opts = {
	    agent: this.agent,
	    perMessageDeflate: this.perMessageDeflate
	  };

	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;
	  if (this.extraHeaders) {
	    opts.headers = this.extraHeaders;
	  }

	  this.ws = BrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, protocols, opts);

	  if (this.ws.binaryType === undefined) {
	    this.supportsBinary = false;
	  }

	  if (this.ws.supports && this.ws.supports.binary) {
	    this.supportsBinary = true;
	    this.ws.binaryType = 'buffer';
	  } else {
	    this.ws.binaryType = 'arraybuffer';
	  }

	  this.addEventListeners();
	};

	/**
	 * Adds event listeners to the socket
	 *
	 * @api private
	 */

	WS.prototype.addEventListeners = function(){
	  var self = this;

	  this.ws.onopen = function(){
	    self.onOpen();
	  };
	  this.ws.onclose = function(){
	    self.onClose();
	  };
	  this.ws.onmessage = function(ev){
	    self.onData(ev.data);
	  };
	  this.ws.onerror = function(e){
	    self.onError('websocket error', e);
	  };
	};

	/**
	 * Override `onData` to use a timer on iOS.
	 * See: https://gist.github.com/mloughran/2052006
	 *
	 * @api private
	 */

	if ('undefined' != typeof navigator
	  && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
	  WS.prototype.onData = function(data){
	    var self = this;
	    setTimeout(function(){
	      Transport.prototype.onData.call(self, data);
	    }, 0);
	  };
	}

	/**
	 * Writes data to socket.
	 *
	 * @param {Array} array of packets.
	 * @api private
	 */

	WS.prototype.write = function(packets){
	  var self = this;
	  this.writable = false;

	  // encodePacket efficient as it uses WS framing
	  // no need for encodePayload
	  var total = packets.length;
	  for (var i = 0, l = total; i < l; i++) {
	    (function(packet) {
	      parser.encodePacket(packet, self.supportsBinary, function(data) {
	        if (!BrowserWebSocket) {
	          // always create a new object (GH-437)
	          var opts = {};
	          if (packet.options) {
	            opts.compress = packet.options.compress;
	          }

	          if (self.perMessageDeflate) {
	            var len = 'string' == typeof data ? global.Buffer.byteLength(data) : data.length;
	            if (len < self.perMessageDeflate.threshold) {
	              opts.compress = false;
	            }
	          }
	        }

	        //Sometimes the websocket has already been closed but the browser didn't
	        //have a chance of informing us about it yet, in that case send will
	        //throw an error
	        try {
	          if (BrowserWebSocket) {
	            // TypeError is thrown when passing the second argument on Safari
	            self.ws.send(data);
	          } else {
	            self.ws.send(data, opts);
	          }
	        } catch (e){
	          debug('websocket closed before onclose event');
	        }

	        --total || done();
	      });
	    })(packets[i]);
	  }

	  function done(){
	    self.emit('flush');

	    // fake drain
	    // defer to next tick to allow Socket to clear writeBuffer
	    setTimeout(function(){
	      self.writable = true;
	      self.emit('drain');
	    }, 0);
	  }
	};

	/**
	 * Called upon close
	 *
	 * @api private
	 */

	WS.prototype.onClose = function(){
	  Transport.prototype.onClose.call(this);
	};

	/**
	 * Closes socket.
	 *
	 * @api private
	 */

	WS.prototype.doClose = function(){
	  if (typeof this.ws !== 'undefined') {
	    this.ws.close();
	  }
	};

	/**
	 * Generates uri for connection.
	 *
	 * @api private
	 */

	WS.prototype.uri = function(){
	  var query = this.query || {};
	  var schema = this.secure ? 'wss' : 'ws';
	  var port = '';

	  // avoid port if default for schema
	  if (this.port && (('wss' == schema && this.port != 443)
	    || ('ws' == schema && this.port != 80))) {
	    port = ':' + this.port;
	  }

	  // append timestamp to URI
	  if (this.timestampRequests) {
	    query[this.timestampParam] = yeast();
	  }

	  // communicate binary support capabilities
	  if (!this.supportsBinary) {
	    query.b64 = 1;
	  }

	  query = parseqs.encode(query);

	  // prepend ? to query
	  if (query.length) {
	    query = '?' + query;
	  }

	  var ipv6 = this.hostname.indexOf(':') !== -1;
	  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
	};

	/**
	 * Feature detection for WebSocket.
	 *
	 * @return {Boolean} whether this transport is available.
	 * @api public
	 */

	WS.prototype.check = function(){
	  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 115 */
/***/ function(module, exports) {


	/**
	 * Gets the keys for an object.
	 *
	 * @return {Array} keys
	 * @api private
	 */

	module.exports = Object.keys || function keys (obj){
	  var arr = [];
	  var has = Object.prototype.hasOwnProperty;

	  for (var i in obj) {
	    if (has.call(obj, i)) {
	      arr.push(i);
	    }
	  }
	  return arr;
	};


/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/*
	 * Module requirements.
	 */

	var isArray = __webpack_require__(17);

	/**
	 * Module exports.
	 */

	module.exports = hasBinary;

	/**
	 * Checks for binary data.
	 *
	 * Right now only Buffer and ArrayBuffer are supported..
	 *
	 * @param {Object} anything
	 * @api public
	 */

	function hasBinary(data) {

	  function _hasBinary(obj) {
	    if (!obj) return false;

	    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||
	         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
	         (global.Blob && obj instanceof Blob) ||
	         (global.File && obj instanceof File)
	        ) {
	      return true;
	    }

	    if (isArray(obj)) {
	      for (var i = 0; i < obj.length; i++) {
	          if (_hasBinary(obj[i])) {
	              return true;
	          }
	      }
	    } else if (obj && 'object' == typeof obj) {
	      if (obj.toJSON) {
	        obj = obj.toJSON();
	      }

	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
	          return true;
	        }
	      }
	    }

	    return false;
	  }

	  return _hasBinary(data);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 117 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;

	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};

	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;

	  if (!this._events)
	    this._events = {};

	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      }
	      throw TypeError('Uncaught, unspecified "error" event.');
	    }
	  }

	  handler = this._events[type];

	  if (isUndefined(handler))
	    return false;

	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }

	  return true;
	};

	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events)
	    this._events = {};

	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);

	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];

	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }

	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }

	  return this;
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  var fired = false;

	  function g() {
	    this.removeListener(type, g);

	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }

	  g.listener = listener;
	  this.on(type, g);

	  return this;
	};

	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events || !this._events[type])
	    return this;

	  list = this._events[type];
	  length = list.length;
	  position = -1;

	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);

	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }

	    if (position < 0)
	      return this;

	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }

	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }

	  return this;
	};

	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;

	  if (!this._events)
	    return this;

	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }

	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }

	  listeners = this._events[type];

	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];

	  return this;
	};

	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};

	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];

	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};

	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};

	function isFunction(arg) {
	  return typeof arg === 'function';
	}

	function isNumber(arg) {
	  return typeof arg === 'number';
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 118 */
/***/ function(module, exports) {

	"use strict";
	'use strict';

	var hasOwn = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;

	var isArray = function isArray(arr) {
		if (typeof Array.isArray === 'function') {
			return Array.isArray(arr);
		}

		return toStr.call(arr) === '[object Array]';
	};

	var isPlainObject = function isPlainObject(obj) {
		if (!obj || toStr.call(obj) !== '[object Object]') {
			return false;
		}

		var hasOwnConstructor = hasOwn.call(obj, 'constructor');
		var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
		// Not own constructor property must be Object
		if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.
		var key;
		for (key in obj) {/**/}

		return typeof key === 'undefined' || hasOwn.call(obj, key);
	};

	module.exports = function extend() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[0],
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if (typeof target === 'boolean') {
			deep = target;
			target = arguments[1] || {};
			// skip the boolean and the target
			i = 2;
		} else if ((typeof target !== 'object' && typeof target !== 'function') || target == null) {
			target = {};
		}

		for (; i < length; ++i) {
			options = arguments[i];
			// Only deal with non-null/undefined values
			if (options != null) {
				// Extend the base object
				for (name in options) {
					src = target[name];
					copy = options[name];

					// Prevent never-ending loop
					if (target !== copy) {
						// Recurse if we're merging plain objects or arrays
						if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
							if (copyIsArray) {
								copyIsArray = false;
								clone = src && isArray(src) ? src : [];
							} else {
								clone = src && isPlainObject(src) ? src : {};
							}

							// Never move original objects, clone them
							target[name] = extend(deep, clone, copy);

						// Don't bring in undefined values
						} else if (typeof copy !== 'undefined') {
							target[name] = copy;
						}
					}
				}
			}
		}

		// Return the modified object
		return target;
	};



/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v2.0.7 - 2016-04-22
	 * http://hammerjs.github.io/
	 *
	 * Copyright (c) 2016 Jorik Tangelder;
	 * Licensed under the MIT license */
	(function(window, document, exportName, undefined) {
	  'use strict';

	var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
	var TEST_ELEMENT = document.createElement('div');

	var TYPE_FUNCTION = 'function';

	var round = Math.round;
	var abs = Math.abs;
	var now = Date.now;

	/**
	 * set a timeout with a given scope
	 * @param {Function} fn
	 * @param {Number} timeout
	 * @param {Object} context
	 * @returns {number}
	 */
	function setTimeoutContext(fn, timeout, context) {
	    return setTimeout(bindFn(fn, context), timeout);
	}

	/**
	 * if the argument is an array, we want to execute the fn on each entry
	 * if it aint an array we don't want to do a thing.
	 * this is used by all the methods that accept a single and array argument.
	 * @param {*|Array} arg
	 * @param {String} fn
	 * @param {Object} [context]
	 * @returns {Boolean}
	 */
	function invokeArrayArg(arg, fn, context) {
	    if (Array.isArray(arg)) {
	        each(arg, context[fn], context);
	        return true;
	    }
	    return false;
	}

	/**
	 * walk objects and arrays
	 * @param {Object} obj
	 * @param {Function} iterator
	 * @param {Object} context
	 */
	function each(obj, iterator, context) {
	    var i;

	    if (!obj) {
	        return;
	    }

	    if (obj.forEach) {
	        obj.forEach(iterator, context);
	    } else if (obj.length !== undefined) {
	        i = 0;
	        while (i < obj.length) {
	            iterator.call(context, obj[i], i, obj);
	            i++;
	        }
	    } else {
	        for (i in obj) {
	            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
	        }
	    }
	}

	/**
	 * wrap a method with a deprecation warning and stack trace
	 * @param {Function} method
	 * @param {String} name
	 * @param {String} message
	 * @returns {Function} A new function wrapping the supplied method.
	 */
	function deprecate(method, name, message) {
	    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
	    return function() {
	        var e = new Error('get-stack-trace');
	        var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
	            .replace(/^\s+at\s+/gm, '')
	            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

	        var log = window.console && (window.console.warn || window.console.log);
	        if (log) {
	            log.call(window.console, deprecationMessage, stack);
	        }
	        return method.apply(this, arguments);
	    };
	}

	/**
	 * extend object.
	 * means that properties in dest will be overwritten by the ones in src.
	 * @param {Object} target
	 * @param {...Object} objects_to_assign
	 * @returns {Object} target
	 */
	var assign;
	if (typeof Object.assign !== 'function') {
	    assign = function assign(target) {
	        if (target === undefined || target === null) {
	            throw new TypeError('Cannot convert undefined or null to object');
	        }

	        var output = Object(target);
	        for (var index = 1; index < arguments.length; index++) {
	            var source = arguments[index];
	            if (source !== undefined && source !== null) {
	                for (var nextKey in source) {
	                    if (source.hasOwnProperty(nextKey)) {
	                        output[nextKey] = source[nextKey];
	                    }
	                }
	            }
	        }
	        return output;
	    };
	} else {
	    assign = Object.assign;
	}

	/**
	 * extend object.
	 * means that properties in dest will be overwritten by the ones in src.
	 * @param {Object} dest
	 * @param {Object} src
	 * @param {Boolean} [merge=false]
	 * @returns {Object} dest
	 */
	var extend = deprecate(function extend(dest, src, merge) {
	    var keys = Object.keys(src);
	    var i = 0;
	    while (i < keys.length) {
	        if (!merge || (merge && dest[keys[i]] === undefined)) {
	            dest[keys[i]] = src[keys[i]];
	        }
	        i++;
	    }
	    return dest;
	}, 'extend', 'Use `assign`.');

	/**
	 * merge the values from src in the dest.
	 * means that properties that exist in dest will not be overwritten by src
	 * @param {Object} dest
	 * @param {Object} src
	 * @returns {Object} dest
	 */
	var merge = deprecate(function merge(dest, src) {
	    return extend(dest, src, true);
	}, 'merge', 'Use `assign`.');

	/**
	 * simple class inheritance
	 * @param {Function} child
	 * @param {Function} base
	 * @param {Object} [properties]
	 */
	function inherit(child, base, properties) {
	    var baseP = base.prototype,
	        childP;

	    childP = child.prototype = Object.create(baseP);
	    childP.constructor = child;
	    childP._super = baseP;

	    if (properties) {
	        assign(childP, properties);
	    }
	}

	/**
	 * simple function bind
	 * @param {Function} fn
	 * @param {Object} context
	 * @returns {Function}
	 */
	function bindFn(fn, context) {
	    return function boundFn() {
	        return fn.apply(context, arguments);
	    };
	}

	/**
	 * let a boolean value also be a function that must return a boolean
	 * this first item in args will be used as the context
	 * @param {Boolean|Function} val
	 * @param {Array} [args]
	 * @returns {Boolean}
	 */
	function boolOrFn(val, args) {
	    if (typeof val == TYPE_FUNCTION) {
	        return val.apply(args ? args[0] || undefined : undefined, args);
	    }
	    return val;
	}

	/**
	 * use the val2 when val1 is undefined
	 * @param {*} val1
	 * @param {*} val2
	 * @returns {*}
	 */
	function ifUndefined(val1, val2) {
	    return (val1 === undefined) ? val2 : val1;
	}

	/**
	 * addEventListener with multiple events at once
	 * @param {EventTarget} target
	 * @param {String} types
	 * @param {Function} handler
	 */
	function addEventListeners(target, types, handler) {
	    each(splitStr(types), function(type) {
	        target.addEventListener(type, handler, false);
	    });
	}

	/**
	 * removeEventListener with multiple events at once
	 * @param {EventTarget} target
	 * @param {String} types
	 * @param {Function} handler
	 */
	function removeEventListeners(target, types, handler) {
	    each(splitStr(types), function(type) {
	        target.removeEventListener(type, handler, false);
	    });
	}

	/**
	 * find if a node is in the given parent
	 * @method hasParent
	 * @param {HTMLElement} node
	 * @param {HTMLElement} parent
	 * @return {Boolean} found
	 */
	function hasParent(node, parent) {
	    while (node) {
	        if (node == parent) {
	            return true;
	        }
	        node = node.parentNode;
	    }
	    return false;
	}

	/**
	 * small indexOf wrapper
	 * @param {String} str
	 * @param {String} find
	 * @returns {Boolean} found
	 */
	function inStr(str, find) {
	    return str.indexOf(find) > -1;
	}

	/**
	 * split string on whitespace
	 * @param {String} str
	 * @returns {Array} words
	 */
	function splitStr(str) {
	    return str.trim().split(/\s+/g);
	}

	/**
	 * find if a array contains the object using indexOf or a simple polyFill
	 * @param {Array} src
	 * @param {String} find
	 * @param {String} [findByKey]
	 * @return {Boolean|Number} false when not found, or the index
	 */
	function inArray(src, find, findByKey) {
	    if (src.indexOf && !findByKey) {
	        return src.indexOf(find);
	    } else {
	        var i = 0;
	        while (i < src.length) {
	            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
	                return i;
	            }
	            i++;
	        }
	        return -1;
	    }
	}

	/**
	 * convert array-like objects to real arrays
	 * @param {Object} obj
	 * @returns {Array}
	 */
	function toArray(obj) {
	    return Array.prototype.slice.call(obj, 0);
	}

	/**
	 * unique array with objects based on a key (like 'id') or just by the array's value
	 * @param {Array} src [{id:1},{id:2},{id:1}]
	 * @param {String} [key]
	 * @param {Boolean} [sort=False]
	 * @returns {Array} [{id:1},{id:2}]
	 */
	function uniqueArray(src, key, sort) {
	    var results = [];
	    var values = [];
	    var i = 0;

	    while (i < src.length) {
	        var val = key ? src[i][key] : src[i];
	        if (inArray(values, val) < 0) {
	            results.push(src[i]);
	        }
	        values[i] = val;
	        i++;
	    }

	    if (sort) {
	        if (!key) {
	            results = results.sort();
	        } else {
	            results = results.sort(function sortUniqueArray(a, b) {
	                return a[key] > b[key];
	            });
	        }
	    }

	    return results;
	}

	/**
	 * get the prefixed property
	 * @param {Object} obj
	 * @param {String} property
	 * @returns {String|Undefined} prefixed
	 */
	function prefixed(obj, property) {
	    var prefix, prop;
	    var camelProp = property[0].toUpperCase() + property.slice(1);

	    var i = 0;
	    while (i < VENDOR_PREFIXES.length) {
	        prefix = VENDOR_PREFIXES[i];
	        prop = (prefix) ? prefix + camelProp : property;

	        if (prop in obj) {
	            return prop;
	        }
	        i++;
	    }
	    return undefined;
	}

	/**
	 * get a unique id
	 * @returns {number} uniqueId
	 */
	var _uniqueId = 1;
	function uniqueId() {
	    return _uniqueId++;
	}

	/**
	 * get the window object of an element
	 * @param {HTMLElement} element
	 * @returns {DocumentView|Window}
	 */
	function getWindowForElement(element) {
	    var doc = element.ownerDocument || element;
	    return (doc.defaultView || doc.parentWindow || window);
	}

	var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

	var SUPPORT_TOUCH = ('ontouchstart' in window);
	var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
	var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

	var INPUT_TYPE_TOUCH = 'touch';
	var INPUT_TYPE_PEN = 'pen';
	var INPUT_TYPE_MOUSE = 'mouse';
	var INPUT_TYPE_KINECT = 'kinect';

	var COMPUTE_INTERVAL = 25;

	var INPUT_START = 1;
	var INPUT_MOVE = 2;
	var INPUT_END = 4;
	var INPUT_CANCEL = 8;

	var DIRECTION_NONE = 1;
	var DIRECTION_LEFT = 2;
	var DIRECTION_RIGHT = 4;
	var DIRECTION_UP = 8;
	var DIRECTION_DOWN = 16;

	var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
	var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
	var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

	var PROPS_XY = ['x', 'y'];
	var PROPS_CLIENT_XY = ['clientX', 'clientY'];

	/**
	 * create new input type manager
	 * @param {Manager} manager
	 * @param {Function} callback
	 * @returns {Input}
	 * @constructor
	 */
	function Input(manager, callback) {
	    var self = this;
	    this.manager = manager;
	    this.callback = callback;
	    this.element = manager.element;
	    this.target = manager.options.inputTarget;

	    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
	    // so when disabled the input events are completely bypassed.
	    this.domHandler = function(ev) {
	        if (boolOrFn(manager.options.enable, [manager])) {
	            self.handler(ev);
	        }
	    };

	    this.init();

	}

	Input.prototype = {
	    /**
	     * should handle the inputEvent data and trigger the callback
	     * @virtual
	     */
	    handler: function() { },

	    /**
	     * bind the events
	     */
	    init: function() {
	        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
	        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
	        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
	    },

	    /**
	     * unbind the events
	     */
	    destroy: function() {
	        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
	        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
	        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
	    }
	};

	/**
	 * create new input type manager
	 * called by the Manager constructor
	 * @param {Hammer} manager
	 * @returns {Input}
	 */
	function createInputInstance(manager) {
	    var Type;
	    var inputClass = manager.options.inputClass;

	    if (inputClass) {
	        Type = inputClass;
	    } else if (SUPPORT_POINTER_EVENTS) {
	        Type = PointerEventInput;
	    } else if (SUPPORT_ONLY_TOUCH) {
	        Type = TouchInput;
	    } else if (!SUPPORT_TOUCH) {
	        Type = MouseInput;
	    } else {
	        Type = TouchMouseInput;
	    }
	    return new (Type)(manager, inputHandler);
	}

	/**
	 * handle input events
	 * @param {Manager} manager
	 * @param {String} eventType
	 * @param {Object} input
	 */
	function inputHandler(manager, eventType, input) {
	    var pointersLen = input.pointers.length;
	    var changedPointersLen = input.changedPointers.length;
	    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
	    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

	    input.isFirst = !!isFirst;
	    input.isFinal = !!isFinal;

	    if (isFirst) {
	        manager.session = {};
	    }

	    // source event is the normalized value of the domEvents
	    // like 'touchstart, mouseup, pointerdown'
	    input.eventType = eventType;

	    // compute scale, rotation etc
	    computeInputData(manager, input);

	    // emit secret event
	    manager.emit('hammer.input', input);

	    manager.recognize(input);
	    manager.session.prevInput = input;
	}

	/**
	 * extend the data with some usable properties like scale, rotate, velocity etc
	 * @param {Object} manager
	 * @param {Object} input
	 */
	function computeInputData(manager, input) {
	    var session = manager.session;
	    var pointers = input.pointers;
	    var pointersLength = pointers.length;

	    // store the first input to calculate the distance and direction
	    if (!session.firstInput) {
	        session.firstInput = simpleCloneInputData(input);
	    }

	    // to compute scale and rotation we need to store the multiple touches
	    if (pointersLength > 1 && !session.firstMultiple) {
	        session.firstMultiple = simpleCloneInputData(input);
	    } else if (pointersLength === 1) {
	        session.firstMultiple = false;
	    }

	    var firstInput = session.firstInput;
	    var firstMultiple = session.firstMultiple;
	    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

	    var center = input.center = getCenter(pointers);
	    input.timeStamp = now();
	    input.deltaTime = input.timeStamp - firstInput.timeStamp;

	    input.angle = getAngle(offsetCenter, center);
	    input.distance = getDistance(offsetCenter, center);

	    computeDeltaXY(session, input);
	    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

	    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
	    input.overallVelocityX = overallVelocity.x;
	    input.overallVelocityY = overallVelocity.y;
	    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

	    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
	    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

	    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
	        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

	    computeIntervalInputData(session, input);

	    // find the correct target
	    var target = manager.element;
	    if (hasParent(input.srcEvent.target, target)) {
	        target = input.srcEvent.target;
	    }
	    input.target = target;
	}

	function computeDeltaXY(session, input) {
	    var center = input.center;
	    var offset = session.offsetDelta || {};
	    var prevDelta = session.prevDelta || {};
	    var prevInput = session.prevInput || {};

	    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
	        prevDelta = session.prevDelta = {
	            x: prevInput.deltaX || 0,
	            y: prevInput.deltaY || 0
	        };

	        offset = session.offsetDelta = {
	            x: center.x,
	            y: center.y
	        };
	    }

	    input.deltaX = prevDelta.x + (center.x - offset.x);
	    input.deltaY = prevDelta.y + (center.y - offset.y);
	}

	/**
	 * velocity is calculated every x ms
	 * @param {Object} session
	 * @param {Object} input
	 */
	function computeIntervalInputData(session, input) {
	    var last = session.lastInterval || input,
	        deltaTime = input.timeStamp - last.timeStamp,
	        velocity, velocityX, velocityY, direction;

	    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
	        var deltaX = input.deltaX - last.deltaX;
	        var deltaY = input.deltaY - last.deltaY;

	        var v = getVelocity(deltaTime, deltaX, deltaY);
	        velocityX = v.x;
	        velocityY = v.y;
	        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
	        direction = getDirection(deltaX, deltaY);

	        session.lastInterval = input;
	    } else {
	        // use latest velocity info if it doesn't overtake a minimum period
	        velocity = last.velocity;
	        velocityX = last.velocityX;
	        velocityY = last.velocityY;
	        direction = last.direction;
	    }

	    input.velocity = velocity;
	    input.velocityX = velocityX;
	    input.velocityY = velocityY;
	    input.direction = direction;
	}

	/**
	 * create a simple clone from the input used for storage of firstInput and firstMultiple
	 * @param {Object} input
	 * @returns {Object} clonedInputData
	 */
	function simpleCloneInputData(input) {
	    // make a simple copy of the pointers because we will get a reference if we don't
	    // we only need clientXY for the calculations
	    var pointers = [];
	    var i = 0;
	    while (i < input.pointers.length) {
	        pointers[i] = {
	            clientX: round(input.pointers[i].clientX),
	            clientY: round(input.pointers[i].clientY)
	        };
	        i++;
	    }

	    return {
	        timeStamp: now(),
	        pointers: pointers,
	        center: getCenter(pointers),
	        deltaX: input.deltaX,
	        deltaY: input.deltaY
	    };
	}

	/**
	 * get the center of all the pointers
	 * @param {Array} pointers
	 * @return {Object} center contains `x` and `y` properties
	 */
	function getCenter(pointers) {
	    var pointersLength = pointers.length;

	    // no need to loop when only one touch
	    if (pointersLength === 1) {
	        return {
	            x: round(pointers[0].clientX),
	            y: round(pointers[0].clientY)
	        };
	    }

	    var x = 0, y = 0, i = 0;
	    while (i < pointersLength) {
	        x += pointers[i].clientX;
	        y += pointers[i].clientY;
	        i++;
	    }

	    return {
	        x: round(x / pointersLength),
	        y: round(y / pointersLength)
	    };
	}

	/**
	 * calculate the velocity between two points. unit is in px per ms.
	 * @param {Number} deltaTime
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Object} velocity `x` and `y`
	 */
	function getVelocity(deltaTime, x, y) {
	    return {
	        x: x / deltaTime || 0,
	        y: y / deltaTime || 0
	    };
	}

	/**
	 * get the direction between two points
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Number} direction
	 */
	function getDirection(x, y) {
	    if (x === y) {
	        return DIRECTION_NONE;
	    }

	    if (abs(x) >= abs(y)) {
	        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
	    }
	    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
	}

	/**
	 * calculate the absolute distance between two points
	 * @param {Object} p1 {x, y}
	 * @param {Object} p2 {x, y}
	 * @param {Array} [props] containing x and y keys
	 * @return {Number} distance
	 */
	function getDistance(p1, p2, props) {
	    if (!props) {
	        props = PROPS_XY;
	    }
	    var x = p2[props[0]] - p1[props[0]],
	        y = p2[props[1]] - p1[props[1]];

	    return Math.sqrt((x * x) + (y * y));
	}

	/**
	 * calculate the angle between two coordinates
	 * @param {Object} p1
	 * @param {Object} p2
	 * @param {Array} [props] containing x and y keys
	 * @return {Number} angle
	 */
	function getAngle(p1, p2, props) {
	    if (!props) {
	        props = PROPS_XY;
	    }
	    var x = p2[props[0]] - p1[props[0]],
	        y = p2[props[1]] - p1[props[1]];
	    return Math.atan2(y, x) * 180 / Math.PI;
	}

	/**
	 * calculate the rotation degrees between two pointersets
	 * @param {Array} start array of pointers
	 * @param {Array} end array of pointers
	 * @return {Number} rotation
	 */
	function getRotation(start, end) {
	    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
	}

	/**
	 * calculate the scale factor between two pointersets
	 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
	 * @param {Array} start array of pointers
	 * @param {Array} end array of pointers
	 * @return {Number} scale
	 */
	function getScale(start, end) {
	    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
	}

	var MOUSE_INPUT_MAP = {
	    mousedown: INPUT_START,
	    mousemove: INPUT_MOVE,
	    mouseup: INPUT_END
	};

	var MOUSE_ELEMENT_EVENTS = 'mousedown';
	var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

	/**
	 * Mouse events input
	 * @constructor
	 * @extends Input
	 */
	function MouseInput() {
	    this.evEl = MOUSE_ELEMENT_EVENTS;
	    this.evWin = MOUSE_WINDOW_EVENTS;

	    this.pressed = false; // mousedown state

	    Input.apply(this, arguments);
	}

	inherit(MouseInput, Input, {
	    /**
	     * handle mouse events
	     * @param {Object} ev
	     */
	    handler: function MEhandler(ev) {
	        var eventType = MOUSE_INPUT_MAP[ev.type];

	        // on start we want to have the left mouse button down
	        if (eventType & INPUT_START && ev.button === 0) {
	            this.pressed = true;
	        }

	        if (eventType & INPUT_MOVE && ev.which !== 1) {
	            eventType = INPUT_END;
	        }

	        // mouse must be down
	        if (!this.pressed) {
	            return;
	        }

	        if (eventType & INPUT_END) {
	            this.pressed = false;
	        }

	        this.callback(this.manager, eventType, {
	            pointers: [ev],
	            changedPointers: [ev],
	            pointerType: INPUT_TYPE_MOUSE,
	            srcEvent: ev
	        });
	    }
	});

	var POINTER_INPUT_MAP = {
	    pointerdown: INPUT_START,
	    pointermove: INPUT_MOVE,
	    pointerup: INPUT_END,
	    pointercancel: INPUT_CANCEL,
	    pointerout: INPUT_CANCEL
	};

	// in IE10 the pointer types is defined as an enum
	var IE10_POINTER_TYPE_ENUM = {
	    2: INPUT_TYPE_TOUCH,
	    3: INPUT_TYPE_PEN,
	    4: INPUT_TYPE_MOUSE,
	    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
	};

	var POINTER_ELEMENT_EVENTS = 'pointerdown';
	var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

	// IE10 has prefixed support, and case-sensitive
	if (window.MSPointerEvent && !window.PointerEvent) {
	    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
	    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
	}

	/**
	 * Pointer events input
	 * @constructor
	 * @extends Input
	 */
	function PointerEventInput() {
	    this.evEl = POINTER_ELEMENT_EVENTS;
	    this.evWin = POINTER_WINDOW_EVENTS;

	    Input.apply(this, arguments);

	    this.store = (this.manager.session.pointerEvents = []);
	}

	inherit(PointerEventInput, Input, {
	    /**
	     * handle mouse events
	     * @param {Object} ev
	     */
	    handler: function PEhandler(ev) {
	        var store = this.store;
	        var removePointer = false;

	        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
	        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
	        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

	        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

	        // get index of the event in the store
	        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

	        // start and mouse must be down
	        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
	            if (storeIndex < 0) {
	                store.push(ev);
	                storeIndex = store.length - 1;
	            }
	        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
	            removePointer = true;
	        }

	        // it not found, so the pointer hasn't been down (so it's probably a hover)
	        if (storeIndex < 0) {
	            return;
	        }

	        // update the event in the store
	        store[storeIndex] = ev;

	        this.callback(this.manager, eventType, {
	            pointers: store,
	            changedPointers: [ev],
	            pointerType: pointerType,
	            srcEvent: ev
	        });

	        if (removePointer) {
	            // remove from the store
	            store.splice(storeIndex, 1);
	        }
	    }
	});

	var SINGLE_TOUCH_INPUT_MAP = {
	    touchstart: INPUT_START,
	    touchmove: INPUT_MOVE,
	    touchend: INPUT_END,
	    touchcancel: INPUT_CANCEL
	};

	var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
	var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

	/**
	 * Touch events input
	 * @constructor
	 * @extends Input
	 */
	function SingleTouchInput() {
	    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
	    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
	    this.started = false;

	    Input.apply(this, arguments);
	}

	inherit(SingleTouchInput, Input, {
	    handler: function TEhandler(ev) {
	        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

	        // should we handle the touch events?
	        if (type === INPUT_START) {
	            this.started = true;
	        }

	        if (!this.started) {
	            return;
	        }

	        var touches = normalizeSingleTouches.call(this, ev, type);

	        // when done, reset the started state
	        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
	            this.started = false;
	        }

	        this.callback(this.manager, type, {
	            pointers: touches[0],
	            changedPointers: touches[1],
	            pointerType: INPUT_TYPE_TOUCH,
	            srcEvent: ev
	        });
	    }
	});

	/**
	 * @this {TouchInput}
	 * @param {Object} ev
	 * @param {Number} type flag
	 * @returns {undefined|Array} [all, changed]
	 */
	function normalizeSingleTouches(ev, type) {
	    var all = toArray(ev.touches);
	    var changed = toArray(ev.changedTouches);

	    if (type & (INPUT_END | INPUT_CANCEL)) {
	        all = uniqueArray(all.concat(changed), 'identifier', true);
	    }

	    return [all, changed];
	}

	var TOUCH_INPUT_MAP = {
	    touchstart: INPUT_START,
	    touchmove: INPUT_MOVE,
	    touchend: INPUT_END,
	    touchcancel: INPUT_CANCEL
	};

	var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

	/**
	 * Multi-user touch events input
	 * @constructor
	 * @extends Input
	 */
	function TouchInput() {
	    this.evTarget = TOUCH_TARGET_EVENTS;
	    this.targetIds = {};

	    Input.apply(this, arguments);
	}

	inherit(TouchInput, Input, {
	    handler: function MTEhandler(ev) {
	        var type = TOUCH_INPUT_MAP[ev.type];
	        var touches = getTouches.call(this, ev, type);
	        if (!touches) {
	            return;
	        }

	        this.callback(this.manager, type, {
	            pointers: touches[0],
	            changedPointers: touches[1],
	            pointerType: INPUT_TYPE_TOUCH,
	            srcEvent: ev
	        });
	    }
	});

	/**
	 * @this {TouchInput}
	 * @param {Object} ev
	 * @param {Number} type flag
	 * @returns {undefined|Array} [all, changed]
	 */
	function getTouches(ev, type) {
	    var allTouches = toArray(ev.touches);
	    var targetIds = this.targetIds;

	    // when there is only one touch, the process can be simplified
	    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
	        targetIds[allTouches[0].identifier] = true;
	        return [allTouches, allTouches];
	    }

	    var i,
	        targetTouches,
	        changedTouches = toArray(ev.changedTouches),
	        changedTargetTouches = [],
	        target = this.target;

	    // get target touches from touches
	    targetTouches = allTouches.filter(function(touch) {
	        return hasParent(touch.target, target);
	    });

	    // collect touches
	    if (type === INPUT_START) {
	        i = 0;
	        while (i < targetTouches.length) {
	            targetIds[targetTouches[i].identifier] = true;
	            i++;
	        }
	    }

	    // filter changed touches to only contain touches that exist in the collected target ids
	    i = 0;
	    while (i < changedTouches.length) {
	        if (targetIds[changedTouches[i].identifier]) {
	            changedTargetTouches.push(changedTouches[i]);
	        }

	        // cleanup removed touches
	        if (type & (INPUT_END | INPUT_CANCEL)) {
	            delete targetIds[changedTouches[i].identifier];
	        }
	        i++;
	    }

	    if (!changedTargetTouches.length) {
	        return;
	    }

	    return [
	        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
	        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
	        changedTargetTouches
	    ];
	}

	/**
	 * Combined touch and mouse input
	 *
	 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
	 * This because touch devices also emit mouse events while doing a touch.
	 *
	 * @constructor
	 * @extends Input
	 */

	var DEDUP_TIMEOUT = 2500;
	var DEDUP_DISTANCE = 25;

	function TouchMouseInput() {
	    Input.apply(this, arguments);

	    var handler = bindFn(this.handler, this);
	    this.touch = new TouchInput(this.manager, handler);
	    this.mouse = new MouseInput(this.manager, handler);

	    this.primaryTouch = null;
	    this.lastTouches = [];
	}

	inherit(TouchMouseInput, Input, {
	    /**
	     * handle mouse and touch events
	     * @param {Hammer} manager
	     * @param {String} inputEvent
	     * @param {Object} inputData
	     */
	    handler: function TMEhandler(manager, inputEvent, inputData) {
	        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
	            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

	        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
	            return;
	        }

	        // when we're in a touch event, record touches to  de-dupe synthetic mouse event
	        if (isTouch) {
	            recordTouches.call(this, inputEvent, inputData);
	        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
	            return;
	        }

	        this.callback(manager, inputEvent, inputData);
	    },

	    /**
	     * remove the event listeners
	     */
	    destroy: function destroy() {
	        this.touch.destroy();
	        this.mouse.destroy();
	    }
	});

	function recordTouches(eventType, eventData) {
	    if (eventType & INPUT_START) {
	        this.primaryTouch = eventData.changedPointers[0].identifier;
	        setLastTouch.call(this, eventData);
	    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
	        setLastTouch.call(this, eventData);
	    }
	}

	function setLastTouch(eventData) {
	    var touch = eventData.changedPointers[0];

	    if (touch.identifier === this.primaryTouch) {
	        var lastTouch = {x: touch.clientX, y: touch.clientY};
	        this.lastTouches.push(lastTouch);
	        var lts = this.lastTouches;
	        var removeLastTouch = function() {
	            var i = lts.indexOf(lastTouch);
	            if (i > -1) {
	                lts.splice(i, 1);
	            }
	        };
	        setTimeout(removeLastTouch, DEDUP_TIMEOUT);
	    }
	}

	function isSyntheticEvent(eventData) {
	    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
	    for (var i = 0; i < this.lastTouches.length; i++) {
	        var t = this.lastTouches[i];
	        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
	        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
	            return true;
	        }
	    }
	    return false;
	}

	var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
	var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

	// magical touchAction value
	var TOUCH_ACTION_COMPUTE = 'compute';
	var TOUCH_ACTION_AUTO = 'auto';
	var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
	var TOUCH_ACTION_NONE = 'none';
	var TOUCH_ACTION_PAN_X = 'pan-x';
	var TOUCH_ACTION_PAN_Y = 'pan-y';
	var TOUCH_ACTION_MAP = getTouchActionProps();

	/**
	 * Touch Action
	 * sets the touchAction property or uses the js alternative
	 * @param {Manager} manager
	 * @param {String} value
	 * @constructor
	 */
	function TouchAction(manager, value) {
	    this.manager = manager;
	    this.set(value);
	}

	TouchAction.prototype = {
	    /**
	     * set the touchAction value on the element or enable the polyfill
	     * @param {String} value
	     */
	    set: function(value) {
	        // find out the touch-action by the event handlers
	        if (value == TOUCH_ACTION_COMPUTE) {
	            value = this.compute();
	        }

	        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
	            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
	        }
	        this.actions = value.toLowerCase().trim();
	    },

	    /**
	     * just re-set the touchAction value
	     */
	    update: function() {
	        this.set(this.manager.options.touchAction);
	    },

	    /**
	     * compute the value for the touchAction property based on the recognizer's settings
	     * @returns {String} value
	     */
	    compute: function() {
	        var actions = [];
	        each(this.manager.recognizers, function(recognizer) {
	            if (boolOrFn(recognizer.options.enable, [recognizer])) {
	                actions = actions.concat(recognizer.getTouchAction());
	            }
	        });
	        return cleanTouchActions(actions.join(' '));
	    },

	    /**
	     * this method is called on each input cycle and provides the preventing of the browser behavior
	     * @param {Object} input
	     */
	    preventDefaults: function(input) {
	        var srcEvent = input.srcEvent;
	        var direction = input.offsetDirection;

	        // if the touch action did prevented once this session
	        if (this.manager.session.prevented) {
	            srcEvent.preventDefault();
	            return;
	        }

	        var actions = this.actions;
	        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
	        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
	        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

	        if (hasNone) {
	            //do not prevent defaults if this is a tap gesture

	            var isTapPointer = input.pointers.length === 1;
	            var isTapMovement = input.distance < 2;
	            var isTapTouchTime = input.deltaTime < 250;

	            if (isTapPointer && isTapMovement && isTapTouchTime) {
	                return;
	            }
	        }

	        if (hasPanX && hasPanY) {
	            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
	            return;
	        }

	        if (hasNone ||
	            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
	            (hasPanX && direction & DIRECTION_VERTICAL)) {
	            return this.preventSrc(srcEvent);
	        }
	    },

	    /**
	     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
	     * @param {Object} srcEvent
	     */
	    preventSrc: function(srcEvent) {
	        this.manager.session.prevented = true;
	        srcEvent.preventDefault();
	    }
	};

	/**
	 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
	 * @param {String} actions
	 * @returns {*}
	 */
	function cleanTouchActions(actions) {
	    // none
	    if (inStr(actions, TOUCH_ACTION_NONE)) {
	        return TOUCH_ACTION_NONE;
	    }

	    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
	    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

	    // if both pan-x and pan-y are set (different recognizers
	    // for different directions, e.g. horizontal pan but vertical swipe?)
	    // we need none (as otherwise with pan-x pan-y combined none of these
	    // recognizers will work, since the browser would handle all panning
	    if (hasPanX && hasPanY) {
	        return TOUCH_ACTION_NONE;
	    }

	    // pan-x OR pan-y
	    if (hasPanX || hasPanY) {
	        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
	    }

	    // manipulation
	    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
	        return TOUCH_ACTION_MANIPULATION;
	    }

	    return TOUCH_ACTION_AUTO;
	}

	function getTouchActionProps() {
	    if (!NATIVE_TOUCH_ACTION) {
	        return false;
	    }
	    var touchMap = {};
	    var cssSupports = window.CSS && window.CSS.supports;
	    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {

	        // If css.supports is not supported but there is native touch-action assume it supports
	        // all values. This is the case for IE 10 and 11.
	        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
	    });
	    return touchMap;
	}

	/**
	 * Recognizer flow explained; *
	 * All recognizers have the initial state of POSSIBLE when a input session starts.
	 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
	 * Example session for mouse-input: mousedown -> mousemove -> mouseup
	 *
	 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
	 * which determines with state it should be.
	 *
	 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
	 * POSSIBLE to give it another change on the next cycle.
	 *
	 *               Possible
	 *                  |
	 *            +-----+---------------+
	 *            |                     |
	 *      +-----+-----+               |
	 *      |           |               |
	 *   Failed      Cancelled          |
	 *                          +-------+------+
	 *                          |              |
	 *                      Recognized       Began
	 *                                         |
	 *                                      Changed
	 *                                         |
	 *                                  Ended/Recognized
	 */
	var STATE_POSSIBLE = 1;
	var STATE_BEGAN = 2;
	var STATE_CHANGED = 4;
	var STATE_ENDED = 8;
	var STATE_RECOGNIZED = STATE_ENDED;
	var STATE_CANCELLED = 16;
	var STATE_FAILED = 32;

	/**
	 * Recognizer
	 * Every recognizer needs to extend from this class.
	 * @constructor
	 * @param {Object} options
	 */
	function Recognizer(options) {
	    this.options = assign({}, this.defaults, options || {});

	    this.id = uniqueId();

	    this.manager = null;

	    // default is enable true
	    this.options.enable = ifUndefined(this.options.enable, true);

	    this.state = STATE_POSSIBLE;

	    this.simultaneous = {};
	    this.requireFail = [];
	}

	Recognizer.prototype = {
	    /**
	     * @virtual
	     * @type {Object}
	     */
	    defaults: {},

	    /**
	     * set options
	     * @param {Object} options
	     * @return {Recognizer}
	     */
	    set: function(options) {
	        assign(this.options, options);

	        // also update the touchAction, in case something changed about the directions/enabled state
	        this.manager && this.manager.touchAction.update();
	        return this;
	    },

	    /**
	     * recognize simultaneous with an other recognizer.
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    recognizeWith: function(otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
	            return this;
	        }

	        var simultaneous = this.simultaneous;
	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        if (!simultaneous[otherRecognizer.id]) {
	            simultaneous[otherRecognizer.id] = otherRecognizer;
	            otherRecognizer.recognizeWith(this);
	        }
	        return this;
	    },

	    /**
	     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    dropRecognizeWith: function(otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
	            return this;
	        }

	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        delete this.simultaneous[otherRecognizer.id];
	        return this;
	    },

	    /**
	     * recognizer can only run when an other is failing
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    requireFailure: function(otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
	            return this;
	        }

	        var requireFail = this.requireFail;
	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        if (inArray(requireFail, otherRecognizer) === -1) {
	            requireFail.push(otherRecognizer);
	            otherRecognizer.requireFailure(this);
	        }
	        return this;
	    },

	    /**
	     * drop the requireFailure link. it does not remove the link on the other recognizer.
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    dropRequireFailure: function(otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
	            return this;
	        }

	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        var index = inArray(this.requireFail, otherRecognizer);
	        if (index > -1) {
	            this.requireFail.splice(index, 1);
	        }
	        return this;
	    },

	    /**
	     * has require failures boolean
	     * @returns {boolean}
	     */
	    hasRequireFailures: function() {
	        return this.requireFail.length > 0;
	    },

	    /**
	     * if the recognizer can recognize simultaneous with an other recognizer
	     * @param {Recognizer} otherRecognizer
	     * @returns {Boolean}
	     */
	    canRecognizeWith: function(otherRecognizer) {
	        return !!this.simultaneous[otherRecognizer.id];
	    },

	    /**
	     * You should use `tryEmit` instead of `emit` directly to check
	     * that all the needed recognizers has failed before emitting.
	     * @param {Object} input
	     */
	    emit: function(input) {
	        var self = this;
	        var state = this.state;

	        function emit(event) {
	            self.manager.emit(event, input);
	        }

	        // 'panstart' and 'panmove'
	        if (state < STATE_ENDED) {
	            emit(self.options.event + stateStr(state));
	        }

	        emit(self.options.event); // simple 'eventName' events

	        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
	            emit(input.additionalEvent);
	        }

	        // panend and pancancel
	        if (state >= STATE_ENDED) {
	            emit(self.options.event + stateStr(state));
	        }
	    },

	    /**
	     * Check that all the require failure recognizers has failed,
	     * if true, it emits a gesture event,
	     * otherwise, setup the state to FAILED.
	     * @param {Object} input
	     */
	    tryEmit: function(input) {
	        if (this.canEmit()) {
	            return this.emit(input);
	        }
	        // it's failing anyway
	        this.state = STATE_FAILED;
	    },

	    /**
	     * can we emit?
	     * @returns {boolean}
	     */
	    canEmit: function() {
	        var i = 0;
	        while (i < this.requireFail.length) {
	            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
	                return false;
	            }
	            i++;
	        }
	        return true;
	    },

	    /**
	     * update the recognizer
	     * @param {Object} inputData
	     */
	    recognize: function(inputData) {
	        // make a new copy of the inputData
	        // so we can change the inputData without messing up the other recognizers
	        var inputDataClone = assign({}, inputData);

	        // is is enabled and allow recognizing?
	        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
	            this.reset();
	            this.state = STATE_FAILED;
	            return;
	        }

	        // reset when we've reached the end
	        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
	            this.state = STATE_POSSIBLE;
	        }

	        this.state = this.process(inputDataClone);

	        // the recognizer has recognized a gesture
	        // so trigger an event
	        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
	            this.tryEmit(inputDataClone);
	        }
	    },

	    /**
	     * return the state of the recognizer
	     * the actual recognizing happens in this method
	     * @virtual
	     * @param {Object} inputData
	     * @returns {Const} STATE
	     */
	    process: function(inputData) { }, // jshint ignore:line

	    /**
	     * return the preferred touch-action
	     * @virtual
	     * @returns {Array}
	     */
	    getTouchAction: function() { },

	    /**
	     * called when the gesture isn't allowed to recognize
	     * like when another is being recognized or it is disabled
	     * @virtual
	     */
	    reset: function() { }
	};

	/**
	 * get a usable string, used as event postfix
	 * @param {Const} state
	 * @returns {String} state
	 */
	function stateStr(state) {
	    if (state & STATE_CANCELLED) {
	        return 'cancel';
	    } else if (state & STATE_ENDED) {
	        return 'end';
	    } else if (state & STATE_CHANGED) {
	        return 'move';
	    } else if (state & STATE_BEGAN) {
	        return 'start';
	    }
	    return '';
	}

	/**
	 * direction cons to string
	 * @param {Const} direction
	 * @returns {String}
	 */
	function directionStr(direction) {
	    if (direction == DIRECTION_DOWN) {
	        return 'down';
	    } else if (direction == DIRECTION_UP) {
	        return 'up';
	    } else if (direction == DIRECTION_LEFT) {
	        return 'left';
	    } else if (direction == DIRECTION_RIGHT) {
	        return 'right';
	    }
	    return '';
	}

	/**
	 * get a recognizer by name if it is bound to a manager
	 * @param {Recognizer|String} otherRecognizer
	 * @param {Recognizer} recognizer
	 * @returns {Recognizer}
	 */
	function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
	    var manager = recognizer.manager;
	    if (manager) {
	        return manager.get(otherRecognizer);
	    }
	    return otherRecognizer;
	}

	/**
	 * This recognizer is just used as a base for the simple attribute recognizers.
	 * @constructor
	 * @extends Recognizer
	 */
	function AttrRecognizer() {
	    Recognizer.apply(this, arguments);
	}

	inherit(AttrRecognizer, Recognizer, {
	    /**
	     * @namespace
	     * @memberof AttrRecognizer
	     */
	    defaults: {
	        /**
	         * @type {Number}
	         * @default 1
	         */
	        pointers: 1
	    },

	    /**
	     * Used to check if it the recognizer receives valid input, like input.distance > 10.
	     * @memberof AttrRecognizer
	     * @param {Object} input
	     * @returns {Boolean} recognized
	     */
	    attrTest: function(input) {
	        var optionPointers = this.options.pointers;
	        return optionPointers === 0 || input.pointers.length === optionPointers;
	    },

	    /**
	     * Process the input and return the state for the recognizer
	     * @memberof AttrRecognizer
	     * @param {Object} input
	     * @returns {*} State
	     */
	    process: function(input) {
	        var state = this.state;
	        var eventType = input.eventType;

	        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
	        var isValid = this.attrTest(input);

	        // on cancel input and we've recognized before, return STATE_CANCELLED
	        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
	            return state | STATE_CANCELLED;
	        } else if (isRecognized || isValid) {
	            if (eventType & INPUT_END) {
	                return state | STATE_ENDED;
	            } else if (!(state & STATE_BEGAN)) {
	                return STATE_BEGAN;
	            }
	            return state | STATE_CHANGED;
	        }
	        return STATE_FAILED;
	    }
	});

	/**
	 * Pan
	 * Recognized when the pointer is down and moved in the allowed direction.
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function PanRecognizer() {
	    AttrRecognizer.apply(this, arguments);

	    this.pX = null;
	    this.pY = null;
	}

	inherit(PanRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof PanRecognizer
	     */
	    defaults: {
	        event: 'pan',
	        threshold: 10,
	        pointers: 1,
	        direction: DIRECTION_ALL
	    },

	    getTouchAction: function() {
	        var direction = this.options.direction;
	        var actions = [];
	        if (direction & DIRECTION_HORIZONTAL) {
	            actions.push(TOUCH_ACTION_PAN_Y);
	        }
	        if (direction & DIRECTION_VERTICAL) {
	            actions.push(TOUCH_ACTION_PAN_X);
	        }
	        return actions;
	    },

	    directionTest: function(input) {
	        var options = this.options;
	        var hasMoved = true;
	        var distance = input.distance;
	        var direction = input.direction;
	        var x = input.deltaX;
	        var y = input.deltaY;

	        // lock to axis?
	        if (!(direction & options.direction)) {
	            if (options.direction & DIRECTION_HORIZONTAL) {
	                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
	                hasMoved = x != this.pX;
	                distance = Math.abs(input.deltaX);
	            } else {
	                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
	                hasMoved = y != this.pY;
	                distance = Math.abs(input.deltaY);
	            }
	        }
	        input.direction = direction;
	        return hasMoved && distance > options.threshold && direction & options.direction;
	    },

	    attrTest: function(input) {
	        return AttrRecognizer.prototype.attrTest.call(this, input) &&
	            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
	    },

	    emit: function(input) {

	        this.pX = input.deltaX;
	        this.pY = input.deltaY;

	        var direction = directionStr(input.direction);

	        if (direction) {
	            input.additionalEvent = this.options.event + direction;
	        }
	        this._super.emit.call(this, input);
	    }
	});

	/**
	 * Pinch
	 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function PinchRecognizer() {
	    AttrRecognizer.apply(this, arguments);
	}

	inherit(PinchRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof PinchRecognizer
	     */
	    defaults: {
	        event: 'pinch',
	        threshold: 0,
	        pointers: 2
	    },

	    getTouchAction: function() {
	        return [TOUCH_ACTION_NONE];
	    },

	    attrTest: function(input) {
	        return this._super.attrTest.call(this, input) &&
	            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
	    },

	    emit: function(input) {
	        if (input.scale !== 1) {
	            var inOut = input.scale < 1 ? 'in' : 'out';
	            input.additionalEvent = this.options.event + inOut;
	        }
	        this._super.emit.call(this, input);
	    }
	});

	/**
	 * Press
	 * Recognized when the pointer is down for x ms without any movement.
	 * @constructor
	 * @extends Recognizer
	 */
	function PressRecognizer() {
	    Recognizer.apply(this, arguments);

	    this._timer = null;
	    this._input = null;
	}

	inherit(PressRecognizer, Recognizer, {
	    /**
	     * @namespace
	     * @memberof PressRecognizer
	     */
	    defaults: {
	        event: 'press',
	        pointers: 1,
	        time: 251, // minimal time of the pointer to be pressed
	        threshold: 9 // a minimal movement is ok, but keep it low
	    },

	    getTouchAction: function() {
	        return [TOUCH_ACTION_AUTO];
	    },

	    process: function(input) {
	        var options = this.options;
	        var validPointers = input.pointers.length === options.pointers;
	        var validMovement = input.distance < options.threshold;
	        var validTime = input.deltaTime > options.time;

	        this._input = input;

	        // we only allow little movement
	        // and we've reached an end event, so a tap is possible
	        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
	            this.reset();
	        } else if (input.eventType & INPUT_START) {
	            this.reset();
	            this._timer = setTimeoutContext(function() {
	                this.state = STATE_RECOGNIZED;
	                this.tryEmit();
	            }, options.time, this);
	        } else if (input.eventType & INPUT_END) {
	            return STATE_RECOGNIZED;
	        }
	        return STATE_FAILED;
	    },

	    reset: function() {
	        clearTimeout(this._timer);
	    },

	    emit: function(input) {
	        if (this.state !== STATE_RECOGNIZED) {
	            return;
	        }

	        if (input && (input.eventType & INPUT_END)) {
	            this.manager.emit(this.options.event + 'up', input);
	        } else {
	            this._input.timeStamp = now();
	            this.manager.emit(this.options.event, this._input);
	        }
	    }
	});

	/**
	 * Rotate
	 * Recognized when two or more pointer are moving in a circular motion.
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function RotateRecognizer() {
	    AttrRecognizer.apply(this, arguments);
	}

	inherit(RotateRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof RotateRecognizer
	     */
	    defaults: {
	        event: 'rotate',
	        threshold: 0,
	        pointers: 2
	    },

	    getTouchAction: function() {
	        return [TOUCH_ACTION_NONE];
	    },

	    attrTest: function(input) {
	        return this._super.attrTest.call(this, input) &&
	            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
	    }
	});

	/**
	 * Swipe
	 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function SwipeRecognizer() {
	    AttrRecognizer.apply(this, arguments);
	}

	inherit(SwipeRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof SwipeRecognizer
	     */
	    defaults: {
	        event: 'swipe',
	        threshold: 10,
	        velocity: 0.3,
	        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
	        pointers: 1
	    },

	    getTouchAction: function() {
	        return PanRecognizer.prototype.getTouchAction.call(this);
	    },

	    attrTest: function(input) {
	        var direction = this.options.direction;
	        var velocity;

	        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
	            velocity = input.overallVelocity;
	        } else if (direction & DIRECTION_HORIZONTAL) {
	            velocity = input.overallVelocityX;
	        } else if (direction & DIRECTION_VERTICAL) {
	            velocity = input.overallVelocityY;
	        }

	        return this._super.attrTest.call(this, input) &&
	            direction & input.offsetDirection &&
	            input.distance > this.options.threshold &&
	            input.maxPointers == this.options.pointers &&
	            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
	    },

	    emit: function(input) {
	        var direction = directionStr(input.offsetDirection);
	        if (direction) {
	            this.manager.emit(this.options.event + direction, input);
	        }

	        this.manager.emit(this.options.event, input);
	    }
	});

	/**
	 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
	 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
	 * a single tap.
	 *
	 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
	 * multi-taps being recognized.
	 * @constructor
	 * @extends Recognizer
	 */
	function TapRecognizer() {
	    Recognizer.apply(this, arguments);

	    // previous time and center,
	    // used for tap counting
	    this.pTime = false;
	    this.pCenter = false;

	    this._timer = null;
	    this._input = null;
	    this.count = 0;
	}

	inherit(TapRecognizer, Recognizer, {
	    /**
	     * @namespace
	     * @memberof PinchRecognizer
	     */
	    defaults: {
	        event: 'tap',
	        pointers: 1,
	        taps: 1,
	        interval: 300, // max time between the multi-tap taps
	        time: 250, // max time of the pointer to be down (like finger on the screen)
	        threshold: 9, // a minimal movement is ok, but keep it low
	        posThreshold: 10 // a multi-tap can be a bit off the initial position
	    },

	    getTouchAction: function() {
	        return [TOUCH_ACTION_MANIPULATION];
	    },

	    process: function(input) {
	        var options = this.options;

	        var validPointers = input.pointers.length === options.pointers;
	        var validMovement = input.distance < options.threshold;
	        var validTouchTime = input.deltaTime < options.time;

	        this.reset();

	        if ((input.eventType & INPUT_START) && (this.count === 0)) {
	            return this.failTimeout();
	        }

	        // we only allow little movement
	        // and we've reached an end event, so a tap is possible
	        if (validMovement && validTouchTime && validPointers) {
	            if (input.eventType != INPUT_END) {
	                return this.failTimeout();
	            }

	            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
	            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

	            this.pTime = input.timeStamp;
	            this.pCenter = input.center;

	            if (!validMultiTap || !validInterval) {
	                this.count = 1;
	            } else {
	                this.count += 1;
	            }

	            this._input = input;

	            // if tap count matches we have recognized it,
	            // else it has began recognizing...
	            var tapCount = this.count % options.taps;
	            if (tapCount === 0) {
	                // no failing requirements, immediately trigger the tap event
	                // or wait as long as the multitap interval to trigger
	                if (!this.hasRequireFailures()) {
	                    return STATE_RECOGNIZED;
	                } else {
	                    this._timer = setTimeoutContext(function() {
	                        this.state = STATE_RECOGNIZED;
	                        this.tryEmit();
	                    }, options.interval, this);
	                    return STATE_BEGAN;
	                }
	            }
	        }
	        return STATE_FAILED;
	    },

	    failTimeout: function() {
	        this._timer = setTimeoutContext(function() {
	            this.state = STATE_FAILED;
	        }, this.options.interval, this);
	        return STATE_FAILED;
	    },

	    reset: function() {
	        clearTimeout(this._timer);
	    },

	    emit: function() {
	        if (this.state == STATE_RECOGNIZED) {
	            this._input.tapCount = this.count;
	            this.manager.emit(this.options.event, this._input);
	        }
	    }
	});

	/**
	 * Simple way to create a manager with a default set of recognizers.
	 * @param {HTMLElement} element
	 * @param {Object} [options]
	 * @constructor
	 */
	function Hammer(element, options) {
	    options = options || {};
	    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
	    return new Manager(element, options);
	}

	/**
	 * @const {string}
	 */
	Hammer.VERSION = '2.0.7';

	/**
	 * default settings
	 * @namespace
	 */
	Hammer.defaults = {
	    /**
	     * set if DOM events are being triggered.
	     * But this is slower and unused by simple implementations, so disabled by default.
	     * @type {Boolean}
	     * @default false
	     */
	    domEvents: false,

	    /**
	     * The value for the touchAction property/fallback.
	     * When set to `compute` it will magically set the correct value based on the added recognizers.
	     * @type {String}
	     * @default compute
	     */
	    touchAction: TOUCH_ACTION_COMPUTE,

	    /**
	     * @type {Boolean}
	     * @default true
	     */
	    enable: true,

	    /**
	     * EXPERIMENTAL FEATURE -- can be removed/changed
	     * Change the parent input target element.
	     * If Null, then it is being set the to main element.
	     * @type {Null|EventTarget}
	     * @default null
	     */
	    inputTarget: null,

	    /**
	     * force an input class
	     * @type {Null|Function}
	     * @default null
	     */
	    inputClass: null,

	    /**
	     * Default recognizer setup when calling `Hammer()`
	     * When creating a new Manager these will be skipped.
	     * @type {Array}
	     */
	    preset: [
	        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
	        [RotateRecognizer, {enable: false}],
	        [PinchRecognizer, {enable: false}, ['rotate']],
	        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
	        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
	        [TapRecognizer],
	        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
	        [PressRecognizer]
	    ],

	    /**
	     * Some CSS properties can be used to improve the working of Hammer.
	     * Add them to this method and they will be set when creating a new Manager.
	     * @namespace
	     */
	    cssProps: {
	        /**
	         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
	         * @type {String}
	         * @default 'none'
	         */
	        userSelect: 'none',

	        /**
	         * Disable the Windows Phone grippers when pressing an element.
	         * @type {String}
	         * @default 'none'
	         */
	        touchSelect: 'none',

	        /**
	         * Disables the default callout shown when you touch and hold a touch target.
	         * On iOS, when you touch and hold a touch target such as a link, Safari displays
	         * a callout containing information about the link. This property allows you to disable that callout.
	         * @type {String}
	         * @default 'none'
	         */
	        touchCallout: 'none',

	        /**
	         * Specifies whether zooming is enabled. Used by IE10>
	         * @type {String}
	         * @default 'none'
	         */
	        contentZooming: 'none',

	        /**
	         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
	         * @type {String}
	         * @default 'none'
	         */
	        userDrag: 'none',

	        /**
	         * Overrides the highlight color shown when the user taps a link or a JavaScript
	         * clickable element in iOS. This property obeys the alpha value, if specified.
	         * @type {String}
	         * @default 'rgba(0,0,0,0)'
	         */
	        tapHighlightColor: 'rgba(0,0,0,0)'
	    }
	};

	var STOP = 1;
	var FORCED_STOP = 2;

	/**
	 * Manager
	 * @param {HTMLElement} element
	 * @param {Object} [options]
	 * @constructor
	 */
	function Manager(element, options) {
	    this.options = assign({}, Hammer.defaults, options || {});

	    this.options.inputTarget = this.options.inputTarget || element;

	    this.handlers = {};
	    this.session = {};
	    this.recognizers = [];
	    this.oldCssProps = {};

	    this.element = element;
	    this.input = createInputInstance(this);
	    this.touchAction = new TouchAction(this, this.options.touchAction);

	    toggleCssProps(this, true);

	    each(this.options.recognizers, function(item) {
	        var recognizer = this.add(new (item[0])(item[1]));
	        item[2] && recognizer.recognizeWith(item[2]);
	        item[3] && recognizer.requireFailure(item[3]);
	    }, this);
	}

	Manager.prototype = {
	    /**
	     * set options
	     * @param {Object} options
	     * @returns {Manager}
	     */
	    set: function(options) {
	        assign(this.options, options);

	        // Options that need a little more setup
	        if (options.touchAction) {
	            this.touchAction.update();
	        }
	        if (options.inputTarget) {
	            // Clean up existing event listeners and reinitialize
	            this.input.destroy();
	            this.input.target = options.inputTarget;
	            this.input.init();
	        }
	        return this;
	    },

	    /**
	     * stop recognizing for this session.
	     * This session will be discarded, when a new [input]start event is fired.
	     * When forced, the recognizer cycle is stopped immediately.
	     * @param {Boolean} [force]
	     */
	    stop: function(force) {
	        this.session.stopped = force ? FORCED_STOP : STOP;
	    },

	    /**
	     * run the recognizers!
	     * called by the inputHandler function on every movement of the pointers (touches)
	     * it walks through all the recognizers and tries to detect the gesture that is being made
	     * @param {Object} inputData
	     */
	    recognize: function(inputData) {
	        var session = this.session;
	        if (session.stopped) {
	            return;
	        }

	        // run the touch-action polyfill
	        this.touchAction.preventDefaults(inputData);

	        var recognizer;
	        var recognizers = this.recognizers;

	        // this holds the recognizer that is being recognized.
	        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
	        // if no recognizer is detecting a thing, it is set to `null`
	        var curRecognizer = session.curRecognizer;

	        // reset when the last recognizer is recognized
	        // or when we're in a new session
	        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
	            curRecognizer = session.curRecognizer = null;
	        }

	        var i = 0;
	        while (i < recognizers.length) {
	            recognizer = recognizers[i];

	            // find out if we are allowed try to recognize the input for this one.
	            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
	            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
	            //      that is being recognized.
	            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
	            //      this can be setup with the `recognizeWith()` method on the recognizer.
	            if (session.stopped !== FORCED_STOP && ( // 1
	                    !curRecognizer || recognizer == curRecognizer || // 2
	                    recognizer.canRecognizeWith(curRecognizer))) { // 3
	                recognizer.recognize(inputData);
	            } else {
	                recognizer.reset();
	            }

	            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
	            // current active recognizer. but only if we don't already have an active recognizer
	            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
	                curRecognizer = session.curRecognizer = recognizer;
	            }
	            i++;
	        }
	    },

	    /**
	     * get a recognizer by its event name.
	     * @param {Recognizer|String} recognizer
	     * @returns {Recognizer|Null}
	     */
	    get: function(recognizer) {
	        if (recognizer instanceof Recognizer) {
	            return recognizer;
	        }

	        var recognizers = this.recognizers;
	        for (var i = 0; i < recognizers.length; i++) {
	            if (recognizers[i].options.event == recognizer) {
	                return recognizers[i];
	            }
	        }
	        return null;
	    },

	    /**
	     * add a recognizer to the manager
	     * existing recognizers with the same event name will be removed
	     * @param {Recognizer} recognizer
	     * @returns {Recognizer|Manager}
	     */
	    add: function(recognizer) {
	        if (invokeArrayArg(recognizer, 'add', this)) {
	            return this;
	        }

	        // remove existing
	        var existing = this.get(recognizer.options.event);
	        if (existing) {
	            this.remove(existing);
	        }

	        this.recognizers.push(recognizer);
	        recognizer.manager = this;

	        this.touchAction.update();
	        return recognizer;
	    },

	    /**
	     * remove a recognizer by name or instance
	     * @param {Recognizer|String} recognizer
	     * @returns {Manager}
	     */
	    remove: function(recognizer) {
	        if (invokeArrayArg(recognizer, 'remove', this)) {
	            return this;
	        }

	        recognizer = this.get(recognizer);

	        // let's make sure this recognizer exists
	        if (recognizer) {
	            var recognizers = this.recognizers;
	            var index = inArray(recognizers, recognizer);

	            if (index !== -1) {
	                recognizers.splice(index, 1);
	                this.touchAction.update();
	            }
	        }

	        return this;
	    },

	    /**
	     * bind event
	     * @param {String} events
	     * @param {Function} handler
	     * @returns {EventEmitter} this
	     */
	    on: function(events, handler) {
	        if (events === undefined) {
	            return;
	        }
	        if (handler === undefined) {
	            return;
	        }

	        var handlers = this.handlers;
	        each(splitStr(events), function(event) {
	            handlers[event] = handlers[event] || [];
	            handlers[event].push(handler);
	        });
	        return this;
	    },

	    /**
	     * unbind event, leave emit blank to remove all handlers
	     * @param {String} events
	     * @param {Function} [handler]
	     * @returns {EventEmitter} this
	     */
	    off: function(events, handler) {
	        if (events === undefined) {
	            return;
	        }

	        var handlers = this.handlers;
	        each(splitStr(events), function(event) {
	            if (!handler) {
	                delete handlers[event];
	            } else {
	                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
	            }
	        });
	        return this;
	    },

	    /**
	     * emit event to the listeners
	     * @param {String} event
	     * @param {Object} data
	     */
	    emit: function(event, data) {
	        // we also want to trigger dom events
	        if (this.options.domEvents) {
	            triggerDomEvent(event, data);
	        }

	        // no handlers, so skip it all
	        var handlers = this.handlers[event] && this.handlers[event].slice();
	        if (!handlers || !handlers.length) {
	            return;
	        }

	        data.type = event;
	        data.preventDefault = function() {
	            data.srcEvent.preventDefault();
	        };

	        var i = 0;
	        while (i < handlers.length) {
	            handlers[i](data);
	            i++;
	        }
	    },

	    /**
	     * destroy the manager and unbinds all events
	     * it doesn't unbind dom events, that is the user own responsibility
	     */
	    destroy: function() {
	        this.element && toggleCssProps(this, false);

	        this.handlers = {};
	        this.session = {};
	        this.input.destroy();
	        this.element = null;
	    }
	};

	/**
	 * add/remove the css properties as defined in manager.options.cssProps
	 * @param {Manager} manager
	 * @param {Boolean} add
	 */
	function toggleCssProps(manager, add) {
	    var element = manager.element;
	    if (!element.style) {
	        return;
	    }
	    var prop;
	    each(manager.options.cssProps, function(value, name) {
	        prop = prefixed(element.style, name);
	        if (add) {
	            manager.oldCssProps[prop] = element.style[prop];
	            element.style[prop] = value;
	        } else {
	            element.style[prop] = manager.oldCssProps[prop] || '';
	        }
	    });
	    if (!add) {
	        manager.oldCssProps = {};
	    }
	}

	/**
	 * trigger dom event
	 * @param {String} event
	 * @param {Object} data
	 */
	function triggerDomEvent(event, data) {
	    var gestureEvent = document.createEvent('Event');
	    gestureEvent.initEvent(event, true, true);
	    gestureEvent.gesture = data;
	    data.target.dispatchEvent(gestureEvent);
	}

	assign(Hammer, {
	    INPUT_START: INPUT_START,
	    INPUT_MOVE: INPUT_MOVE,
	    INPUT_END: INPUT_END,
	    INPUT_CANCEL: INPUT_CANCEL,

	    STATE_POSSIBLE: STATE_POSSIBLE,
	    STATE_BEGAN: STATE_BEGAN,
	    STATE_CHANGED: STATE_CHANGED,
	    STATE_ENDED: STATE_ENDED,
	    STATE_RECOGNIZED: STATE_RECOGNIZED,
	    STATE_CANCELLED: STATE_CANCELLED,
	    STATE_FAILED: STATE_FAILED,

	    DIRECTION_NONE: DIRECTION_NONE,
	    DIRECTION_LEFT: DIRECTION_LEFT,
	    DIRECTION_RIGHT: DIRECTION_RIGHT,
	    DIRECTION_UP: DIRECTION_UP,
	    DIRECTION_DOWN: DIRECTION_DOWN,
	    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
	    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
	    DIRECTION_ALL: DIRECTION_ALL,

	    Manager: Manager,
	    Input: Input,
	    TouchAction: TouchAction,

	    TouchInput: TouchInput,
	    MouseInput: MouseInput,
	    PointerEventInput: PointerEventInput,
	    TouchMouseInput: TouchMouseInput,
	    SingleTouchInput: SingleTouchInput,

	    Recognizer: Recognizer,
	    AttrRecognizer: AttrRecognizer,
	    Tap: TapRecognizer,
	    Pan: PanRecognizer,
	    Swipe: SwipeRecognizer,
	    Pinch: PinchRecognizer,
	    Rotate: RotateRecognizer,
	    Press: PressRecognizer,

	    on: addEventListeners,
	    off: removeEventListeners,
	    each: each,
	    merge: merge,
	    extend: extend,
	    assign: assign,
	    inherit: inherit,
	    bindFn: bindFn,
	    prefixed: prefixed
	});

	// this prevents errors when Hammer is loaded in the presence of an AMD
	//  style loader but by script tag, not by the loader.
	var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
	freeGlobal.Hammer = Hammer;

	if (true) {
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	        return Hammer;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (typeof module != 'undefined' && module.exports) {
	    module.exports = Hammer;
	} else {
	    window[exportName] = Hammer;
	}

	})(window, document, 'Hammer');


/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/*
	 * Module requirements.
	 */

	var isArray = __webpack_require__(17);

	/**
	 * Module exports.
	 */

	module.exports = hasBinary;

	/**
	 * Checks for binary data.
	 *
	 * Right now only Buffer and ArrayBuffer are supported..
	 *
	 * @param {Object} anything
	 * @api public
	 */

	function hasBinary(data) {

	  function _hasBinary(obj) {
	    if (!obj) return false;

	    if ( (global.Buffer && global.Buffer.isBuffer && global.Buffer.isBuffer(obj)) ||
	         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
	         (global.Blob && obj instanceof Blob) ||
	         (global.File && obj instanceof File)
	        ) {
	      return true;
	    }

	    if (isArray(obj)) {
	      for (var i = 0; i < obj.length; i++) {
	          if (_hasBinary(obj[i])) {
	              return true;
	          }
	      }
	    } else if (obj && 'object' == typeof obj) {
	      // see: https://github.com/Automattic/has-binary/pull/4
	      if (obj.toJSON && 'function' == typeof obj.toJSON) {
	        obj = obj.toJSON();
	      }

	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
	          return true;
	        }
	      }
	    }

	    return false;
	  }

	  return _hasBinary(data);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 121 */
/***/ function(module, exports) {


	/**
	 * Module exports.
	 *
	 * Logic borrowed from Modernizr:
	 *
	 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
	 */

	try {
	  module.exports = typeof XMLHttpRequest !== 'undefined' &&
	    'withCredentials' in new XMLHttpRequest();
	} catch (err) {
	  // if XMLHttp support is disabled in IE then it will throw
	  // when trying to create
	  module.exports = false;
	}


/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = {
	  XmlEntities: __webpack_require__(124),
	  Html4Entities: __webpack_require__(123),
	  Html5Entities: __webpack_require__(41),
	  AllHtmlEntities: __webpack_require__(41)
	};


/***/ },
/* 123 */
/***/ function(module, exports) {

	var HTML_ALPHA = ['apos', 'nbsp', 'iexcl', 'cent', 'pound', 'curren', 'yen', 'brvbar', 'sect', 'uml', 'copy', 'ordf', 'laquo', 'not', 'shy', 'reg', 'macr', 'deg', 'plusmn', 'sup2', 'sup3', 'acute', 'micro', 'para', 'middot', 'cedil', 'sup1', 'ordm', 'raquo', 'frac14', 'frac12', 'frac34', 'iquest', 'Agrave', 'Aacute', 'Acirc', 'Atilde', 'Auml', 'Aring', 'Aelig', 'Ccedil', 'Egrave', 'Eacute', 'Ecirc', 'Euml', 'Igrave', 'Iacute', 'Icirc', 'Iuml', 'ETH', 'Ntilde', 'Ograve', 'Oacute', 'Ocirc', 'Otilde', 'Ouml', 'times', 'Oslash', 'Ugrave', 'Uacute', 'Ucirc', 'Uuml', 'Yacute', 'THORN', 'szlig', 'agrave', 'aacute', 'acirc', 'atilde', 'auml', 'aring', 'aelig', 'ccedil', 'egrave', 'eacute', 'ecirc', 'euml', 'igrave', 'iacute', 'icirc', 'iuml', 'eth', 'ntilde', 'ograve', 'oacute', 'ocirc', 'otilde', 'ouml', 'divide', 'Oslash', 'ugrave', 'uacute', 'ucirc', 'uuml', 'yacute', 'thorn', 'yuml', 'quot', 'amp', 'lt', 'gt', 'oelig', 'oelig', 'scaron', 'scaron', 'yuml', 'circ', 'tilde', 'ensp', 'emsp', 'thinsp', 'zwnj', 'zwj', 'lrm', 'rlm', 'ndash', 'mdash', 'lsquo', 'rsquo', 'sbquo', 'ldquo', 'rdquo', 'bdquo', 'dagger', 'dagger', 'permil', 'lsaquo', 'rsaquo', 'euro', 'fnof', 'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega', 'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigmaf', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega', 'thetasym', 'upsih', 'piv', 'bull', 'hellip', 'prime', 'prime', 'oline', 'frasl', 'weierp', 'image', 'real', 'trade', 'alefsym', 'larr', 'uarr', 'rarr', 'darr', 'harr', 'crarr', 'larr', 'uarr', 'rarr', 'darr', 'harr', 'forall', 'part', 'exist', 'empty', 'nabla', 'isin', 'notin', 'ni', 'prod', 'sum', 'minus', 'lowast', 'radic', 'prop', 'infin', 'ang', 'and', 'or', 'cap', 'cup', 'int', 'there4', 'sim', 'cong', 'asymp', 'ne', 'equiv', 'le', 'ge', 'sub', 'sup', 'nsub', 'sube', 'supe', 'oplus', 'otimes', 'perp', 'sdot', 'lceil', 'rceil', 'lfloor', 'rfloor', 'lang', 'rang', 'loz', 'spades', 'clubs', 'hearts', 'diams'];
	var HTML_CODES = [39, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 34, 38, 60, 62, 338, 339, 352, 353, 376, 710, 732, 8194, 8195, 8201, 8204, 8205, 8206, 8207, 8211, 8212, 8216, 8217, 8218, 8220, 8221, 8222, 8224, 8225, 8240, 8249, 8250, 8364, 402, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 977, 978, 982, 8226, 8230, 8242, 8243, 8254, 8260, 8472, 8465, 8476, 8482, 8501, 8592, 8593, 8594, 8595, 8596, 8629, 8656, 8657, 8658, 8659, 8660, 8704, 8706, 8707, 8709, 8711, 8712, 8713, 8715, 8719, 8721, 8722, 8727, 8730, 8733, 8734, 8736, 8743, 8744, 8745, 8746, 8747, 8756, 8764, 8773, 8776, 8800, 8801, 8804, 8805, 8834, 8835, 8836, 8838, 8839, 8853, 8855, 8869, 8901, 8968, 8969, 8970, 8971, 9001, 9002, 9674, 9824, 9827, 9829, 9830];

	var alphaIndex = {};
	var numIndex = {};

	var i = 0;
	var length = HTML_ALPHA.length;
	while (i < length) {
	    var a = HTML_ALPHA[i];
	    var c = HTML_CODES[i];
	    alphaIndex[a] = String.fromCharCode(c);
	    numIndex[c] = a;
	    i++;
	}

	/**
	 * @constructor
	 */
	function Html4Entities() {}

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	Html4Entities.prototype.decode = function(str) {
	    if (str.length === 0) {
	        return '';
	    }
	    return str.replace(/&(#?[\w\d]+);?/g, function(s, entity) {
	        var chr;
	        if (entity.charAt(0) === "#") {
	            var code = entity.charAt(1).toLowerCase() === 'x' ?
	                parseInt(entity.substr(2), 16) :
	                parseInt(entity.substr(1));

	            if (!(isNaN(code) || code < -32768 || code > 65535)) {
	                chr = String.fromCharCode(code);
	            }
	        } else {
	            chr = alphaIndex[entity];
	        }
	        return chr || s;
	    });
	};

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	Html4Entities.decode = function(str) {
	    return new Html4Entities().decode(str);
	};

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	Html4Entities.prototype.encode = function(str) {
	    var strLength = str.length;
	    if (strLength === 0) {
	        return '';
	    }
	    var result = '';
	    var i = 0;
	    while (i < strLength) {
	        var alpha = numIndex[str.charCodeAt(i)];
	        result += alpha ? "&" + alpha + ";" : str.charAt(i);
	        i++;
	    }
	    return result;
	};

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	Html4Entities.encode = function(str) {
	    return new Html4Entities().encode(str);
	};

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	Html4Entities.prototype.encodeNonUTF = function(str) {
	    var strLength = str.length;
	    if (strLength === 0) {
	        return '';
	    }
	    var result = '';
	    var i = 0;
	    while (i < strLength) {
	        var cc = str.charCodeAt(i);
	        var alpha = numIndex[cc];
	        if (alpha) {
	            result += "&" + alpha + ";";
	        } else if (cc < 32 || cc > 126) {
	            result += "&#" + cc + ";";
	        } else {
	            result += str.charAt(i);
	        }
	        i++;
	    }
	    return result;
	};

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	Html4Entities.encodeNonUTF = function(str) {
	    return new Html4Entities().encodeNonUTF(str);
	};

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	Html4Entities.prototype.encodeNonASCII = function(str) {
	    var strLength = str.length;
	    if (strLength === 0) {
	        return '';
	    }
	    var result = '';
	    var i = 0;
	    while (i < strLength) {
	        var c = str.charCodeAt(i);
	        if (c <= 255) {
	            result += str[i++];
	            continue;
	        }
	        result += '&#' + c + ';';
	        i++;
	    }
	    return result;
	};

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	Html4Entities.encodeNonASCII = function(str) {
	    return new Html4Entities().encodeNonASCII(str);
	};

	module.exports = Html4Entities;


/***/ },
/* 124 */
/***/ function(module, exports) {

	var ALPHA_INDEX = {
	    '&lt': '<',
	    '&gt': '>',
	    '&quot': '"',
	    '&apos': '\'',
	    '&amp': '&',
	    '&lt;': '<',
	    '&gt;': '>',
	    '&quot;': '"',
	    '&apos;': '\'',
	    '&amp;': '&'
	};

	var CHAR_INDEX = {
	    60: 'lt',
	    62: 'gt',
	    34: 'quot',
	    39: 'apos',
	    38: 'amp'
	};

	var CHAR_S_INDEX = {
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    '\'': '&apos;',
	    '&': '&amp;'
	};

	/**
	 * @constructor
	 */
	function XmlEntities() {}

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	XmlEntities.prototype.encode = function(str) {
	    if (str.length === 0) {
	        return '';
	    }
	    return str.replace(/<|>|"|'|&/g, function(s) {
	        return CHAR_S_INDEX[s];
	    });
	};

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	 XmlEntities.encode = function(str) {
	    return new XmlEntities().encode(str);
	 };

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	XmlEntities.prototype.decode = function(str) {
	    if (str.length === 0) {
	        return '';
	    }
	    return str.replace(/&#?[0-9a-zA-Z]+;?/g, function(s) {
	        if (s.charAt(1) === '#') {
	            var code = s.charAt(2).toLowerCase() === 'x' ?
	                parseInt(s.substr(3), 16) :
	                parseInt(s.substr(2));

	            if (isNaN(code) || code < -32768 || code > 65535) {
	                return '';
	            }
	            return String.fromCharCode(code);
	        }
	        return ALPHA_INDEX[s] || s;
	    });
	};

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	 XmlEntities.decode = function(str) {
	    return new XmlEntities().decode(str);
	 };

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	XmlEntities.prototype.encodeNonUTF = function(str) {
	    var strLength = str.length;
	    if (strLength === 0) {
	        return '';
	    }
	    var result = '';
	    var i = 0;
	    while (i < strLength) {
	        var c = str.charCodeAt(i);
	        var alpha = CHAR_INDEX[c];
	        if (alpha) {
	            result += "&" + alpha + ";";
	            i++;
	            continue;
	        }
	        if (c < 32 || c > 126) {
	            result += '&#' + c + ';';
	        } else {
	            result += str.charAt(i);
	        }
	        i++;
	    }
	    return result;
	};

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	 XmlEntities.encodeNonUTF = function(str) {
	    return new XmlEntities().encodeNonUTF(str);
	 };

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	XmlEntities.prototype.encodeNonASCII = function(str) {
	    var strLenght = str.length;
	    if (strLenght === 0) {
	        return '';
	    }
	    var result = '';
	    var i = 0;
	    while (i < strLenght) {
	        var c = str.charCodeAt(i);
	        if (c <= 255) {
	            result += str[i++];
	            continue;
	        }
	        result += '&#' + c + ';';
	        i++;
	    }
	    return result;
	};

	/**
	 * @param {String} str
	 * @returns {String}
	 */
	 XmlEntities.encodeNonASCII = function(str) {
	    return new XmlEntities().encodeNonASCII(str);
	 };

	module.exports = XmlEntities;


/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Bez 1.0.11
	 * http://github.com/rdallasgray/bez
	 *
	 * A plugin to convert CSS3 cubic-bezier co-ordinates to jQuery-compatible easing functions
	 *
	 * With thanks to Nikolay Nemshilov for clarification on the cubic-bezier maths
	 * See http://st-on-it.blogspot.com/2011/05/calculating-cubic-bezier-function.html
	 *
	 * Copyright 2016 Robert Dallas Gray. All rights reserved.
	 * Provided under the FreeBSD license: https://github.com/rdallasgray/bez/blob/master/LICENSE.txt
	 */
	(function(factory) {
	  if (true) {
	    factory(jQuery);
	  } else if (typeof define === "function" && define.amd) {
	    define(["jquery"], factory);
	  } else {
	    factory(jQuery);
	  }
	}(function($) {
	  $.extend({ bez: function(encodedFuncName, coOrdArray) {
	    if ($.isArray(encodedFuncName)) {
	      coOrdArray = encodedFuncName;
	      encodedFuncName = 'bez_' + coOrdArray.join('_').replace(/\./g, 'p');
	    }
	    if (typeof $.easing[encodedFuncName] !== "function") {
	      var polyBez = function(p1, p2) {
	        var A = [null, null], B = [null, null], C = [null, null],
	            bezCoOrd = function(t, ax) {
	              C[ax] = 3 * p1[ax], B[ax] = 3 * (p2[ax] - p1[ax]) - C[ax], A[ax] = 1 - C[ax] - B[ax];
	              return t * (C[ax] + t * (B[ax] + t * A[ax]));
	            },
	            xDeriv = function(t) {
	              return C[0] + t * (2 * B[0] + 3 * A[0] * t);
	            },
	            xForT = function(t) {
	              var x = t, i = 0, z;
	              while (++i < 14) {
	                z = bezCoOrd(x, 0) - t;
	                if (Math.abs(z) < 1e-3) break;
	                x -= z / xDeriv(x);
	              }
	              return x;
	            };
	        return function(t) {
	          return bezCoOrd(xForT(t), 1);
	        }
	      };
	      $.easing[encodedFuncName] = function(x, t, b, c, d) {
	        return c * polyBez([coOrdArray[0], coOrdArray[1]], [coOrdArray[2], coOrdArray[3]])(t/d) + b;
	      }
	    }
	    return encodedFuncName;
	  }});
	}));


/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	/*global self, document, DOMException */

	/*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js */

	// Full polyfill for browsers with no classList support
	if (!("classList" in document.createElement("_"))) {
	  (function (view) {

	  "use strict";

	  if (!('Element' in view)) return;

	  var
	      classListProp = "classList"
	    , protoProp = "prototype"
	    , elemCtrProto = view.Element[protoProp]
	    , objCtr = Object
	    , strTrim = String[protoProp].trim || function () {
	      return this.replace(/^\s+|\s+$/g, "");
	    }
	    , arrIndexOf = Array[protoProp].indexOf || function (item) {
	      var
	          i = 0
	        , len = this.length
	      ;
	      for (; i < len; i++) {
	        if (i in this && this[i] === item) {
	          return i;
	        }
	      }
	      return -1;
	    }
	    // Vendors: please allow content code to instantiate DOMExceptions
	    , DOMEx = function (type, message) {
	      this.name = type;
	      this.code = DOMException[type];
	      this.message = message;
	    }
	    , checkTokenAndGetIndex = function (classList, token) {
	      if (token === "") {
	        throw new DOMEx(
	            "SYNTAX_ERR"
	          , "An invalid or illegal string was specified"
	        );
	      }
	      if (/\s/.test(token)) {
	        throw new DOMEx(
	            "INVALID_CHARACTER_ERR"
	          , "String contains an invalid character"
	        );
	      }
	      return arrIndexOf.call(classList, token);
	    }
	    , ClassList = function (elem) {
	      var
	          trimmedClasses = strTrim.call(elem.getAttribute("class") || "")
	        , classes = trimmedClasses ? trimmedClasses.split(/\s+/) : []
	        , i = 0
	        , len = classes.length
	      ;
	      for (; i < len; i++) {
	        this.push(classes[i]);
	      }
	      this._updateClassName = function () {
	        elem.setAttribute("class", this.toString());
	      };
	    }
	    , classListProto = ClassList[protoProp] = []
	    , classListGetter = function () {
	      return new ClassList(this);
	    }
	  ;
	  // Most DOMException implementations don't allow calling DOMException's toString()
	  // on non-DOMExceptions. Error's toString() is sufficient here.
	  DOMEx[protoProp] = Error[protoProp];
	  classListProto.item = function (i) {
	    return this[i] || null;
	  };
	  classListProto.contains = function (token) {
	    token += "";
	    return checkTokenAndGetIndex(this, token) !== -1;
	  };
	  classListProto.add = function () {
	    var
	        tokens = arguments
	      , i = 0
	      , l = tokens.length
	      , token
	      , updated = false
	    ;
	    do {
	      token = tokens[i] + "";
	      if (checkTokenAndGetIndex(this, token) === -1) {
	        this.push(token);
	        updated = true;
	      }
	    }
	    while (++i < l);

	    if (updated) {
	      this._updateClassName();
	    }
	  };
	  classListProto.remove = function () {
	    var
	        tokens = arguments
	      , i = 0
	      , l = tokens.length
	      , token
	      , updated = false
	      , index
	    ;
	    do {
	      token = tokens[i] + "";
	      index = checkTokenAndGetIndex(this, token);
	      while (index !== -1) {
	        this.splice(index, 1);
	        updated = true;
	        index = checkTokenAndGetIndex(this, token);
	      }
	    }
	    while (++i < l);

	    if (updated) {
	      this._updateClassName();
	    }
	  };
	  classListProto.toggle = function (token, force) {
	    token += "";

	    var
	        result = this.contains(token)
	      , method = result ?
	        force !== true && "remove"
	      :
	        force !== false && "add"
	    ;

	    if (method) {
	      this[method](token);
	    }

	    if (force === true || force === false) {
	      return force;
	    } else {
	      return !result;
	    }
	  };
	  classListProto.toString = function () {
	    return this.join(" ");
	  };

	  if (objCtr.defineProperty) {
	    var classListPropDesc = {
	        get: classListGetter
	      , enumerable: true
	      , configurable: true
	    };
	    try {
	      objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
	    } catch (ex) { // IE 8 doesn't support enumerable:true
	      if (ex.number === -0x7FF5EC54) {
	        classListPropDesc.enumerable = false;
	        objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
	      }
	    }
	  } else if (objCtr[protoProp].__defineGetter__) {
	    elemCtrProto.__defineGetter__(classListProp, classListGetter);
	  }

	  }(self));
	}

	/* Blob.js
	 * A Blob implementation.
	 * 2014-07-24
	 *
	 * By Eli Grey, http://eligrey.com
	 * By Devin Samarin, https://github.com/dsamarin
	 * License: X11/MIT
	 *   See https://github.com/eligrey/Blob.js/blob/master/LICENSE.md
	 */

	/*global self, unescape */
	/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,
	  plusplus: true */

	/*! @source http://purl.eligrey.com/github/Blob.js/blob/master/Blob.js */

	(function (view) {
	  "use strict";

	  view.URL = view.URL || view.webkitURL;

	  if (view.Blob && view.URL) {
	    try {
	      new Blob;
	      return;
	    } catch (e) {}
	  }

	  // Internally we use a BlobBuilder implementation to base Blob off of
	  // in order to support older browsers that only have BlobBuilder
	  var BlobBuilder = view.BlobBuilder || view.WebKitBlobBuilder || view.MozBlobBuilder || (function(view) {
	    var
	        get_class = function(object) {
	        return Object.prototype.toString.call(object).match(/^\[object\s(.*)\]$/)[1];
	      }
	      , FakeBlobBuilder = function BlobBuilder() {
	        this.data = [];
	      }
	      , FakeBlob = function Blob(data, type, encoding) {
	        this.data = data;
	        this.size = data.length;
	        this.type = type;
	        this.encoding = encoding;
	      }
	      , FBB_proto = FakeBlobBuilder.prototype
	      , FB_proto = FakeBlob.prototype
	      , FileReaderSync = view.FileReaderSync
	      , FileException = function(type) {
	        this.code = this[this.name = type];
	      }
	      , file_ex_codes = (
	          "NOT_FOUND_ERR SECURITY_ERR ABORT_ERR NOT_READABLE_ERR ENCODING_ERR "
	        + "NO_MODIFICATION_ALLOWED_ERR INVALID_STATE_ERR SYNTAX_ERR"
	      ).split(" ")
	      , file_ex_code = file_ex_codes.length
	      , real_URL = view.URL || view.webkitURL || view
	      , real_create_object_URL = real_URL.createObjectURL
	      , real_revoke_object_URL = real_URL.revokeObjectURL
	      , URL = real_URL
	      , btoa = view.btoa
	      , atob = view.atob

	      , ArrayBuffer = view.ArrayBuffer
	      , Uint8Array = view.Uint8Array

	      , origin = /^[\w-]+:\/*\[?[\w\.:-]+\]?(?::[0-9]+)?/
	    ;
	    FakeBlob.fake = FB_proto.fake = true;
	    while (file_ex_code--) {
	      FileException.prototype[file_ex_codes[file_ex_code]] = file_ex_code + 1;
	    }
	    // Polyfill URL
	    if (!real_URL.createObjectURL) {
	      URL = view.URL = function(uri) {
	        var
	            uri_info = document.createElementNS("http://www.w3.org/1999/xhtml", "a")
	          , uri_origin
	        ;
	        uri_info.href = uri;
	        if (!("origin" in uri_info)) {
	          if (uri_info.protocol.toLowerCase() === "data:") {
	            uri_info.origin = null;
	          } else {
	            uri_origin = uri.match(origin);
	            uri_info.origin = uri_origin && uri_origin[1];
	          }
	        }
	        return uri_info;
	      };
	    }
	    URL.createObjectURL = function(blob) {
	      var
	          type = blob.type
	        , data_URI_header
	      ;
	      if (type === null) {
	        type = "application/octet-stream";
	      }
	      if (blob instanceof FakeBlob) {
	        data_URI_header = "data:" + type;
	        if (blob.encoding === "base64") {
	          return data_URI_header + ";base64," + blob.data;
	        } else if (blob.encoding === "URI") {
	          return data_URI_header + "," + decodeURIComponent(blob.data);
	        } if (btoa) {
	          return data_URI_header + ";base64," + btoa(blob.data);
	        } else {
	          return data_URI_header + "," + encodeURIComponent(blob.data);
	        }
	      } else if (real_create_object_URL) {
	        return real_create_object_URL.call(real_URL, blob);
	      }
	    };
	    URL.revokeObjectURL = function(object_URL) {
	      if (object_URL.substring(0, 5) !== "data:" && real_revoke_object_URL) {
	        real_revoke_object_URL.call(real_URL, object_URL);
	      }
	    };
	    FBB_proto.append = function(data/*, endings*/) {
	      var bb = this.data;
	      // decode data to a binary string
	      if (Uint8Array && (data instanceof ArrayBuffer || data instanceof Uint8Array)) {
	        var
	            str = ""
	          , buf = new Uint8Array(data)
	          , i = 0
	          , buf_len = buf.length
	        ;
	        for (; i < buf_len; i++) {
	          str += String.fromCharCode(buf[i]);
	        }
	        bb.push(str);
	      } else if (get_class(data) === "Blob" || get_class(data) === "File") {
	        if (FileReaderSync) {
	          var fr = new FileReaderSync;
	          bb.push(fr.readAsBinaryString(data));
	        } else {
	          // async FileReader won't work as BlobBuilder is sync
	          throw new FileException("NOT_READABLE_ERR");
	        }
	      } else if (data instanceof FakeBlob) {
	        if (data.encoding === "base64" && atob) {
	          bb.push(atob(data.data));
	        } else if (data.encoding === "URI") {
	          bb.push(decodeURIComponent(data.data));
	        } else if (data.encoding === "raw") {
	          bb.push(data.data);
	        }
	      } else {
	        if (typeof data !== "string") {
	          data += ""; // convert unsupported types to strings
	        }
	        // decode UTF-16 to binary string
	        bb.push(unescape(encodeURIComponent(data)));
	      }
	    };
	    FBB_proto.getBlob = function(type) {
	      if (!arguments.length) {
	        type = null;
	      }
	      return new FakeBlob(this.data.join(""), type, "raw");
	    };
	    FBB_proto.toString = function() {
	      return "[object BlobBuilder]";
	    };
	    FB_proto.slice = function(start, end, type) {
	      var args = arguments.length;
	      if (args < 3) {
	        type = null;
	      }
	      return new FakeBlob(
	          this.data.slice(start, args > 1 ? end : this.data.length)
	        , type
	        , this.encoding
	      );
	    };
	    FB_proto.toString = function() {
	      return "[object Blob]";
	    };
	    FB_proto.close = function() {
	      this.size = 0;
	      delete this.data;
	    };
	    return FakeBlobBuilder;
	  }(view));

	  view.Blob = function(blobParts, options) {
	    var type = options ? (options.type || "") : "";
	    var builder = new BlobBuilder();
	    if (blobParts) {
	      for (var i = 0, len = blobParts.length; i < len; i++) {
	        if (Uint8Array && blobParts[i] instanceof Uint8Array) {
	          builder.append(blobParts[i].buffer);
	        }
	        else {
	          builder.append(blobParts[i]);
	        }
	      }
	    }
	    var blob = builder.getBlob(type);
	    if (!blob.slice && blob.webkitSlice) {
	      blob.slice = blob.webkitSlice;
	    }
	    return blob;
	  };

	  var getPrototypeOf = Object.getPrototypeOf || function(object) {
	    return object.__proto__;
	  };
	  view.Blob.prototype = getPrototypeOf(new view.Blob());
	}(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this.content || this));

	(function (root, factory) {
	    'use strict';
	    if (true) {
	        module.exports = factory;
	    } else if (typeof define === 'function' && define.amd) {
	        define(function () {
	            return factory;
	        });
	    } else {
	        root.MediumEditor = factory;
	    }
	}(this, function () {

	    'use strict';

	function MediumEditor(elements, options) {
	    'use strict';
	    return this.init(elements, options);
	}

	MediumEditor.extensions = {};
	/*jshint unused: true */
	(function (window) {
	    'use strict';

	    function copyInto(overwrite, dest) {
	        var prop,
	            sources = Array.prototype.slice.call(arguments, 2);
	        dest = dest || {};
	        for (var i = 0; i < sources.length; i++) {
	            var source = sources[i];
	            if (source) {
	                for (prop in source) {
	                    if (source.hasOwnProperty(prop) &&
	                        typeof source[prop] !== 'undefined' &&
	                        (overwrite || dest.hasOwnProperty(prop) === false)) {
	                        dest[prop] = source[prop];
	                    }
	                }
	            }
	        }
	        return dest;
	    }

	    // https://developer.mozilla.org/en-US/docs/Web/API/Node/contains
	    // Some browsers (including phantom) don't return true for Node.contains(child)
	    // if child is a text node.  Detect these cases here and use a fallback
	    // for calls to Util.isDescendant()
	    var nodeContainsWorksWithTextNodes = false;
	    try {
	        var testParent = document.createElement('div'),
	            testText = document.createTextNode(' ');
	        testParent.appendChild(testText);
	        nodeContainsWorksWithTextNodes = testParent.contains(testText);
	    } catch (exc) {}

	    var Util = {

	        // http://stackoverflow.com/questions/17907445/how-to-detect-ie11#comment30165888_17907562
	        // by rg89
	        isIE: ((navigator.appName === 'Microsoft Internet Explorer') || ((navigator.appName === 'Netscape') && (new RegExp('Trident/.*rv:([0-9]{1,}[.0-9]{0,})').exec(navigator.userAgent) !== null))),

	        isEdge: (/Edge\/\d+/).exec(navigator.userAgent) !== null,

	        // if firefox
	        isFF: (navigator.userAgent.toLowerCase().indexOf('firefox') > -1),

	        // http://stackoverflow.com/a/11752084/569101
	        isMac: (window.navigator.platform.toUpperCase().indexOf('MAC') >= 0),

	        // https://github.com/jashkenas/underscore
	        // Lonely letter MUST USE the uppercase code
	        keyCode: {
	            BACKSPACE: 8,
	            TAB: 9,
	            ENTER: 13,
	            ESCAPE: 27,
	            SPACE: 32,
	            DELETE: 46,
	            K: 75, // K keycode, and not k
	            M: 77,
	            V: 86
	        },

	        /**
	         * Returns true if it's metaKey on Mac, or ctrlKey on non-Mac.
	         * See #591
	         */
	        isMetaCtrlKey: function (event) {
	            if ((Util.isMac && event.metaKey) || (!Util.isMac && event.ctrlKey)) {
	                return true;
	            }

	            return false;
	        },

	        /**
	         * Returns true if the key associated to the event is inside keys array
	         *
	         * @see : https://github.com/jquery/jquery/blob/0705be475092aede1eddae01319ec931fb9c65fc/src/event.js#L473-L484
	         * @see : http://stackoverflow.com/q/4471582/569101
	         */
	        isKey: function (event, keys) {
	            var keyCode = Util.getKeyCode(event);

	            // it's not an array let's just compare strings!
	            if (false === Array.isArray(keys)) {
	                return keyCode === keys;
	            }

	            if (-1 === keys.indexOf(keyCode)) {
	                return false;
	            }

	            return true;
	        },

	        getKeyCode: function (event) {
	            var keyCode = event.which;

	            // getting the key code from event
	            if (null === keyCode) {
	                keyCode = event.charCode !== null ? event.charCode : event.keyCode;
	            }

	            return keyCode;
	        },

	        blockContainerElementNames: [
	            // elements our editor generates
	            'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote', 'pre', 'ul', 'li', 'ol',
	            // all other known block elements
	            'address', 'article', 'aside', 'audio', 'canvas', 'dd', 'dl', 'dt', 'fieldset',
	            'figcaption', 'figure', 'footer', 'form', 'header', 'hgroup', 'main', 'nav',
	            'noscript', 'output', 'section', 'video',
	            'table', 'thead', 'tbody', 'tfoot', 'tr', 'th', 'td'
	        ],

	        emptyElementNames: ['br', 'col', 'colgroup', 'hr', 'img', 'input', 'source', 'wbr'],

	        extend: function extend(/* dest, source1, source2, ...*/) {
	            var args = [true].concat(Array.prototype.slice.call(arguments));
	            return copyInto.apply(this, args);
	        },

	        defaults: function defaults(/*dest, source1, source2, ...*/) {
	            var args = [false].concat(Array.prototype.slice.call(arguments));
	            return copyInto.apply(this, args);
	        },

	        /*
	         * Create a link around the provided text nodes which must be adjacent to each other and all be
	         * descendants of the same closest block container. If the preconditions are not met, unexpected
	         * behavior will result.
	         */
	        createLink: function (document, textNodes, href, target) {
	            var anchor = document.createElement('a');
	            Util.moveTextRangeIntoElement(textNodes[0], textNodes[textNodes.length - 1], anchor);
	            anchor.setAttribute('href', href);
	            if (target) {
	                anchor.setAttribute('target', target);
	            }
	            return anchor;
	        },

	        /*
	         * Given the provided match in the format {start: 1, end: 2} where start and end are indices into the
	         * textContent of the provided element argument, modify the DOM inside element to ensure that the text
	         * identified by the provided match can be returned as text nodes that contain exactly that text, without
	         * any additional text at the beginning or end of the returned array of adjacent text nodes.
	         *
	         * The only DOM manipulation performed by this function is splitting the text nodes, non-text nodes are
	         * not affected in any way.
	         */
	        findOrCreateMatchingTextNodes: function (document, element, match) {
	            var treeWalker = document.createTreeWalker(element, NodeFilter.SHOW_ALL, null, false),
	                matchedNodes = [],
	                currentTextIndex = 0,
	                startReached = false,
	                currentNode = null,
	                newNode = null;

	            while ((currentNode = treeWalker.nextNode()) !== null) {
	                if (currentNode.nodeType > 3) {
	                    continue;
	                } else if (currentNode.nodeType === 3) {
	                    if (!startReached && match.start < (currentTextIndex + currentNode.nodeValue.length)) {
	                        startReached = true;
	                        newNode = Util.splitStartNodeIfNeeded(currentNode, match.start, currentTextIndex);
	                    }
	                    if (startReached) {
	                        Util.splitEndNodeIfNeeded(currentNode, newNode, match.end, currentTextIndex);
	                    }
	                    if (startReached && currentTextIndex === match.end) {
	                        break; // Found the node(s) corresponding to the link. Break out and move on to the next.
	                    } else if (startReached && currentTextIndex > (match.end + 1)) {
	                        throw new Error('PerformLinking overshot the target!'); // should never happen...
	                    }

	                    if (startReached) {
	                        matchedNodes.push(newNode || currentNode);
	                    }

	                    currentTextIndex += currentNode.nodeValue.length;
	                    if (newNode !== null) {
	                        currentTextIndex += newNode.nodeValue.length;
	                        // Skip the newNode as we'll already have pushed it to the matches
	                        treeWalker.nextNode();
	                    }
	                    newNode = null;
	                } else if (currentNode.tagName.toLowerCase() === 'img') {
	                    if (!startReached && (match.start <= currentTextIndex)) {
	                        startReached = true;
	                    }
	                    if (startReached) {
	                        matchedNodes.push(currentNode);
	                    }
	                }
	            }
	            return matchedNodes;
	        },

	        /*
	         * Given the provided text node and text coordinates, split the text node if needed to make it align
	         * precisely with the coordinates.
	         *
	         * This function is intended to be called from Util.findOrCreateMatchingTextNodes.
	         */
	        splitStartNodeIfNeeded: function (currentNode, matchStartIndex, currentTextIndex) {
	            if (matchStartIndex !== currentTextIndex) {
	                return currentNode.splitText(matchStartIndex - currentTextIndex);
	            }
	            return null;
	        },

	        /*
	         * Given the provided text node and text coordinates, split the text node if needed to make it align
	         * precisely with the coordinates. The newNode argument should from the result of Util.splitStartNodeIfNeeded,
	         * if that function has been called on the same currentNode.
	         *
	         * This function is intended to be called from Util.findOrCreateMatchingTextNodes.
	         */
	        splitEndNodeIfNeeded: function (currentNode, newNode, matchEndIndex, currentTextIndex) {
	            var textIndexOfEndOfFarthestNode,
	                endSplitPoint;
	            textIndexOfEndOfFarthestNode = currentTextIndex + (newNode || currentNode).nodeValue.length +
	                    (newNode ? currentNode.nodeValue.length : 0) -
	                    1;
	            endSplitPoint = (newNode || currentNode).nodeValue.length -
	                    (textIndexOfEndOfFarthestNode + 1 - matchEndIndex);
	            if (textIndexOfEndOfFarthestNode >= matchEndIndex &&
	                    currentTextIndex !== textIndexOfEndOfFarthestNode &&
	                    endSplitPoint !== 0) {
	                (newNode || currentNode).splitText(endSplitPoint);
	            }
	        },

	        /*
	        * Take an element, and break up all of its text content into unique pieces such that:
	         * 1) All text content of the elements are in separate blocks. No piece of text content should span
	         *    across multiple blocks. This means no element return by this function should have
	         *    any blocks as children.
	         * 2) The union of the textcontent of all of the elements returned here covers all
	         *    of the text within the element.
	         *
	         *
	         * EXAMPLE:
	         * In the event that we have something like:
	         *
	         * <blockquote>
	         *   <p>Some Text</p>
	         *   <ol>
	         *     <li>List Item 1</li>
	         *     <li>List Item 2</li>
	         *   </ol>
	         * </blockquote>
	         *
	         * This function would return these elements as an array:
	         *   [ <p>Some Text</p>, <li>List Item 1</li>, <li>List Item 2</li> ]
	         *
	         * Since the <blockquote> and <ol> elements contain blocks within them they are not returned.
	         * Since the <p> and <li>'s don't contain block elements and cover all the text content of the
	         * <blockquote> container, they are the elements returned.
	         */
	        splitByBlockElements: function (element) {
	            if (element.nodeType !== 3 && element.nodeType !== 1) {
	                return [];
	            }

	            var toRet = [],
	                blockElementQuery = MediumEditor.util.blockContainerElementNames.join(',');

	            if (element.nodeType === 3 || element.querySelectorAll(blockElementQuery).length === 0) {
	                return [element];
	            }

	            for (var i = 0; i < element.childNodes.length; i++) {
	                var child = element.childNodes[i];
	                if (child.nodeType === 3) {
	                    toRet.push(child);
	                } else if (child.nodeType === 1) {
	                    var blockElements = child.querySelectorAll(blockElementQuery);
	                    if (blockElements.length === 0) {
	                        toRet.push(child);
	                    } else {
	                        toRet = toRet.concat(MediumEditor.util.splitByBlockElements(child));
	                    }
	                }
	            }

	            return toRet;
	        },

	        // Find the next node in the DOM tree that represents any text that is being
	        // displayed directly next to the targetNode (passed as an argument)
	        // Text that appears directly next to the current node can be:
	        //  - A sibling text node
	        //  - A descendant of a sibling element
	        //  - A sibling text node of an ancestor
	        //  - A descendant of a sibling element of an ancestor
	        findAdjacentTextNodeWithContent: function findAdjacentTextNodeWithContent(rootNode, targetNode, ownerDocument) {
	            var pastTarget = false,
	                nextNode,
	                nodeIterator = ownerDocument.createNodeIterator(rootNode, NodeFilter.SHOW_TEXT, null, false);

	            // Use a native NodeIterator to iterate over all the text nodes that are descendants
	            // of the rootNode.  Once past the targetNode, choose the first non-empty text node
	            nextNode = nodeIterator.nextNode();
	            while (nextNode) {
	                if (nextNode === targetNode) {
	                    pastTarget = true;
	                } else if (pastTarget) {
	                    if (nextNode.nodeType === 3 && nextNode.nodeValue && nextNode.nodeValue.trim().length > 0) {
	                        break;
	                    }
	                }
	                nextNode = nodeIterator.nextNode();
	            }

	            return nextNode;
	        },

	        // Find an element's previous sibling within a medium-editor element
	        // If one doesn't exist, find the closest ancestor's previous sibling
	        findPreviousSibling: function (node) {
	            if (!node || Util.isMediumEditorElement(node)) {
	                return false;
	            }

	            var previousSibling = node.previousSibling;
	            while (!previousSibling && !Util.isMediumEditorElement(node.parentNode)) {
	                node = node.parentNode;
	                previousSibling = node.previousSibling;
	            }

	            return previousSibling;
	        },

	        isDescendant: function isDescendant(parent, child, checkEquality) {
	            if (!parent || !child) {
	                return false;
	            }
	            if (parent === child) {
	                return !!checkEquality;
	            }
	            // If parent is not an element, it can't have any descendants
	            if (parent.nodeType !== 1) {
	                return false;
	            }
	            if (nodeContainsWorksWithTextNodes || child.nodeType !== 3) {
	                return parent.contains(child);
	            }
	            var node = child.parentNode;
	            while (node !== null) {
	                if (node === parent) {
	                    return true;
	                }
	                node = node.parentNode;
	            }
	            return false;
	        },

	        // https://github.com/jashkenas/underscore
	        isElement: function isElement(obj) {
	            return !!(obj && obj.nodeType === 1);
	        },

	        // https://github.com/jashkenas/underscore
	        throttle: function (func, wait) {
	            var THROTTLE_INTERVAL = 50,
	                context,
	                args,
	                result,
	                timeout = null,
	                previous = 0,
	                later = function () {
	                    previous = Date.now();
	                    timeout = null;
	                    result = func.apply(context, args);
	                    if (!timeout) {
	                        context = args = null;
	                    }
	                };

	            if (!wait && wait !== 0) {
	                wait = THROTTLE_INTERVAL;
	            }

	            return function () {
	                var now = Date.now(),
	                    remaining = wait - (now - previous);

	                context = this;
	                args = arguments;
	                if (remaining <= 0 || remaining > wait) {
	                    if (timeout) {
	                        clearTimeout(timeout);
	                        timeout = null;
	                    }
	                    previous = now;
	                    result = func.apply(context, args);
	                    if (!timeout) {
	                        context = args = null;
	                    }
	                } else if (!timeout) {
	                    timeout = setTimeout(later, remaining);
	                }
	                return result;
	            };
	        },

	        traverseUp: function (current, testElementFunction) {
	            if (!current) {
	                return false;
	            }

	            do {
	                if (current.nodeType === 1) {
	                    if (testElementFunction(current)) {
	                        return current;
	                    }
	                    // do not traverse upwards past the nearest containing editor
	                    if (Util.isMediumEditorElement(current)) {
	                        return false;
	                    }
	                }

	                current = current.parentNode;
	            } while (current);

	            return false;
	        },

	        htmlEntities: function (str) {
	            // converts special characters (like <) into their escaped/encoded values (like &lt;).
	            // This allows you to show to display the string without the browser reading it as HTML.
	            return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
	        },

	        // http://stackoverflow.com/questions/6690752/insert-html-at-caret-in-a-contenteditable-div
	        insertHTMLCommand: function (doc, html) {
	            var selection, range, el, fragment, node, lastNode, toReplace,
	                res = false,
	                ecArgs = ['insertHTML', false, html];

	            /* Edge's implementation of insertHTML is just buggy right now:
	             * - Doesn't allow leading white space at the beginning of an element
	             * - Found a case when a <font size="2"> tag was inserted when calling alignCenter inside a blockquote
	             *
	             * There are likely other bugs, these are just the ones we found so far.
	             * For now, let's just use the same fallback we did for IE
	             */
	            if (!MediumEditor.util.isEdge && doc.queryCommandSupported('insertHTML')) {
	                try {
	                    return doc.execCommand.apply(doc, ecArgs);
	                } catch (ignore) {}
	            }

	            selection = doc.getSelection();
	            if (selection.rangeCount) {
	                range = selection.getRangeAt(0);
	                toReplace = range.commonAncestorContainer;

	                // https://github.com/yabwe/medium-editor/issues/748
	                // If the selection is an empty editor element, create a temporary text node inside of the editor
	                // and select it so that we don't delete the editor element
	                if (Util.isMediumEditorElement(toReplace) && !toReplace.firstChild) {
	                    range.selectNode(toReplace.appendChild(doc.createTextNode('')));
	                } else if ((toReplace.nodeType === 3 && range.startOffset === 0 && range.endOffset === toReplace.nodeValue.length) ||
	                        (toReplace.nodeType !== 3 && toReplace.innerHTML === range.toString())) {
	                    // Ensure range covers maximum amount of nodes as possible
	                    // By moving up the DOM and selecting ancestors whose only child is the range
	                    while (!Util.isMediumEditorElement(toReplace) &&
	                            toReplace.parentNode &&
	                            toReplace.parentNode.childNodes.length === 1 &&
	                            !Util.isMediumEditorElement(toReplace.parentNode)) {
	                        toReplace = toReplace.parentNode;
	                    }
	                    range.selectNode(toReplace);
	                }
	                range.deleteContents();

	                el = doc.createElement('div');
	                el.innerHTML = html;
	                fragment = doc.createDocumentFragment();
	                while (el.firstChild) {
	                    node = el.firstChild;
	                    lastNode = fragment.appendChild(node);
	                }
	                range.insertNode(fragment);

	                // Preserve the selection:
	                if (lastNode) {
	                    range = range.cloneRange();
	                    range.setStartAfter(lastNode);
	                    range.collapse(true);
	                    MediumEditor.selection.selectRange(doc, range);
	                }
	                res = true;
	            }

	            // https://github.com/yabwe/medium-editor/issues/992
	            // If we're monitoring calls to execCommand, notify listeners as if a real call had happened
	            if (doc.execCommand.callListeners) {
	                doc.execCommand.callListeners(ecArgs, res);
	            }
	            return res;
	        },

	        execFormatBlock: function (doc, tagName) {
	            // Get the top level block element that contains the selection
	            var blockContainer = Util.getTopBlockContainer(MediumEditor.selection.getSelectionStart(doc)),
	                childNodes;

	            // Special handling for blockquote
	            if (tagName === 'blockquote') {
	                if (blockContainer) {
	                    childNodes = Array.prototype.slice.call(blockContainer.childNodes);
	                    // Check if the blockquote has a block element as a child (nested blocks)
	                    if (childNodes.some(function (childNode) {
	                        return Util.isBlockContainer(childNode);
	                    })) {
	                        // FF handles blockquote differently on formatBlock
	                        // allowing nesting, we need to use outdent
	                        // https://developer.mozilla.org/en-US/docs/Rich-Text_Editing_in_Mozilla
	                        return doc.execCommand('outdent', false, null);
	                    }
	                }

	                // When IE blockquote needs to be called as indent
	                // http://stackoverflow.com/questions/1816223/rich-text-editor-with-blockquote-function/1821777#1821777
	                if (Util.isIE) {
	                    return doc.execCommand('indent', false, tagName);
	                }
	            }

	            // If the blockContainer is already the element type being passed in
	            // treat it as 'undo' formatting and just convert it to a <p>
	            if (blockContainer && tagName === blockContainer.nodeName.toLowerCase()) {
	                tagName = 'p';
	            }

	            // When IE we need to add <> to heading elements
	            // http://stackoverflow.com/questions/10741831/execcommand-formatblock-headings-in-ie
	            if (Util.isIE) {
	                tagName = '<' + tagName + '>';
	            }

	            // When FF, IE and Edge, we have to handle blockquote node seperately as 'formatblock' does not work.
	            // https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand#Commands
	            if (blockContainer && blockContainer.nodeName.toLowerCase() === 'blockquote') {
	                // For IE, just use outdent
	                if (Util.isIE && tagName === '<p>') {
	                    return doc.execCommand('outdent', false, tagName);
	                }

	                // For Firefox and Edge, make sure there's a nested block element before calling outdent
	                if ((Util.isFF || Util.isEdge) && tagName === 'p') {
	                    childNodes = Array.prototype.slice.call(blockContainer.childNodes);
	                    // If there are some non-block elements we need to wrap everything in a <p> before we outdent
	                    if (childNodes.some(function (childNode) {
	                        return !Util.isBlockContainer(childNode);
	                    })) {
	                        doc.execCommand('formatBlock', false, tagName);
	                    }
	                    return doc.execCommand('outdent', false, tagName);
	                }
	            }

	            return doc.execCommand('formatBlock', false, tagName);
	        },

	        /**
	         * Set target to blank on the given el element
	         *
	         * TODO: not sure if this should be here
	         *
	         * When creating a link (using core -> createLink) the selection returned by Firefox will be the parent of the created link
	         * instead of the created link itself (as it is for Chrome for example), so we retrieve all "a" children to grab the good one by
	         * using `anchorUrl` to ensure that we are adding target="_blank" on the good one.
	         * This isn't a bulletproof solution anyway ..
	         */
	        setTargetBlank: function (el, anchorUrl) {
	            var i, url = anchorUrl || false;
	            if (el.nodeName.toLowerCase() === 'a') {
	                el.target = '_blank';
	            } else {
	                el = el.getElementsByTagName('a');

	                for (i = 0; i < el.length; i += 1) {
	                    if (false === url || url === el[i].attributes.href.value) {
	                        el[i].target = '_blank';
	                    }
	                }
	            }
	        },

	        /*
	         * this function is called to explicitly remove the target='_blank' as FF holds on to _blank value even
	         * after unchecking the checkbox on anchor form
	         */
	        removeTargetBlank: function (el, anchorUrl) {
	            var i;
	            if (el.nodeName.toLowerCase() === 'a') {
	                el.removeAttribute('target');
	            } else {
	                el = el.getElementsByTagName('a');

	                for (i = 0; i < el.length; i += 1) {
	                    if (anchorUrl === el[i].attributes.href.value) {
	                        el[i].removeAttribute('target');
	                    }
	                }
	            }
	        },

	        addClassToAnchors: function (el, buttonClass) {
	            var classes = buttonClass.split(' '),
	                i,
	                j;
	            if (el.nodeName.toLowerCase() === 'a') {
	                for (j = 0; j < classes.length; j += 1) {
	                    el.classList.add(classes[j]);
	                }
	            } else {
	                el = el.getElementsByTagName('a');
	                for (i = 0; i < el.length; i += 1) {
	                    for (j = 0; j < classes.length; j += 1) {
	                        el[i].classList.add(classes[j]);
	                    }
	                }
	            }
	        },

	        isListItem: function (node) {
	            if (!node) {
	                return false;
	            }
	            if (node.nodeName.toLowerCase() === 'li') {
	                return true;
	            }

	            var parentNode = node.parentNode,
	                tagName = parentNode.nodeName.toLowerCase();
	            while (tagName === 'li' || (!Util.isBlockContainer(parentNode) && tagName !== 'div')) {
	                if (tagName === 'li') {
	                    return true;
	                }
	                parentNode = parentNode.parentNode;
	                if (parentNode) {
	                    tagName = parentNode.nodeName.toLowerCase();
	                } else {
	                    return false;
	                }
	            }
	            return false;
	        },

	        cleanListDOM: function (ownerDocument, element) {
	            if (element.nodeName.toLowerCase() !== 'li') {
	                return;
	            }

	            var list = element.parentElement;

	            if (list.parentElement.nodeName.toLowerCase() === 'p') { // yes we need to clean up
	                Util.unwrap(list.parentElement, ownerDocument);

	                // move cursor at the end of the text inside the list
	                // for some unknown reason, the cursor is moved to end of the "visual" line
	                MediumEditor.selection.moveCursor(ownerDocument, element.firstChild, element.firstChild.textContent.length);
	            }
	        },

	        /* splitDOMTree
	         *
	         * Given a root element some descendant element, split the root element
	         * into its own element containing the descendant element and all elements
	         * on the left or right side of the descendant ('right' is default)
	         *
	         * example:
	         *
	         *         <div>
	         *      /    |   \
	         *  <span> <span> <span>
	         *   / \    / \    / \
	         *  1   2  3   4  5   6
	         *
	         *  If I wanted to split this tree given the <div> as the root and "4" as the leaf
	         *  the result would be (the prime ' marks indicates nodes that are created as clones):
	         *
	         *   SPLITTING OFF 'RIGHT' TREE       SPLITTING OFF 'LEFT' TREE
	         *
	         *     <div>            <div>'              <div>'      <div>
	         *      / \              / \                 / \          |
	         * <span> <span>   <span>' <span>       <span> <span>   <span>
	         *   / \    |        |      / \           /\     /\       /\
	         *  1   2   3        4     5   6         1  2   3  4     5  6
	         *
	         *  The above example represents splitting off the 'right' or 'left' part of a tree, where
	         *  the <div>' would be returned as an element not appended to the DOM, and the <div>
	         *  would remain in place where it was
	         *
	        */
	        splitOffDOMTree: function (rootNode, leafNode, splitLeft) {
	            var splitOnNode = leafNode,
	                createdNode = null,
	                splitRight = !splitLeft;

	            // loop until we hit the root
	            while (splitOnNode !== rootNode) {
	                var currParent = splitOnNode.parentNode,
	                    newParent = currParent.cloneNode(false),
	                    targetNode = (splitRight ? splitOnNode : currParent.firstChild),
	                    appendLast;

	                // Create a new parent element which is a clone of the current parent
	                if (createdNode) {
	                    if (splitRight) {
	                        // If we're splitting right, add previous created element before siblings
	                        newParent.appendChild(createdNode);
	                    } else {
	                        // If we're splitting left, add previous created element last
	                        appendLast = createdNode;
	                    }
	                }
	                createdNode = newParent;

	                while (targetNode) {
	                    var sibling = targetNode.nextSibling;
	                    // Special handling for the 'splitNode'
	                    if (targetNode === splitOnNode) {
	                        if (!targetNode.hasChildNodes()) {
	                            targetNode.parentNode.removeChild(targetNode);
	                        } else {
	                            // For the node we're splitting on, if it has children, we need to clone it
	                            // and not just move it
	                            targetNode = targetNode.cloneNode(false);
	                        }
	                        // If the resulting split node has content, add it
	                        if (targetNode.textContent) {
	                            createdNode.appendChild(targetNode);
	                        }

	                        targetNode = (splitRight ? sibling : null);
	                    } else {
	                        // For general case, just remove the element and only
	                        // add it to the split tree if it contains something
	                        targetNode.parentNode.removeChild(targetNode);
	                        if (targetNode.hasChildNodes() || targetNode.textContent) {
	                            createdNode.appendChild(targetNode);
	                        }

	                        targetNode = sibling;
	                    }
	                }

	                // If we had an element we wanted to append at the end, do that now
	                if (appendLast) {
	                    createdNode.appendChild(appendLast);
	                }

	                splitOnNode = currParent;
	            }

	            return createdNode;
	        },

	        moveTextRangeIntoElement: function (startNode, endNode, newElement) {
	            if (!startNode || !endNode) {
	                return false;
	            }

	            var rootNode = Util.findCommonRoot(startNode, endNode);
	            if (!rootNode) {
	                return false;
	            }

	            if (endNode === startNode) {
	                var temp = startNode.parentNode,
	                    sibling = startNode.nextSibling;
	                temp.removeChild(startNode);
	                newElement.appendChild(startNode);
	                if (sibling) {
	                    temp.insertBefore(newElement, sibling);
	                } else {
	                    temp.appendChild(newElement);
	                }
	                return newElement.hasChildNodes();
	            }

	            // create rootChildren array which includes all the children
	            // we care about
	            var rootChildren = [],
	                firstChild,
	                lastChild,
	                nextNode;
	            for (var i = 0; i < rootNode.childNodes.length; i++) {
	                nextNode = rootNode.childNodes[i];
	                if (!firstChild) {
	                    if (Util.isDescendant(nextNode, startNode, true)) {
	                        firstChild = nextNode;
	                    }
	                } else {
	                    if (Util.isDescendant(nextNode, endNode, true)) {
	                        lastChild = nextNode;
	                        break;
	                    } else {
	                        rootChildren.push(nextNode);
	                    }
	                }
	            }

	            var afterLast = lastChild.nextSibling,
	                fragment = rootNode.ownerDocument.createDocumentFragment();

	            // build up fragment on startNode side of tree
	            if (firstChild === startNode) {
	                firstChild.parentNode.removeChild(firstChild);
	                fragment.appendChild(firstChild);
	            } else {
	                fragment.appendChild(Util.splitOffDOMTree(firstChild, startNode));
	            }

	            // add any elements between firstChild & lastChild
	            rootChildren.forEach(function (element) {
	                element.parentNode.removeChild(element);
	                fragment.appendChild(element);
	            });

	            // build up fragment on endNode side of the tree
	            if (lastChild === endNode) {
	                lastChild.parentNode.removeChild(lastChild);
	                fragment.appendChild(lastChild);
	            } else {
	                fragment.appendChild(Util.splitOffDOMTree(lastChild, endNode, true));
	            }

	            // Add fragment into passed in element
	            newElement.appendChild(fragment);

	            if (lastChild.parentNode === rootNode) {
	                // If last child is in the root, insert newElement in front of it
	                rootNode.insertBefore(newElement, lastChild);
	            } else if (afterLast) {
	                // If last child was removed, but it had a sibling, insert in front of it
	                rootNode.insertBefore(newElement, afterLast);
	            } else {
	                // lastChild was removed and was the last actual element just append
	                rootNode.appendChild(newElement);
	            }

	            return newElement.hasChildNodes();
	        },

	        /* based on http://stackoverflow.com/a/6183069 */
	        depthOfNode: function (inNode) {
	            var theDepth = 0,
	                node = inNode;
	            while (node.parentNode !== null) {
	                node = node.parentNode;
	                theDepth++;
	            }
	            return theDepth;
	        },

	        findCommonRoot: function (inNode1, inNode2) {
	            var depth1 = Util.depthOfNode(inNode1),
	                depth2 = Util.depthOfNode(inNode2),
	                node1 = inNode1,
	                node2 = inNode2;

	            while (depth1 !== depth2) {
	                if (depth1 > depth2) {
	                    node1 = node1.parentNode;
	                    depth1 -= 1;
	                } else {
	                    node2 = node2.parentNode;
	                    depth2 -= 1;
	                }
	            }

	            while (node1 !== node2) {
	                node1 = node1.parentNode;
	                node2 = node2.parentNode;
	            }

	            return node1;
	        },
	        /* END - based on http://stackoverflow.com/a/6183069 */

	        isElementAtBeginningOfBlock: function (node) {
	            var textVal,
	                sibling;
	            while (!Util.isBlockContainer(node) && !Util.isMediumEditorElement(node)) {
	                sibling = node;
	                while (sibling = sibling.previousSibling) {
	                    textVal = sibling.nodeType === 3 ? sibling.nodeValue : sibling.textContent;
	                    if (textVal.length > 0) {
	                        return false;
	                    }
	                }
	                node = node.parentNode;
	            }
	            return true;
	        },

	        isMediumEditorElement: function (element) {
	            return element && element.getAttribute && !!element.getAttribute('data-medium-editor-element');
	        },

	        getContainerEditorElement: function (element) {
	            return Util.traverseUp(element, function (node) {
	                return Util.isMediumEditorElement(node);
	            });
	        },

	        isBlockContainer: function (element) {
	            return element && element.nodeType !== 3 && Util.blockContainerElementNames.indexOf(element.nodeName.toLowerCase()) !== -1;
	        },

	        /* Finds the closest ancestor which is a block container element
	         * If element is within editor element but not within any other block element,
	         * the editor element is returned
	         */
	        getClosestBlockContainer: function (node) {
	            return Util.traverseUp(node, function (node) {
	                return Util.isBlockContainer(node) || Util.isMediumEditorElement(node);
	            });
	        },

	        /* Finds highest level ancestor element which is a block container element
	         * If element is within editor element but not within any other block element,
	         * the editor element is returned
	         */
	        getTopBlockContainer: function (element) {
	            var topBlock = Util.isBlockContainer(element) ? element : false;
	            Util.traverseUp(element, function (el) {
	                if (Util.isBlockContainer(el)) {
	                    topBlock = el;
	                }
	                if (!topBlock && Util.isMediumEditorElement(el)) {
	                    topBlock = el;
	                    return true;
	                }
	                return false;
	            });
	            return topBlock;
	        },

	        getFirstSelectableLeafNode: function (element) {
	            while (element && element.firstChild) {
	                element = element.firstChild;
	            }

	            // We don't want to set the selection to an element that can't have children, this messes up Gecko.
	            element = Util.traverseUp(element, function (el) {
	                return Util.emptyElementNames.indexOf(el.nodeName.toLowerCase()) === -1;
	            });
	            // Selecting at the beginning of a table doesn't work in PhantomJS.
	            if (element.nodeName.toLowerCase() === 'table') {
	                var firstCell = element.querySelector('th, td');
	                if (firstCell) {
	                    element = firstCell;
	                }
	            }
	            return element;
	        },

	        // TODO: remove getFirstTextNode AND _getFirstTextNode when jumping in 6.0.0 (no code references)
	        getFirstTextNode: function (element) {
	            Util.warn('getFirstTextNode is deprecated and will be removed in version 6.0.0');
	            return Util._getFirstTextNode(element);
	        },

	        _getFirstTextNode: function (element) {
	            if (element.nodeType === 3) {
	                return element;
	            }

	            for (var i = 0; i < element.childNodes.length; i++) {
	                var textNode = Util._getFirstTextNode(element.childNodes[i]);
	                if (textNode !== null) {
	                    return textNode;
	                }
	            }
	            return null;
	        },

	        ensureUrlHasProtocol: function (url) {
	            if (url.indexOf('://') === -1) {
	                return 'http://' + url;
	            }
	            return url;
	        },

	        warn: function () {
	            if (window.console !== undefined && typeof window.console.warn === 'function') {
	                window.console.warn.apply(window.console, arguments);
	            }
	        },

	        deprecated: function (oldName, newName, version) {
	            // simple deprecation warning mechanism.
	            var m = oldName + ' is deprecated, please use ' + newName + ' instead.';
	            if (version) {
	                m += ' Will be removed in ' + version;
	            }
	            Util.warn(m);
	        },

	        deprecatedMethod: function (oldName, newName, args, version) {
	            // run the replacement and warn when someone calls a deprecated method
	            Util.deprecated(oldName, newName, version);
	            if (typeof this[newName] === 'function') {
	                this[newName].apply(this, args);
	            }
	        },

	        cleanupAttrs: function (el, attrs) {
	            attrs.forEach(function (attr) {
	                el.removeAttribute(attr);
	            });
	        },

	        cleanupTags: function (el, tags) {
	            tags.forEach(function (tag) {
	                if (el.nodeName.toLowerCase() === tag) {
	                    el.parentNode.removeChild(el);
	                }
	            });
	        },

	        // get the closest parent
	        getClosestTag: function (el, tag) {
	            return Util.traverseUp(el, function (element) {
	                return element.nodeName.toLowerCase() === tag.toLowerCase();
	            });
	        },

	        unwrap: function (el, doc) {
	            var fragment = doc.createDocumentFragment(),
	                nodes = Array.prototype.slice.call(el.childNodes);

	            // cast nodeList to array since appending child
	            // to a different node will alter length of el.childNodes
	            for (var i = 0; i < nodes.length; i++) {
	                fragment.appendChild(nodes[i]);
	            }

	            if (fragment.childNodes.length) {
	                el.parentNode.replaceChild(fragment, el);
	            } else {
	                el.parentNode.removeChild(el);
	            }
	        },

	        guid: function () {
	            function _s4() {
	                return Math
	                    .floor((1 + Math.random()) * 0x10000)
	                    .toString(16)
	                    .substring(1);
	            }

	            return _s4() + _s4() + '-' + _s4() + '-' + _s4() + '-' + _s4() + '-' + _s4() + _s4() + _s4();
	        }
	    };

	    MediumEditor.util = Util;
	}(window));

	(function () {
	    'use strict';

	    var Extension = function (options) {
	        MediumEditor.util.extend(this, options);
	    };

	    Extension.extend = function (protoProps) {
	        // magic extender thinger. mostly borrowed from backbone/goog.inherits
	        // place this function on some thing you want extend-able.
	        //
	        // example:
	        //
	        //      function Thing(args){
	        //          this.options = args;
	        //      }
	        //
	        //      Thing.prototype = { foo: "bar" };
	        //      Thing.extend = extenderify;
	        //
	        //      var ThingTwo = Thing.extend({ foo: "baz" });
	        //
	        //      var thingOne = new Thing(); // foo === "bar"
	        //      var thingTwo = new ThingTwo(); // foo === "baz"
	        //
	        //      which seems like some simply shallow copy nonsense
	        //      at first, but a lot more is going on there.
	        //
	        //      passing a `constructor` to the extend props
	        //      will cause the instance to instantiate through that
	        //      instead of the parent's constructor.

	        var parent = this,
	            child;

	        // The constructor function for the new subclass is either defined by you
	        // (the "constructor" property in your `extend` definition), or defaulted
	        // by us to simply call the parent's constructor.

	        if (protoProps && protoProps.hasOwnProperty('constructor')) {
	            child = protoProps.constructor;
	        } else {
	            child = function () {
	                return parent.apply(this, arguments);
	            };
	        }

	        // das statics (.extend comes over, so your subclass can have subclasses too)
	        MediumEditor.util.extend(child, parent);

	        // Set the prototype chain to inherit from `parent`, without calling
	        // `parent`'s constructor function.
	        var Surrogate = function () {
	            this.constructor = child;
	        };
	        Surrogate.prototype = parent.prototype;
	        child.prototype = new Surrogate();

	        if (protoProps) {
	            MediumEditor.util.extend(child.prototype, protoProps);
	        }

	        // todo: $super?

	        return child;
	    };

	    Extension.prototype = {
	        /* init: [function]
	         *
	         * Called by MediumEditor during initialization.
	         * The .base property will already have been set to
	         * current instance of MediumEditor when this is called.
	         * All helper methods will exist as well
	         */
	        init: function () {},

	        /* base: [MediumEditor instance]
	         *
	         * If not overriden, this will be set to the current instance
	         * of MediumEditor, before the init method is called
	         */
	        base: undefined,

	        /* name: [string]
	         *
	         * 'name' of the extension, used for retrieving the extension.
	         * If not set, MediumEditor will set this to be the key
	         * used when passing the extension into MediumEditor via the
	         * 'extensions' option
	         */
	        name: undefined,

	        /* checkState: [function (node)]
	         *
	         * If implemented, this function will be called one or more times
	         * the state of the editor & toolbar are updated.
	         * When the state is updated, the editor does the following:
	         *
	         * 1) Find the parent node containing the current selection
	         * 2) Call checkState on the extension, passing the node as an argument
	         * 3) Get the parent node of the previous node
	         * 4) Repeat steps #2 and #3 until we move outside the parent contenteditable
	         */
	        checkState: undefined,

	        /* destroy: [function ()]
	         *
	         * This method should remove any created html, custom event handlers
	         * or any other cleanup tasks that should be performed.
	         * If implemented, this function will be called when MediumEditor's
	         * destroy method has been called.
	         */
	        destroy: undefined,

	        /* As alternatives to checkState, these functions provide a more structured
	         * path to updating the state of an extension (usually a button) whenever
	         * the state of the editor & toolbar are updated.
	         */

	        /* queryCommandState: [function ()]
	         *
	         * If implemented, this function will be called once on each extension
	         * when the state of the editor/toolbar is being updated.
	         *
	         * If this function returns a non-null value, the extension will
	         * be ignored as the code climbs the dom tree.
	         *
	         * If this function returns true, and the setActive() function is defined
	         * setActive() will be called
	         */
	        queryCommandState: undefined,

	        /* isActive: [function ()]
	         *
	         * If implemented, this function will be called when MediumEditor
	         * has determined that this extension is 'active' for the current selection.
	         * This may be called when the editor & toolbar are being updated,
	         * but only if queryCommandState() or isAlreadyApplied() functions
	         * are implemented, and when called, return true.
	         */
	        isActive: undefined,

	        /* isAlreadyApplied: [function (node)]
	         *
	         * If implemented, this function is similar to checkState() in
	         * that it will be called repeatedly as MediumEditor moves up
	         * the DOM to update the editor & toolbar after a state change.
	         *
	         * NOTE: This function will NOT be called if checkState() has
	         * been implemented. This function will NOT be called if
	         * queryCommandState() is implemented and returns a non-null
	         * value when called
	         */
	        isAlreadyApplied: undefined,

	        /* setActive: [function ()]
	         *
	         * If implemented, this function is called when MediumEditor knows
	         * that this extension is currently enabled.  Currently, this
	         * function is called when updating the editor & toolbar, and
	         * only if queryCommandState() or isAlreadyApplied(node) return
	         * true when called
	         */
	        setActive: undefined,

	        /* setInactive: [function ()]
	         *
	         * If implemented, this function is called when MediumEditor knows
	         * that this extension is currently disabled.  Curently, this
	         * is called at the beginning of each state change for
	         * the editor & toolbar. After calling this, MediumEditor
	         * will attempt to update the extension, either via checkState()
	         * or the combination of queryCommandState(), isAlreadyApplied(node),
	         * isActive(), and setActive()
	         */
	        setInactive: undefined,

	        /************************ Helpers ************************
	         * The following are helpers that are either set by MediumEditor
	         * during initialization, or are helper methods which either
	         * route calls to the MediumEditor instance or provide common
	         * functionality for all extensions
	         *********************************************************/

	        /* window: [Window]
	         *
	         * If not overriden, this will be set to the window object
	         * to be used by MediumEditor and its extensions.  This is
	         * passed via the 'contentWindow' option to MediumEditor
	         * and is the global 'window' object by default
	         */
	        'window': undefined,

	        /* document: [Document]
	         *
	         * If not overriden, this will be set to the document object
	         * to be used by MediumEditor and its extensions. This is
	         * passed via the 'ownerDocument' optin to MediumEditor
	         * and is the global 'document' object by default
	         */
	        'document': undefined,

	        /* getEditorElements: [function ()]
	         *
	         * Helper function which returns an array containing
	         * all the contenteditable elements for this instance
	         * of MediumEditor
	         */
	        getEditorElements: function () {
	            return this.base.elements;
	        },

	        /* getEditorId: [function ()]
	         *
	         * Helper function which returns a unique identifier
	         * for this instance of MediumEditor
	         */
	        getEditorId: function () {
	            return this.base.id;
	        },

	        /* getEditorOptions: [function (option)]
	         *
	         * Helper function which returns the value of an option
	         * used to initialize this instance of MediumEditor
	         */
	        getEditorOption: function (option) {
	            return this.base.options[option];
	        }
	    };

	    /* List of method names to add to the prototype of Extension
	     * Each of these methods will be defined as helpers that
	     * just call directly into the MediumEditor instance.
	     *
	     * example for 'on' method:
	     * Extension.prototype.on = function () {
	     *     return this.base.on.apply(this.base, arguments);
	     * }
	     */
	    [
	        // general helpers
	        'execAction',

	        // event handling
	        'on',
	        'off',
	        'subscribe',
	        'trigger'

	    ].forEach(function (helper) {
	        Extension.prototype[helper] = function () {
	            return this.base[helper].apply(this.base, arguments);
	        };
	    });

	    MediumEditor.Extension = Extension;
	})();

	(function () {
	    'use strict';

	    function filterOnlyParentElements(node) {
	        if (MediumEditor.util.isBlockContainer(node)) {
	            return NodeFilter.FILTER_ACCEPT;
	        } else {
	            return NodeFilter.FILTER_SKIP;
	        }
	    }

	    var Selection = {
	        findMatchingSelectionParent: function (testElementFunction, contentWindow) {
	            var selection = contentWindow.getSelection(),
	                range,
	                current;

	            if (selection.rangeCount === 0) {
	                return false;
	            }

	            range = selection.getRangeAt(0);
	            current = range.commonAncestorContainer;

	            return MediumEditor.util.traverseUp(current, testElementFunction);
	        },

	        getSelectionElement: function (contentWindow) {
	            return this.findMatchingSelectionParent(function (el) {
	                return MediumEditor.util.isMediumEditorElement(el);
	            }, contentWindow);
	        },

	        // http://stackoverflow.com/questions/17678843/cant-restore-selection-after-html-modify-even-if-its-the-same-html
	        // Tim Down
	        exportSelection: function (root, doc) {
	            if (!root) {
	                return null;
	            }

	            var selectionState = null,
	                selection = doc.getSelection();

	            if (selection.rangeCount > 0) {
	                var range = selection.getRangeAt(0),
	                    preSelectionRange = range.cloneRange(),
	                    start;

	                preSelectionRange.selectNodeContents(root);
	                preSelectionRange.setEnd(range.startContainer, range.startOffset);
	                start = preSelectionRange.toString().length;

	                selectionState = {
	                    start: start,
	                    end: start + range.toString().length
	                };

	                // Check to see if the selection starts with any images
	                // if so we need to make sure the the beginning of the selection is
	                // set correctly when importing selection
	                if (this.doesRangeStartWithImages(range, doc)) {
	                    selectionState.startsWithImage = true;
	                }

	                // Check to see if the selection has any trailing images
	                // if so, this this means we need to look for them when we import selection
	                var trailingImageCount = this.getTrailingImageCount(root, selectionState, range.endContainer, range.endOffset);
	                if (trailingImageCount) {
	                    selectionState.trailingImageCount = trailingImageCount;
	                }

	                // If start = 0 there may still be an empty paragraph before it, but we don't care.
	                if (start !== 0) {
	                    var emptyBlocksIndex = this.getIndexRelativeToAdjacentEmptyBlocks(doc, root, range.startContainer, range.startOffset);
	                    if (emptyBlocksIndex !== -1) {
	                        selectionState.emptyBlocksIndex = emptyBlocksIndex;
	                    }
	                }
	            }

	            return selectionState;
	        },

	        // http://stackoverflow.com/questions/17678843/cant-restore-selection-after-html-modify-even-if-its-the-same-html
	        // Tim Down
	        //
	        // {object} selectionState - the selection to import
	        // {DOMElement} root - the root element the selection is being restored inside of
	        // {Document} doc - the document to use for managing selection
	        // {boolean} [favorLaterSelectionAnchor] - defaults to false. If true, import the cursor immediately
	        //      subsequent to an anchor tag if it would otherwise be placed right at the trailing edge inside the
	        //      anchor. This cursor positioning, even though visually equivalent to the user, can affect behavior
	        //      in MS IE.
	        importSelection: function (selectionState, root, doc, favorLaterSelectionAnchor) {
	            if (!selectionState || !root) {
	                return;
	            }

	            var range = doc.createRange();
	            range.setStart(root, 0);
	            range.collapse(true);

	            var node = root,
	                nodeStack = [],
	                charIndex = 0,
	                foundStart = false,
	                foundEnd = false,
	                trailingImageCount = 0,
	                stop = false,
	                nextCharIndex,
	                allowRangeToStartAtEndOfNode = false,
	                lastTextNode = null;

	            // When importing selection, the start of the selection may lie at the end of an element
	            // or at the beginning of an element.  Since visually there is no difference between these 2
	            // we will try to move the selection to the beginning of an element since this is generally
	            // what users will expect and it's a more predictable behavior.
	            //
	            // However, there are some specific cases when we don't want to do this:
	            //  1) We're attempting to move the cursor outside of the end of an anchor [favorLaterSelectionAnchor = true]
	            //  2) The selection starts with an image, which is special since an image doesn't have any 'content'
	            //     as far as selection and ranges are concerned
	            //  3) The selection starts after a specified number of empty block elements (selectionState.emptyBlocksIndex)
	            //
	            // For these cases, we want the selection to start at a very specific location, so we should NOT
	            // automatically move the cursor to the beginning of the first actual chunk of text
	            if (favorLaterSelectionAnchor || selectionState.startsWithImage || typeof selectionState.emptyBlocksIndex !== 'undefined') {
	                allowRangeToStartAtEndOfNode = true;
	            }

	            while (!stop && node) {
	                // Only iterate over elements and text nodes
	                if (node.nodeType > 3) {
	                    node = nodeStack.pop();
	                    continue;
	                }

	                // If we hit a text node, we need to add the amount of characters to the overall count
	                if (node.nodeType === 3 && !foundEnd) {
	                    nextCharIndex = charIndex + node.length;
	                    // Check if we're at or beyond the start of the selection we're importing
	                    if (!foundStart && selectionState.start >= charIndex && selectionState.start <= nextCharIndex) {
	                        // NOTE: We only want to allow a selection to start at the END of an element if
	                        //  allowRangeToStartAtEndOfNode is true
	                        if (allowRangeToStartAtEndOfNode || selectionState.start < nextCharIndex) {
	                            range.setStart(node, selectionState.start - charIndex);
	                            foundStart = true;
	                        }
	                        // We're at the end of a text node where the selection could start but we shouldn't
	                        // make the selection start here because allowRangeToStartAtEndOfNode is false.
	                        // However, we should keep a reference to this node in case there aren't any more
	                        // text nodes after this, so that we have somewhere to import the selection to
	                        else {
	                            lastTextNode = node;
	                        }
	                    }
	                    // We've found the start of the selection, check if we're at or beyond the end of the selection we're importing
	                    if (foundStart && selectionState.end >= charIndex && selectionState.end <= nextCharIndex) {
	                        if (!selectionState.trailingImageCount) {
	                            range.setEnd(node, selectionState.end - charIndex);
	                            stop = true;
	                        } else {
	                            foundEnd = true;
	                        }
	                    }
	                    charIndex = nextCharIndex;
	                } else {
	                    if (selectionState.trailingImageCount && foundEnd) {
	                        if (node.nodeName.toLowerCase() === 'img') {
	                            trailingImageCount++;
	                        }
	                        if (trailingImageCount === selectionState.trailingImageCount) {
	                            // Find which index the image is in its parent's children
	                            var endIndex = 0;
	                            while (node.parentNode.childNodes[endIndex] !== node) {
	                                endIndex++;
	                            }
	                            range.setEnd(node.parentNode, endIndex + 1);
	                            stop = true;
	                        }
	                    }

	                    if (!stop && node.nodeType === 1) {
	                        // this is an element
	                        // add all its children to the stack
	                        var i = node.childNodes.length - 1;
	                        while (i >= 0) {
	                            nodeStack.push(node.childNodes[i]);
	                            i -= 1;
	                        }
	                    }
	                }

	                if (!stop) {
	                    node = nodeStack.pop();
	                }
	            }

	            // If we've gone through the entire text but didn't find the beginning of a text node
	            // to make the selection start at, we should fall back to starting the selection
	            // at the END of the last text node we found
	            if (!foundStart && lastTextNode) {
	                range.setStart(lastTextNode, lastTextNode.length);
	                range.setEnd(lastTextNode, lastTextNode.length);
	            }

	            if (typeof selectionState.emptyBlocksIndex !== 'undefined') {
	                range = this.importSelectionMoveCursorPastBlocks(doc, root, selectionState.emptyBlocksIndex, range);
	            }

	            // If the selection is right at the ending edge of a link, put it outside the anchor tag instead of inside.
	            if (favorLaterSelectionAnchor) {
	                range = this.importSelectionMoveCursorPastAnchor(selectionState, range);
	            }

	            this.selectRange(doc, range);
	        },

	        // Utility method called from importSelection only
	        importSelectionMoveCursorPastAnchor: function (selectionState, range) {
	            var nodeInsideAnchorTagFunction = function (node) {
	                return node.nodeName.toLowerCase() === 'a';
	            };
	            if (selectionState.start === selectionState.end &&
	                    range.startContainer.nodeType === 3 &&
	                    range.startOffset === range.startContainer.nodeValue.length &&
	                    MediumEditor.util.traverseUp(range.startContainer, nodeInsideAnchorTagFunction)) {
	                var prevNode = range.startContainer,
	                    currentNode = range.startContainer.parentNode;
	                while (currentNode !== null && currentNode.nodeName.toLowerCase() !== 'a') {
	                    if (currentNode.childNodes[currentNode.childNodes.length - 1] !== prevNode) {
	                        currentNode = null;
	                    } else {
	                        prevNode = currentNode;
	                        currentNode = currentNode.parentNode;
	                    }
	                }
	                if (currentNode !== null && currentNode.nodeName.toLowerCase() === 'a') {
	                    var currentNodeIndex = null;
	                    for (var i = 0; currentNodeIndex === null && i < currentNode.parentNode.childNodes.length; i++) {
	                        if (currentNode.parentNode.childNodes[i] === currentNode) {
	                            currentNodeIndex = i;
	                        }
	                    }
	                    range.setStart(currentNode.parentNode, currentNodeIndex + 1);
	                    range.collapse(true);
	                }
	            }
	            return range;
	        },

	        // Uses the emptyBlocksIndex calculated by getIndexRelativeToAdjacentEmptyBlocks
	        // to move the cursor back to the start of the correct paragraph
	        importSelectionMoveCursorPastBlocks: function (doc, root, index, range) {
	            var treeWalker = doc.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, filterOnlyParentElements, false),
	                startContainer = range.startContainer,
	                startBlock,
	                targetNode,
	                currIndex = 0;
	            index = index || 1; // If index is 0, we still want to move to the next block

	            // Chrome counts newlines and spaces that separate block elements as actual elements.
	            // If the selection is inside one of these text nodes, and it has a previous sibling
	            // which is a block element, we want the treewalker to start at the previous sibling
	            // and NOT at the parent of the textnode
	            if (startContainer.nodeType === 3 && MediumEditor.util.isBlockContainer(startContainer.previousSibling)) {
	                startBlock = startContainer.previousSibling;
	            } else {
	                startBlock = MediumEditor.util.getClosestBlockContainer(startContainer);
	            }

	            // Skip over empty blocks until we hit the block we want the selection to be in
	            while (treeWalker.nextNode()) {
	                if (!targetNode) {
	                    // Loop through all blocks until we hit the starting block element
	                    if (startBlock === treeWalker.currentNode) {
	                        targetNode = treeWalker.currentNode;
	                    }
	                } else {
	                    targetNode = treeWalker.currentNode;
	                    currIndex++;
	                    // We hit the target index, bail
	                    if (currIndex === index) {
	                        break;
	                    }
	                    // If we find a non-empty block, ignore the emptyBlocksIndex and just put selection here
	                    if (targetNode.textContent.length > 0) {
	                        break;
	                    }
	                }
	            }

	            if (!targetNode) {
	                targetNode = startBlock;
	            }

	            // We're selecting a high-level block node, so make sure the cursor gets moved into the deepest
	            // element at the beginning of the block
	            range.setStart(MediumEditor.util.getFirstSelectableLeafNode(targetNode), 0);

	            return range;
	        },

	        // Returns -1 unless the cursor is at the beginning of a paragraph/block
	        // If the paragraph/block is preceeded by empty paragraphs/block (with no text)
	        // it will return the number of empty paragraphs before the cursor.
	        // Otherwise, it will return 0, which indicates the cursor is at the beginning
	        // of a paragraph/block, and not at the end of the paragraph/block before it
	        getIndexRelativeToAdjacentEmptyBlocks: function (doc, root, cursorContainer, cursorOffset) {
	            // If there is text in front of the cursor, that means there isn't only empty blocks before it
	            if (cursorContainer.textContent.length > 0 && cursorOffset > 0) {
	                return -1;
	            }

	            // Check if the block that contains the cursor has any other text in front of the cursor
	            var node = cursorContainer;
	            if (node.nodeType !== 3) {
	                node = cursorContainer.childNodes[cursorOffset];
	            }
	            if (node) {
	                // The element isn't at the beginning of a block, so it has content before it
	                if (!MediumEditor.util.isElementAtBeginningOfBlock(node)) {
	                    return -1;
	                }

	                var previousSibling = MediumEditor.util.findPreviousSibling(node);
	                // If there is no previous sibling, this is the first text element in the editor
	                if (!previousSibling) {
	                    return -1;
	                }
	                // If the previous sibling has text, then there are no empty blocks before this
	                else if (previousSibling.nodeValue) {
	                    return -1;
	                }
	            }

	            // Walk over block elements, counting number of empty blocks between last piece of text
	            // and the block the cursor is in
	            var closestBlock = MediumEditor.util.getClosestBlockContainer(cursorContainer),
	                treeWalker = doc.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, filterOnlyParentElements, false),
	                emptyBlocksCount = 0;
	            while (treeWalker.nextNode()) {
	                var blockIsEmpty = treeWalker.currentNode.textContent === '';
	                if (blockIsEmpty || emptyBlocksCount > 0) {
	                    emptyBlocksCount += 1;
	                }
	                if (treeWalker.currentNode === closestBlock) {
	                    return emptyBlocksCount;
	                }
	                if (!blockIsEmpty) {
	                    emptyBlocksCount = 0;
	                }
	            }

	            return emptyBlocksCount;
	        },

	        // Returns true if the selection range begins with an image tag
	        // Returns false if the range starts with any non empty text nodes
	        doesRangeStartWithImages: function (range, doc) {
	            if (range.startOffset !== 0 || range.startContainer.nodeType !== 1) {
	                return false;
	            }

	            if (range.startContainer.nodeName.toLowerCase() === 'img') {
	                return true;
	            }

	            var img = range.startContainer.querySelector('img');
	            if (!img) {
	                return false;
	            }

	            var treeWalker = doc.createTreeWalker(range.startContainer, NodeFilter.SHOW_ALL, null, false);
	            while (treeWalker.nextNode()) {
	                var next = treeWalker.currentNode;
	                // If we hit the image, then there isn't any text before the image so
	                // the image is at the beginning of the range
	                if (next === img) {
	                    break;
	                }
	                // If we haven't hit the iamge, but found text that contains content
	                // then the range doesn't start with an image
	                if (next.nodeValue) {
	                    return false;
	                }
	            }

	            return true;
	        },

	        getTrailingImageCount: function (root, selectionState, endContainer, endOffset) {
	            // If the endOffset of a range is 0, the endContainer doesn't contain images
	            // If the endContainer is a text node, there are no trailing images
	            if (endOffset === 0 || endContainer.nodeType !== 1) {
	                return 0;
	            }

	            // If the endContainer isn't an image, and doesn't have an image descendants
	            // there are no trailing images
	            if (endContainer.nodeName.toLowerCase() !== 'img' && !endContainer.querySelector('img')) {
	                return 0;
	            }

	            var lastNode = endContainer.childNodes[endOffset - 1];
	            while (lastNode.hasChildNodes()) {
	                lastNode = lastNode.lastChild;
	            }

	            var node = root,
	                nodeStack = [],
	                charIndex = 0,
	                foundStart = false,
	                foundEnd = false,
	                stop = false,
	                nextCharIndex,
	                trailingImages = 0;

	            while (!stop && node) {
	                // Only iterate over elements and text nodes
	                if (node.nodeType > 3) {
	                    node = nodeStack.pop();
	                    continue;
	                }

	                if (node.nodeType === 3 && !foundEnd) {
	                    trailingImages = 0;
	                    nextCharIndex = charIndex + node.length;
	                    if (!foundStart && selectionState.start >= charIndex && selectionState.start <= nextCharIndex) {
	                        foundStart = true;
	                    }
	                    if (foundStart && selectionState.end >= charIndex && selectionState.end <= nextCharIndex) {
	                        foundEnd = true;
	                    }
	                    charIndex = nextCharIndex;
	                } else {
	                    if (node.nodeName.toLowerCase() === 'img') {
	                        trailingImages++;
	                    }

	                    if (node === lastNode) {
	                        stop = true;
	                    } else if (node.nodeType === 1) {
	                        // this is an element
	                        // add all its children to the stack
	                        var i = node.childNodes.length - 1;
	                        while (i >= 0) {
	                            nodeStack.push(node.childNodes[i]);
	                            i -= 1;
	                        }
	                    }
	                }

	                if (!stop) {
	                    node = nodeStack.pop();
	                }
	            }

	            return trailingImages;
	        },

	        // determine if the current selection contains any 'content'
	        // content being any non-white space text or an image
	        selectionContainsContent: function (doc) {
	            var sel = doc.getSelection();

	            // collapsed selection or selection withour range doesn't contain content
	            if (!sel || sel.isCollapsed || !sel.rangeCount) {
	                return false;
	            }

	            // if toString() contains any text, the selection contains some content
	            if (sel.toString().trim() !== '') {
	                return true;
	            }

	            // if selection contains only image(s), it will return empty for toString()
	            // so check for an image manually
	            var selectionNode = this.getSelectedParentElement(sel.getRangeAt(0));
	            if (selectionNode) {
	                if (selectionNode.nodeName.toLowerCase() === 'img' ||
	                    (selectionNode.nodeType === 1 && selectionNode.querySelector('img'))) {
	                    return true;
	                }
	            }

	            return false;
	        },

	        selectionInContentEditableFalse: function (contentWindow) {
	            // determine if the current selection is exclusively inside
	            // a contenteditable="false", though treat the case of an
	            // explicit contenteditable="true" inside a "false" as false.
	            var sawtrue,
	                sawfalse = this.findMatchingSelectionParent(function (el) {
	                    var ce = el && el.getAttribute('contenteditable');
	                    if (ce === 'true') {
	                        sawtrue = true;
	                    }
	                    return el.nodeName !== '#text' && ce === 'false';
	                }, contentWindow);

	            return !sawtrue && sawfalse;
	        },

	        // http://stackoverflow.com/questions/4176923/html-of-selected-text
	        // by Tim Down
	        getSelectionHtml: function getSelectionHtml(doc) {
	            var i,
	                html = '',
	                sel = doc.getSelection(),
	                len,
	                container;
	            if (sel.rangeCount) {
	                container = doc.createElement('div');
	                for (i = 0, len = sel.rangeCount; i < len; i += 1) {
	                    container.appendChild(sel.getRangeAt(i).cloneContents());
	                }
	                html = container.innerHTML;
	            }
	            return html;
	        },

	        /**
	         *  Find the caret position within an element irrespective of any inline tags it may contain.
	         *
	         *  @param {DOMElement} An element containing the cursor to find offsets relative to.
	         *  @param {Range} A Range representing cursor position. Will window.getSelection if none is passed.
	         *  @return {Object} 'left' and 'right' attributes contain offsets from begining and end of Element
	         */
	        getCaretOffsets: function getCaretOffsets(element, range) {
	            var preCaretRange, postCaretRange;

	            if (!range) {
	                range = window.getSelection().getRangeAt(0);
	            }

	            preCaretRange = range.cloneRange();
	            postCaretRange = range.cloneRange();

	            preCaretRange.selectNodeContents(element);
	            preCaretRange.setEnd(range.endContainer, range.endOffset);

	            postCaretRange.selectNodeContents(element);
	            postCaretRange.setStart(range.endContainer, range.endOffset);

	            return {
	                left: preCaretRange.toString().length,
	                right: postCaretRange.toString().length
	            };
	        },

	        // http://stackoverflow.com/questions/15867542/range-object-get-selection-parent-node-chrome-vs-firefox
	        rangeSelectsSingleNode: function (range) {
	            var startNode = range.startContainer;
	            return startNode === range.endContainer &&
	                startNode.hasChildNodes() &&
	                range.endOffset === range.startOffset + 1;
	        },

	        getSelectedParentElement: function (range) {
	            if (!range) {
	                return null;
	            }

	            // Selection encompasses a single element
	            if (this.rangeSelectsSingleNode(range) && range.startContainer.childNodes[range.startOffset].nodeType !== 3) {
	                return range.startContainer.childNodes[range.startOffset];
	            }

	            // Selection range starts inside a text node, so get its parent
	            if (range.startContainer.nodeType === 3) {
	                return range.startContainer.parentNode;
	            }

	            // Selection starts inside an element
	            return range.startContainer;
	        },

	        getSelectedElements: function (doc) {
	            var selection = doc.getSelection(),
	                range,
	                toRet,
	                currNode;

	            if (!selection.rangeCount || selection.isCollapsed || !selection.getRangeAt(0).commonAncestorContainer) {
	                return [];
	            }

	            range = selection.getRangeAt(0);

	            if (range.commonAncestorContainer.nodeType === 3) {
	                toRet = [];
	                currNode = range.commonAncestorContainer;
	                while (currNode.parentNode && currNode.parentNode.childNodes.length === 1) {
	                    toRet.push(currNode.parentNode);
	                    currNode = currNode.parentNode;
	                }

	                return toRet;
	            }

	            return [].filter.call(range.commonAncestorContainer.getElementsByTagName('*'), function (el) {
	                return (typeof selection.containsNode === 'function') ? selection.containsNode(el, true) : true;
	            });
	        },

	        selectNode: function (node, doc) {
	            var range = doc.createRange();
	            range.selectNodeContents(node);
	            this.selectRange(doc, range);
	        },

	        select: function (doc, startNode, startOffset, endNode, endOffset) {
	            var range = doc.createRange();
	            range.setStart(startNode, startOffset);
	            if (endNode) {
	                range.setEnd(endNode, endOffset);
	            } else {
	                range.collapse(true);
	            }
	            this.selectRange(doc, range);
	            return range;
	        },

	        /**
	         *  Clear the current highlighted selection and set the caret to the start or the end of that prior selection, defaults to end.
	         *
	         *  @param {DomDocument} doc            Current document
	         *  @param {boolean} moveCursorToStart  A boolean representing whether or not to set the caret to the beginning of the prior selection.
	         */
	        clearSelection: function (doc, moveCursorToStart) {
	            if (moveCursorToStart) {
	                doc.getSelection().collapseToStart();
	            } else {
	                doc.getSelection().collapseToEnd();
	            }
	        },

	        /**
	         * Move cursor to the given node with the given offset.
	         *
	         * @param  {DomDocument} doc     Current document
	         * @param  {DomElement}  node    Element where to jump
	         * @param  {integer}     offset  Where in the element should we jump, 0 by default
	         */
	        moveCursor: function (doc, node, offset) {
	            this.select(doc, node, offset);
	        },

	        getSelectionRange: function (ownerDocument) {
	            var selection = ownerDocument.getSelection();
	            if (selection.rangeCount === 0) {
	                return null;
	            }
	            return selection.getRangeAt(0);
	        },

	        selectRange: function (ownerDocument, range) {
	            var selection = ownerDocument.getSelection();

	            selection.removeAllRanges();
	            selection.addRange(range);
	        },

	        // http://stackoverflow.com/questions/1197401/how-can-i-get-the-element-the-caret-is-in-with-javascript-when-using-contentedi
	        // by You
	        getSelectionStart: function (ownerDocument) {
	            var node = ownerDocument.getSelection().anchorNode,
	                startNode = (node && node.nodeType === 3 ? node.parentNode : node);

	            return startNode;
	        }
	    };

	    MediumEditor.selection = Selection;
	}());

	(function () {
	    'use strict';

	    var Events = function (instance) {
	        this.base = instance;
	        this.options = this.base.options;
	        this.events = [];
	        this.disabledEvents = {};
	        this.customEvents = {};
	        this.listeners = {};
	    };

	    Events.prototype = {
	        InputEventOnContenteditableSupported: !MediumEditor.util.isIE && !MediumEditor.util.isEdge,

	        // Helpers for event handling

	        attachDOMEvent: function (targets, event, listener, useCapture) {
	            targets = MediumEditor.util.isElement(targets) || [window, document].indexOf(targets) > -1 ? [targets] : targets;

	            Array.prototype.forEach.call(targets, function (target) {
	                target.addEventListener(event, listener, useCapture);
	                this.events.push([target, event, listener, useCapture]);
	            }.bind(this));
	        },

	        detachDOMEvent: function (targets, event, listener, useCapture) {
	            var index, e;
	            targets = MediumEditor.util.isElement(targets) || [window, document].indexOf(targets) > -1 ? [targets] : targets;

	            Array.prototype.forEach.call(targets, function (target) {
	                index = this.indexOfListener(target, event, listener, useCapture);
	                if (index !== -1) {
	                    e = this.events.splice(index, 1)[0];
	                    e[0].removeEventListener(e[1], e[2], e[3]);
	                }
	            }.bind(this));
	        },

	        indexOfListener: function (target, event, listener, useCapture) {
	            var i, n, item;
	            for (i = 0, n = this.events.length; i < n; i = i + 1) {
	                item = this.events[i];
	                if (item[0] === target && item[1] === event && item[2] === listener && item[3] === useCapture) {
	                    return i;
	                }
	            }
	            return -1;
	        },

	        detachAllDOMEvents: function () {
	            var e = this.events.pop();
	            while (e) {
	                e[0].removeEventListener(e[1], e[2], e[3]);
	                e = this.events.pop();
	            }
	        },

	        detachAllEventsFromElement: function (element) {
	            var filtered = this.events.filter(function (e) {
	                return e && e[0].getAttribute && e[0].getAttribute('medium-editor-index') === element.getAttribute('medium-editor-index');
	            });

	            for (var i = 0, len = filtered.length; i < len; i++) {
	                var e = filtered[i];
	                this.detachDOMEvent(e[0], e[1], e[2], e[3]);
	            }
	        },

	        // Attach all existing handlers to a new element
	        attachAllEventsToElement: function (element) {
	            if (this.listeners['editableInput']) {
	                this.contentCache[element.getAttribute('medium-editor-index')] = element.innerHTML;
	            }

	            if (this.eventsCache) {
	                this.eventsCache.forEach(function (e) {
	                    this.attachDOMEvent(element, e['name'], e['handler'].bind(this));
	                }, this);
	            }
	        },

	        enableCustomEvent: function (event) {
	            if (this.disabledEvents[event] !== undefined) {
	                delete this.disabledEvents[event];
	            }
	        },

	        disableCustomEvent: function (event) {
	            this.disabledEvents[event] = true;
	        },

	        // custom events
	        attachCustomEvent: function (event, listener) {
	            this.setupListener(event);
	            if (!this.customEvents[event]) {
	                this.customEvents[event] = [];
	            }
	            this.customEvents[event].push(listener);
	        },

	        detachCustomEvent: function (event, listener) {
	            var index = this.indexOfCustomListener(event, listener);
	            if (index !== -1) {
	                this.customEvents[event].splice(index, 1);
	                // TODO: If array is empty, should detach internal listeners via destroyListener()
	            }
	        },

	        indexOfCustomListener: function (event, listener) {
	            if (!this.customEvents[event] || !this.customEvents[event].length) {
	                return -1;
	            }

	            return this.customEvents[event].indexOf(listener);
	        },

	        detachAllCustomEvents: function () {
	            this.customEvents = {};
	            // TODO: Should detach internal listeners here via destroyListener()
	        },

	        triggerCustomEvent: function (name, data, editable) {
	            if (this.customEvents[name] && !this.disabledEvents[name]) {
	                this.customEvents[name].forEach(function (listener) {
	                    listener(data, editable);
	                });
	            }
	        },

	        // Cleaning up

	        destroy: function () {
	            this.detachAllDOMEvents();
	            this.detachAllCustomEvents();
	            this.detachExecCommand();

	            if (this.base.elements) {
	                this.base.elements.forEach(function (element) {
	                    element.removeAttribute('data-medium-focused');
	                });
	            }
	        },

	        // Listening to calls to document.execCommand

	        // Attach a listener to be notified when document.execCommand is called
	        attachToExecCommand: function () {
	            if (this.execCommandListener) {
	                return;
	            }

	            // Store an instance of the listener so:
	            // 1) We only attach to execCommand once
	            // 2) We can remove the listener later
	            this.execCommandListener = function (execInfo) {
	                this.handleDocumentExecCommand(execInfo);
	            }.bind(this);

	            // Ensure that execCommand has been wrapped correctly
	            this.wrapExecCommand();

	            // Add listener to list of execCommand listeners
	            this.options.ownerDocument.execCommand.listeners.push(this.execCommandListener);
	        },

	        // Remove our listener for calls to document.execCommand
	        detachExecCommand: function () {
	            var doc = this.options.ownerDocument;
	            if (!this.execCommandListener || !doc.execCommand.listeners) {
	                return;
	            }

	            // Find the index of this listener in the array of listeners so it can be removed
	            var index = doc.execCommand.listeners.indexOf(this.execCommandListener);
	            if (index !== -1) {
	                doc.execCommand.listeners.splice(index, 1);
	            }

	            // If the list of listeners is now empty, put execCommand back to its original state
	            if (!doc.execCommand.listeners.length) {
	                this.unwrapExecCommand();
	            }
	        },

	        // Wrap document.execCommand in a custom method so we can listen to calls to it
	        wrapExecCommand: function () {
	            var doc = this.options.ownerDocument;

	            // Ensure all instance of MediumEditor only wrap execCommand once
	            if (doc.execCommand.listeners) {
	                return;
	            }

	            // Helper method to call all listeners to execCommand
	            var callListeners = function (args, result) {
	                    if (doc.execCommand.listeners) {
	                        doc.execCommand.listeners.forEach(function (listener) {
	                            listener({
	                                command: args[0],
	                                value: args[2],
	                                args: args,
	                                result: result
	                            });
	                        });
	                    }
	                },

	            // Create a wrapper method for execCommand which will:
	            // 1) Call document.execCommand with the correct arguments
	            // 2) Loop through any listeners and notify them that execCommand was called
	            //    passing extra info on the call
	            // 3) Return the result
	                wrapper = function () {
	                    var result = doc.execCommand.orig.apply(this, arguments);

	                    if (!doc.execCommand.listeners) {
	                        return result;
	                    }

	                    var args = Array.prototype.slice.call(arguments);
	                    callListeners(args, result);

	                    return result;
	                };

	            // Store a reference to the original execCommand
	            wrapper.orig = doc.execCommand;

	            // Attach an array for storing listeners
	            wrapper.listeners = [];

	            // Helper for notifying listeners
	            wrapper.callListeners = callListeners;

	            // Overwrite execCommand
	            doc.execCommand = wrapper;
	        },

	        // Revert document.execCommand back to its original self
	        unwrapExecCommand: function () {
	            var doc = this.options.ownerDocument;
	            if (!doc.execCommand.orig) {
	                return;
	            }

	            // Use the reference to the original execCommand to revert back
	            doc.execCommand = doc.execCommand.orig;
	        },

	        // Listening to browser events to emit events medium-editor cares about
	        setupListener: function (name) {
	            if (this.listeners[name]) {
	                return;
	            }

	            switch (name) {
	                case 'externalInteraction':
	                    // Detecting when user has interacted with elements outside of MediumEditor
	                    this.attachDOMEvent(this.options.ownerDocument.body, 'mousedown', this.handleBodyMousedown.bind(this), true);
	                    this.attachDOMEvent(this.options.ownerDocument.body, 'click', this.handleBodyClick.bind(this), true);
	                    this.attachDOMEvent(this.options.ownerDocument.body, 'focus', this.handleBodyFocus.bind(this), true);
	                    break;
	                case 'blur':
	                    // Detecting when focus is lost
	                    this.setupListener('externalInteraction');
	                    break;
	                case 'focus':
	                    // Detecting when focus moves into some part of MediumEditor
	                    this.setupListener('externalInteraction');
	                    break;
	                case 'editableInput':
	                    // setup cache for knowing when the content has changed
	                    this.contentCache = {};
	                    this.base.elements.forEach(function (element) {
	                        this.contentCache[element.getAttribute('medium-editor-index')] = element.innerHTML;
	                    }, this);

	                    // Attach to the 'oninput' event, handled correctly by most browsers
	                    if (this.InputEventOnContenteditableSupported) {
	                        this.attachToEachElement('input', this.handleInput);
	                    }

	                    // For browsers which don't support the input event on contenteditable (IE)
	                    // we'll attach to 'selectionchange' on the document and 'keypress' on the editables
	                    if (!this.InputEventOnContenteditableSupported) {
	                        this.setupListener('editableKeypress');
	                        this.keypressUpdateInput = true;
	                        this.attachDOMEvent(document, 'selectionchange', this.handleDocumentSelectionChange.bind(this));
	                        // Listen to calls to execCommand
	                        this.attachToExecCommand();
	                    }
	                    break;
	                case 'editableClick':
	                    // Detecting click in the contenteditables
	                    this.attachToEachElement('click', this.handleClick);
	                    break;
	                case 'editableBlur':
	                    // Detecting blur in the contenteditables
	                    this.attachToEachElement('blur', this.handleBlur);
	                    break;
	                case 'editableKeypress':
	                    // Detecting keypress in the contenteditables
	                    this.attachToEachElement('keypress', this.handleKeypress);
	                    break;
	                case 'editableKeyup':
	                    // Detecting keyup in the contenteditables
	                    this.attachToEachElement('keyup', this.handleKeyup);
	                    break;
	                case 'editableKeydown':
	                    // Detecting keydown on the contenteditables
	                    this.attachToEachElement('keydown', this.handleKeydown);
	                    break;
	                case 'editableKeydownSpace':
	                    // Detecting keydown for SPACE on the contenteditables
	                    this.setupListener('editableKeydown');
	                    break;
	                case 'editableKeydownEnter':
	                    // Detecting keydown for ENTER on the contenteditables
	                    this.setupListener('editableKeydown');
	                    break;
	                case 'editableKeydownTab':
	                    // Detecting keydown for TAB on the contenteditable
	                    this.setupListener('editableKeydown');
	                    break;
	                case 'editableKeydownDelete':
	                    // Detecting keydown for DELETE/BACKSPACE on the contenteditables
	                    this.setupListener('editableKeydown');
	                    break;
	                case 'editableMouseover':
	                    // Detecting mouseover on the contenteditables
	                    this.attachToEachElement('mouseover', this.handleMouseover);
	                    break;
	                case 'editableDrag':
	                    // Detecting dragover and dragleave on the contenteditables
	                    this.attachToEachElement('dragover', this.handleDragging);
	                    this.attachToEachElement('dragleave', this.handleDragging);
	                    break;
	                case 'editableDrop':
	                    // Detecting drop on the contenteditables
	                    this.attachToEachElement('drop', this.handleDrop);
	                    break;
	                case 'editablePaste':
	                    // Detecting paste on the contenteditables
	                    this.attachToEachElement('paste', this.handlePaste);
	                    break;
	            }
	            this.listeners[name] = true;
	        },

	        attachToEachElement: function (name, handler) {
	            // build our internal cache to know which element got already what handler attached
	            if (!this.eventsCache) {
	                this.eventsCache = [];
	            }

	            this.base.elements.forEach(function (element) {
	                this.attachDOMEvent(element, name, handler.bind(this));
	            }, this);

	            this.eventsCache.push({ 'name': name, 'handler': handler });
	        },

	        cleanupElement: function (element) {
	            var index = element.getAttribute('medium-editor-index');
	            if (index) {
	                this.detachAllEventsFromElement(element);
	                if (this.contentCache) {
	                    delete this.contentCache[index];
	                }
	            }
	        },

	        focusElement: function (element) {
	            element.focus();
	            this.updateFocus(element, { target: element, type: 'focus' });
	        },

	        updateFocus: function (target, eventObj) {
	            var toolbar = this.base.getExtensionByName('toolbar'),
	                toolbarEl = toolbar ? toolbar.getToolbarElement() : null,
	                anchorPreview = this.base.getExtensionByName('anchor-preview'),
	                previewEl = (anchorPreview && anchorPreview.getPreviewElement) ? anchorPreview.getPreviewElement() : null,
	                hadFocus = this.base.getFocusedElement(),
	                toFocus;

	            // For clicks, we need to know if the mousedown that caused the click happened inside the existing focused element.
	            // If so, we don't want to focus another element
	            if (hadFocus &&
	                    eventObj.type === 'click' &&
	                    this.lastMousedownTarget &&
	                    (MediumEditor.util.isDescendant(hadFocus, this.lastMousedownTarget, true) ||
	                     MediumEditor.util.isDescendant(toolbarEl, this.lastMousedownTarget, true) ||
	                     MediumEditor.util.isDescendant(previewEl, this.lastMousedownTarget, true))) {
	                toFocus = hadFocus;
	            }

	            if (!toFocus) {
	                this.base.elements.some(function (element) {
	                    // If the target is part of an editor element, this is the element getting focus
	                    if (!toFocus && (MediumEditor.util.isDescendant(element, target, true))) {
	                        toFocus = element;
	                    }

	                    // bail if we found an element that's getting focus
	                    return !!toFocus;
	                }, this);
	            }

	            // Check if the target is external (not part of the editor, toolbar, or anchorpreview)
	            var externalEvent = !MediumEditor.util.isDescendant(hadFocus, target, true) &&
	                                !MediumEditor.util.isDescendant(toolbarEl, target, true) &&
	                                !MediumEditor.util.isDescendant(previewEl, target, true);

	            if (toFocus !== hadFocus) {
	                // If element has focus, and focus is going outside of editor
	                // Don't blur focused element if clicking on editor, toolbar, or anchorpreview
	                if (hadFocus && externalEvent) {
	                    // Trigger blur on the editable that has lost focus
	                    hadFocus.removeAttribute('data-medium-focused');
	                    this.triggerCustomEvent('blur', eventObj, hadFocus);
	                }

	                // If focus is going into an editor element
	                if (toFocus) {
	                    // Trigger focus on the editable that now has focus
	                    toFocus.setAttribute('data-medium-focused', true);
	                    this.triggerCustomEvent('focus', eventObj, toFocus);
	                }
	            }

	            if (externalEvent) {
	                this.triggerCustomEvent('externalInteraction', eventObj);
	            }
	        },

	        updateInput: function (target, eventObj) {
	            if (!this.contentCache) {
	                return;
	            }
	            // An event triggered which signifies that the user may have changed someting
	            // Look in our cache of input for the contenteditables to see if something changed
	            var index = target.getAttribute('medium-editor-index'),
	                html = target.innerHTML;

	            if (html !== this.contentCache[index]) {
	                // The content has changed since the last time we checked, fire the event
	                this.triggerCustomEvent('editableInput', eventObj, target);
	            }
	            this.contentCache[index] = html;
	        },

	        handleDocumentSelectionChange: function (event) {
	            // When selectionchange fires, target and current target are set
	            // to document, since this is where the event is handled
	            // However, currentTarget will have an 'activeElement' property
	            // which will point to whatever element has focus.
	            if (event.currentTarget && event.currentTarget.activeElement) {
	                var activeElement = event.currentTarget.activeElement,
	                    currentTarget;
	                // We can look at the 'activeElement' to determine if the selectionchange has
	                // happened within a contenteditable owned by this instance of MediumEditor
	                this.base.elements.some(function (element) {
	                    if (MediumEditor.util.isDescendant(element, activeElement, true)) {
	                        currentTarget = element;
	                        return true;
	                    }
	                    return false;
	                }, this);

	                // We know selectionchange fired within one of our contenteditables
	                if (currentTarget) {
	                    this.updateInput(currentTarget, { target: activeElement, currentTarget: currentTarget });
	                }
	            }
	        },

	        handleDocumentExecCommand: function () {
	            // document.execCommand has been called
	            // If one of our contenteditables currently has focus, we should
	            // attempt to trigger the 'editableInput' event
	            var target = this.base.getFocusedElement();
	            if (target) {
	                this.updateInput(target, { target: target, currentTarget: target });
	            }
	        },

	        handleBodyClick: function (event) {
	            this.updateFocus(event.target, event);
	        },

	        handleBodyFocus: function (event) {
	            this.updateFocus(event.target, event);
	        },

	        handleBodyMousedown: function (event) {
	            this.lastMousedownTarget = event.target;
	        },

	        handleInput: function (event) {
	            this.updateInput(event.currentTarget, event);
	        },

	        handleClick: function (event) {
	            this.triggerCustomEvent('editableClick', event, event.currentTarget);
	        },

	        handleBlur: function (event) {
	            this.triggerCustomEvent('editableBlur', event, event.currentTarget);
	        },

	        handleKeypress: function (event) {
	            this.triggerCustomEvent('editableKeypress', event, event.currentTarget);

	            // If we're doing manual detection of the editableInput event we need
	            // to check for input changes during 'keypress'
	            if (this.keypressUpdateInput) {
	                var eventObj = { target: event.target, currentTarget: event.currentTarget };

	                // In IE, we need to let the rest of the event stack complete before we detect
	                // changes to input, so using setTimeout here
	                setTimeout(function () {
	                    this.updateInput(eventObj.currentTarget, eventObj);
	                }.bind(this), 0);
	            }
	        },

	        handleKeyup: function (event) {
	            this.triggerCustomEvent('editableKeyup', event, event.currentTarget);
	        },

	        handleMouseover: function (event) {
	            this.triggerCustomEvent('editableMouseover', event, event.currentTarget);
	        },

	        handleDragging: function (event) {
	            this.triggerCustomEvent('editableDrag', event, event.currentTarget);
	        },

	        handleDrop: function (event) {
	            this.triggerCustomEvent('editableDrop', event, event.currentTarget);
	        },

	        handlePaste: function (event) {
	            this.triggerCustomEvent('editablePaste', event, event.currentTarget);
	        },

	        handleKeydown: function (event) {

	            this.triggerCustomEvent('editableKeydown', event, event.currentTarget);

	            if (MediumEditor.util.isKey(event, MediumEditor.util.keyCode.SPACE)) {
	                return this.triggerCustomEvent('editableKeydownSpace', event, event.currentTarget);
	            }

	            if (MediumEditor.util.isKey(event, MediumEditor.util.keyCode.ENTER) || (event.ctrlKey && MediumEditor.util.isKey(event, MediumEditor.util.keyCode.M))) {
	                return this.triggerCustomEvent('editableKeydownEnter', event, event.currentTarget);
	            }

	            if (MediumEditor.util.isKey(event, MediumEditor.util.keyCode.TAB)) {
	                return this.triggerCustomEvent('editableKeydownTab', event, event.currentTarget);
	            }

	            if (MediumEditor.util.isKey(event, [MediumEditor.util.keyCode.DELETE, MediumEditor.util.keyCode.BACKSPACE])) {
	                return this.triggerCustomEvent('editableKeydownDelete', event, event.currentTarget);
	            }
	        }
	    };

	    MediumEditor.Events = Events;
	}());

	(function () {
	    'use strict';

	    var Button = MediumEditor.Extension.extend({

	        /* Button Options */

	        /* action: [string]
	         * The action argument to pass to MediumEditor.execAction()
	         * when the button is clicked
	         */
	        action: undefined,

	        /* aria: [string]
	         * The value to add as the aria-label attribute of the button
	         * element displayed in the toolbar.
	         * This is also used as the tooltip for the button
	         */
	        aria: undefined,

	        /* tagNames: [Array]
	         * NOTE: This is not used if useQueryState is set to true.
	         *
	         * Array of element tag names that would indicate that this
	         * button has already been applied. If this action has already
	         * been applied, the button will be displayed as 'active' in the toolbar
	         *
	         * Example:
	         * For 'bold', if the text is ever within a <b> or <strong>
	         * tag that indicates the text is already bold. So the array
	         * of tagNames for bold would be: ['b', 'strong']
	         */
	        tagNames: undefined,

	        /* style: [Object]
	         * NOTE: This is not used if useQueryState is set to true.
	         *
	         * A pair of css property & value(s) that indicate that this
	         * button has already been applied. If this action has already
	         * been applied, the button will be displayed as 'active' in the toolbar
	         * Properties of the object:
	         *   prop [String]: name of the css property
	         *   value [String]: value(s) of the css property
	         *                   multiple values can be separated by a '|'
	         *
	         * Example:
	         * For 'bold', if the text is ever within an element with a 'font-weight'
	         * style property set to '700' or 'bold', that indicates the text
	         * is already bold.  So the style object for bold would be:
	         * { prop: 'font-weight', value: '700|bold' }
	         */
	        style: undefined,

	        /* useQueryState: [boolean]
	         * Enables/disables whether this button should use the built-in
	         * document.queryCommandState() method to determine whether
	         * the action has already been applied.  If the action has already
	         * been applied, the button will be displayed as 'active' in the toolbar
	         *
	         * Example:
	         * For 'bold', if this is set to true, the code will call:
	         * document.queryCommandState('bold') which will return true if the
	         * browser thinks the text is already bold, and false otherwise
	         */
	        useQueryState: undefined,

	        /* contentDefault: [string]
	         * Default innerHTML to put inside the button
	         */
	        contentDefault: undefined,

	        /* contentFA: [string]
	         * The innerHTML to use for the content of the button
	         * if the `buttonLabels` option for MediumEditor is set to 'fontawesome'
	         */
	        contentFA: undefined,

	        /* classList: [Array]
	         * An array of classNames (strings) to be added to the button
	         */
	        classList: undefined,

	        /* attrs: [object]
	         * A set of key-value pairs to add to the button as custom attributes
	         */
	        attrs: undefined,

	        // The button constructor can optionally accept the name of a built-in button
	        // (ie 'bold', 'italic', etc.)
	        // When the name of a button is passed, it will initialize itself with the
	        // configuration for that button
	        constructor: function (options) {
	            if (Button.isBuiltInButton(options)) {
	                MediumEditor.Extension.call(this, this.defaults[options]);
	            } else {
	                MediumEditor.Extension.call(this, options);
	            }
	        },

	        init: function () {
	            MediumEditor.Extension.prototype.init.apply(this, arguments);

	            this.button = this.createButton();
	            this.on(this.button, 'click', this.handleClick.bind(this));
	        },

	        /* getButton: [function ()]
	         *
	         * If implemented, this function will be called when
	         * the toolbar is being created.  The DOM Element returned
	         * by this function will be appended to the toolbar along
	         * with any other buttons.
	         */
	        getButton: function () {
	            return this.button;
	        },

	        getAction: function () {
	            return (typeof this.action === 'function') ? this.action(this.base.options) : this.action;
	        },

	        getAria: function () {
	            return (typeof this.aria === 'function') ? this.aria(this.base.options) : this.aria;
	        },

	        getTagNames: function () {
	            return (typeof this.tagNames === 'function') ? this.tagNames(this.base.options) : this.tagNames;
	        },

	        createButton: function () {
	            var button = this.document.createElement('button'),
	                content = this.contentDefault,
	                ariaLabel = this.getAria(),
	                buttonLabels = this.getEditorOption('buttonLabels');
	            // Add class names
	            button.classList.add('medium-editor-action');
	            button.classList.add('medium-editor-action-' + this.name);
	            if (this.classList) {
	                this.classList.forEach(function (className) {
	                    button.classList.add(className);
	                });
	            }

	            // Add attributes
	            button.setAttribute('data-action', this.getAction());
	            if (ariaLabel) {
	                button.setAttribute('title', ariaLabel);
	                button.setAttribute('aria-label', ariaLabel);
	            }
	            if (this.attrs) {
	                Object.keys(this.attrs).forEach(function (attr) {
	                    button.setAttribute(attr, this.attrs[attr]);
	                }, this);
	            }

	            if (buttonLabels === 'fontawesome' && this.contentFA) {
	                content = this.contentFA;
	            }
	            button.innerHTML = content;
	            return button;
	        },

	        handleClick: function (event) {
	            event.preventDefault();
	            event.stopPropagation();

	            var action = this.getAction();

	            if (action) {
	                this.execAction(action);
	            }
	        },

	        isActive: function () {
	            return this.button.classList.contains(this.getEditorOption('activeButtonClass'));
	        },

	        setInactive: function () {
	            this.button.classList.remove(this.getEditorOption('activeButtonClass'));
	            delete this.knownState;
	        },

	        setActive: function () {
	            this.button.classList.add(this.getEditorOption('activeButtonClass'));
	            delete this.knownState;
	        },

	        queryCommandState: function () {
	            var queryState = null;
	            if (this.useQueryState) {
	                queryState = this.base.queryCommandState(this.getAction());
	            }
	            return queryState;
	        },

	        isAlreadyApplied: function (node) {
	            var isMatch = false,
	                tagNames = this.getTagNames(),
	                styleVals,
	                computedStyle;

	            if (this.knownState === false || this.knownState === true) {
	                return this.knownState;
	            }

	            if (tagNames && tagNames.length > 0) {
	                isMatch = tagNames.indexOf(node.nodeName.toLowerCase()) !== -1;
	            }

	            if (!isMatch && this.style) {
	                styleVals = this.style.value.split('|');
	                computedStyle = this.window.getComputedStyle(node, null).getPropertyValue(this.style.prop);
	                styleVals.forEach(function (val) {
	                    if (!this.knownState) {
	                        isMatch = (computedStyle.indexOf(val) !== -1);
	                        // text-decoration is not inherited by default
	                        // so if the computed style for text-decoration doesn't match
	                        // don't write to knownState so we can fallback to other checks
	                        if (isMatch || this.style.prop !== 'text-decoration') {
	                            this.knownState = isMatch;
	                        }
	                    }
	                }, this);
	            }

	            return isMatch;
	        }
	    });

	    Button.isBuiltInButton = function (name) {
	        return (typeof name === 'string') && MediumEditor.extensions.button.prototype.defaults.hasOwnProperty(name);
	    };

	    MediumEditor.extensions.button = Button;
	}());

	(function () {
	    'use strict';

	    /* MediumEditor.extensions.button.defaults: [Object]
	     * Set of default config options for all of the built-in MediumEditor buttons
	     */
	    MediumEditor.extensions.button.prototype.defaults = {
	        'bold': {
	            name: 'bold',
	            action: 'bold',
	            aria: 'bold',
	            tagNames: ['b', 'strong'],
	            style: {
	                prop: 'font-weight',
	                value: '700|bold'
	            },
	            useQueryState: true,
	            contentDefault: '<b>B</b>',
	            contentFA: '<i class="fa fa-bold"></i>'
	        },
	        'italic': {
	            name: 'italic',
	            action: 'italic',
	            aria: 'italic',
	            tagNames: ['i', 'em'],
	            style: {
	                prop: 'font-style',
	                value: 'italic'
	            },
	            useQueryState: true,
	            contentDefault: '<b><i>I</i></b>',
	            contentFA: '<i class="fa fa-italic"></i>'
	        },
	        'underline': {
	            name: 'underline',
	            action: 'underline',
	            aria: 'underline',
	            tagNames: ['u'],
	            style: {
	                prop: 'text-decoration',
	                value: 'underline'
	            },
	            useQueryState: true,
	            contentDefault: '<b><u>U</u></b>',
	            contentFA: '<i class="fa fa-underline"></i>'
	        },
	        'strikethrough': {
	            name: 'strikethrough',
	            action: 'strikethrough',
	            aria: 'strike through',
	            tagNames: ['strike'],
	            style: {
	                prop: 'text-decoration',
	                value: 'line-through'
	            },
	            useQueryState: true,
	            contentDefault: '<s>A</s>',
	            contentFA: '<i class="fa fa-strikethrough"></i>'
	        },
	        'superscript': {
	            name: 'superscript',
	            action: 'superscript',
	            aria: 'superscript',
	            tagNames: ['sup'],
	            /* firefox doesn't behave the way we want it to, so we CAN'T use queryCommandState for superscript
	               https://github.com/guardian/scribe/blob/master/BROWSERINCONSISTENCIES.md#documentquerycommandstate */
	            // useQueryState: true
	            contentDefault: '<b>x<sup>1</sup></b>',
	            contentFA: '<i class="fa fa-superscript"></i>'
	        },
	        'subscript': {
	            name: 'subscript',
	            action: 'subscript',
	            aria: 'subscript',
	            tagNames: ['sub'],
	            /* firefox doesn't behave the way we want it to, so we CAN'T use queryCommandState for subscript
	               https://github.com/guardian/scribe/blob/master/BROWSERINCONSISTENCIES.md#documentquerycommandstate */
	            // useQueryState: true
	            contentDefault: '<b>x<sub>1</sub></b>',
	            contentFA: '<i class="fa fa-subscript"></i>'
	        },
	        'image': {
	            name: 'image',
	            action: 'image',
	            aria: 'image',
	            tagNames: ['img'],
	            contentDefault: '<b>image</b>',
	            contentFA: '<i class="fa fa-picture-o"></i>'
	        },
	        'orderedlist': {
	            name: 'orderedlist',
	            action: 'insertorderedlist',
	            aria: 'ordered list',
	            tagNames: ['ol'],
	            useQueryState: true,
	            contentDefault: '<b>1.</b>',
	            contentFA: '<i class="fa fa-list-ol"></i>'
	        },
	        'unorderedlist': {
	            name: 'unorderedlist',
	            action: 'insertunorderedlist',
	            aria: 'unordered list',
	            tagNames: ['ul'],
	            useQueryState: true,
	            contentDefault: '<b>&bull;</b>',
	            contentFA: '<i class="fa fa-list-ul"></i>'
	        },
	        'indent': {
	            name: 'indent',
	            action: 'indent',
	            aria: 'indent',
	            tagNames: [],
	            contentDefault: '<b>&rarr;</b>',
	            contentFA: '<i class="fa fa-indent"></i>'
	        },
	        'outdent': {
	            name: 'outdent',
	            action: 'outdent',
	            aria: 'outdent',
	            tagNames: [],
	            contentDefault: '<b>&larr;</b>',
	            contentFA: '<i class="fa fa-outdent"></i>'
	        },
	        'justifyCenter': {
	            name: 'justifyCenter',
	            action: 'justifyCenter',
	            aria: 'center justify',
	            tagNames: [],
	            style: {
	                prop: 'text-align',
	                value: 'center'
	            },
	            contentDefault: '<b>C</b>',
	            contentFA: '<i class="fa fa-align-center"></i>'
	        },
	        'justifyFull': {
	            name: 'justifyFull',
	            action: 'justifyFull',
	            aria: 'full justify',
	            tagNames: [],
	            style: {
	                prop: 'text-align',
	                value: 'justify'
	            },
	            contentDefault: '<b>J</b>',
	            contentFA: '<i class="fa fa-align-justify"></i>'
	        },
	        'justifyLeft': {
	            name: 'justifyLeft',
	            action: 'justifyLeft',
	            aria: 'left justify',
	            tagNames: [],
	            style: {
	                prop: 'text-align',
	                value: 'left'
	            },
	            contentDefault: '<b>L</b>',
	            contentFA: '<i class="fa fa-align-left"></i>'
	        },
	        'justifyRight': {
	            name: 'justifyRight',
	            action: 'justifyRight',
	            aria: 'right justify',
	            tagNames: [],
	            style: {
	                prop: 'text-align',
	                value: 'right'
	            },
	            contentDefault: '<b>R</b>',
	            contentFA: '<i class="fa fa-align-right"></i>'
	        },
	        // Known inline elements that are not removed, or not removed consistantly across browsers:
	        // <span>, <label>, <br>
	        'removeFormat': {
	            name: 'removeFormat',
	            aria: 'remove formatting',
	            action: 'removeFormat',
	            contentDefault: '<b>X</b>',
	            contentFA: '<i class="fa fa-eraser"></i>'
	        },

	        /***** Buttons for appending block elements (append-<element> action) *****/

	        'quote': {
	            name: 'quote',
	            action: 'append-blockquote',
	            aria: 'blockquote',
	            tagNames: ['blockquote'],
	            contentDefault: '<b>&ldquo;</b>',
	            contentFA: '<i class="fa fa-quote-right"></i>'
	        },
	        'pre': {
	            name: 'pre',
	            action: 'append-pre',
	            aria: 'preformatted text',
	            tagNames: ['pre'],
	            contentDefault: '<b>0101</b>',
	            contentFA: '<i class="fa fa-code fa-lg"></i>'
	        },
	        'h1': {
	            name: 'h1',
	            action: 'append-h1',
	            aria: 'header type one',
	            tagNames: ['h1'],
	            contentDefault: '<b>H1</b>',
	            contentFA: '<i class="fa fa-header"><sup>1</sup>'
	        },
	        'h2': {
	            name: 'h2',
	            action: 'append-h2',
	            aria: 'header type two',
	            tagNames: ['h2'],
	            contentDefault: '<b>H2</b>',
	            contentFA: '<i class="fa fa-header"><sup>2</sup>'
	        },
	        'h3': {
	            name: 'h3',
	            action: 'append-h3',
	            aria: 'header type three',
	            tagNames: ['h3'],
	            contentDefault: '<b>H3</b>',
	            contentFA: '<i class="fa fa-header"><sup>3</sup>'
	        },
	        'h4': {
	            name: 'h4',
	            action: 'append-h4',
	            aria: 'header type four',
	            tagNames: ['h4'],
	            contentDefault: '<b>H4</b>',
	            contentFA: '<i class="fa fa-header"><sup>4</sup>'
	        },
	        'h5': {
	            name: 'h5',
	            action: 'append-h5',
	            aria: 'header type five',
	            tagNames: ['h5'],
	            contentDefault: '<b>H5</b>',
	            contentFA: '<i class="fa fa-header"><sup>5</sup>'
	        },
	        'h6': {
	            name: 'h6',
	            action: 'append-h6',
	            aria: 'header type six',
	            tagNames: ['h6'],
	            contentDefault: '<b>H6</b>',
	            contentFA: '<i class="fa fa-header"><sup>6</sup>'
	        }
	    };

	})();
	(function () {
	    'use strict';

	    /* Base functionality for an extension which will display
	     * a 'form' inside the toolbar
	     */
	    var FormExtension = MediumEditor.extensions.button.extend({

	        init: function () {
	            MediumEditor.extensions.button.prototype.init.apply(this, arguments);
	        },

	        // default labels for the form buttons
	        formSaveLabel: '&#10003;',
	        formCloseLabel: '&times;',

	        /* activeClass: [string]
	         * set class which added to shown form
	         */
	        activeClass: 'medium-editor-toolbar-form-active',

	        /* hasForm: [boolean]
	         *
	         * Setting this to true will cause getForm() to be called
	         * when the toolbar is created, so the form can be appended
	         * inside the toolbar container
	         */
	        hasForm: true,

	        /* getForm: [function ()]
	         *
	         * When hasForm is true, this function must be implemented
	         * and return a DOM Element which will be appended to
	         * the toolbar container. The form should start hidden, and
	         * the extension can choose when to hide/show it
	         */
	        getForm: function () {},

	        /* isDisplayed: [function ()]
	         *
	         * This function should return true/false reflecting
	         * whether the form is currently displayed
	         */
	        isDisplayed: function () {
	            if (this.hasForm) {
	                return this.getForm().classList.contains(this.activeClass);
	            }
	            return false;
	        },

	        /* hideForm: [function ()]
	         *
	         * This function should show the form element inside
	         * the toolbar container
	         */
	        showForm: function () {
	            if (this.hasForm) {
	                this.getForm().classList.add(this.activeClass);
	            }
	        },

	        /* hideForm: [function ()]
	         *
	         * This function should hide the form element inside
	         * the toolbar container
	         */
	        hideForm: function () {
	            if (this.hasForm) {
	                this.getForm().classList.remove(this.activeClass);
	            }
	        },

	        /************************ Helpers ************************
	         * The following are helpers that are either set by MediumEditor
	         * during initialization, or are helper methods which either
	         * route calls to the MediumEditor instance or provide common
	         * functionality for all form extensions
	         *********************************************************/

	        /* showToolbarDefaultActions: [function ()]
	         *
	         * Helper method which will turn back the toolbar after canceling
	         * the customized form
	         */
	        showToolbarDefaultActions: function () {
	            var toolbar = this.base.getExtensionByName('toolbar');
	            if (toolbar) {
	                toolbar.showToolbarDefaultActions();
	            }
	        },

	        /* hideToolbarDefaultActions: [function ()]
	         *
	         * Helper function which will hide the default contents of the
	         * toolbar, but leave the toolbar container in the same state
	         * to allow a form to display its custom contents inside the toolbar
	         */
	        hideToolbarDefaultActions: function () {
	            var toolbar = this.base.getExtensionByName('toolbar');
	            if (toolbar) {
	                toolbar.hideToolbarDefaultActions();
	            }
	        },

	        /* setToolbarPosition: [function ()]
	         *
	         * Helper function which will update the size and position
	         * of the toolbar based on the toolbar content and the current
	         * position of the user's selection
	         */
	        setToolbarPosition: function () {
	            var toolbar = this.base.getExtensionByName('toolbar');
	            if (toolbar) {
	                toolbar.setToolbarPosition();
	            }
	        }
	    });

	    MediumEditor.extensions.form = FormExtension;
	})();
	(function () {
	    'use strict';

	    var AnchorForm = MediumEditor.extensions.form.extend({
	        /* Anchor Form Options */

	        /* customClassOption: [string]  (previously options.anchorButton + options.anchorButtonClass)
	         * Custom class name the user can optionally have added to their created links (ie 'button').
	         * If passed as a non-empty string, a checkbox will be displayed allowing the user to choose
	         * whether to have the class added to the created link or not.
	         */
	        customClassOption: null,

	        /* customClassOptionText: [string]
	         * text to be shown in the checkbox when the __customClassOption__ is being used.
	         */
	        customClassOptionText: 'Button',

	        /* linkValidation: [boolean]  (previously options.checkLinkFormat)
	         * enables/disables check for common URL protocols on anchor links.
	         */
	        linkValidation: false,

	        /* placeholderText: [string]  (previously options.anchorInputPlaceholder)
	         * text to be shown as placeholder of the anchor input.
	         */
	        placeholderText: 'Paste or type a link',

	        /* targetCheckbox: [boolean]  (previously options.anchorTarget)
	         * enables/disables displaying a "Open in new window" checkbox, which when checked
	         * changes the `target` attribute of the created link.
	         */
	        targetCheckbox: false,

	        /* targetCheckboxText: [string]  (previously options.anchorInputCheckboxLabel)
	         * text to be shown in the checkbox enabled via the __targetCheckbox__ option.
	         */
	        targetCheckboxText: 'Open in new window',

	        // Options for the Button base class
	        name: 'anchor',
	        action: 'createLink',
	        aria: 'link',
	        tagNames: ['a'],
	        contentDefault: '<b>#</b>',
	        contentFA: '<i class="fa fa-link"></i>',

	        init: function () {
	            MediumEditor.extensions.form.prototype.init.apply(this, arguments);

	            this.subscribe('editableKeydown', this.handleKeydown.bind(this));
	        },

	        // Called when the button the toolbar is clicked
	        // Overrides ButtonExtension.handleClick
	        handleClick: function (event) {
	            event.preventDefault();
	            event.stopPropagation();

	            var range = MediumEditor.selection.getSelectionRange(this.document);

	            if (range.startContainer.nodeName.toLowerCase() === 'a' ||
	                range.endContainer.nodeName.toLowerCase() === 'a' ||
	                MediumEditor.util.getClosestTag(MediumEditor.selection.getSelectedParentElement(range), 'a')) {
	                return this.execAction('unlink');
	            }

	            if (!this.isDisplayed()) {
	                this.showForm();
	            }

	            return false;
	        },

	        // Called when user hits the defined shortcut (CTRL / COMMAND + K)
	        handleKeydown: function (event) {
	            if (MediumEditor.util.isKey(event, MediumEditor.util.keyCode.K) && MediumEditor.util.isMetaCtrlKey(event) && !event.shiftKey) {
	                this.handleClick(event);
	            }
	        },

	        // Called by medium-editor to append form to the toolbar
	        getForm: function () {
	            if (!this.form) {
	                this.form = this.createForm();
	            }
	            return this.form;
	        },

	        getTemplate: function () {
	            var template = [
	                '<input type="text" class="medium-editor-toolbar-input" placeholder="', this.placeholderText, '">'
	            ];

	            template.push(
	                '<a href="#" class="medium-editor-toolbar-save">',
	                this.getEditorOption('buttonLabels') === 'fontawesome' ? '<i class="fa fa-check"></i>' : this.formSaveLabel,
	                '</a>'
	            );

	            template.push('<a href="#" class="medium-editor-toolbar-close">',
	                this.getEditorOption('buttonLabels') === 'fontawesome' ? '<i class="fa fa-times"></i>' : this.formCloseLabel,
	                '</a>');

	            // both of these options are slightly moot with the ability to
	            // override the various form buildup/serialize functions.

	            if (this.targetCheckbox) {
	                // fixme: ideally, this targetCheckboxText would be a formLabel too,
	                // figure out how to deprecate? also consider `fa-` icon default implcations.
	                template.push(
	                    '<div class="medium-editor-toolbar-form-row">',
	                    '<input type="checkbox" class="medium-editor-toolbar-anchor-target">',
	                    '<label>',
	                    this.targetCheckboxText,
	                    '</label>',
	                    '</div>'
	                );
	            }

	            if (this.customClassOption) {
	                // fixme: expose this `Button` text as a formLabel property, too
	                // and provide similar access to a `fa-` icon default.
	                template.push(
	                    '<div class="medium-editor-toolbar-form-row">',
	                    '<input type="checkbox" class="medium-editor-toolbar-anchor-button">',
	                    '<label>',
	                    this.customClassOptionText,
	                    '</label>',
	                    '</div>'
	                );
	            }

	            return template.join('');

	        },

	        // Used by medium-editor when the default toolbar is to be displayed
	        isDisplayed: function () {
	            return MediumEditor.extensions.form.prototype.isDisplayed.apply(this);
	        },

	        hideForm: function () {
	            MediumEditor.extensions.form.prototype.hideForm.apply(this);
	            this.getInput().value = '';
	        },

	        showForm: function (opts) {
	            var input = this.getInput(),
	                targetCheckbox = this.getAnchorTargetCheckbox(),
	                buttonCheckbox = this.getAnchorButtonCheckbox();

	            opts = opts || { value: '' };
	            // TODO: This is for backwards compatability
	            // We don't need to support the 'string' argument in 6.0.0
	            if (typeof opts === 'string') {
	                opts = {
	                    value: opts
	                };
	            }

	            this.base.saveSelection();
	            this.hideToolbarDefaultActions();
	            MediumEditor.extensions.form.prototype.showForm.apply(this);
	            this.setToolbarPosition();

	            input.value = opts.value;
	            input.focus();

	            // If we have a target checkbox, we want it to be checked/unchecked
	            // based on whether the existing link has target=_blank
	            if (targetCheckbox) {
	                targetCheckbox.checked = opts.target === '_blank';
	            }

	            // If we have a custom class checkbox, we want it to be checked/unchecked
	            // based on whether an existing link already has the class
	            if (buttonCheckbox) {
	                var classList = opts.buttonClass ? opts.buttonClass.split(' ') : [];
	                buttonCheckbox.checked = (classList.indexOf(this.customClassOption) !== -1);
	            }
	        },

	        // Called by core when tearing down medium-editor (destroy)
	        destroy: function () {
	            if (!this.form) {
	                return false;
	            }

	            if (this.form.parentNode) {
	                this.form.parentNode.removeChild(this.form);
	            }

	            delete this.form;
	        },

	        // core methods

	        getFormOpts: function () {
	            // no notion of private functions? wanted `_getFormOpts`
	            var targetCheckbox = this.getAnchorTargetCheckbox(),
	                buttonCheckbox = this.getAnchorButtonCheckbox(),
	                opts = {
	                    value: this.getInput().value.trim()
	                };

	            if (this.linkValidation) {
	                opts.value = this.checkLinkFormat(opts.value);
	            }

	            opts.target = '_self';
	            if (targetCheckbox && targetCheckbox.checked) {
	                opts.target = '_blank';
	            }

	            if (buttonCheckbox && buttonCheckbox.checked) {
	                opts.buttonClass = this.customClassOption;
	            }

	            return opts;
	        },

	        doFormSave: function () {
	            var opts = this.getFormOpts();
	            this.completeFormSave(opts);
	        },

	        completeFormSave: function (opts) {
	            this.base.restoreSelection();
	            this.execAction(this.action, opts);
	            this.base.checkSelection();
	        },

	        checkLinkFormat: function (value) {
	            // Matches any alphabetical characters followed by ://
	            // Matches protocol relative "//"
	            // Matches common external protocols "mailto:" "tel:" "maps:"
	            var urlSchemeRegex = /^([a-z]+:)?\/\/|^(mailto|tel|maps):/i,
	            // var te is a regex for checking if the string is a telephone number
	            telRegex = /^\+?\s?\(?(?:\d\s?\-?\)?){3,20}$/;
	            if (telRegex.test(value)) {
	                return 'tel:' + value;
	            } else {
	                // Check for URL scheme and default to http:// if none found
	                return (urlSchemeRegex.test(value) ? '' : 'http://') + encodeURI(value);
	            }
	        },

	        doFormCancel: function () {
	            this.base.restoreSelection();
	            this.base.checkSelection();
	        },

	        // form creation and event handling
	        attachFormEvents: function (form) {
	            var close = form.querySelector('.medium-editor-toolbar-close'),
	                save = form.querySelector('.medium-editor-toolbar-save'),
	                input = form.querySelector('.medium-editor-toolbar-input');

	            // Handle clicks on the form itself
	            this.on(form, 'click', this.handleFormClick.bind(this));

	            // Handle typing in the textbox
	            this.on(input, 'keyup', this.handleTextboxKeyup.bind(this));

	            // Handle close button clicks
	            this.on(close, 'click', this.handleCloseClick.bind(this));

	            // Handle save button clicks (capture)
	            this.on(save, 'click', this.handleSaveClick.bind(this), true);

	        },

	        createForm: function () {
	            var doc = this.document,
	                form = doc.createElement('div');

	            // Anchor Form (div)
	            form.className = 'medium-editor-toolbar-form';
	            form.id = 'medium-editor-toolbar-form-anchor-' + this.getEditorId();
	            form.innerHTML = this.getTemplate();
	            this.attachFormEvents(form);

	            return form;
	        },

	        getInput: function () {
	            return this.getForm().querySelector('input.medium-editor-toolbar-input');
	        },

	        getAnchorTargetCheckbox: function () {
	            return this.getForm().querySelector('.medium-editor-toolbar-anchor-target');
	        },

	        getAnchorButtonCheckbox: function () {
	            return this.getForm().querySelector('.medium-editor-toolbar-anchor-button');
	        },

	        handleTextboxKeyup: function (event) {
	            // For ENTER -> create the anchor
	            if (event.keyCode === MediumEditor.util.keyCode.ENTER) {
	                event.preventDefault();
	                this.doFormSave();
	                return;
	            }

	            // For ESCAPE -> close the form
	            if (event.keyCode === MediumEditor.util.keyCode.ESCAPE) {
	                event.preventDefault();
	                this.doFormCancel();
	            }
	        },

	        handleFormClick: function (event) {
	            // make sure not to hide form when clicking inside the form
	            event.stopPropagation();
	        },

	        handleSaveClick: function (event) {
	            // Clicking Save -> create the anchor
	            event.preventDefault();
	            this.doFormSave();
	        },

	        handleCloseClick: function (event) {
	            // Click Close -> close the form
	            event.preventDefault();
	            this.doFormCancel();
	        }
	    });

	    MediumEditor.extensions.anchor = AnchorForm;
	}());

	(function () {
	    'use strict';

	    var AnchorPreview = MediumEditor.Extension.extend({
	        name: 'anchor-preview',

	        // Anchor Preview Options

	        /* hideDelay: [number]  (previously options.anchorPreviewHideDelay)
	         * time in milliseconds to show the anchor tag preview after the mouse has left the anchor tag.
	         */
	        hideDelay: 500,

	        /* previewValueSelector: [string]
	         * the default selector to locate where to put the activeAnchor value in the preview
	         */
	        previewValueSelector: 'a',

	        /* showWhenToolbarIsVisible: [boolean]
	         * determines whether the anchor tag preview shows up when the toolbar is visible
	         */
	        showWhenToolbarIsVisible: false,

	        init: function () {
	            this.anchorPreview = this.createPreview();

	            this.getEditorOption('elementsContainer').appendChild(this.anchorPreview);

	            this.attachToEditables();
	        },

	        getPreviewElement: function () {
	            return this.anchorPreview;
	        },

	        createPreview: function () {
	            var el = this.document.createElement('div');

	            el.id = 'medium-editor-anchor-preview-' + this.getEditorId();
	            el.className = 'medium-editor-anchor-preview';
	            el.innerHTML = this.getTemplate();

	            this.on(el, 'click', this.handleClick.bind(this));

	            return el;
	        },

	        getTemplate: function () {
	            return '<div class="medium-editor-toolbar-anchor-preview" id="medium-editor-toolbar-anchor-preview">' +
	                '    <a class="medium-editor-toolbar-anchor-preview-inner"></a>' +
	                '</div>';
	        },

	        destroy: function () {
	            if (this.anchorPreview) {
	                if (this.anchorPreview.parentNode) {
	                    this.anchorPreview.parentNode.removeChild(this.anchorPreview);
	                }
	                delete this.anchorPreview;
	            }
	        },

	        hidePreview: function () {
	            this.anchorPreview.classList.remove('medium-editor-anchor-preview-active');
	            this.activeAnchor = null;
	        },

	        showPreview: function (anchorEl) {
	            if (this.anchorPreview.classList.contains('medium-editor-anchor-preview-active') ||
	                    anchorEl.getAttribute('data-disable-preview')) {
	                return true;
	            }

	            if (this.previewValueSelector) {
	                this.anchorPreview.querySelector(this.previewValueSelector).textContent = anchorEl.attributes.href.value;
	                this.anchorPreview.querySelector(this.previewValueSelector).href = anchorEl.attributes.href.value;
	            }

	            this.anchorPreview.classList.add('medium-toolbar-arrow-over');
	            this.anchorPreview.classList.remove('medium-toolbar-arrow-under');

	            if (!this.anchorPreview.classList.contains('medium-editor-anchor-preview-active')) {
	                this.anchorPreview.classList.add('medium-editor-anchor-preview-active');
	            }

	            this.activeAnchor = anchorEl;

	            this.positionPreview();
	            this.attachPreviewHandlers();

	            return this;
	        },

	        positionPreview: function (activeAnchor) {
	            activeAnchor = activeAnchor || this.activeAnchor;
	            var buttonHeight = this.anchorPreview.offsetHeight,
	                boundary = activeAnchor.getBoundingClientRect(),
	                middleBoundary = (boundary.left + boundary.right) / 2,
	                diffLeft = this.diffLeft,
	                diffTop = this.diffTop,
	                halfOffsetWidth,
	                defaultLeft;

	            halfOffsetWidth = this.anchorPreview.offsetWidth / 2;
	            var toolbarExtension = this.base.getExtensionByName('toolbar');
	            if (toolbarExtension) {
	                diffLeft = toolbarExtension.diffLeft;
	                diffTop = toolbarExtension.diffTop;
	            }
	            defaultLeft = diffLeft - halfOffsetWidth;

	            this.anchorPreview.style.top = Math.round(buttonHeight + boundary.bottom - diffTop + this.window.pageYOffset - this.anchorPreview.offsetHeight) + 'px';
	            this.anchorPreview.style.right = 'initial';
	            if (middleBoundary < halfOffsetWidth) {
	                this.anchorPreview.style.left = defaultLeft + halfOffsetWidth + 'px';
	                this.anchorPreview.style.right = 'initial';
	            } else if ((this.window.innerWidth - middleBoundary) < halfOffsetWidth) {
	                this.anchorPreview.style.left = 'auto';
	                this.anchorPreview.style.right = 0;
	            } else {
	                this.anchorPreview.style.left = defaultLeft + middleBoundary + 'px';
	                this.anchorPreview.style.right = 'initial';
	            }
	        },

	        attachToEditables: function () {
	            this.subscribe('editableMouseover', this.handleEditableMouseover.bind(this));
	            this.subscribe('positionedToolbar', this.handlePositionedToolbar.bind(this));
	        },

	        handlePositionedToolbar: function () {
	            // If the toolbar is visible and positioned, we don't need to hide the preview
	            // when showWhenToolbarIsVisible is true
	            if (!this.showWhenToolbarIsVisible) {
	                this.hidePreview();
	            }
	        },

	        handleClick: function (event) {
	            var anchorExtension = this.base.getExtensionByName('anchor'),
	                activeAnchor = this.activeAnchor;

	            if (anchorExtension && activeAnchor) {
	                event.preventDefault();

	                this.base.selectElement(this.activeAnchor);

	                // Using setTimeout + delay because:
	                // We may actually be displaying the anchor form, which should be controlled by delay
	                this.base.delay(function () {
	                    if (activeAnchor) {
	                        var opts = {
	                            url: activeAnchor.attributes.href.value,
	                            target: activeAnchor.getAttribute('target'),
	                            buttonClass: activeAnchor.getAttribute('class')
	                        };
	                        anchorExtension.showForm(opts);
	                        activeAnchor = null;
	                    }
	                }.bind(this));
	            }

	            this.hidePreview();
	        },

	        handleAnchorMouseout: function () {
	            this.anchorToPreview = null;
	            this.off(this.activeAnchor, 'mouseout', this.instanceHandleAnchorMouseout);
	            this.instanceHandleAnchorMouseout = null;
	        },

	        handleEditableMouseover: function (event) {
	            var target = MediumEditor.util.getClosestTag(event.target, 'a');

	            if (false === target) {
	                return;
	            }

	            // Detect empty href attributes
	            // The browser will make href="" or href="#top"
	            // into absolute urls when accessed as event.target.href, so check the html
	            if (!/href=["']\S+["']/.test(target.outerHTML) || /href=["']#\S+["']/.test(target.outerHTML)) {
	                return true;
	            }

	            // only show when toolbar is not present
	            var toolbar = this.base.getExtensionByName('toolbar');
	            if (!this.showWhenToolbarIsVisible && toolbar && toolbar.isDisplayed && toolbar.isDisplayed()) {
	                return true;
	            }

	            // detach handler for other anchor in case we hovered multiple anchors quickly
	            if (this.activeAnchor && this.activeAnchor !== target) {
	                this.detachPreviewHandlers();
	            }

	            this.anchorToPreview = target;

	            this.instanceHandleAnchorMouseout = this.handleAnchorMouseout.bind(this);
	            this.on(this.anchorToPreview, 'mouseout', this.instanceHandleAnchorMouseout);
	            // Using setTimeout + delay because:
	            // - We're going to show the anchor preview according to the configured delay
	            //   if the mouse has not left the anchor tag in that time
	            this.base.delay(function () {
	                if (this.anchorToPreview) {
	                    this.showPreview(this.anchorToPreview);
	                }
	            }.bind(this));
	        },

	        handlePreviewMouseover: function () {
	            this.lastOver = (new Date()).getTime();
	            this.hovering = true;
	        },

	        handlePreviewMouseout: function (event) {
	            if (!event.relatedTarget || !/anchor-preview/.test(event.relatedTarget.className)) {
	                this.hovering = false;
	            }
	        },

	        updatePreview: function () {
	            if (this.hovering) {
	                return true;
	            }
	            var durr = (new Date()).getTime() - this.lastOver;
	            if (durr > this.hideDelay) {
	                // hide the preview 1/2 second after mouse leaves the link
	                this.detachPreviewHandlers();
	            }
	        },

	        detachPreviewHandlers: function () {
	            // cleanup
	            clearInterval(this.intervalTimer);
	            if (this.instanceHandlePreviewMouseover) {
	                this.off(this.anchorPreview, 'mouseover', this.instanceHandlePreviewMouseover);
	                this.off(this.anchorPreview, 'mouseout', this.instanceHandlePreviewMouseout);
	                if (this.activeAnchor) {
	                    this.off(this.activeAnchor, 'mouseover', this.instanceHandlePreviewMouseover);
	                    this.off(this.activeAnchor, 'mouseout', this.instanceHandlePreviewMouseout);
	                }
	            }

	            this.hidePreview();

	            this.hovering = this.instanceHandlePreviewMouseover = this.instanceHandlePreviewMouseout = null;
	        },

	        // TODO: break up method and extract out handlers
	        attachPreviewHandlers: function () {
	            this.lastOver = (new Date()).getTime();
	            this.hovering = true;

	            this.instanceHandlePreviewMouseover = this.handlePreviewMouseover.bind(this);
	            this.instanceHandlePreviewMouseout = this.handlePreviewMouseout.bind(this);

	            this.intervalTimer = setInterval(this.updatePreview.bind(this), 200);

	            this.on(this.anchorPreview, 'mouseover', this.instanceHandlePreviewMouseover);
	            this.on(this.anchorPreview, 'mouseout', this.instanceHandlePreviewMouseout);
	            this.on(this.activeAnchor, 'mouseover', this.instanceHandlePreviewMouseover);
	            this.on(this.activeAnchor, 'mouseout', this.instanceHandlePreviewMouseout);
	        }
	    });

	    MediumEditor.extensions.anchorPreview = AnchorPreview;
	}());

	(function () {
	    'use strict';

	    var WHITESPACE_CHARS,
	        KNOWN_TLDS_FRAGMENT,
	        LINK_REGEXP_TEXT,
	        KNOWN_TLDS_REGEXP;

	    WHITESPACE_CHARS = [' ', '\t', '\n', '\r', '\u00A0', '\u2000', '\u2001', '\u2002', '\u2003',
	                                    '\u2028', '\u2029'];
	    KNOWN_TLDS_FRAGMENT = 'com|net|org|edu|gov|mil|aero|asia|biz|cat|coop|info|int|jobs|mobi|museum|name|post|pro|tel|travel|' +
	        'xxx|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|' +
	        'bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cs|cu|cv|cx|cy|cz|dd|de|dj|dk|dm|do|dz|ec|ee|eg|eh|er|es|et|eu|fi|fj|' +
	        'fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|' +
	        'is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mm|' +
	        'mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|' +
	        'pt|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|ja|sk|sl|sm|sn|so|sr|ss|st|su|sv|sx|sy|sz|tc|td|tf|tg|th|' +
	        'tj|tk|tl|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|yu|za|zm|zw';

	    LINK_REGEXP_TEXT =
	        '(' +
	        // Version of Gruber URL Regexp optimized for JS: http://stackoverflow.com/a/17733640
	        '((?:(https?://|ftps?://|nntp://)|www\\d{0,3}[.]|[a-z0-9.\\-]+[.](' + KNOWN_TLDS_FRAGMENT + ')\\\/)\\S+(?:[^\\s`!\\[\\]{};:\'\".,?\u00AB\u00BB\u201C\u201D\u2018\u2019]))' +
	        // Addition to above Regexp to support bare domains/one level subdomains with common non-i18n TLDs and without www prefix:
	        ')|(([a-z0-9\\-]+\\.)?[a-z0-9\\-]+\\.(' + KNOWN_TLDS_FRAGMENT + '))';

	    KNOWN_TLDS_REGEXP = new RegExp('^(' + KNOWN_TLDS_FRAGMENT + ')$', 'i');

	    function nodeIsNotInsideAnchorTag(node) {
	        return !MediumEditor.util.getClosestTag(node, 'a');
	    }

	    var AutoLink = MediumEditor.Extension.extend({
	        init: function () {
	            MediumEditor.Extension.prototype.init.apply(this, arguments);

	            this.disableEventHandling = false;
	            this.subscribe('editableKeypress', this.onKeypress.bind(this));
	            this.subscribe('editableBlur', this.onBlur.bind(this));
	            // MS IE has it's own auto-URL detect feature but ours is better in some ways. Be consistent.
	            this.document.execCommand('AutoUrlDetect', false, false);
	        },

	        isLastInstance: function () {
	            var activeInstances = 0;
	            for (var i = 0; i < this.window._mediumEditors.length; i++) {
	                var editor = this.window._mediumEditors[i];
	                if (editor !== null && editor.getExtensionByName('autoLink') !== undefined) {
	                    activeInstances++;
	                }
	            }
	            return activeInstances === 1;
	        },

	        destroy: function () {
	            // Turn AutoUrlDetect back on
	            if (this.document.queryCommandSupported('AutoUrlDetect') && this.isLastInstance()) {
	                this.document.execCommand('AutoUrlDetect', false, true);
	            }
	        },

	        onBlur: function (blurEvent, editable) {
	            this.performLinking(editable);
	        },

	        onKeypress: function (keyPressEvent) {
	            if (this.disableEventHandling) {
	                return;
	            }

	            if (MediumEditor.util.isKey(keyPressEvent, [MediumEditor.util.keyCode.SPACE, MediumEditor.util.keyCode.ENTER])) {
	                clearTimeout(this.performLinkingTimeout);
	                // Saving/restoring the selection in the middle of a keypress doesn't work well...
	                this.performLinkingTimeout = setTimeout(function () {
	                    try {
	                        var sel = this.base.exportSelection();
	                        if (this.performLinking(keyPressEvent.target)) {
	                            // pass true for favorLaterSelectionAnchor - this is needed for links at the end of a
	                            // paragraph in MS IE, or MS IE causes the link to be deleted right after adding it.
	                            this.base.importSelection(sel, true);
	                        }
	                    } catch (e) {
	                        if (window.console) {
	                            window.console.error('Failed to perform linking', e);
	                        }
	                        this.disableEventHandling = true;
	                    }
	                }.bind(this), 0);
	            }
	        },

	        performLinking: function (contenteditable) {
	            /*
	            Perform linking on blockElement basis, blockElements are HTML elements with text content and without
	            child element.

	            Example:
	            - HTML content
	            <blockquote>
	              <p>link.</p>
	              <p>my</p>
	            </blockquote>

	            - blockElements
	            [<p>link.</p>, <p>my</p>]

	            otherwise the detection can wrongly find the end of one paragraph and the beginning of another paragraph
	            to constitute a link, such as a paragraph ending "link." and the next paragraph beginning with "my" is
	            interpreted into "link.my" and the code tries to create a link across blockElements - which doesn't work
	            and is terrible.
	            (Medium deletes the spaces/returns between P tags so the textContent ends up without paragraph spacing)
	            */
	            var blockElements = MediumEditor.util.splitByBlockElements(contenteditable),
	                documentModified = false;
	            if (blockElements.length === 0) {
	                blockElements = [contenteditable];
	            }
	            for (var i = 0; i < blockElements.length; i++) {
	                documentModified = this.removeObsoleteAutoLinkSpans(blockElements[i]) || documentModified;
	                documentModified = this.performLinkingWithinElement(blockElements[i]) || documentModified;
	            }
	            this.base.events.updateInput(contenteditable, { target: contenteditable, currentTarget: contenteditable });
	            return documentModified;
	        },

	        removeObsoleteAutoLinkSpans: function (element) {
	            if (!element || element.nodeType === 3) {
	                return false;
	            }

	            var spans = element.querySelectorAll('span[data-auto-link="true"]'),
	                documentModified = false;

	            for (var i = 0; i < spans.length; i++) {
	                var textContent = spans[i].textContent;
	                if (textContent.indexOf('://') === -1) {
	                    textContent = MediumEditor.util.ensureUrlHasProtocol(textContent);
	                }
	                if (spans[i].getAttribute('data-href') !== textContent && nodeIsNotInsideAnchorTag(spans[i])) {
	                    documentModified = true;
	                    var trimmedTextContent = textContent.replace(/\s+$/, '');
	                    if (spans[i].getAttribute('data-href') === trimmedTextContent) {
	                        var charactersTrimmed = textContent.length - trimmedTextContent.length,
	                            subtree = MediumEditor.util.splitOffDOMTree(spans[i], this.splitTextBeforeEnd(spans[i], charactersTrimmed));
	                        spans[i].parentNode.insertBefore(subtree, spans[i].nextSibling);
	                    } else {
	                        // Some editing has happened to the span, so just remove it entirely. The user can put it back
	                        // around just the href content if they need to prevent it from linking
	                        MediumEditor.util.unwrap(spans[i], this.document);
	                    }
	                }
	            }
	            return documentModified;
	        },

	        splitTextBeforeEnd: function (element, characterCount) {
	            var treeWalker = this.document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null, false),
	                lastChildNotExhausted = true;

	            // Start the tree walker at the last descendant of the span
	            while (lastChildNotExhausted) {
	                lastChildNotExhausted = treeWalker.lastChild() !== null;
	            }

	            var currentNode,
	                currentNodeValue,
	                previousNode;
	            while (characterCount > 0 && previousNode !== null) {
	                currentNode = treeWalker.currentNode;
	                currentNodeValue = currentNode.nodeValue;
	                if (currentNodeValue.length > characterCount) {
	                    previousNode = currentNode.splitText(currentNodeValue.length - characterCount);
	                    characterCount = 0;
	                } else {
	                    previousNode = treeWalker.previousNode();
	                    characterCount -= currentNodeValue.length;
	                }
	            }
	            return previousNode;
	        },

	        performLinkingWithinElement: function (element) {
	            var matches = this.findLinkableText(element),
	                linkCreated = false;

	            for (var matchIndex = 0; matchIndex < matches.length; matchIndex++) {
	                var matchingTextNodes = MediumEditor.util.findOrCreateMatchingTextNodes(this.document, element,
	                        matches[matchIndex]);
	                if (this.shouldNotLink(matchingTextNodes)) {
	                    continue;
	                }
	                this.createAutoLink(matchingTextNodes, matches[matchIndex].href);
	            }
	            return linkCreated;
	        },

	        shouldNotLink: function (textNodes) {
	            var shouldNotLink = false;
	            for (var i = 0; i < textNodes.length && shouldNotLink === false; i++) {
	                // Do not link if the text node is either inside an anchor or inside span[data-auto-link]
	                shouldNotLink = !!MediumEditor.util.traverseUp(textNodes[i], function (node) {
	                    return node.nodeName.toLowerCase() === 'a' ||
	                        (node.getAttribute && node.getAttribute('data-auto-link') === 'true');
	                });
	            }
	            return shouldNotLink;
	        },

	        findLinkableText: function (contenteditable) {
	            var linkRegExp = new RegExp(LINK_REGEXP_TEXT, 'gi'),
	                textContent = contenteditable.textContent,
	                match = null,
	                matches = [];

	            while ((match = linkRegExp.exec(textContent)) !== null) {
	                var matchOk = true,
	                    matchEnd = match.index + match[0].length;
	                // If the regexp detected something as a link that has text immediately preceding/following it, bail out.
	                matchOk = (match.index === 0 || WHITESPACE_CHARS.indexOf(textContent[match.index - 1]) !== -1) &&
	                    (matchEnd === textContent.length || WHITESPACE_CHARS.indexOf(textContent[matchEnd]) !== -1);
	                // If the regexp detected a bare domain that doesn't use one of our expected TLDs, bail out.
	                matchOk = matchOk && (match[0].indexOf('/') !== -1 ||
	                    KNOWN_TLDS_REGEXP.test(match[0].split('.').pop().split('?').shift()));

	                if (matchOk) {
	                    matches.push({
	                        href: match[0],
	                        start: match.index,
	                        end: matchEnd
	                    });
	                }
	            }
	            return matches;
	        },

	        createAutoLink: function (textNodes, href) {
	            href = MediumEditor.util.ensureUrlHasProtocol(href);
	            var anchor = MediumEditor.util.createLink(this.document, textNodes, href, this.getEditorOption('targetBlank') ? '_blank' : null),
	                span = this.document.createElement('span');
	            span.setAttribute('data-auto-link', 'true');
	            span.setAttribute('data-href', href);
	            anchor.insertBefore(span, anchor.firstChild);
	            while (anchor.childNodes.length > 1) {
	                span.appendChild(anchor.childNodes[1]);
	            }
	        }

	    });

	    MediumEditor.extensions.autoLink = AutoLink;
	}());

	(function () {
	    'use strict';

	    var CLASS_DRAG_OVER = 'medium-editor-dragover';

	    function clearClassNames(element) {
	        var editable = MediumEditor.util.getContainerEditorElement(element),
	            existing = Array.prototype.slice.call(editable.parentElement.querySelectorAll('.' + CLASS_DRAG_OVER));

	        existing.forEach(function (el) {
	            el.classList.remove(CLASS_DRAG_OVER);
	        });
	    }

	    var FileDragging = MediumEditor.Extension.extend({
	        name: 'fileDragging',

	        allowedTypes: ['image'],

	        init: function () {
	            MediumEditor.Extension.prototype.init.apply(this, arguments);

	            this.subscribe('editableDrag', this.handleDrag.bind(this));
	            this.subscribe('editableDrop', this.handleDrop.bind(this));
	        },

	        handleDrag: function (event) {
	            event.preventDefault();
	            event.dataTransfer.dropEffect = 'copy';

	            var target = event.target.classList ? event.target : event.target.parentElement;

	            // Ensure the class gets removed from anything that had it before
	            clearClassNames(target);

	            if (event.type === 'dragover') {
	                target.classList.add(CLASS_DRAG_OVER);
	            }
	        },

	        handleDrop: function (event) {
	            // Prevent file from opening in the current window
	            event.preventDefault();
	            event.stopPropagation();
	            // Select the dropping target, and set the selection to the end of the target
	            // https://github.com/yabwe/medium-editor/issues/980
	            this.base.selectElement(event.target);
	            var selection = this.base.exportSelection();
	            selection.start = selection.end;
	            this.base.importSelection(selection);
	            // IE9 does not support the File API, so prevent file from opening in the window
	            // but also don't try to actually get the file
	            if (event.dataTransfer.files) {
	                Array.prototype.slice.call(event.dataTransfer.files).forEach(function (file) {
	                    if (this.isAllowedFile(file)) {
	                        if (file.type.match('image')) {
	                            this.insertImageFile(file);
	                        }
	                    }
	                }, this);
	            }

	            // Make sure we remove our class from everything
	            clearClassNames(event.target);
	        },

	        isAllowedFile: function (file) {
	            return this.allowedTypes.some(function (fileType) {
	                return !!file.type.match(fileType);
	            });
	        },

	        insertImageFile: function (file) {
	            if (typeof FileReader !== 'function') {
	                return;
	            }
	            var fileReader = new FileReader();
	            fileReader.readAsDataURL(file);

	            // attach the onload event handler, makes it easier to listen in with jasmine
	            fileReader.addEventListener('load', function (e) {
	                var addImageElement = this.document.createElement('img');
	                addImageElement.src = e.target.result;
	                MediumEditor.util.insertHTMLCommand(this.document, addImageElement.outerHTML);
	            }.bind(this));
	        }
	    });

	    MediumEditor.extensions.fileDragging = FileDragging;
	}());

	(function () {
	    'use strict';

	    var KeyboardCommands = MediumEditor.Extension.extend({
	        name: 'keyboard-commands',

	        /* KeyboardCommands Options */

	        /* commands: [Array]
	         * Array of objects describing each command and the combination of keys that will trigger it
	         * Required for each object:
	         *   command [String] (argument passed to editor.execAction())
	         *   key [String] (keyboard character that triggers this command)
	         *   meta [boolean] (whether the ctrl/meta key has to be active or inactive)
	         *   shift [boolean] (whether the shift key has to be active or inactive)
	         *   alt [boolean] (whether the alt key has to be active or inactive)
	         */
	        commands: [
	            {
	                command: 'bold',
	                key: 'B',
	                meta: true,
	                shift: false,
	                alt: false
	            },
	            {
	                command: 'italic',
	                key: 'I',
	                meta: true,
	                shift: false,
	                alt: false
	            },
	            {
	                command: 'underline',
	                key: 'U',
	                meta: true,
	                shift: false,
	                alt: false
	            }
	        ],

	        init: function () {
	            MediumEditor.Extension.prototype.init.apply(this, arguments);

	            this.subscribe('editableKeydown', this.handleKeydown.bind(this));
	            this.keys = {};
	            this.commands.forEach(function (command) {
	                var keyCode = command.key.charCodeAt(0);
	                if (!this.keys[keyCode]) {
	                    this.keys[keyCode] = [];
	                }
	                this.keys[keyCode].push(command);
	            }, this);
	        },

	        handleKeydown: function (event) {
	            var keyCode = MediumEditor.util.getKeyCode(event);
	            if (!this.keys[keyCode]) {
	                return;
	            }

	            var isMeta = MediumEditor.util.isMetaCtrlKey(event),
	                isShift = !!event.shiftKey,
	                isAlt = !!event.altKey;

	            this.keys[keyCode].forEach(function (data) {
	                if (data.meta === isMeta &&
	                    data.shift === isShift &&
	                    (data.alt === isAlt ||
	                     undefined === data.alt)) { // TODO deprecated: remove check for undefined === data.alt when jumping to 6.0.0
	                    event.preventDefault();
	                    event.stopPropagation();

	                    // command can be a function to execute
	                    if (typeof data.command === 'function') {
	                        data.command.apply(this);
	                    }
	                    // command can be false so the shortcut is just disabled
	                    else if (false !== data.command) {
	                        this.execAction(data.command);
	                    }
	                }
	            }, this);
	        }
	    });

	    MediumEditor.extensions.keyboardCommands = KeyboardCommands;
	}());

	(function () {
	    'use strict';

	    var FontNameForm = MediumEditor.extensions.form.extend({

	        name: 'fontname',
	        action: 'fontName',
	        aria: 'change font name',
	        contentDefault: '&#xB1;', // ±
	        contentFA: '<i class="fa fa-font"></i>',

	        fonts: ['', 'Arial', 'Verdana', 'Times New Roman'],

	        init: function () {
	            MediumEditor.extensions.form.prototype.init.apply(this, arguments);
	        },

	        // Called when the button the toolbar is clicked
	        // Overrides ButtonExtension.handleClick
	        handleClick: function (event) {
	            event.preventDefault();
	            event.stopPropagation();

	            if (!this.isDisplayed()) {
	                // Get FontName of current selection (convert to string since IE returns this as number)
	                var fontName = this.document.queryCommandValue('fontName') + '';
	                this.showForm(fontName);
	            }

	            return false;
	        },

	        // Called by medium-editor to append form to the toolbar
	        getForm: function () {
	            if (!this.form) {
	                this.form = this.createForm();
	            }
	            return this.form;
	        },

	        // Used by medium-editor when the default toolbar is to be displayed
	        isDisplayed: function () {
	            return this.getForm().style.display === 'block';
	        },

	        hideForm: function () {
	            this.getForm().style.display = 'none';
	            this.getSelect().value = '';
	        },

	        showForm: function (fontName) {
	            var select = this.getSelect();

	            this.base.saveSelection();
	            this.hideToolbarDefaultActions();
	            this.getForm().style.display = 'block';
	            this.setToolbarPosition();

	            select.value = fontName || '';
	            select.focus();
	        },

	        // Called by core when tearing down medium-editor (destroy)
	        destroy: function () {
	            if (!this.form) {
	                return false;
	            }

	            if (this.form.parentNode) {
	                this.form.parentNode.removeChild(this.form);
	            }

	            delete this.form;
	        },

	        // core methods

	        doFormSave: function () {
	            this.base.restoreSelection();
	            this.base.checkSelection();
	        },

	        doFormCancel: function () {
	            this.base.restoreSelection();
	            this.clearFontName();
	            this.base.checkSelection();
	        },

	        // form creation and event handling
	        createForm: function () {
	            var doc = this.document,
	                form = doc.createElement('div'),
	                select = doc.createElement('select'),
	                close = doc.createElement('a'),
	                save = doc.createElement('a'),
	                option;

	            // Font Name Form (div)
	            form.className = 'medium-editor-toolbar-form';
	            form.id = 'medium-editor-toolbar-form-fontname-' + this.getEditorId();

	            // Handle clicks on the form itself
	            this.on(form, 'click', this.handleFormClick.bind(this));

	            // Add font names
	            for (var i = 0; i<this.fonts.length; i++) {
	                option = doc.createElement('option');
	                option.innerHTML = this.fonts[i];
	                option.value = this.fonts[i];
	                select.appendChild(option);
	            }

	            select.className = 'medium-editor-toolbar-select';
	            form.appendChild(select);

	            // Handle typing in the textbox
	            this.on(select, 'change', this.handleFontChange.bind(this));

	            // Add save buton
	            save.setAttribute('href', '#');
	            save.className = 'medium-editor-toobar-save';
	            save.innerHTML = this.getEditorOption('buttonLabels') === 'fontawesome' ?
	                             '<i class="fa fa-check"></i>' :
	                             '&#10003;';
	            form.appendChild(save);

	            // Handle save button clicks (capture)
	            this.on(save, 'click', this.handleSaveClick.bind(this), true);

	            // Add close button
	            close.setAttribute('href', '#');
	            close.className = 'medium-editor-toobar-close';
	            close.innerHTML = this.getEditorOption('buttonLabels') === 'fontawesome' ?
	                              '<i class="fa fa-times"></i>' :
	                              '&times;';
	            form.appendChild(close);

	            // Handle close button clicks
	            this.on(close, 'click', this.handleCloseClick.bind(this));

	            return form;
	        },

	        getSelect: function () {
	            return this.getForm().querySelector('select.medium-editor-toolbar-select');
	        },

	        clearFontName: function () {
	            MediumEditor.selection.getSelectedElements(this.document).forEach(function (el) {
	                if (el.nodeName.toLowerCase() === 'font' && el.hasAttribute('face')) {
	                    el.removeAttribute('face');
	                }
	            });
	        },

	        handleFontChange: function () {
	            var font = this.getSelect().value;
	            if (font === '') {
	                this.clearFontName();
	            } else {
	                this.execAction('fontName', { value: font });
	            }
	        },

	        handleFormClick: function (event) {
	            // make sure not to hide form when clicking inside the form
	            event.stopPropagation();
	        },

	        handleSaveClick: function (event) {
	            // Clicking Save -> create the font size
	            event.preventDefault();
	            this.doFormSave();
	        },

	        handleCloseClick: function (event) {
	            // Click Close -> close the form
	            event.preventDefault();
	            this.doFormCancel();
	        }
	    });

	    MediumEditor.extensions.fontName = FontNameForm;
	}());

	(function () {
	    'use strict';

	    var FontSizeForm = MediumEditor.extensions.form.extend({

	        name: 'fontsize',
	        action: 'fontSize',
	        aria: 'increase/decrease font size',
	        contentDefault: '&#xB1;', // ±
	        contentFA: '<i class="fa fa-text-height"></i>',

	        init: function () {
	            MediumEditor.extensions.form.prototype.init.apply(this, arguments);
	        },

	        // Called when the button the toolbar is clicked
	        // Overrides ButtonExtension.handleClick
	        handleClick: function (event) {
	            event.preventDefault();
	            event.stopPropagation();

	            if (!this.isDisplayed()) {
	                // Get fontsize of current selection (convert to string since IE returns this as number)
	                var fontSize = this.document.queryCommandValue('fontSize') + '';
	                this.showForm(fontSize);
	            }

	            return false;
	        },

	        // Called by medium-editor to append form to the toolbar
	        getForm: function () {
	            if (!this.form) {
	                this.form = this.createForm();
	            }
	            return this.form;
	        },

	        // Used by medium-editor when the default toolbar is to be displayed
	        isDisplayed: function () {
	            return this.getForm().style.display === 'block';
	        },

	        hideForm: function () {
	            this.getForm().style.display = 'none';
	            this.getInput().value = '';
	        },

	        showForm: function (fontSize) {
	            var input = this.getInput();

	            this.base.saveSelection();
	            this.hideToolbarDefaultActions();
	            this.getForm().style.display = 'block';
	            this.setToolbarPosition();

	            input.value = fontSize || '';
	            input.focus();
	        },

	        // Called by core when tearing down medium-editor (destroy)
	        destroy: function () {
	            if (!this.form) {
	                return false;
	            }

	            if (this.form.parentNode) {
	                this.form.parentNode.removeChild(this.form);
	            }

	            delete this.form;
	        },

	        // core methods

	        doFormSave: function () {
	            this.base.restoreSelection();
	            this.base.checkSelection();
	        },

	        doFormCancel: function () {
	            this.base.restoreSelection();
	            this.clearFontSize();
	            this.base.checkSelection();
	        },

	        // form creation and event handling
	        createForm: function () {
	            var doc = this.document,
	                form = doc.createElement('div'),
	                input = doc.createElement('input'),
	                close = doc.createElement('a'),
	                save = doc.createElement('a');

	            // Font Size Form (div)
	            form.className = 'medium-editor-toolbar-form';
	            form.id = 'medium-editor-toolbar-form-fontsize-' + this.getEditorId();

	            // Handle clicks on the form itself
	            this.on(form, 'click', this.handleFormClick.bind(this));

	            // Add font size slider
	            input.setAttribute('type', 'range');
	            input.setAttribute('min', '1');
	            input.setAttribute('max', '7');
	            input.className = 'medium-editor-toolbar-input';
	            form.appendChild(input);

	            // Handle typing in the textbox
	            this.on(input, 'change', this.handleSliderChange.bind(this));

	            // Add save buton
	            save.setAttribute('href', '#');
	            save.className = 'medium-editor-toobar-save';
	            save.innerHTML = this.getEditorOption('buttonLabels') === 'fontawesome' ?
	                             '<i class="fa fa-check"></i>' :
	                             '&#10003;';
	            form.appendChild(save);

	            // Handle save button clicks (capture)
	            this.on(save, 'click', this.handleSaveClick.bind(this), true);

	            // Add close button
	            close.setAttribute('href', '#');
	            close.className = 'medium-editor-toobar-close';
	            close.innerHTML = this.getEditorOption('buttonLabels') === 'fontawesome' ?
	                              '<i class="fa fa-times"></i>' :
	                              '&times;';
	            form.appendChild(close);

	            // Handle close button clicks
	            this.on(close, 'click', this.handleCloseClick.bind(this));

	            return form;
	        },

	        getInput: function () {
	            return this.getForm().querySelector('input.medium-editor-toolbar-input');
	        },

	        clearFontSize: function () {
	            MediumEditor.selection.getSelectedElements(this.document).forEach(function (el) {
	                if (el.nodeName.toLowerCase() === 'font' && el.hasAttribute('size')) {
	                    el.removeAttribute('size');
	                }
	            });
	        },

	        handleSliderChange: function () {
	            var size = this.getInput().value;
	            if (size === '4') {
	                this.clearFontSize();
	            } else {
	                this.execAction('fontSize', { value: size });
	            }
	        },

	        handleFormClick: function (event) {
	            // make sure not to hide form when clicking inside the form
	            event.stopPropagation();
	        },

	        handleSaveClick: function (event) {
	            // Clicking Save -> create the font size
	            event.preventDefault();
	            this.doFormSave();
	        },

	        handleCloseClick: function (event) {
	            // Click Close -> close the form
	            event.preventDefault();
	            this.doFormCancel();
	        }
	    });

	    MediumEditor.extensions.fontSize = FontSizeForm;
	}());
	(function () {
	    'use strict';

	    /* Helpers and internal variables that don't need to be members of actual paste handler */

	    var pasteBinDefaultContent = '%ME_PASTEBIN%',
	        lastRange = null,
	        keyboardPasteEditable = null,
	        stopProp = function (event) {
	            event.stopPropagation();
	        };

	    /*jslint regexp: true*/
	    /*
	        jslint does not allow character negation, because the negation
	        will not match any unicode characters. In the regexes in this
	        block, negation is used specifically to match the end of an html
	        tag, and in fact unicode characters *should* be allowed.
	    */
	    function createReplacements() {
	        return [
	            // Remove anything but the contents within the BODY element
	            [new RegExp(/^[\s\S]*<body[^>]*>\s*|\s*<\/body[^>]*>[\s\S]*$/g), ''],

	            // cleanup comments added by Chrome when pasting html
	            [new RegExp(/<!--StartFragment-->|<!--EndFragment-->/g), ''],

	            // Trailing BR elements
	            [new RegExp(/<br>$/i), ''],

	            // replace two bogus tags that begin pastes from google docs
	            [new RegExp(/<[^>]*docs-internal-guid[^>]*>/gi), ''],
	            [new RegExp(/<\/b>(<br[^>]*>)?$/gi), ''],

	             // un-html spaces and newlines inserted by OS X
	            [new RegExp(/<span class="Apple-converted-space">\s+<\/span>/g), ' '],
	            [new RegExp(/<br class="Apple-interchange-newline">/g), '<br>'],

	            // replace google docs italics+bold with a span to be replaced once the html is inserted
	            [new RegExp(/<span[^>]*(font-style:italic;font-weight:bold|font-weight:bold;font-style:italic)[^>]*>/gi), '<span class="replace-with italic bold">'],

	            // replace google docs italics with a span to be replaced once the html is inserted
	            [new RegExp(/<span[^>]*font-style:italic[^>]*>/gi), '<span class="replace-with italic">'],

	            //[replace google docs bolds with a span to be replaced once the html is inserted
	            [new RegExp(/<span[^>]*font-weight:bold[^>]*>/gi), '<span class="replace-with bold">'],

	             // replace manually entered b/i/a tags with real ones
	            [new RegExp(/&lt;(\/?)(i|b|a)&gt;/gi), '<$1$2>'],

	             // replace manually a tags with real ones, converting smart-quotes from google docs
	            [new RegExp(/&lt;a(?:(?!href).)+href=(?:&quot;|&rdquo;|&ldquo;|"|“|”)(((?!&quot;|&rdquo;|&ldquo;|"|“|”).)*)(?:&quot;|&rdquo;|&ldquo;|"|“|”)(?:(?!&gt;).)*&gt;/gi), '<a href="$1">'],

	            // Newlines between paragraphs in html have no syntactic value,
	            // but then have a tendency to accidentally become additional paragraphs down the line
	            [new RegExp(/<\/p>\n+/gi), '</p>'],
	            [new RegExp(/\n+<p/gi), '<p'],

	            // Microsoft Word makes these odd tags, like <o:p></o:p>
	            [new RegExp(/<\/?o:[a-z]*>/gi), ''],

	            // Microsoft Word adds some special elements around list items
	            [new RegExp(/<!\[if !supportLists\]>(((?!<!).)*)<!\[endif]\>/gi), '$1']
	        ];
	    }
	    /*jslint regexp: false*/

	    /**
	     * Gets various content types out of the Clipboard API. It will also get the
	     * plain text using older IE and WebKit API.
	     *
	     * @param {event} event Event fired on paste.
	     * @param {win} reference to window
	     * @param {doc} reference to document
	     * @return {Object} Object with mime types and data for those mime types.
	     */
	    function getClipboardContent(event, win, doc) {
	        var dataTransfer = event.clipboardData || win.clipboardData || doc.dataTransfer,
	            data = {};

	        if (!dataTransfer) {
	            return data;
	        }

	        // Use old WebKit/IE API
	        if (dataTransfer.getData) {
	            var legacyText = dataTransfer.getData('Text');
	            if (legacyText && legacyText.length > 0) {
	                data['text/plain'] = legacyText;
	            }
	        }

	        if (dataTransfer.types) {
	            for (var i = 0; i < dataTransfer.types.length; i++) {
	                var contentType = dataTransfer.types[i];
	                data[contentType] = dataTransfer.getData(contentType);
	            }
	        }

	        return data;
	    }

	    var PasteHandler = MediumEditor.Extension.extend({
	        /* Paste Options */

	        /* forcePlainText: [boolean]
	         * Forces pasting as plain text.
	         */
	        forcePlainText: true,

	        /* cleanPastedHTML: [boolean]
	         * cleans pasted content from different sources, like google docs etc.
	         */
	        cleanPastedHTML: false,

	        /* preCleanReplacements: [Array]
	         * custom pairs (2 element arrays) of RegExp and replacement text to use during past when
	         * __forcePlainText__ or __cleanPastedHTML__ are `true` OR when calling `cleanPaste(text)` helper method.
	         * These replacements are executed before any medium editor defined replacements.
	         */
	        preCleanReplacements: [],

	        /* cleanReplacements: [Array]
	         * custom pairs (2 element arrays) of RegExp and replacement text to use during paste when
	         * __forcePlainText__ or __cleanPastedHTML__ are `true` OR when calling `cleanPaste(text)` helper method.
	         * These replacements are executed after any medium editor defined replacements.
	         */
	        cleanReplacements: [],

	        /* cleanAttrs:: [Array]
	         * list of element attributes to remove during paste when __cleanPastedHTML__ is `true` or when
	         * calling `cleanPaste(text)` or `pasteHTML(html, options)` helper methods.
	         */
	        cleanAttrs: ['class', 'style', 'dir'],

	        /* cleanTags: [Array]
	         * list of element tag names to remove during paste when __cleanPastedHTML__ is `true` or when
	         * calling `cleanPaste(text)` or `pasteHTML(html, options)` helper methods.
	         */
	        cleanTags: ['meta'],

	        init: function () {
	            MediumEditor.Extension.prototype.init.apply(this, arguments);

	            if (this.forcePlainText || this.cleanPastedHTML) {
	                this.subscribe('editablePaste', this.handlePaste.bind(this));
	                this.subscribe('editableKeydown', this.handleKeydown.bind(this));
	            }
	        },

	        destroy: function () {
	            // Make sure pastebin is destroyed in case it's still around for some reason
	            if (this.forcePlainText || this.cleanPastedHTML) {
	                this.removePasteBin();
	            }
	        },

	        handlePaste: function (event, editable) {
	            if (event.defaultPrevented) {
	                return;
	            }

	            var clipboardContent = getClipboardContent(event, this.window, this.document),
	                pastedHTML = clipboardContent['text/html'],
	                pastedPlain = clipboardContent['text/plain'];

	            if (this.window.clipboardData && event.clipboardData === undefined && !pastedHTML) {
	                // If window.clipboardData exists, but event.clipboardData doesn't exist,
	                // we're probably in IE. IE only has two possibilities for clipboard
	                // data format: 'Text' and 'URL'.
	                //
	                // For IE, we'll fallback to 'Text' for text/html
	                pastedHTML = pastedPlain;
	            }

	            if (pastedHTML || pastedPlain) {
	                event.preventDefault();

	                this.doPaste(pastedHTML, pastedPlain, editable);
	            }
	        },

	        doPaste: function (pastedHTML, pastedPlain, editable) {
	            var paragraphs,
	                html = '',
	                p;

	            if (this.cleanPastedHTML && pastedHTML) {
	                return this.cleanPaste(pastedHTML);
	            }

	            if (!(this.getEditorOption('disableReturn') || (editable && editable.getAttribute('data-disable-return')))) {
	                paragraphs = pastedPlain.split(/[\r\n]+/g);
	                // If there are no \r\n in data, don't wrap in <p>
	                if (paragraphs.length > 1) {
	                    for (p = 0; p < paragraphs.length; p += 1) {
	                        if (paragraphs[p] !== '') {
	                            html += '<p>' + MediumEditor.util.htmlEntities(paragraphs[p]) + '</p>';
	                        }
	                    }
	                } else {
	                    html = MediumEditor.util.htmlEntities(paragraphs[0]);
	                }
	            } else {
	                html = MediumEditor.util.htmlEntities(pastedPlain);
	            }
	            MediumEditor.util.insertHTMLCommand(this.document, html);
	        },

	        handlePasteBinPaste: function (event) {
	            if (event.defaultPrevented) {
	                this.removePasteBin();
	                return;
	            }

	            var clipboardContent = getClipboardContent(event, this.window, this.document),
	                pastedHTML = clipboardContent['text/html'],
	                pastedPlain = clipboardContent['text/plain'],
	                editable = keyboardPasteEditable;

	            // If we have valid html already, or we're not in cleanPastedHTML mode
	            // we can ignore the paste bin and just paste now
	            if (!this.cleanPastedHTML || pastedHTML) {
	                event.preventDefault();
	                this.removePasteBin();
	                this.doPaste(pastedHTML, pastedPlain, editable);
	                return;
	            }

	            // We need to look at the paste bin, so do a setTimeout to let the paste
	            // fall through into the paste bin
	            setTimeout(function () {
	                // Only look for HTML if we're in cleanPastedHTML mode
	                if (this.cleanPastedHTML) {
	                    // If clipboard didn't have HTML, try the paste bin
	                    pastedHTML = this.getPasteBinHtml();
	                }

	                // If we needed the paste bin, we're done with it now, remove it
	                this.removePasteBin();

	                // Handle the paste with the html from the paste bin
	                this.doPaste(pastedHTML, pastedPlain, editable);
	            }.bind(this), 0);
	        },

	        handleKeydown: function (event, editable) {
	            // if it's not Ctrl+V, do nothing
	            if (!(MediumEditor.util.isKey(event, MediumEditor.util.keyCode.V) && MediumEditor.util.isMetaCtrlKey(event))) {
	                return;
	            }

	            event.stopImmediatePropagation();

	            this.removePasteBin();
	            this.createPasteBin(editable);
	        },

	        createPasteBin: function (editable) {
	            var rects,
	                range = MediumEditor.selection.getSelectionRange(this.document),
	                top = this.window.pageYOffset;

	            keyboardPasteEditable = editable;

	            if (range) {
	                rects = range.getClientRects();

	                // on empty line, rects is empty so we grab information from the first container of the range
	                if (rects.length) {
	                    top += rects[0].top;
	                } else {
	                    top += range.startContainer.getBoundingClientRect().top;
	                }
	            }

	            lastRange = range;

	            var pasteBinElm = this.document.createElement('div');
	            pasteBinElm.id = this.pasteBinId = 'medium-editor-pastebin-' + (+Date.now());
	            pasteBinElm.setAttribute('style', 'border: 1px red solid; position: absolute; top: ' + top + 'px; width: 10px; height: 10px; overflow: hidden; opacity: 0');
	            pasteBinElm.setAttribute('contentEditable', true);
	            pasteBinElm.innerHTML = pasteBinDefaultContent;

	            this.document.body.appendChild(pasteBinElm);

	            // avoid .focus() to stop other event (actually the paste event)
	            this.on(pasteBinElm, 'focus', stopProp);
	            this.on(pasteBinElm, 'focusin', stopProp);
	            this.on(pasteBinElm, 'focusout', stopProp);

	            pasteBinElm.focus();

	            MediumEditor.selection.selectNode(pasteBinElm, this.document);

	            if (!this.boundHandlePaste) {
	                this.boundHandlePaste = this.handlePasteBinPaste.bind(this);
	            }

	            this.on(pasteBinElm, 'paste', this.boundHandlePaste);
	        },

	        removePasteBin: function () {
	            if (null !== lastRange) {
	                MediumEditor.selection.selectRange(this.document, lastRange);
	                lastRange = null;
	            }

	            if (null !== keyboardPasteEditable) {
	                keyboardPasteEditable = null;
	            }

	            var pasteBinElm = this.getPasteBin();
	            if (!pasteBinElm) {
	                return;
	            }

	            if (pasteBinElm) {
	                this.off(pasteBinElm, 'focus', stopProp);
	                this.off(pasteBinElm, 'focusin', stopProp);
	                this.off(pasteBinElm, 'focusout', stopProp);
	                this.off(pasteBinElm, 'paste', this.boundHandlePaste);
	                pasteBinElm.parentElement.removeChild(pasteBinElm);
	            }
	        },

	        getPasteBin: function () {
	            return this.document.getElementById(this.pasteBinId);
	        },

	        getPasteBinHtml: function () {
	            var pasteBinElm = this.getPasteBin();

	            if (!pasteBinElm) {
	                return false;
	            }

	            // WebKit has a nice bug where it clones the paste bin if you paste from for example notepad
	            // so we need to force plain text mode in this case
	            if (pasteBinElm.firstChild && pasteBinElm.firstChild.id === 'mcepastebin') {
	                return false;
	            }

	            var pasteBinHtml = pasteBinElm.innerHTML;

	            // If paste bin is empty try using plain text mode
	            // since that is better than nothing right
	            if (!pasteBinHtml || pasteBinHtml === pasteBinDefaultContent) {
	                return false;
	            }

	            return pasteBinHtml;
	        },

	        cleanPaste: function (text) {
	            var i, elList, tmp, workEl,
	                multiline = /<p|<br|<div/.test(text),
	                replacements = [].concat(
	                    this.preCleanReplacements || [],
	                    createReplacements(),
	                    this.cleanReplacements || []);

	            for (i = 0; i < replacements.length; i += 1) {
	                text = text.replace(replacements[i][0], replacements[i][1]);
	            }

	            if (!multiline) {
	                return this.pasteHTML(text);
	            }

	            // create a temporary div to cleanup block elements
	            tmp = this.document.createElement('div');

	            // double br's aren't converted to p tags, but we want paragraphs.
	            tmp.innerHTML = '<p>' + text.split('<br><br>').join('</p><p>') + '</p>';

	            // block element cleanup
	            elList = tmp.querySelectorAll('a,p,div,br');
	            for (i = 0; i < elList.length; i += 1) {
	                workEl = elList[i];

	                // Microsoft Word replaces some spaces with newlines.
	                // While newlines between block elements are meaningless, newlines within
	                // elements are sometimes actually spaces.
	                workEl.innerHTML = workEl.innerHTML.replace(/\n/gi, ' ');

	                switch (workEl.nodeName.toLowerCase()) {
	                    case 'p':
	                    case 'div':
	                        this.filterCommonBlocks(workEl);
	                        break;
	                    case 'br':
	                        this.filterLineBreak(workEl);
	                        break;
	                }
	            }

	            this.pasteHTML(tmp.innerHTML);
	        },

	        pasteHTML: function (html, options) {
	            options = MediumEditor.util.defaults({}, options, {
	                cleanAttrs: this.cleanAttrs,
	                cleanTags: this.cleanTags
	            });

	            var elList, workEl, i, fragmentBody, pasteBlock = this.document.createDocumentFragment();

	            pasteBlock.appendChild(this.document.createElement('body'));

	            fragmentBody = pasteBlock.querySelector('body');
	            fragmentBody.innerHTML = html;

	            this.cleanupSpans(fragmentBody);

	            elList = fragmentBody.querySelectorAll('*');
	            for (i = 0; i < elList.length; i += 1) {
	                workEl = elList[i];

	                if ('a' === workEl.nodeName.toLowerCase() && this.getEditorOption('targetBlank')) {
	                    MediumEditor.util.setTargetBlank(workEl);
	                }

	                MediumEditor.util.cleanupAttrs(workEl, options.cleanAttrs);
	                MediumEditor.util.cleanupTags(workEl, options.cleanTags);
	            }

	            MediumEditor.util.insertHTMLCommand(this.document, fragmentBody.innerHTML.replace(/&nbsp;/g, ' '));
	        },

	        // TODO (6.0): Make this an internal helper instead of member of paste handler
	        isCommonBlock: function (el) {
	            return (el && (el.nodeName.toLowerCase() === 'p' || el.nodeName.toLowerCase() === 'div'));
	        },

	        // TODO (6.0): Make this an internal helper instead of member of paste handler
	        filterCommonBlocks: function (el) {
	            if (/^\s*$/.test(el.textContent) && el.parentNode) {
	                el.parentNode.removeChild(el);
	            }
	        },

	        // TODO (6.0): Make this an internal helper instead of member of paste handler
	        filterLineBreak: function (el) {
	            if (this.isCommonBlock(el.previousElementSibling)) {
	                // remove stray br's following common block elements
	                this.removeWithParent(el);
	            } else if (this.isCommonBlock(el.parentNode) && (el.parentNode.firstChild === el || el.parentNode.lastChild === el)) {
	                // remove br's just inside open or close tags of a div/p
	                this.removeWithParent(el);
	            } else if (el.parentNode && el.parentNode.childElementCount === 1 && el.parentNode.textContent === '') {
	                // and br's that are the only child of elements other than div/p
	                this.removeWithParent(el);
	            }
	        },

	        // TODO (6.0): Make this an internal helper instead of member of paste handler
	        // remove an element, including its parent, if it is the only element within its parent
	        removeWithParent: function (el) {
	            if (el && el.parentNode) {
	                if (el.parentNode.parentNode && el.parentNode.childElementCount === 1) {
	                    el.parentNode.parentNode.removeChild(el.parentNode);
	                } else {
	                    el.parentNode.removeChild(el);
	                }
	            }
	        },

	        // TODO (6.0): Make this an internal helper instead of member of paste handler
	        cleanupSpans: function (containerEl) {
	            var i,
	                el,
	                newEl,
	                spans = containerEl.querySelectorAll('.replace-with'),
	                isCEF = function (el) {
	                    return (el && el.nodeName !== '#text' && el.getAttribute('contenteditable') === 'false');
	                };

	            for (i = 0; i < spans.length; i += 1) {
	                el = spans[i];
	                newEl = this.document.createElement(el.classList.contains('bold') ? 'b' : 'i');

	                if (el.classList.contains('bold') && el.classList.contains('italic')) {
	                    // add an i tag as well if this has both italics and bold
	                    newEl.innerHTML = '<i>' + el.innerHTML + '</i>';
	                } else {
	                    newEl.innerHTML = el.innerHTML;
	                }
	                el.parentNode.replaceChild(newEl, el);
	            }

	            spans = containerEl.querySelectorAll('span');
	            for (i = 0; i < spans.length; i += 1) {
	                el = spans[i];

	                // bail if span is in contenteditable = false
	                if (MediumEditor.util.traverseUp(el, isCEF)) {
	                    return false;
	                }

	                // remove empty spans, replace others with their contents
	                MediumEditor.util.unwrap(el, this.document);
	            }
	        }
	    });

	    MediumEditor.extensions.paste = PasteHandler;
	}());

	(function () {
	    'use strict';

	    var Placeholder = MediumEditor.Extension.extend({
	        name: 'placeholder',

	        /* Placeholder Options */

	        /* text: [string]
	         * Text to display in the placeholder
	         */
	        text: 'Type your text',

	        /* hideOnClick: [boolean]
	         * Should we hide the placeholder on click (true) or when user starts typing (false)
	         */
	        hideOnClick: true,

	        init: function () {
	            MediumEditor.Extension.prototype.init.apply(this, arguments);

	            this.initPlaceholders();
	            this.attachEventHandlers();
	        },

	        initPlaceholders: function () {
	            this.getEditorElements().forEach(function (el) {
	                if (!el.getAttribute('data-placeholder')) {
	                    el.setAttribute('data-placeholder', this.text);
	                }
	                this.updatePlaceholder(el);
	            }, this);
	        },

	        destroy: function () {
	            this.getEditorElements().forEach(function (el) {
	                if (el.getAttribute('data-placeholder') === this.text) {
	                    el.removeAttribute('data-placeholder');
	                }
	            }, this);
	        },

	        showPlaceholder: function (el) {
	            if (el) {
	                el.classList.add('medium-editor-placeholder');
	            }
	        },

	        hidePlaceholder: function (el) {
	            if (el) {
	                el.classList.remove('medium-editor-placeholder');
	            }
	        },

	        updatePlaceholder: function (el, dontShow) {
	            // If the element has content, hide the placeholder
	            if (el.querySelector('img, blockquote, ul, ol') || (el.textContent.replace(/^\s+|\s+$/g, '') !== '')) {
	                return this.hidePlaceholder(el);
	            }

	            if (!dontShow) {
	                this.showPlaceholder(el);
	            }
	        },

	        attachEventHandlers: function () {
	            if (this.hideOnClick) {
	                // For the 'hideOnClick' option, the placeholder should always be hidden on focus
	                this.subscribe('focus', this.handleFocus.bind(this));
	            }

	            // If the editor has content, it should always hide the placeholder
	            this.subscribe('editableInput', this.handleInput.bind(this));

	            // When the editor loses focus, check if the placeholder should be visible
	            this.subscribe('blur', this.handleBlur.bind(this));
	        },

	        handleInput: function (event, element) {
	            // If the placeholder should be hidden on focus and the
	            // element has focus, don't show the placeholder
	            var dontShow = this.hideOnClick && (element === this.base.getFocusedElement());

	            // Editor's content has changed, check if the placeholder should be hidden
	            this.updatePlaceholder(element, dontShow);
	        },

	        handleFocus: function (event, element) {
	            // Editor has focus, hide the placeholder
	            this.hidePlaceholder(element);
	        },

	        handleBlur: function (event, element) {
	            // Editor has lost focus, check if the placeholder should be shown
	            this.updatePlaceholder(element);
	        }
	    });

	    MediumEditor.extensions.placeholder = Placeholder;
	}());

	(function () {
	    'use strict';

	    var Toolbar = MediumEditor.Extension.extend({
	        name: 'toolbar',

	        /* Toolbar Options */

	        /* align: ['left'|'center'|'right']
	         * When the __static__ option is true, this aligns the static toolbar
	         * relative to the medium-editor element.
	         */
	        align: 'center',

	        /* allowMultiParagraphSelection: [boolean]
	         * enables/disables whether the toolbar should be displayed when
	         * selecting multiple paragraphs/block elements
	         */
	        allowMultiParagraphSelection: true,

	        /* buttons: [Array]
	         * the names of the set of buttons to display on the toolbar.
	         */
	        buttons: ['bold', 'italic', 'underline', 'anchor', 'h2', 'h3', 'quote'],

	        /* diffLeft: [Number]
	         * value in pixels to be added to the X axis positioning of the toolbar.
	         */
	        diffLeft: 0,

	        /* diffTop: [Number]
	         * value in pixels to be added to the Y axis positioning of the toolbar.
	         */
	        diffTop: -10,

	        /* firstButtonClass: [string]
	         * CSS class added to the first button in the toolbar.
	         */
	        firstButtonClass: 'medium-editor-button-first',

	        /* lastButtonClass: [string]
	         * CSS class added to the last button in the toolbar.
	         */
	        lastButtonClass: 'medium-editor-button-last',

	        /* standardizeSelectionStart: [boolean]
	         * enables/disables standardizing how the beginning of a range is decided
	         * between browsers whenever the selected text is analyzed for updating toolbar buttons status.
	         */
	        standardizeSelectionStart: false,

	        /* static: [boolean]
	         * enable/disable the toolbar always displaying in the same location
	         * relative to the medium-editor element.
	         */
	        static: false,

	        /* sticky: [boolean]
	         * When the __static__ option is true, this enables/disables the toolbar
	         * "sticking" to the viewport and staying visible on the screen while
	         * the page scrolls.
	         */
	        sticky: false,

	        /* stickyTopOffset: [Number]
	         * Value in pixel of the top offset above the toolbar
	         */
	        stickyTopOffset: 0,

	        /* updateOnEmptySelection: [boolean]
	         * When the __static__ option is true, this enables/disables updating
	         * the state of the toolbar buttons even when the selection is collapsed
	         * (there is no selection, just a cursor).
	         */
	        updateOnEmptySelection: false,

	        /* relativeContainer: [node]
	         * appending the toolbar to a given node instead of body
	         */
	        relativeContainer: null,

	        init: function () {
	            MediumEditor.Extension.prototype.init.apply(this, arguments);

	            this.initThrottledMethods();

	            if (!this.relativeContainer) {
	                this.getEditorOption('elementsContainer').appendChild(this.getToolbarElement());
	            } else {
	                this.relativeContainer.appendChild(this.getToolbarElement());
	            }
	        },

	        // Helper method to execute method for every extension, but ignoring the toolbar extension
	        forEachExtension: function (iterator, context) {
	            return this.base.extensions.forEach(function (command) {
	                if (command === this) {
	                    return;
	                }
	                return iterator.apply(context || this, arguments);
	            }, this);
	        },

	        // Toolbar creation/deletion

	        createToolbar: function () {
	            var toolbar = this.document.createElement('div');

	            toolbar.id = 'medium-editor-toolbar-' + this.getEditorId();
	            toolbar.className = 'medium-editor-toolbar';

	            if (this.static) {
	                toolbar.className += ' static-toolbar';
	            } else if (this.relativeContainer) {
	                toolbar.className += ' medium-editor-relative-toolbar';
	            } else {
	                toolbar.className += ' medium-editor-stalker-toolbar';
	            }

	            toolbar.appendChild(this.createToolbarButtons());

	            // Add any forms that extensions may have
	            this.forEachExtension(function (extension) {
	                if (extension.hasForm) {
	                    toolbar.appendChild(extension.getForm());
	                }
	            });

	            this.attachEventHandlers();

	            return toolbar;
	        },

	        createToolbarButtons: function () {
	            var ul = this.document.createElement('ul'),
	                li,
	                btn,
	                buttons,
	                extension,
	                buttonName,
	                buttonOpts;

	            ul.id = 'medium-editor-toolbar-actions' + this.getEditorId();
	            ul.className = 'medium-editor-toolbar-actions';
	            ul.style.display = 'block';

	            this.buttons.forEach(function (button) {
	                if (typeof button === 'string') {
	                    buttonName = button;
	                    buttonOpts = null;
	                } else {
	                    buttonName = button.name;
	                    buttonOpts = button;
	                }

	                // If the button already exists as an extension, it'll be returned
	                // othwerise it'll create the default built-in button
	                extension = this.base.addBuiltInExtension(buttonName, buttonOpts);

	                if (extension && typeof extension.getButton === 'function') {
	                    btn = extension.getButton(this.base);
	                    li = this.document.createElement('li');
	                    if (MediumEditor.util.isElement(btn)) {
	                        li.appendChild(btn);
	                    } else {
	                        li.innerHTML = btn;
	                    }
	                    ul.appendChild(li);
	                }
	            }, this);

	            buttons = ul.querySelectorAll('button');
	            if (buttons.length > 0) {
	                buttons[0].classList.add(this.firstButtonClass);
	                buttons[buttons.length - 1].classList.add(this.lastButtonClass);
	            }

	            return ul;
	        },

	        destroy: function () {
	            if (this.toolbar) {
	                if (this.toolbar.parentNode) {
	                    this.toolbar.parentNode.removeChild(this.toolbar);
	                }
	                delete this.toolbar;
	            }
	        },

	        // Toolbar accessors

	        getToolbarElement: function () {
	            if (!this.toolbar) {
	                this.toolbar = this.createToolbar();
	            }

	            return this.toolbar;
	        },

	        getToolbarActionsElement: function () {
	            return this.getToolbarElement().querySelector('.medium-editor-toolbar-actions');
	        },

	        // Toolbar event handlers

	        initThrottledMethods: function () {
	            // throttledPositionToolbar is throttled because:
	            // - It will be called when the browser is resizing, which can fire many times very quickly
	            // - For some event (like resize) a slight lag in UI responsiveness is OK and provides performance benefits
	            this.throttledPositionToolbar = MediumEditor.util.throttle(function () {
	                if (this.base.isActive) {
	                    this.positionToolbarIfShown();
	                }
	            }.bind(this));
	        },

	        attachEventHandlers: function () {
	            // MediumEditor custom events for when user beings and ends interaction with a contenteditable and its elements
	            this.subscribe('blur', this.handleBlur.bind(this));
	            this.subscribe('focus', this.handleFocus.bind(this));

	            // Updating the state of the toolbar as things change
	            this.subscribe('editableClick', this.handleEditableClick.bind(this));
	            this.subscribe('editableKeyup', this.handleEditableKeyup.bind(this));

	            // Handle mouseup on document for updating the selection in the toolbar
	            this.on(this.document.documentElement, 'mouseup', this.handleDocumentMouseup.bind(this));

	            // Add a scroll event for sticky toolbar
	            if (this.static && this.sticky) {
	                // On scroll (capture), re-position the toolbar
	                this.on(this.window, 'scroll', this.handleWindowScroll.bind(this), true);
	            }

	            // On resize, re-position the toolbar
	            this.on(this.window, 'resize', this.handleWindowResize.bind(this));
	        },

	        handleWindowScroll: function () {
	            this.positionToolbarIfShown();
	        },

	        handleWindowResize: function () {
	            this.throttledPositionToolbar();
	        },

	        handleDocumentMouseup: function (event) {
	            // Do not trigger checkState when mouseup fires over the toolbar
	            if (event &&
	                    event.target &&
	                    MediumEditor.util.isDescendant(this.getToolbarElement(), event.target)) {
	                return false;
	            }
	            this.checkState();
	        },

	        handleEditableClick: function () {
	            // Delay the call to checkState to handle bug where selection is empty
	            // immediately after clicking inside a pre-existing selection
	            setTimeout(function () {
	                this.checkState();
	            }.bind(this), 0);
	        },

	        handleEditableKeyup: function () {
	            this.checkState();
	        },

	        handleBlur: function () {
	            // Kill any previously delayed calls to hide the toolbar
	            clearTimeout(this.hideTimeout);

	            // Blur may fire even if we have a selection, so we want to prevent any delayed showToolbar
	            // calls from happening in this specific case
	            clearTimeout(this.delayShowTimeout);

	            // Delay the call to hideToolbar to handle bug with multiple editors on the page at once
	            this.hideTimeout = setTimeout(function () {
	                this.hideToolbar();
	            }.bind(this), 1);
	        },

	        handleFocus: function () {
	            this.checkState();
	        },

	        // Hiding/showing toolbar

	        isDisplayed: function () {
	            return this.getToolbarElement().classList.contains('medium-editor-toolbar-active');
	        },

	        showToolbar: function () {
	            clearTimeout(this.hideTimeout);
	            if (!this.isDisplayed()) {
	                this.getToolbarElement().classList.add('medium-editor-toolbar-active');
	                this.trigger('showToolbar', {}, this.base.getFocusedElement());
	            }
	        },

	        hideToolbar: function () {
	            if (this.isDisplayed()) {
	                this.getToolbarElement().classList.remove('medium-editor-toolbar-active');
	                this.trigger('hideToolbar', {}, this.base.getFocusedElement());
	            }
	        },

	        isToolbarDefaultActionsDisplayed: function () {
	            return this.getToolbarActionsElement().style.display === 'block';
	        },

	        hideToolbarDefaultActions: function () {
	            if (this.isToolbarDefaultActionsDisplayed()) {
	                this.getToolbarActionsElement().style.display = 'none';
	            }
	        },

	        showToolbarDefaultActions: function () {
	            this.hideExtensionForms();

	            if (!this.isToolbarDefaultActionsDisplayed()) {
	                this.getToolbarActionsElement().style.display = 'block';
	            }

	            // Using setTimeout + options.delay because:
	            // We will actually be displaying the toolbar, which should be controlled by options.delay
	            this.delayShowTimeout = this.base.delay(function () {
	                this.showToolbar();
	            }.bind(this));
	        },

	        hideExtensionForms: function () {
	            // Hide all extension forms
	            this.forEachExtension(function (extension) {
	                if (extension.hasForm && extension.isDisplayed()) {
	                    extension.hideForm();
	                }
	            });
	        },

	        // Responding to changes in user selection

	        // Checks for existance of multiple block elements in the current selection
	        multipleBlockElementsSelected: function () {
	            var regexEmptyHTMLTags = /<[^\/>][^>]*><\/[^>]+>/gim, // http://stackoverflow.com/questions/3129738/remove-empty-tags-using-regex
	                regexBlockElements = new RegExp('<(' + MediumEditor.util.blockContainerElementNames.join('|') + ')[^>]*>', 'g'),
	                selectionHTML = MediumEditor.selection.getSelectionHtml(this.document).replace(regexEmptyHTMLTags, ''), // Filter out empty blocks from selection
	                hasMultiParagraphs = selectionHTML.match(regexBlockElements); // Find how many block elements are within the html

	            return !!hasMultiParagraphs && hasMultiParagraphs.length > 1;
	        },

	        modifySelection: function () {
	            var selection = this.window.getSelection(),
	                selectionRange = selection.getRangeAt(0);

	            /*
	            * In firefox, there are cases (ie doubleclick of a word) where the selectionRange start
	            * will be at the very end of an element.  In other browsers, the selectionRange start
	            * would instead be at the very beginning of an element that actually has content.
	            * example:
	            *   <span>foo</span><span>bar</span>
	            *
	            * If the text 'bar' is selected, most browsers will have the selectionRange start at the beginning
	            * of the 'bar' span.  However, there are cases where firefox will have the selectionRange start
	            * at the end of the 'foo' span.  The contenteditable behavior will be ok, but if there are any
	            * properties on the 'bar' span, they won't be reflected accurately in the toolbar
	            * (ie 'Bold' button wouldn't be active)
	            *
	            * So, for cases where the selectionRange start is at the end of an element/node, find the next
	            * adjacent text node that actually has content in it, and move the selectionRange start there.
	            */
	            if (this.standardizeSelectionStart &&
	                    selectionRange.startContainer.nodeValue &&
	                    (selectionRange.startOffset === selectionRange.startContainer.nodeValue.length)) {
	                var adjacentNode = MediumEditor.util.findAdjacentTextNodeWithContent(MediumEditor.selection.getSelectionElement(this.window), selectionRange.startContainer, this.document);
	                if (adjacentNode) {
	                    var offset = 0;
	                    while (adjacentNode.nodeValue.substr(offset, 1).trim().length === 0) {
	                        offset = offset + 1;
	                    }
	                    selectionRange = MediumEditor.selection.select(this.document, adjacentNode, offset,
	                        selectionRange.endContainer, selectionRange.endOffset);
	                }
	            }
	        },

	        checkState: function () {
	            if (this.base.preventSelectionUpdates) {
	                return;
	            }

	            // If no editable has focus OR selection is inside contenteditable = false
	            // hide toolbar
	            if (!this.base.getFocusedElement() ||
	                    MediumEditor.selection.selectionInContentEditableFalse(this.window)) {
	                return this.hideToolbar();
	            }

	            // If there's no selection element, selection element doesn't belong to this editor
	            // or toolbar is disabled for this selection element
	            // hide toolbar
	            var selectionElement = MediumEditor.selection.getSelectionElement(this.window);
	            if (!selectionElement ||
	                    this.getEditorElements().indexOf(selectionElement) === -1 ||
	                    selectionElement.getAttribute('data-disable-toolbar')) {
	                return this.hideToolbar();
	            }

	            // Now we know there's a focused editable with a selection

	            // If the updateOnEmptySelection option is true, show the toolbar
	            if (this.updateOnEmptySelection && this.static) {
	                return this.showAndUpdateToolbar();
	            }

	            // If we don't have a 'valid' selection -> hide toolbar
	            if (!MediumEditor.selection.selectionContainsContent(this.document) ||
	                (this.allowMultiParagraphSelection === false && this.multipleBlockElementsSelected())) {
	                return this.hideToolbar();
	            }

	            this.showAndUpdateToolbar();
	        },

	        // Updating the toolbar

	        showAndUpdateToolbar: function () {
	            this.modifySelection();
	            this.setToolbarButtonStates();
	            this.trigger('positionToolbar', {}, this.base.getFocusedElement());
	            this.showToolbarDefaultActions();
	            this.setToolbarPosition();
	        },

	        setToolbarButtonStates: function () {
	            this.forEachExtension(function (extension) {
	                if (typeof extension.isActive === 'function' &&
	                    typeof extension.setInactive === 'function') {
	                    extension.setInactive();
	                }
	            });

	            this.checkActiveButtons();
	        },

	        checkActiveButtons: function () {
	            var manualStateChecks = [],
	                queryState = null,
	                selectionRange = MediumEditor.selection.getSelectionRange(this.document),
	                parentNode,
	                updateExtensionState = function (extension) {
	                    if (typeof extension.checkState === 'function') {
	                        extension.checkState(parentNode);
	                    } else if (typeof extension.isActive === 'function' &&
	                               typeof extension.isAlreadyApplied === 'function' &&
	                               typeof extension.setActive === 'function') {
	                        if (!extension.isActive() && extension.isAlreadyApplied(parentNode)) {
	                            extension.setActive();
	                        }
	                    }
	                };

	            if (!selectionRange) {
	                return;
	            }

	            // Loop through all extensions
	            this.forEachExtension(function (extension) {
	                // For those extensions where we can use document.queryCommandState(), do so
	                if (typeof extension.queryCommandState === 'function') {
	                    queryState = extension.queryCommandState();
	                    // If queryCommandState returns a valid value, we can trust the browser
	                    // and don't need to do our manual checks
	                    if (queryState !== null) {
	                        if (queryState && typeof extension.setActive === 'function') {
	                            extension.setActive();
	                        }
	                        return;
	                    }
	                }
	                // We can't use queryCommandState for this extension, so add to manualStateChecks
	                manualStateChecks.push(extension);
	            });

	            parentNode = MediumEditor.selection.getSelectedParentElement(selectionRange);

	            // Make sure the selection parent isn't outside of the contenteditable
	            if (!this.getEditorElements().some(function (element) {
	                    return MediumEditor.util.isDescendant(element, parentNode, true);
	                })) {
	                return;
	            }

	            // Climb up the DOM and do manual checks for whether a certain extension is currently enabled for this node
	            while (parentNode) {
	                manualStateChecks.forEach(updateExtensionState);

	                // we can abort the search upwards if we leave the contentEditable element
	                if (MediumEditor.util.isMediumEditorElement(parentNode)) {
	                    break;
	                }
	                parentNode = parentNode.parentNode;
	            }
	        },

	        // Positioning toolbar

	        positionToolbarIfShown: function () {
	            if (this.isDisplayed()) {
	                this.setToolbarPosition();
	            }
	        },

	        setToolbarPosition: function () {
	            var container = this.base.getFocusedElement(),
	                selection = this.window.getSelection();

	            // If there isn't a valid selection, bail
	            if (!container) {
	                return this;
	            }

	            if (this.static || !selection.isCollapsed) {
	                this.showToolbar();

	                // we don't need any absolute positioning if relativeContainer is set
	                if (!this.relativeContainer) {
	                    if (this.static) {
	                        this.positionStaticToolbar(container);
	                    } else {
	                        this.positionToolbar(selection);
	                    }
	                }

	                this.trigger('positionedToolbar', {}, this.base.getFocusedElement());
	            }
	        },

	        positionStaticToolbar: function (container) {
	            // position the toolbar at left 0, so we can get the real width of the toolbar
	            this.getToolbarElement().style.left = '0';

	            // document.documentElement for IE 9
	            var scrollTop = (this.document.documentElement && this.document.documentElement.scrollTop) || this.document.body.scrollTop,
	                windowWidth = this.window.innerWidth,
	                toolbarElement = this.getToolbarElement(),
	                containerRect = container.getBoundingClientRect(),
	                containerTop = containerRect.top + scrollTop,
	                containerCenter = (containerRect.left + (containerRect.width / 2)),
	                toolbarHeight = toolbarElement.offsetHeight,
	                toolbarWidth = toolbarElement.offsetWidth,
	                halfOffsetWidth = toolbarWidth / 2,
	                targetLeft;

	            if (this.sticky) {
	                // If it's beyond the height of the editor, position it at the bottom of the editor
	                if (scrollTop > (containerTop + container.offsetHeight - toolbarHeight - this.stickyTopOffset)) {
	                    toolbarElement.style.top = (containerTop + container.offsetHeight - toolbarHeight) + 'px';
	                    toolbarElement.classList.remove('medium-editor-sticky-toolbar');
	                // Stick the toolbar to the top of the window
	                } else if (scrollTop > (containerTop - toolbarHeight - this.stickyTopOffset)) {
	                    toolbarElement.classList.add('medium-editor-sticky-toolbar');
	                    toolbarElement.style.top = this.stickyTopOffset + 'px';
	                // Normal static toolbar position
	                } else {
	                    toolbarElement.classList.remove('medium-editor-sticky-toolbar');
	                    toolbarElement.style.top = containerTop - toolbarHeight + 'px';
	                }
	            } else {
	                toolbarElement.style.top = containerTop - toolbarHeight + 'px';
	            }

	            switch (this.align) {
	                case 'left':
	                    targetLeft = containerRect.left;
	                    break;

	                case 'right':
	                    targetLeft = containerRect.right - toolbarWidth;
	                    break;

	                case 'center':
	                    targetLeft = containerCenter - halfOffsetWidth;
	                    break;
	            }

	            if (targetLeft < 0) {
	                targetLeft = 0;
	            } else if ((targetLeft + toolbarWidth) > windowWidth) {
	                targetLeft = (windowWidth - Math.ceil(toolbarWidth) - 1);
	            }

	            toolbarElement.style.left = targetLeft + 'px';
	        },

	        positionToolbar: function (selection) {
	            // position the toolbar at left 0, so we can get the real width of the toolbar
	            this.getToolbarElement().style.left = '0';
	            this.getToolbarElement().style.right = 'initial';

	            var range = selection.getRangeAt(0),
	                boundary = range.getBoundingClientRect();

	            // Handle selections with just images
	            if (!boundary || ((boundary.height === 0 && boundary.width === 0) && range.startContainer === range.endContainer)) {
	                // If there's a nested image, use that for the bounding rectangle
	                if (range.startContainer.nodeType === 1 && range.startContainer.querySelector('img')) {
	                    boundary = range.startContainer.querySelector('img').getBoundingClientRect();
	                } else {
	                    boundary = range.startContainer.getBoundingClientRect();
	                }
	            }

	            var windowWidth = this.window.innerWidth,
	                middleBoundary = (boundary.left + boundary.right) / 2,
	                toolbarElement = this.getToolbarElement(),
	                toolbarHeight = toolbarElement.offsetHeight,
	                toolbarWidth = toolbarElement.offsetWidth,
	                halfOffsetWidth = toolbarWidth / 2,
	                buttonHeight = 50,
	                defaultLeft = this.diffLeft - halfOffsetWidth;

	            if (boundary.top < buttonHeight) {
	                toolbarElement.classList.add('medium-toolbar-arrow-over');
	                toolbarElement.classList.remove('medium-toolbar-arrow-under');
	                toolbarElement.style.top = buttonHeight + boundary.bottom - this.diffTop + this.window.pageYOffset - toolbarHeight + 'px';
	            } else {
	                toolbarElement.classList.add('medium-toolbar-arrow-under');
	                toolbarElement.classList.remove('medium-toolbar-arrow-over');
	                toolbarElement.style.top = boundary.top + this.diffTop + this.window.pageYOffset - toolbarHeight + 'px';
	            }

	            if (middleBoundary < halfOffsetWidth) {
	                toolbarElement.style.left = defaultLeft + halfOffsetWidth + 'px';
	                toolbarElement.style.right = 'initial';
	            } else if ((windowWidth - middleBoundary) < halfOffsetWidth) {
	                toolbarElement.style.left = 'auto';
	                toolbarElement.style.right = 0;
	            } else {
	                toolbarElement.style.left = defaultLeft + middleBoundary + 'px';
	                toolbarElement.style.right = 'initial';
	            }
	        }
	    });

	    MediumEditor.extensions.toolbar = Toolbar;
	}());

	(function () {
	    'use strict';

	    var ImageDragging = MediumEditor.Extension.extend({
	        init: function () {
	            MediumEditor.Extension.prototype.init.apply(this, arguments);

	            this.subscribe('editableDrag', this.handleDrag.bind(this));
	            this.subscribe('editableDrop', this.handleDrop.bind(this));
	        },

	        handleDrag: function (event) {
	            var className = 'medium-editor-dragover';
	            event.preventDefault();
	            event.dataTransfer.dropEffect = 'copy';

	            if (event.type === 'dragover') {
	                event.target.classList.add(className);
	            } else if (event.type === 'dragleave') {
	                event.target.classList.remove(className);
	            }
	        },

	        handleDrop: function (event) {
	            var className = 'medium-editor-dragover',
	                files;
	            event.preventDefault();
	            event.stopPropagation();

	            // IE9 does not support the File API, so prevent file from opening in a new window
	            // but also don't try to actually get the file
	            if (event.dataTransfer.files) {
	                files = Array.prototype.slice.call(event.dataTransfer.files, 0);
	                files.some(function (file) {
	                    if (file.type.match('image')) {
	                        var fileReader, id;
	                        fileReader = new FileReader();
	                        fileReader.readAsDataURL(file);

	                        id = 'medium-img-' + (+new Date());
	                        MediumEditor.util.insertHTMLCommand(this.document, '<img class="medium-editor-image-loading" id="' + id + '" />');

	                        fileReader.onload = function () {
	                            var img = this.document.getElementById(id);
	                            if (img) {
	                                img.removeAttribute('id');
	                                img.removeAttribute('class');
	                                img.src = fileReader.result;
	                            }
	                        }.bind(this);
	                    }
	                }.bind(this));
	            }
	            event.target.classList.remove(className);
	        }
	    });

	    MediumEditor.extensions.imageDragging = ImageDragging;
	}());

	(function () {
	    'use strict';

	    // Event handlers that shouldn't be exposed externally

	    function handleDisableExtraSpaces(event) {
	        var node = MediumEditor.selection.getSelectionStart(this.options.ownerDocument),
	            textContent = node.textContent,
	            caretPositions = MediumEditor.selection.getCaretOffsets(node);

	        if ((textContent[caretPositions.left - 1] === undefined) || (textContent[caretPositions.left - 1].trim() === '') || (textContent[caretPositions.left] !== undefined && textContent[caretPositions.left].trim() === '')) {
	            event.preventDefault();
	        }
	    }

	    function handleDisabledEnterKeydown(event, element) {
	        if (this.options.disableReturn || element.getAttribute('data-disable-return')) {
	            event.preventDefault();
	        } else if (this.options.disableDoubleReturn || element.getAttribute('data-disable-double-return')) {
	            var node = MediumEditor.selection.getSelectionStart(this.options.ownerDocument);

	            // if current text selection is empty OR previous sibling text is empty OR it is not a list
	            if ((node && node.textContent.trim() === '' && node.nodeName.toLowerCase() !== 'li') ||
	                (node.previousElementSibling && node.previousElementSibling.nodeName.toLowerCase() !== 'br' &&
	                 node.previousElementSibling.textContent.trim() === '')) {
	                event.preventDefault();
	            }
	        }
	    }

	    function handleTabKeydown(event) {
	        // Override tab only for pre nodes
	        var node = MediumEditor.selection.getSelectionStart(this.options.ownerDocument),
	            tag = node && node.nodeName.toLowerCase();

	        if (tag === 'pre') {
	            event.preventDefault();
	            MediumEditor.util.insertHTMLCommand(this.options.ownerDocument, '    ');
	        }

	        // Tab to indent list structures!
	        if (MediumEditor.util.isListItem(node)) {
	            event.preventDefault();

	            // If Shift is down, outdent, otherwise indent
	            if (event.shiftKey) {
	                this.options.ownerDocument.execCommand('outdent', false, null);
	            } else {
	                this.options.ownerDocument.execCommand('indent', false, null);
	            }
	        }
	    }

	    function handleBlockDeleteKeydowns(event) {
	        var p, node = MediumEditor.selection.getSelectionStart(this.options.ownerDocument),
	            tagName = node.nodeName.toLowerCase(),
	            isEmpty = /^(\s+|<br\/?>)?$/i,
	            isHeader = /h\d/i;

	        if (MediumEditor.util.isKey(event, [MediumEditor.util.keyCode.BACKSPACE, MediumEditor.util.keyCode.ENTER]) &&
	                // has a preceeding sibling
	                node.previousElementSibling &&
	                // in a header
	                isHeader.test(tagName) &&
	                // at the very end of the block
	                MediumEditor.selection.getCaretOffsets(node).left === 0) {
	            if (MediumEditor.util.isKey(event, MediumEditor.util.keyCode.BACKSPACE) && isEmpty.test(node.previousElementSibling.innerHTML)) {
	                // backspacing the begining of a header into an empty previous element will
	                // change the tagName of the current node to prevent one
	                // instead delete previous node and cancel the event.
	                node.previousElementSibling.parentNode.removeChild(node.previousElementSibling);
	                event.preventDefault();
	            } else if (!this.options.disableDoubleReturn && MediumEditor.util.isKey(event, MediumEditor.util.keyCode.ENTER)) {
	                // hitting return in the begining of a header will create empty header elements before the current one
	                // instead, make "<p><br></p>" element, which are what happens if you hit return in an empty paragraph
	                p = this.options.ownerDocument.createElement('p');
	                p.innerHTML = '<br>';
	                node.previousElementSibling.parentNode.insertBefore(p, node);
	                event.preventDefault();
	            }
	        } else if (MediumEditor.util.isKey(event, MediumEditor.util.keyCode.DELETE) &&
	                    // between two sibling elements
	                    node.nextElementSibling &&
	                    node.previousElementSibling &&
	                    // not in a header
	                    !isHeader.test(tagName) &&
	                    // in an empty tag
	                    isEmpty.test(node.innerHTML) &&
	                    // when the next tag *is* a header
	                    isHeader.test(node.nextElementSibling.nodeName.toLowerCase())) {
	            // hitting delete in an empty element preceding a header, ex:
	            //  <p>[CURSOR]</p><h1>Header</h1>
	            // Will cause the h1 to become a paragraph.
	            // Instead, delete the paragraph node and move the cursor to the begining of the h1

	            // remove node and move cursor to start of header
	            MediumEditor.selection.moveCursor(this.options.ownerDocument, node.nextElementSibling);

	            node.previousElementSibling.parentNode.removeChild(node);

	            event.preventDefault();
	        } else if (MediumEditor.util.isKey(event, MediumEditor.util.keyCode.BACKSPACE) &&
	                tagName === 'li' &&
	                // hitting backspace inside an empty li
	                isEmpty.test(node.innerHTML) &&
	                // is first element (no preceeding siblings)
	                !node.previousElementSibling &&
	                // parent also does not have a sibling
	                !node.parentElement.previousElementSibling &&
	                // is not the only li in a list
	                node.nextElementSibling &&
	                node.nextElementSibling.nodeName.toLowerCase() === 'li') {
	            // backspacing in an empty first list element in the first list (with more elements) ex:
	            //  <ul><li>[CURSOR]</li><li>List Item 2</li></ul>
	            // will remove the first <li> but add some extra element before (varies based on browser)
	            // Instead, this will:
	            // 1) remove the list element
	            // 2) create a paragraph before the list
	            // 3) move the cursor into the paragraph

	            // create a paragraph before the list
	            p = this.options.ownerDocument.createElement('p');
	            p.innerHTML = '<br>';
	            node.parentElement.parentElement.insertBefore(p, node.parentElement);

	            // move the cursor into the new paragraph
	            MediumEditor.selection.moveCursor(this.options.ownerDocument, p);

	            // remove the list element
	            node.parentElement.removeChild(node);

	            event.preventDefault();
	        } else if (MediumEditor.util.isKey(event, MediumEditor.util.keyCode.BACKSPACE) &&
	                (MediumEditor.util.getClosestTag(node, 'blockquote') !== false) &&
	                MediumEditor.selection.getCaretOffsets(node).left === 0) {

	            // when cursor is at the begining of the element and the element is <blockquote>
	            // then pressing backspace key should change the <blockquote> to a <p> tag
	            event.preventDefault();
	            MediumEditor.util.execFormatBlock(this.options.ownerDocument, 'p');
	        }
	    }

	    function handleKeyup(event) {
	        var node = MediumEditor.selection.getSelectionStart(this.options.ownerDocument),
	            tagName;

	        if (!node) {
	            return;
	        }

	        // https://github.com/yabwe/medium-editor/issues/994
	        // Firefox thrown an error when calling `formatBlock` on an empty editable blockContainer that's not a <div>
	        if (MediumEditor.util.isMediumEditorElement(node) && node.children.length === 0 && !MediumEditor.util.isBlockContainer(node)) {
	            this.options.ownerDocument.execCommand('formatBlock', false, 'p');
	        }

	        // https://github.com/yabwe/medium-editor/issues/834
	        // https://github.com/yabwe/medium-editor/pull/382
	        // Don't call format block if this is a block element (ie h1, figCaption, etc.)
	        if (MediumEditor.util.isKey(event, MediumEditor.util.keyCode.ENTER) &&
	            !MediumEditor.util.isListItem(node) &&
	            !MediumEditor.util.isBlockContainer(node)) {

	            tagName = node.nodeName.toLowerCase();
	            // For anchor tags, unlink
	            if (tagName === 'a') {
	                this.options.ownerDocument.execCommand('unlink', false, null);
	            } else if (!event.shiftKey && !event.ctrlKey) {
	                this.options.ownerDocument.execCommand('formatBlock', false, 'p');
	            }
	        }
	    }

	    function handleEditableInput(event, editable) {
	        var textarea = editable.parentNode.querySelector('textarea[medium-editor-textarea-id="' + editable.getAttribute('medium-editor-textarea-id') + '"]');
	        if (textarea) {
	            textarea.value = editable.innerHTML.trim();
	        }
	    }

	    // Internal helper methods which shouldn't be exposed externally

	    function addToEditors(win) {
	        if (!win._mediumEditors) {
	            // To avoid breaking users who are assuming that the unique id on
	            // medium-editor elements will start at 1, inserting a 'null' in the
	            // array so the unique-id can always map to the index of the editor instance
	            win._mediumEditors = [null];
	        }

	        // If this already has a unique id, re-use it
	        if (!this.id) {
	            this.id = win._mediumEditors.length;
	        }

	        win._mediumEditors[this.id] = this;
	    }

	    function removeFromEditors(win) {
	        if (!win._mediumEditors || !win._mediumEditors[this.id]) {
	            return;
	        }

	        /* Setting the instance to null in the array instead of deleting it allows:
	         * 1) Each instance to preserve its own unique-id, even after being destroyed
	         *    and initialized again
	         * 2) The unique-id to always correspond to an index in the array of medium-editor
	         *    instances. Thus, we will be able to look at a contenteditable, and determine
	         *    which instance it belongs to, by indexing into the global array.
	         */
	        win._mediumEditors[this.id] = null;
	    }

	    function createElementsArray(selector, doc, filterEditorElements) {
	        var elements = [];

	        if (!selector) {
	            selector = [];
	        }
	        // If string, use as query selector
	        if (typeof selector === 'string') {
	            selector = doc.querySelectorAll(selector);
	        }
	        // If element, put into array
	        if (MediumEditor.util.isElement(selector)) {
	            selector = [selector];
	        }

	        if (filterEditorElements) {
	            // Remove elements that have already been initialized by the editor
	            // selecotr might not be an array (ie NodeList) so use for loop
	            for (var i = 0; i < selector.length; i++) {
	                var el = selector[i];
	                if (MediumEditor.util.isElement(el) &&
	                    !el.getAttribute('data-medium-editor-element') &&
	                    !el.getAttribute('medium-editor-textarea-id')) {
	                    elements.push(el);
	                }
	            }
	        } else {
	            // Convert NodeList (or other array like object) into an array
	            elements = Array.prototype.slice.apply(selector);
	        }

	        return elements;
	    }

	    function cleanupTextareaElement(element) {
	        var textarea = element.parentNode.querySelector('textarea[medium-editor-textarea-id="' + element.getAttribute('medium-editor-textarea-id') + '"]');
	        if (textarea) {
	            // Un-hide the textarea
	            textarea.classList.remove('medium-editor-hidden');
	            textarea.removeAttribute('medium-editor-textarea-id');
	        }
	        if (element.parentNode) {
	            element.parentNode.removeChild(element);
	        }
	    }

	    function setExtensionDefaults(extension, defaults) {
	        Object.keys(defaults).forEach(function (prop) {
	            if (extension[prop] === undefined) {
	                extension[prop] = defaults[prop];
	            }
	        });
	        return extension;
	    }

	    function initExtension(extension, name, instance) {
	        var extensionDefaults = {
	            'window': instance.options.contentWindow,
	            'document': instance.options.ownerDocument,
	            'base': instance
	        };

	        // Add default options into the extension
	        extension = setExtensionDefaults(extension, extensionDefaults);

	        // Call init on the extension
	        if (typeof extension.init === 'function') {
	            extension.init();
	        }

	        // Set extension name (if not already set)
	        if (!extension.name) {
	            extension.name = name;
	        }
	        return extension;
	    }

	    function isToolbarEnabled() {
	        // If any of the elements don't have the toolbar disabled
	        // We need a toolbar
	        if (this.elements.every(function (element) {
	                return !!element.getAttribute('data-disable-toolbar');
	            })) {
	            return false;
	        }

	        return this.options.toolbar !== false;
	    }

	    function isAnchorPreviewEnabled() {
	        // If toolbar is disabled, don't add
	        if (!isToolbarEnabled.call(this)) {
	            return false;
	        }

	        return this.options.anchorPreview !== false;
	    }

	    function isPlaceholderEnabled() {
	        return this.options.placeholder !== false;
	    }

	    function isAutoLinkEnabled() {
	        return this.options.autoLink !== false;
	    }

	    function isImageDraggingEnabled() {
	        return this.options.imageDragging !== false;
	    }

	    function isKeyboardCommandsEnabled() {
	        return this.options.keyboardCommands !== false;
	    }

	    function shouldUseFileDraggingExtension() {
	        // Since the file-dragging extension replaces the image-dragging extension,
	        // we need to check if the user passed an overrided image-dragging extension.
	        // If they have, to avoid breaking users, we won't use file-dragging extension.
	        return !this.options.extensions['imageDragging'];
	    }

	    function createContentEditable(textarea, id, doc) {
	        var div = doc.createElement('div'),
	            now = Date.now(),
	            uniqueId = 'medium-editor-' + now + '-' + id,
	            atts = textarea.attributes;

	        // Some browsers can move pretty fast, since we're using a timestamp
	        // to make a unique-id, ensure that the id is actually unique on the page
	        while (doc.getElementById(uniqueId)) {
	            now++;
	            uniqueId = 'medium-editor-' + now + '-' + id;
	        }

	        div.className = textarea.className;
	        div.id = uniqueId;
	        div.innerHTML = textarea.value;

	        textarea.setAttribute('medium-editor-textarea-id', uniqueId);

	        // re-create all attributes from the textearea to the new created div
	        for (var i = 0, n = atts.length; i < n; i++) {
	            // do not re-create existing attributes
	            if (!div.hasAttribute(atts[i].nodeName)) {
	                div.setAttribute(atts[i].nodeName, atts[i].nodeValue);
	            }
	        }

	        textarea.classList.add('medium-editor-hidden');
	        textarea.parentNode.insertBefore(
	            div,
	            textarea
	        );

	        return div;
	    }

	    function initElement(element, id) {
	        if (!element.getAttribute('data-medium-editor-element')) {
	            if (element.nodeName.toLowerCase() === 'textarea') {
	                element = createContentEditable(element, id, this.options.ownerDocument);

	                // Make sure we only attach to editableInput once for <textarea> elements
	                if (!this.instanceHandleEditableInput) {
	                    this.instanceHandleEditableInput = handleEditableInput.bind(this);
	                    this.subscribe('editableInput', this.instanceHandleEditableInput);
	                }
	            }

	            if (!this.options.disableEditing && !element.getAttribute('data-disable-editing')) {
	                element.setAttribute('contentEditable', true);
	                element.setAttribute('spellcheck', this.options.spellcheck);
	            }

	            // Make sure we only attach to editableKeydownEnter once for disable-return options
	            if (!this.instanceHandleEditableKeydownEnter) {
	                if (element.getAttribute('data-disable-return') || element.getAttribute('data-disable-double-return')) {
	                    this.instanceHandleEditableKeydownEnter = handleDisabledEnterKeydown.bind(this);
	                    this.subscribe('editableKeydownEnter', this.instanceHandleEditableKeydownEnter);
	                }
	            }

	            // if we're not disabling return, add a handler to help handle cleanup
	            // for certain cases when enter is pressed
	            if (!this.options.disableReturn && !element.getAttribute('data-disable-return')) {
	                this.on(element, 'keyup', handleKeyup.bind(this));
	            }

	            element.setAttribute('data-medium-editor-element', true);
	            element.setAttribute('role', 'textbox');
	            element.setAttribute('aria-multiline', true);
	            element.setAttribute('medium-editor-index', MediumEditor.util.guid());

	            this.events.attachAllEventsToElement(element);
	        }

	        return element;
	    }

	    function attachHandlers() {
	        // attach to tabs
	        this.subscribe('editableKeydownTab', handleTabKeydown.bind(this));

	        // Bind keys which can create or destroy a block element: backspace, delete, return
	        this.subscribe('editableKeydownDelete', handleBlockDeleteKeydowns.bind(this));
	        this.subscribe('editableKeydownEnter', handleBlockDeleteKeydowns.bind(this));

	        // Bind double space event
	        if (this.options.disableExtraSpaces) {
	            this.subscribe('editableKeydownSpace', handleDisableExtraSpaces.bind(this));
	        }

	        // Make sure we only attach to editableKeydownEnter once for disable-return options
	        if (!this.instanceHandleEditableKeydownEnter) {
	            // disabling return or double return
	            if (this.options.disableReturn || this.options.disableDoubleReturn) {
	                this.instanceHandleEditableKeydownEnter = handleDisabledEnterKeydown.bind(this);
	                this.subscribe('editableKeydownEnter', this.instanceHandleEditableKeydownEnter);
	            }
	        }
	    }

	    function initExtensions() {

	        this.extensions = [];

	        // Passed in extensions
	        Object.keys(this.options.extensions).forEach(function (name) {
	            // Always save the toolbar extension for last
	            if (name !== 'toolbar' && this.options.extensions[name]) {
	                this.extensions.push(initExtension(this.options.extensions[name], name, this));
	            }
	        }, this);

	        // 4 Cases for imageDragging + fileDragging extensons:
	        //
	        // 1. ImageDragging ON + No Custom Image Dragging Extension:
	        //    * Use fileDragging extension (default options)
	        // 2. ImageDragging OFF + No Custom Image Dragging Extension:
	        //    * Use fileDragging extension w/ images turned off
	        // 3. ImageDragging ON + Custom Image Dragging Extension:
	        //    * Don't use fileDragging (could interfere with custom image dragging extension)
	        // 4. ImageDragging OFF + Custom Image Dragging:
	        //    * Don't use fileDragging (could interfere with custom image dragging extension)
	        if (shouldUseFileDraggingExtension.call(this)) {
	            var opts = this.options.fileDragging;
	            if (!opts) {
	                opts = {};

	                // Image is in the 'allowedTypes' list by default.
	                // If imageDragging is off override the 'allowedTypes' list with an empty one
	                if (!isImageDraggingEnabled.call(this)) {
	                    opts.allowedTypes = [];
	                }
	            }
	            this.addBuiltInExtension('fileDragging', opts);
	        }

	        // Built-in extensions
	        var builtIns = {
	            paste: true,
	            'anchor-preview': isAnchorPreviewEnabled.call(this),
	            autoLink: isAutoLinkEnabled.call(this),
	            keyboardCommands: isKeyboardCommandsEnabled.call(this),
	            placeholder: isPlaceholderEnabled.call(this)
	        };
	        Object.keys(builtIns).forEach(function (name) {
	            if (builtIns[name]) {
	                this.addBuiltInExtension(name);
	            }
	        }, this);

	        // Users can pass in a custom toolbar extension
	        // so check for that first and if it's not present
	        // just create the default toolbar
	        var toolbarExtension = this.options.extensions['toolbar'];
	        if (!toolbarExtension && isToolbarEnabled.call(this)) {
	            // Backwards compatability
	            var toolbarOptions = MediumEditor.util.extend({}, this.options.toolbar, {
	                allowMultiParagraphSelection: this.options.allowMultiParagraphSelection // deprecated
	            });
	            toolbarExtension = new MediumEditor.extensions.toolbar(toolbarOptions);
	        }

	        // If the toolbar is not disabled, so we actually have an extension
	        // initialize it and add it to the extensions array
	        if (toolbarExtension) {
	            this.extensions.push(initExtension(toolbarExtension, 'toolbar', this));
	        }
	    }

	    function mergeOptions(defaults, options) {
	        var deprecatedProperties = [
	            ['allowMultiParagraphSelection', 'toolbar.allowMultiParagraphSelection']
	        ];
	        // warn about using deprecated properties
	        if (options) {
	            deprecatedProperties.forEach(function (pair) {
	                if (options.hasOwnProperty(pair[0]) && options[pair[0]] !== undefined) {
	                    MediumEditor.util.deprecated(pair[0], pair[1], 'v6.0.0');
	                }
	            });
	        }

	        return MediumEditor.util.defaults({}, options, defaults);
	    }

	    function execActionInternal(action, opts) {
	        /*jslint regexp: true*/
	        var appendAction = /^append-(.+)$/gi,
	            justifyAction = /justify([A-Za-z]*)$/g, /* Detecting if is justifyCenter|Right|Left */
	            match,
	            cmdValueArgument;
	        /*jslint regexp: false*/

	        // Actions starting with 'append-' should attempt to format a block of text ('formatBlock') using a specific
	        // type of block element (ie append-blockquote, append-h1, append-pre, etc.)
	        match = appendAction.exec(action);
	        if (match) {
	            return MediumEditor.util.execFormatBlock(this.options.ownerDocument, match[1]);
	        }

	        if (action === 'fontSize') {
	            // TODO: Deprecate support for opts.size in 6.0.0
	            if (opts.size) {
	                MediumEditor.util.deprecated('.size option for fontSize command', '.value', '6.0.0');
	            }
	            cmdValueArgument = opts.value || opts.size;
	            return this.options.ownerDocument.execCommand('fontSize', false, cmdValueArgument);
	        }

	        if (action === 'fontName') {
	            // TODO: Deprecate support for opts.name in 6.0.0
	            if (opts.name) {
	                MediumEditor.util.deprecated('.name option for fontName command', '.value', '6.0.0');
	            }
	            cmdValueArgument = opts.value || opts.name;
	            return this.options.ownerDocument.execCommand('fontName', false, cmdValueArgument);
	        }

	        if (action === 'createLink') {
	            return this.createLink(opts);
	        }

	        if (action === 'image') {
	            var src = this.options.contentWindow.getSelection().toString().trim();
	            return this.options.ownerDocument.execCommand('insertImage', false, src);
	        }

	        /* Issue: https://github.com/yabwe/medium-editor/issues/595
	         * If the action is to justify the text */
	        if (justifyAction.exec(action)) {
	            var result = this.options.ownerDocument.execCommand(action, false, null),
	                parentNode = MediumEditor.selection.getSelectedParentElement(MediumEditor.selection.getSelectionRange(this.options.ownerDocument));
	            if (parentNode) {
	                cleanupJustifyDivFragments.call(this, MediumEditor.util.getTopBlockContainer(parentNode));
	            }

	            return result;
	        }

	        cmdValueArgument = opts && opts.value;
	        return this.options.ownerDocument.execCommand(action, false, cmdValueArgument);
	    }

	    /* If we've just justified text within a container block
	     * Chrome may have removed <br> elements and instead wrapped lines in <div> elements
	     * with a text-align property.  If so, we want to fix this
	     */
	    function cleanupJustifyDivFragments(blockContainer) {
	        if (!blockContainer) {
	            return;
	        }

	        var textAlign,
	            childDivs = Array.prototype.slice.call(blockContainer.childNodes).filter(function (element) {
	                var isDiv = element.nodeName.toLowerCase() === 'div';
	                if (isDiv && !textAlign) {
	                    textAlign = element.style.textAlign;
	                }
	                return isDiv;
	            });

	        /* If we found child <div> elements with text-align style attributes
	         * we should fix this by:
	         *
	         * 1) Unwrapping each <div> which has a text-align style
	         * 2) Insert a <br> element after each set of 'unwrapped' div children
	         * 3) Set the text-align style of the parent block element
	         */
	        if (childDivs.length) {
	            // Since we're mucking with the HTML, preserve selection
	            this.saveSelection();
	            childDivs.forEach(function (div) {
	                if (div.style.textAlign === textAlign) {
	                    var lastChild = div.lastChild;
	                    if (lastChild) {
	                        // Instead of a div, extract the child elements and add a <br>
	                        MediumEditor.util.unwrap(div, this.options.ownerDocument);
	                        var br = this.options.ownerDocument.createElement('BR');
	                        lastChild.parentNode.insertBefore(br, lastChild.nextSibling);
	                    }
	                }
	            }, this);
	            blockContainer.style.textAlign = textAlign;
	            // We're done, so restore selection
	            this.restoreSelection();
	        }
	    }

	    MediumEditor.prototype = {
	        // NOT DOCUMENTED - exposed for backwards compatability
	        init: function (elements, options) {
	            this.options = mergeOptions.call(this, this.defaults, options);
	            this.origElements = elements;

	            if (!this.options.elementsContainer) {
	                this.options.elementsContainer = this.options.ownerDocument.body;
	            }

	            return this.setup();
	        },

	        setup: function () {
	            if (this.isActive) {
	                return;
	            }

	            this.events = new MediumEditor.Events(this);
	            this.elements = [];

	            this.addElements(this.origElements);

	            if (this.elements.length === 0) {
	                return;
	            }

	            this.isActive = true;
	            addToEditors.call(this, this.options.contentWindow);

	            // Call initialization helpers
	            initExtensions.call(this);
	            attachHandlers.call(this);
	        },

	        destroy: function () {
	            if (!this.isActive) {
	                return;
	            }

	            this.isActive = false;

	            this.extensions.forEach(function (extension) {
	                if (typeof extension.destroy === 'function') {
	                    extension.destroy();
	                }
	            }, this);

	            this.events.destroy();

	            this.elements.forEach(function (element) {
	                // Reset elements content, fix for issue where after editor destroyed the red underlines on spelling errors are left
	                if (this.options.spellcheck) {
	                    element.innerHTML = element.innerHTML;
	                }

	                // cleanup extra added attributes
	                element.removeAttribute('contentEditable');
	                element.removeAttribute('spellcheck');
	                element.removeAttribute('data-medium-editor-element');
	                element.removeAttribute('role');
	                element.removeAttribute('aria-multiline');
	                element.removeAttribute('medium-editor-index');

	                // Remove any elements created for textareas
	                if (element.getAttribute('medium-editor-textarea-id')) {
	                    cleanupTextareaElement(element);
	                }
	            }, this);
	            this.elements = [];
	            this.instanceHandleEditableKeydownEnter = null;
	            this.instanceHandleEditableInput = null;

	            removeFromEditors.call(this, this.options.contentWindow);
	        },

	        on: function (target, event, listener, useCapture) {
	            this.events.attachDOMEvent(target, event, listener, useCapture);

	            return this;
	        },

	        off: function (target, event, listener, useCapture) {
	            this.events.detachDOMEvent(target, event, listener, useCapture);

	            return this;
	        },

	        subscribe: function (event, listener) {
	            this.events.attachCustomEvent(event, listener);

	            return this;
	        },

	        unsubscribe: function (event, listener) {
	            this.events.detachCustomEvent(event, listener);

	            return this;
	        },

	        trigger: function (name, data, editable) {
	            this.events.triggerCustomEvent(name, data, editable);

	            return this;
	        },

	        delay: function (fn) {
	            var self = this;
	            return setTimeout(function () {
	                if (self.isActive) {
	                    fn();
	                }
	            }, this.options.delay);
	        },

	        serialize: function () {
	            var i,
	                elementid,
	                content = {},
	                len = this.elements.length;

	            for (i = 0; i < len; i += 1) {
	                elementid = (this.elements[i].id !== '') ? this.elements[i].id : 'element-' + i;
	                content[elementid] = {
	                    value: this.elements[i].innerHTML.trim()
	                };
	            }
	            return content;
	        },

	        getExtensionByName: function (name) {
	            var extension;
	            if (this.extensions && this.extensions.length) {
	                this.extensions.some(function (ext) {
	                    if (ext.name === name) {
	                        extension = ext;
	                        return true;
	                    }
	                    return false;
	                });
	            }
	            return extension;
	        },

	        /**
	         * NOT DOCUMENTED - exposed as a helper for other extensions to use
	         */
	        addBuiltInExtension: function (name, opts) {
	            var extension = this.getExtensionByName(name),
	                merged;
	            if (extension) {
	                return extension;
	            }

	            switch (name) {
	                case 'anchor':
	                    merged = MediumEditor.util.extend({}, this.options.anchor, opts);
	                    extension = new MediumEditor.extensions.anchor(merged);
	                    break;
	                case 'anchor-preview':
	                    extension = new MediumEditor.extensions.anchorPreview(this.options.anchorPreview);
	                    break;
	                case 'autoLink':
	                    extension = new MediumEditor.extensions.autoLink();
	                    break;
	                case 'fileDragging':
	                    extension = new MediumEditor.extensions.fileDragging(opts);
	                    break;
	                case 'fontname':
	                    extension = new MediumEditor.extensions.fontName(this.options.fontName);
	                    break;
	                case 'fontsize':
	                    extension = new MediumEditor.extensions.fontSize(opts);
	                    break;
	                case 'keyboardCommands':
	                    extension = new MediumEditor.extensions.keyboardCommands(this.options.keyboardCommands);
	                    break;
	                case 'paste':
	                    extension = new MediumEditor.extensions.paste(this.options.paste);
	                    break;
	                case 'placeholder':
	                    extension = new MediumEditor.extensions.placeholder(this.options.placeholder);
	                    break;
	                default:
	                    // All of the built-in buttons for MediumEditor are extensions
	                    // so check to see if the extension we're creating is a built-in button
	                    if (MediumEditor.extensions.button.isBuiltInButton(name)) {
	                        if (opts) {
	                            merged = MediumEditor.util.defaults({}, opts, MediumEditor.extensions.button.prototype.defaults[name]);
	                            extension = new MediumEditor.extensions.button(merged);
	                        } else {
	                            extension = new MediumEditor.extensions.button(name);
	                        }
	                    }
	            }

	            if (extension) {
	                this.extensions.push(initExtension(extension, name, this));
	            }

	            return extension;
	        },

	        stopSelectionUpdates: function () {
	            this.preventSelectionUpdates = true;
	        },

	        startSelectionUpdates: function () {
	            this.preventSelectionUpdates = false;
	        },

	        checkSelection: function () {
	            var toolbar = this.getExtensionByName('toolbar');
	            if (toolbar) {
	                toolbar.checkState();
	            }
	            return this;
	        },

	        // Wrapper around document.queryCommandState for checking whether an action has already
	        // been applied to the current selection
	        queryCommandState: function (action) {
	            var fullAction = /^full-(.+)$/gi,
	                match,
	                queryState = null;

	            // Actions starting with 'full-' need to be modified since this is a medium-editor concept
	            match = fullAction.exec(action);
	            if (match) {
	                action = match[1];
	            }

	            try {
	                queryState = this.options.ownerDocument.queryCommandState(action);
	            } catch (exc) {
	                queryState = null;
	            }

	            return queryState;
	        },

	        execAction: function (action, opts) {
	            /*jslint regexp: true*/
	            var fullAction = /^full-(.+)$/gi,
	                match,
	                result;
	            /*jslint regexp: false*/

	            // Actions starting with 'full-' should be applied to to the entire contents of the editable element
	            // (ie full-bold, full-append-pre, etc.)
	            match = fullAction.exec(action);
	            if (match) {
	                // Store the current selection to be restored after applying the action
	                this.saveSelection();
	                // Select all of the contents before calling the action
	                this.selectAllContents();
	                result = execActionInternal.call(this, match[1], opts);
	                // Restore the previous selection
	                this.restoreSelection();
	            } else {
	                result = execActionInternal.call(this, action, opts);
	            }

	            // do some DOM clean-up for known browser issues after the action
	            if (action === 'insertunorderedlist' || action === 'insertorderedlist') {
	                MediumEditor.util.cleanListDOM(this.options.ownerDocument, this.getSelectedParentElement());
	            }

	            this.checkSelection();
	            return result;
	        },

	        getSelectedParentElement: function (range) {
	            if (range === undefined) {
	                range = this.options.contentWindow.getSelection().getRangeAt(0);
	            }
	            return MediumEditor.selection.getSelectedParentElement(range);
	        },

	        selectAllContents: function () {
	            var currNode = MediumEditor.selection.getSelectionElement(this.options.contentWindow);

	            if (currNode) {
	                // Move to the lowest descendant node that still selects all of the contents
	                while (currNode.children.length === 1) {
	                    currNode = currNode.children[0];
	                }

	                this.selectElement(currNode);
	            }
	        },

	        selectElement: function (element) {
	            MediumEditor.selection.selectNode(element, this.options.ownerDocument);

	            var selElement = MediumEditor.selection.getSelectionElement(this.options.contentWindow);
	            if (selElement) {
	                this.events.focusElement(selElement);
	            }
	        },

	        getFocusedElement: function () {
	            var focused;
	            this.elements.some(function (element) {
	                // Find the element that has focus
	                if (!focused && element.getAttribute('data-medium-focused')) {
	                    focused = element;
	                }

	                // bail if we found the element that had focus
	                return !!focused;
	            }, this);

	            return focused;
	        },

	        // Export the state of the selection in respect to one of this
	        // instance of MediumEditor's elements
	        exportSelection: function () {
	            var selectionElement = MediumEditor.selection.getSelectionElement(this.options.contentWindow),
	                editableElementIndex = this.elements.indexOf(selectionElement),
	                selectionState = null;

	            if (editableElementIndex >= 0) {
	                selectionState = MediumEditor.selection.exportSelection(selectionElement, this.options.ownerDocument);
	            }

	            if (selectionState !== null && editableElementIndex !== 0) {
	                selectionState.editableElementIndex = editableElementIndex;
	            }

	            return selectionState;
	        },

	        saveSelection: function () {
	            this.selectionState = this.exportSelection();
	        },

	        // Restore a selection based on a selectionState returned by a call
	        // to MediumEditor.exportSelection
	        importSelection: function (selectionState, favorLaterSelectionAnchor) {
	            if (!selectionState) {
	                return;
	            }

	            var editableElement = this.elements[selectionState.editableElementIndex || 0];
	            MediumEditor.selection.importSelection(selectionState, editableElement, this.options.ownerDocument, favorLaterSelectionAnchor);
	        },

	        restoreSelection: function () {
	            this.importSelection(this.selectionState);
	        },

	        createLink: function (opts) {
	            var currentEditor = MediumEditor.selection.getSelectionElement(this.options.contentWindow),
	                customEvent = {},
	                targetUrl;

	            // Make sure the selection is within an element this editor is tracking
	            if (this.elements.indexOf(currentEditor) === -1) {
	                return;
	            }

	            try {
	                this.events.disableCustomEvent('editableInput');
	                // TODO: Deprecate support for opts.url in 6.0.0
	                if (opts.url) {
	                    MediumEditor.util.deprecated('.url option for createLink', '.value', '6.0.0');
	                }
	                targetUrl = opts.url || opts.value;
	                if (targetUrl && targetUrl.trim().length > 0) {
	                    var currentSelection = this.options.contentWindow.getSelection();
	                    if (currentSelection) {
	                        var currRange = currentSelection.getRangeAt(0),
	                            commonAncestorContainer = currRange.commonAncestorContainer,
	                            exportedSelection,
	                            startContainerParentElement,
	                            endContainerParentElement,
	                            textNodes;

	                        // If the selection is contained within a single text node
	                        // and the selection starts at the beginning of the text node,
	                        // MSIE still says the startContainer is the parent of the text node.
	                        // If the selection is contained within a single text node, we
	                        // want to just use the default browser 'createLink', so we need
	                        // to account for this case and adjust the commonAncestorContainer accordingly
	                        if (currRange.endContainer.nodeType === 3 &&
	                            currRange.startContainer.nodeType !== 3 &&
	                            currRange.startOffset === 0 &&
	                            currRange.startContainer.firstChild === currRange.endContainer) {
	                            commonAncestorContainer = currRange.endContainer;
	                        }

	                        startContainerParentElement = MediumEditor.util.getClosestBlockContainer(currRange.startContainer);
	                        endContainerParentElement = MediumEditor.util.getClosestBlockContainer(currRange.endContainer);

	                        // If the selection is not contained within a single text node
	                        // but the selection is contained within the same block element
	                        // we want to make sure we create a single link, and not multiple links
	                        // which can happen with the built in browser functionality
	                        if (commonAncestorContainer.nodeType !== 3 && commonAncestorContainer.textContent.length !== 0 && startContainerParentElement === endContainerParentElement) {
	                            var parentElement = (startContainerParentElement || currentEditor),
	                                fragment = this.options.ownerDocument.createDocumentFragment();

	                            // since we are going to create a link from an extracted text,
	                            // be sure that if we are updating a link, we won't let an empty link behind (see #754)
	                            // (Workaroung for Chrome)
	                            this.execAction('unlink');

	                            exportedSelection = this.exportSelection();
	                            fragment.appendChild(parentElement.cloneNode(true));

	                            if (currentEditor === parentElement) {
	                                // We have to avoid the editor itself being wiped out when it's the only block element,
	                                // as our reference inside this.elements gets detached from the page when insertHTML runs.
	                                // If we just use [parentElement, 0] and [parentElement, parentElement.childNodes.length]
	                                // as the range boundaries, this happens whenever parentElement === currentEditor.
	                                // The tradeoff to this workaround is that a orphaned tag can sometimes be left behind at
	                                // the end of the editor's content.
	                                // In Gecko:
	                                // as an empty <strong></strong> if parentElement.lastChild is a <strong> tag.
	                                // In WebKit:
	                                // an invented <br /> tag at the end in the same situation
	                                MediumEditor.selection.select(
	                                    this.options.ownerDocument,
	                                    parentElement.firstChild,
	                                    0,
	                                    parentElement.lastChild,
	                                    parentElement.lastChild.nodeType === 3 ?
	                                    parentElement.lastChild.nodeValue.length : parentElement.lastChild.childNodes.length
	                                );
	                            } else {
	                                MediumEditor.selection.select(
	                                    this.options.ownerDocument,
	                                    parentElement,
	                                    0,
	                                    parentElement,
	                                    parentElement.childNodes.length
	                                );
	                            }

	                            var modifiedExportedSelection = this.exportSelection();

	                            textNodes = MediumEditor.util.findOrCreateMatchingTextNodes(
	                                this.options.ownerDocument,
	                                fragment,
	                                {
	                                    start: exportedSelection.start - modifiedExportedSelection.start,
	                                    end: exportedSelection.end - modifiedExportedSelection.start,
	                                    editableElementIndex: exportedSelection.editableElementIndex
	                                }
	                            );
	                            // If textNodes are not present, when changing link on images
	                            // ex: <a><img src="http://image.test.com"></a>, change fragment to currRange.startContainer
	                            // and set textNodes array to [imageElement, imageElement]
	                            if (textNodes.length === 0) {
	                                fragment = this.options.ownerDocument.createDocumentFragment();
	                                fragment.appendChild(commonAncestorContainer.cloneNode(true));
	                                textNodes = [fragment.firstChild.firstChild, fragment.firstChild.lastChild];
	                            }

	                            // Creates the link in the document fragment
	                            MediumEditor.util.createLink(this.options.ownerDocument, textNodes, targetUrl.trim());

	                            // Chrome trims the leading whitespaces when inserting HTML, which messes up restoring the selection.
	                            var leadingWhitespacesCount = (fragment.firstChild.innerHTML.match(/^\s+/) || [''])[0].length;

	                            // Now move the created link back into the original document in a way to preserve undo/redo history
	                            MediumEditor.util.insertHTMLCommand(this.options.ownerDocument, fragment.firstChild.innerHTML.replace(/^\s+/, ''));
	                            exportedSelection.start -= leadingWhitespacesCount;
	                            exportedSelection.end -= leadingWhitespacesCount;

	                            this.importSelection(exportedSelection);
	                        } else {
	                            this.options.ownerDocument.execCommand('createLink', false, targetUrl);
	                        }

	                        if (this.options.targetBlank || opts.target === '_blank') {
	                            MediumEditor.util.setTargetBlank(MediumEditor.selection.getSelectionStart(this.options.ownerDocument), targetUrl);
	                        } else {
	                            MediumEditor.util.removeTargetBlank(MediumEditor.selection.getSelectionStart(this.options.ownerDocument), targetUrl);
	                        }

	                        if (opts.buttonClass) {
	                            MediumEditor.util.addClassToAnchors(MediumEditor.selection.getSelectionStart(this.options.ownerDocument), opts.buttonClass);
	                        }
	                    }
	                }
	                // Fire input event for backwards compatibility if anyone was listening directly to the DOM input event
	                if (this.options.targetBlank || opts.target === '_blank' || opts.buttonClass) {
	                    customEvent = this.options.ownerDocument.createEvent('HTMLEvents');
	                    customEvent.initEvent('input', true, true, this.options.contentWindow);
	                    for (var i = 0, len = this.elements.length; i < len; i += 1) {
	                        this.elements[i].dispatchEvent(customEvent);
	                    }
	                }
	            } finally {
	                this.events.enableCustomEvent('editableInput');
	            }
	            // Fire our custom editableInput event
	            this.events.triggerCustomEvent('editableInput', customEvent, currentEditor);
	        },

	        cleanPaste: function (text) {
	            this.getExtensionByName('paste').cleanPaste(text);
	        },

	        pasteHTML: function (html, options) {
	            this.getExtensionByName('paste').pasteHTML(html, options);
	        },

	        setContent: function (html, index) {
	            index = index || 0;

	            if (this.elements[index]) {
	                var target = this.elements[index];
	                target.innerHTML = html;
	                this.checkContentChanged(target);
	            }
	        },

	        checkContentChanged: function (editable) {
	            editable = editable || MediumEditor.selection.getSelectionElement(this.options.contentWindow);
	            this.events.updateInput(editable, { target: editable, currentTarget: editable });
	        },

	        addElements: function (selector) {
	            // Convert elements into an array
	            var elements = createElementsArray(selector, this.options.ownerDocument, true);

	            // Do we have elements to add now?
	            if (elements.length === 0) {
	                return false;
	            }

	            elements.forEach(function (element) {
	                // Initialize all new elements (we check that in those functions don't worry)
	                element = initElement.call(this, element);

	                // Add new elements to our internal elements array
	                this.elements.push(element);
	            }, this);
	        },

	        removeElements: function (selector) {
	            // Convert elements into an array
	            var elements = createElementsArray(selector, this.options.ownerDocument),
	                toRemove = elements.map(function (el) {
	                    // For textareas, make sure we're looking at the editor div and not the textarea itself
	                    if (el.getAttribute('medium-editor-textarea-id') && el.parentNode) {
	                        return el.parentNode.querySelector('div[medium-editor-textarea-id="' + el.getAttribute('medium-editor-textarea-id') + '"]');
	                    } else {
	                        return el;
	                    }
	                });

	            this.elements = this.elements.filter(function (element) {
	                // If this is an element we want to remove
	                if (toRemove.indexOf(element) !== -1) {
	                    this.events.cleanupElement(element);
	                    if (element.getAttribute('medium-editor-textarea-id')) {
	                        cleanupTextareaElement(element);
	                    }
	                    return false;
	                }
	                return true;
	            }, this);
	        }
	    };
	}());

	(function () {
	    // summary: The default options hash used by the Editor

	    MediumEditor.prototype.defaults = {
	        activeButtonClass: 'medium-editor-button-active',
	        buttonLabels: false,
	        delay: 0,
	        disableReturn: false,
	        disableDoubleReturn: false,
	        disableExtraSpaces: false,
	        disableEditing: false,
	        autoLink: false,
	        elementsContainer: false,
	        contentWindow: window,
	        ownerDocument: document,
	        targetBlank: false,
	        extensions: {},
	        spellcheck: true
	    };
	})();

	MediumEditor.parseVersionString = function (release) {
	    var split = release.split('-'),
	        version = split[0].split('.'),
	        preRelease = (split.length > 1) ? split[1] : '';
	    return {
	        major: parseInt(version[0], 10),
	        minor: parseInt(version[1], 10),
	        revision: parseInt(version[2], 10),
	        preRelease: preRelease,
	        toString: function () {
	            return [version[0], version[1], version[2]].join('.') + (preRelease ? '-' + preRelease : '');
	        }
	    };
	};

	MediumEditor.version = MediumEditor.parseVersionString.call(this, ({
	    // grunt-bump looks for this:
	    'version': '5.18.0'
	}).version);

	    return MediumEditor;
	}()));


/***/ },
/* 127 */
/***/ function(module, exports) {

	/**
	 * Helpers.
	 */

	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @return {String|Number}
	 * @api public
	 */

	module.exports = function(val, options){
	  options = options || {};
	  if ('string' == typeof val) return parse(val);
	  return options.long
	    ? long(val)
	    : short(val);
	};

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  str = '' + str;
	  if (str.length > 10000) return;
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
	  if (!match) return;
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function short(ms) {
	  if (ms >= d) return Math.round(ms / d) + 'd';
	  if (ms >= h) return Math.round(ms / h) + 'h';
	  if (ms >= m) return Math.round(ms / m) + 'm';
	  if (ms >= s) return Math.round(ms / s) + 's';
	  return ms + 'ms';
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function long(ms) {
	  return plural(ms, d, 'day')
	    || plural(ms, h, 'hour')
	    || plural(ms, m, 'minute')
	    || plural(ms, s, 'second')
	    || ms + ' ms';
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, n, name) {
	  if (ms < n) return;
	  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}


/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * JSON parse.
	 *
	 * @see Based on jQuery#parseJSON (MIT) and JSON2
	 * @api private
	 */

	var rvalidchars = /^[\],:{}\s]*$/;
	var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
	var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
	var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
	var rtrimLeft = /^\s+/;
	var rtrimRight = /\s+$/;

	module.exports = function parsejson(data) {
	  if ('string' != typeof data || !data) {
	    return null;
	  }

	  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');

	  // Attempt to parse using the native JSON parser first
	  if (global.JSON && JSON.parse) {
	    return JSON.parse(data);
	  }

	  if (rvalidchars.test(data.replace(rvalidescape, '@')
	      .replace(rvalidtokens, ']')
	      .replace(rvalidbraces, ''))) {
	    return (new Function('return ' + data))();
	  }
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	module.exports = __webpack_require__(130);


/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var ps = __webpack_require__(133);
	var psInstances = __webpack_require__(3);

	function mountJQuery(jQuery) {
	  jQuery.fn.perfectScrollbar = function (settingOrCommand) {
	    return this.each(function () {
	      if (typeof settingOrCommand === 'object' ||
	          typeof settingOrCommand === 'undefined') {
	        // If it's an object or none, initialize.
	        var settings = settingOrCommand;

	        if (!psInstances.get(this)) {
	          ps.initialize(this, settings);
	        }
	      } else {
	        // Unless, it may be a command.
	        var command = settingOrCommand;

	        if (command === 'update') {
	          ps.update(this);
	        } else if (command === 'destroy') {
	          ps.destroy(this);
	        }
	      }
	    });
	  };
	}

	if (true) {
	  // AMD. Register as an anonymous module.
	//  define(['jquery'], mountJQuery);
	} else {
	  var jq = window.jQuery ? window.jQuery : window.$;
	  if (typeof jq !== 'undefined') {
	    mountJQuery(jq);
	  }
	}

	module.exports = mountJQuery;


/***/ },
/* 131 */
/***/ function(module, exports) {

	"use strict";
	'use strict';

	var EventElement = function (element) {
	  this.element = element;
	  this.events = {};
	};

	EventElement.prototype.bind = function (eventName, handler) {
	  if (typeof this.events[eventName] === 'undefined') {
	    this.events[eventName] = [];
	  }
	  this.events[eventName].push(handler);
	  this.element.addEventListener(eventName, handler, false);
	};

	EventElement.prototype.unbind = function (eventName, handler) {
	  var isHandlerProvided = (typeof handler !== 'undefined');
	  this.events[eventName] = this.events[eventName].filter(function (hdlr) {
	    if (isHandlerProvided && hdlr !== handler) {
	      return true;
	    }
	    this.element.removeEventListener(eventName, hdlr, false);
	    return false;
	  }, this);
	};

	EventElement.prototype.unbindAll = function () {
	  for (var name in this.events) {
	    this.unbind(name);
	  }
	};

	var EventManager = function () {
	  this.eventElements = [];
	};

	EventManager.prototype.eventElement = function (element) {
	  var ee = this.eventElements.filter(function (eventElement) {
	    return eventElement.element === element;
	  })[0];
	  if (typeof ee === 'undefined') {
	    ee = new EventElement(element);
	    this.eventElements.push(ee);
	  }
	  return ee;
	};

	EventManager.prototype.bind = function (element, eventName, handler) {
	  this.eventElement(element).bind(eventName, handler);
	};

	EventManager.prototype.unbind = function (element, eventName, handler) {
	  this.eventElement(element).unbind(eventName, handler);
	};

	EventManager.prototype.unbindAll = function () {
	  for (var i = 0; i < this.eventElements.length; i++) {
	    this.eventElements[i].unbindAll();
	  }
	};

	EventManager.prototype.once = function (element, eventName, handler) {
	  var ee = this.eventElement(element);
	  var onceHandler = function (e) {
	    ee.unbind(eventName, onceHandler);
	    handler(e);
	  };
	  ee.bind(eventName, onceHandler);
	};

	module.exports = EventManager;


/***/ },
/* 132 */
/***/ function(module, exports) {

	"use strict";
	'use strict';

	module.exports = (function () {
	  function s4() {
	    return Math.floor((1 + Math.random()) * 0x10000)
	               .toString(16)
	               .substring(1);
	  }
	  return function () {
	    return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
	           s4() + '-' + s4() + s4() + s4();
	  };
	})();


/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var destroy = __webpack_require__(135);
	var initialize = __webpack_require__(143);
	var update = __webpack_require__(144);

	module.exports = {
	  initialize: initialize,
	  update: update,
	  destroy: destroy
	};


/***/ },
/* 134 */
/***/ function(module, exports) {

	"use strict";
	'use strict';

	module.exports = {
	  handlers: ['click-rail', 'drag-scrollbar', 'keyboard', 'wheel', 'touch'],
	  maxScrollbarLength: null,
	  minScrollbarLength: null,
	  scrollXMarginOffset: 0,
	  scrollYMarginOffset: 0,
	  stopPropagationOnClick: true,
	  suppressScrollX: false,
	  suppressScrollY: false,
	  swipePropagation: true,
	  useBothWheelAxes: false,
	  wheelPropagation: false,
	  wheelSpeed: 1,
	  theme: 'default'
	};


/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _ = __webpack_require__(5);
	var dom = __webpack_require__(10);
	var instances = __webpack_require__(3);

	module.exports = function (element) {
	  var i = instances.get(element);

	  if (!i) {
	    return;
	  }

	  i.event.unbindAll();
	  dom.remove(i.scrollbarX);
	  dom.remove(i.scrollbarY);
	  dom.remove(i.scrollbarXRail);
	  dom.remove(i.scrollbarYRail);
	  _.removePsClasses(element);

	  instances.remove(element);
	};


/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _ = __webpack_require__(5);
	var instances = __webpack_require__(3);
	var updateGeometry = __webpack_require__(8);
	var updateScroll = __webpack_require__(9);

	function bindClickRailHandler(element, i) {
	  function pageOffset(el) {
	    return el.getBoundingClientRect();
	  }
	  var stopPropagation = function (e) { e.stopPropagation(); };

	  if (i.settings.stopPropagationOnClick) {
	    i.event.bind(i.scrollbarY, 'click', stopPropagation);
	  }
	  i.event.bind(i.scrollbarYRail, 'click', function (e) {
	    var halfOfScrollbarLength = _.toInt(i.scrollbarYHeight / 2);
	    var positionTop = i.railYRatio * (e.pageY - window.pageYOffset - pageOffset(i.scrollbarYRail).top - halfOfScrollbarLength);
	    var maxPositionTop = i.railYRatio * (i.railYHeight - i.scrollbarYHeight);
	    var positionRatio = positionTop / maxPositionTop;

	    if (positionRatio < 0) {
	      positionRatio = 0;
	    } else if (positionRatio > 1) {
	      positionRatio = 1;
	    }

	    updateScroll(element, 'top', (i.contentHeight - i.containerHeight) * positionRatio);
	    updateGeometry(element);

	    e.stopPropagation();
	  });

	  if (i.settings.stopPropagationOnClick) {
	    i.event.bind(i.scrollbarX, 'click', stopPropagation);
	  }
	  i.event.bind(i.scrollbarXRail, 'click', function (e) {
	    var halfOfScrollbarLength = _.toInt(i.scrollbarXWidth / 2);
	    var positionLeft = i.railXRatio * (e.pageX - window.pageXOffset - pageOffset(i.scrollbarXRail).left - halfOfScrollbarLength);
	    var maxPositionLeft = i.railXRatio * (i.railXWidth - i.scrollbarXWidth);
	    var positionRatio = positionLeft / maxPositionLeft;

	    if (positionRatio < 0) {
	      positionRatio = 0;
	    } else if (positionRatio > 1) {
	      positionRatio = 1;
	    }

	    updateScroll(element, 'left', ((i.contentWidth - i.containerWidth) * positionRatio) - i.negativeScrollAdjustment);
	    updateGeometry(element);

	    e.stopPropagation();
	  });
	}

	module.exports = function (element) {
	  var i = instances.get(element);
	  bindClickRailHandler(element, i);
	};


/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _ = __webpack_require__(5);
	var dom = __webpack_require__(10);
	var instances = __webpack_require__(3);
	var updateGeometry = __webpack_require__(8);
	var updateScroll = __webpack_require__(9);

	function bindMouseScrollXHandler(element, i) {
	  var currentLeft = null;
	  var currentPageX = null;

	  function updateScrollLeft(deltaX) {
	    var newLeft = currentLeft + (deltaX * i.railXRatio);
	    var maxLeft = Math.max(0, i.scrollbarXRail.getBoundingClientRect().left) + (i.railXRatio * (i.railXWidth - i.scrollbarXWidth));

	    if (newLeft < 0) {
	      i.scrollbarXLeft = 0;
	    } else if (newLeft > maxLeft) {
	      i.scrollbarXLeft = maxLeft;
	    } else {
	      i.scrollbarXLeft = newLeft;
	    }

	    var scrollLeft = _.toInt(i.scrollbarXLeft * (i.contentWidth - i.containerWidth) / (i.containerWidth - (i.railXRatio * i.scrollbarXWidth))) - i.negativeScrollAdjustment;
	    updateScroll(element, 'left', scrollLeft);
	  }

	  var mouseMoveHandler = function (e) {
	    updateScrollLeft(e.pageX - currentPageX);
	    updateGeometry(element);
	    e.stopPropagation();
	    e.preventDefault();
	  };

	  var mouseUpHandler = function () {
	    _.stopScrolling(element, 'x');
	    i.event.unbind(i.ownerDocument, 'mousemove', mouseMoveHandler);
	  };

	  i.event.bind(i.scrollbarX, 'mousedown', function (e) {
	    currentPageX = e.pageX;
	    currentLeft = _.toInt(dom.css(i.scrollbarX, 'left')) * i.railXRatio;
	    _.startScrolling(element, 'x');

	    i.event.bind(i.ownerDocument, 'mousemove', mouseMoveHandler);
	    i.event.once(i.ownerDocument, 'mouseup', mouseUpHandler);

	    e.stopPropagation();
	    e.preventDefault();
	  });
	}

	function bindMouseScrollYHandler(element, i) {
	  var currentTop = null;
	  var currentPageY = null;

	  function updateScrollTop(deltaY) {
	    var newTop = currentTop + (deltaY * i.railYRatio);
	    var maxTop = Math.max(0, i.scrollbarYRail.getBoundingClientRect().top) + (i.railYRatio * (i.railYHeight - i.scrollbarYHeight));

	    if (newTop < 0) {
	      i.scrollbarYTop = 0;
	    } else if (newTop > maxTop) {
	      i.scrollbarYTop = maxTop;
	    } else {
	      i.scrollbarYTop = newTop;
	    }

	    var scrollTop = _.toInt(i.scrollbarYTop * (i.contentHeight - i.containerHeight) / (i.containerHeight - (i.railYRatio * i.scrollbarYHeight)));
	    updateScroll(element, 'top', scrollTop);
	  }

	  var mouseMoveHandler = function (e) {
	    updateScrollTop(e.pageY - currentPageY);
	    updateGeometry(element);
	    e.stopPropagation();
	    e.preventDefault();
	  };

	  var mouseUpHandler = function () {
	    _.stopScrolling(element, 'y');
	    i.event.unbind(i.ownerDocument, 'mousemove', mouseMoveHandler);
	  };

	  i.event.bind(i.scrollbarY, 'mousedown', function (e) {
	    currentPageY = e.pageY;
	    currentTop = _.toInt(dom.css(i.scrollbarY, 'top')) * i.railYRatio;
	    _.startScrolling(element, 'y');

	    i.event.bind(i.ownerDocument, 'mousemove', mouseMoveHandler);
	    i.event.once(i.ownerDocument, 'mouseup', mouseUpHandler);

	    e.stopPropagation();
	    e.preventDefault();
	  });
	}

	module.exports = function (element) {
	  var i = instances.get(element);
	  bindMouseScrollXHandler(element, i);
	  bindMouseScrollYHandler(element, i);
	};


/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _ = __webpack_require__(5);
	var dom = __webpack_require__(10);
	var instances = __webpack_require__(3);
	var updateGeometry = __webpack_require__(8);
	var updateScroll = __webpack_require__(9);

	function bindKeyboardHandler(element, i) {
	  var hovered = false;
	  i.event.bind(element, 'mouseenter', function () {
	    hovered = true;
	  });
	  i.event.bind(element, 'mouseleave', function () {
	    hovered = false;
	  });

	  var shouldPrevent = false;
	  function shouldPreventDefault(deltaX, deltaY) {
	    var scrollTop = element.scrollTop;
	    if (deltaX === 0) {
	      if (!i.scrollbarYActive) {
	        return false;
	      }
	      if ((scrollTop === 0 && deltaY > 0) || (scrollTop >= i.contentHeight - i.containerHeight && deltaY < 0)) {
	        return !i.settings.wheelPropagation;
	      }
	    }

	    var scrollLeft = element.scrollLeft;
	    if (deltaY === 0) {
	      if (!i.scrollbarXActive) {
	        return false;
	      }
	      if ((scrollLeft === 0 && deltaX < 0) || (scrollLeft >= i.contentWidth - i.containerWidth && deltaX > 0)) {
	        return !i.settings.wheelPropagation;
	      }
	    }
	    return true;
	  }

	  i.event.bind(i.ownerDocument, 'keydown', function (e) {
	    if (e.isDefaultPrevented && e.isDefaultPrevented()) {
	      return;
	    }

	    var focused = dom.matches(i.scrollbarX, ':focus') ||
	                  dom.matches(i.scrollbarY, ':focus');

	    if (!hovered && !focused) {
	      return;
	    }

	    var activeElement = document.activeElement ? document.activeElement : i.ownerDocument.activeElement;
	    if (activeElement) {
	      if (activeElement.tagName === 'IFRAME') {
	        activeElement = activeElement.contentDocument.activeElement;
	      } else {
	        // go deeper if element is a webcomponent
	        while (activeElement.shadowRoot) {
	          activeElement = activeElement.shadowRoot.activeElement;
	        }
	      }
	      if (_.isEditable(activeElement)) {
	        return;
	      }
	    }

	    var deltaX = 0;
	    var deltaY = 0;

	    switch (e.which) {
	    case 37: // left
	      deltaX = -30;
	      break;
	    case 38: // up
	      deltaY = 30;
	      break;
	    case 39: // right
	      deltaX = 30;
	      break;
	    case 40: // down
	      deltaY = -30;
	      break;
	    case 33: // page up
	      deltaY = 90;
	      break;
	    case 32: // space bar
	      if (e.shiftKey) {
	        deltaY = 90;
	      } else {
	        deltaY = -90;
	      }
	      break;
	    case 34: // page down
	      deltaY = -90;
	      break;
	    case 35: // end
	      if (e.ctrlKey) {
	        deltaY = -i.contentHeight;
	      } else {
	        deltaY = -i.containerHeight;
	      }
	      break;
	    case 36: // home
	      if (e.ctrlKey) {
	        deltaY = element.scrollTop;
	      } else {
	        deltaY = i.containerHeight;
	      }
	      break;
	    default:
	      return;
	    }

	    updateScroll(element, 'top', element.scrollTop - deltaY);
	    updateScroll(element, 'left', element.scrollLeft + deltaX);
	    updateGeometry(element);

	    shouldPrevent = shouldPreventDefault(deltaX, deltaY);
	    if (shouldPrevent) {
	      e.preventDefault();
	    }
	  });
	}

	module.exports = function (element) {
	  var i = instances.get(element);
	  bindKeyboardHandler(element, i);
	};


/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var instances = __webpack_require__(3);
	var updateGeometry = __webpack_require__(8);
	var updateScroll = __webpack_require__(9);

	function bindMouseWheelHandler(element, i) {
	  var shouldPrevent = false;

	  function shouldPreventDefault(deltaX, deltaY) {
	    var scrollTop = element.scrollTop;
	    if (deltaX === 0) {
	      if (!i.scrollbarYActive) {
	        return false;
	      }
	      if ((scrollTop === 0 && deltaY > 0) || (scrollTop >= i.contentHeight - i.containerHeight && deltaY < 0)) {
	        return !i.settings.wheelPropagation;
	      }
	    }

	    var scrollLeft = element.scrollLeft;
	    if (deltaY === 0) {
	      if (!i.scrollbarXActive) {
	        return false;
	      }
	      if ((scrollLeft === 0 && deltaX < 0) || (scrollLeft >= i.contentWidth - i.containerWidth && deltaX > 0)) {
	        return !i.settings.wheelPropagation;
	      }
	    }
	    return true;
	  }

	  function getDeltaFromEvent(e) {
	    var deltaX = e.deltaX;
	    var deltaY = -1 * e.deltaY;

	    if (typeof deltaX === "undefined" || typeof deltaY === "undefined") {
	      // OS X Safari
	      deltaX = -1 * e.wheelDeltaX / 6;
	      deltaY = e.wheelDeltaY / 6;
	    }

	    if (e.deltaMode && e.deltaMode === 1) {
	      // Firefox in deltaMode 1: Line scrolling
	      deltaX *= 10;
	      deltaY *= 10;
	    }

	    if (deltaX !== deltaX && deltaY !== deltaY/* NaN checks */) {
	      // IE in some mouse drivers
	      deltaX = 0;
	      deltaY = e.wheelDelta;
	    }

	    return [deltaX, deltaY];
	  }

	  function shouldBeConsumedByChild(deltaX, deltaY) {
	    var child = element.querySelector('textarea:hover, .ps-child:hover');
	    if (child) {
	      if (child.tagName !== 'TEXTAREA' && !window.getComputedStyle(child).overflow.match(/(scroll|auto)/)) {
	        return false;
	      }

	      var maxScrollTop = child.scrollHeight - child.clientHeight;
	      if (maxScrollTop > 0) {
	        if (!(child.scrollTop === 0 && deltaY > 0) && !(child.scrollTop === maxScrollTop && deltaY < 0)) {
	          return true;
	        }
	      }
	      var maxScrollLeft = child.scrollLeft - child.clientWidth;
	      if (maxScrollLeft > 0) {
	        if (!(child.scrollLeft === 0 && deltaX < 0) && !(child.scrollLeft === maxScrollLeft && deltaX > 0)) {
	          return true;
	        }
	      }
	    }
	    return false;
	  }

	  function mousewheelHandler(e) {
	    var delta = getDeltaFromEvent(e);

	    var deltaX = delta[0];
	    var deltaY = delta[1];

	    if (shouldBeConsumedByChild(deltaX, deltaY)) {
	      return;
	    }

	    shouldPrevent = false;
	    if (!i.settings.useBothWheelAxes) {
	      // deltaX will only be used for horizontal scrolling and deltaY will
	      // only be used for vertical scrolling - this is the default
	      updateScroll(element, 'top', element.scrollTop - (deltaY * i.settings.wheelSpeed));
	      updateScroll(element, 'left', element.scrollLeft + (deltaX * i.settings.wheelSpeed));
	    } else if (i.scrollbarYActive && !i.scrollbarXActive) {
	      // only vertical scrollbar is active and useBothWheelAxes option is
	      // active, so let's scroll vertical bar using both mouse wheel axes
	      if (deltaY) {
	        updateScroll(element, 'top', element.scrollTop - (deltaY * i.settings.wheelSpeed));
	      } else {
	        updateScroll(element, 'top', element.scrollTop + (deltaX * i.settings.wheelSpeed));
	      }
	      shouldPrevent = true;
	    } else if (i.scrollbarXActive && !i.scrollbarYActive) {
	      // useBothWheelAxes and only horizontal bar is active, so use both
	      // wheel axes for horizontal bar
	      if (deltaX) {
	        updateScroll(element, 'left', element.scrollLeft + (deltaX * i.settings.wheelSpeed));
	      } else {
	        updateScroll(element, 'left', element.scrollLeft - (deltaY * i.settings.wheelSpeed));
	      }
	      shouldPrevent = true;
	    }

	    updateGeometry(element);

	    shouldPrevent = (shouldPrevent || shouldPreventDefault(deltaX, deltaY));
	    if (shouldPrevent) {
	      e.stopPropagation();
	      e.preventDefault();
	    }
	  }

	  if (typeof window.onwheel !== "undefined") {
	    i.event.bind(element, 'wheel', mousewheelHandler);
	  } else if (typeof window.onmousewheel !== "undefined") {
	    i.event.bind(element, 'mousewheel', mousewheelHandler);
	  }
	}

	module.exports = function (element) {
	  var i = instances.get(element);
	  bindMouseWheelHandler(element, i);
	};


/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var instances = __webpack_require__(3);
	var updateGeometry = __webpack_require__(8);

	function bindNativeScrollHandler(element, i) {
	  i.event.bind(element, 'scroll', function () {
	    updateGeometry(element);
	  });
	}

	module.exports = function (element) {
	  var i = instances.get(element);
	  bindNativeScrollHandler(element, i);
	};


/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _ = __webpack_require__(5);
	var instances = __webpack_require__(3);
	var updateGeometry = __webpack_require__(8);
	var updateScroll = __webpack_require__(9);

	function bindSelectionHandler(element, i) {
	  function getRangeNode() {
	    var selection = window.getSelection ? window.getSelection() :
	                    document.getSelection ? document.getSelection() : '';
	    if (selection.toString().length === 0) {
	      return null;
	    } else {
	      return selection.getRangeAt(0).commonAncestorContainer;
	    }
	  }

	  var scrollingLoop = null;
	  var scrollDiff = {top: 0, left: 0};
	  function startScrolling() {
	    if (!scrollingLoop) {
	      scrollingLoop = setInterval(function () {
	        if (!instances.get(element)) {
	          clearInterval(scrollingLoop);
	          return;
	        }

	        updateScroll(element, 'top', element.scrollTop + scrollDiff.top);
	        updateScroll(element, 'left', element.scrollLeft + scrollDiff.left);
	        updateGeometry(element);
	      }, 50); // every .1 sec
	    }
	  }
	  function stopScrolling() {
	    if (scrollingLoop) {
	      clearInterval(scrollingLoop);
	      scrollingLoop = null;
	    }
	    _.stopScrolling(element);
	  }

	  var isSelected = false;
	  i.event.bind(i.ownerDocument, 'selectionchange', function () {
	    if (element.contains(getRangeNode())) {
	      isSelected = true;
	    } else {
	      isSelected = false;
	      stopScrolling();
	    }
	  });
	  i.event.bind(window, 'mouseup', function () {
	    if (isSelected) {
	      isSelected = false;
	      stopScrolling();
	    }
	  });

	  i.event.bind(window, 'mousemove', function (e) {
	    if (isSelected) {
	      var mousePosition = {x: e.pageX, y: e.pageY};
	      var containerGeometry = {
	        left: element.offsetLeft,
	        right: element.offsetLeft + element.offsetWidth,
	        top: element.offsetTop,
	        bottom: element.offsetTop + element.offsetHeight
	      };

	      if (mousePosition.x < containerGeometry.left + 3) {
	        scrollDiff.left = -5;
	        _.startScrolling(element, 'x');
	      } else if (mousePosition.x > containerGeometry.right - 3) {
	        scrollDiff.left = 5;
	        _.startScrolling(element, 'x');
	      } else {
	        scrollDiff.left = 0;
	      }

	      if (mousePosition.y < containerGeometry.top + 3) {
	        if (containerGeometry.top + 3 - mousePosition.y < 5) {
	          scrollDiff.top = -5;
	        } else {
	          scrollDiff.top = -20;
	        }
	        _.startScrolling(element, 'y');
	      } else if (mousePosition.y > containerGeometry.bottom - 3) {
	        if (mousePosition.y - containerGeometry.bottom + 3 < 5) {
	          scrollDiff.top = 5;
	        } else {
	          scrollDiff.top = 20;
	        }
	        _.startScrolling(element, 'y');
	      } else {
	        scrollDiff.top = 0;
	      }

	      if (scrollDiff.top === 0 && scrollDiff.left === 0) {
	        stopScrolling();
	      } else {
	        startScrolling();
	      }
	    }
	  });
	}

	module.exports = function (element) {
	  var i = instances.get(element);
	  bindSelectionHandler(element, i);
	};


/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _ = __webpack_require__(5);
	var instances = __webpack_require__(3);
	var updateGeometry = __webpack_require__(8);
	var updateScroll = __webpack_require__(9);

	function bindTouchHandler(element, i, supportsTouch, supportsIePointer) {
	  function shouldPreventDefault(deltaX, deltaY) {
	    var scrollTop = element.scrollTop;
	    var scrollLeft = element.scrollLeft;
	    var magnitudeX = Math.abs(deltaX);
	    var magnitudeY = Math.abs(deltaY);

	    if (magnitudeY > magnitudeX) {
	      // user is perhaps trying to swipe up/down the page

	      if (((deltaY < 0) && (scrollTop === i.contentHeight - i.containerHeight)) ||
	          ((deltaY > 0) && (scrollTop === 0))) {
	        return !i.settings.swipePropagation;
	      }
	    } else if (magnitudeX > magnitudeY) {
	      // user is perhaps trying to swipe left/right across the page

	      if (((deltaX < 0) && (scrollLeft === i.contentWidth - i.containerWidth)) ||
	          ((deltaX > 0) && (scrollLeft === 0))) {
	        return !i.settings.swipePropagation;
	      }
	    }

	    return true;
	  }

	  function applyTouchMove(differenceX, differenceY) {
	    updateScroll(element, 'top', element.scrollTop - differenceY);
	    updateScroll(element, 'left', element.scrollLeft - differenceX);

	    updateGeometry(element);
	  }

	  var startOffset = {};
	  var startTime = 0;
	  var speed = {};
	  var easingLoop = null;
	  var inGlobalTouch = false;
	  var inLocalTouch = false;

	  function globalTouchStart() {
	    inGlobalTouch = true;
	  }
	  function globalTouchEnd() {
	    inGlobalTouch = false;
	  }

	  function getTouch(e) {
	    if (e.targetTouches) {
	      return e.targetTouches[0];
	    } else {
	      // Maybe IE pointer
	      return e;
	    }
	  }
	  function shouldHandle(e) {
	    if (e.targetTouches && e.targetTouches.length === 1) {
	      return true;
	    }
	    if (e.pointerType && e.pointerType !== 'mouse' && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
	      return true;
	    }
	    return false;
	  }
	  function touchStart(e) {
	    if (shouldHandle(e)) {
	      inLocalTouch = true;

	      var touch = getTouch(e);

	      startOffset.pageX = touch.pageX;
	      startOffset.pageY = touch.pageY;

	      startTime = (new Date()).getTime();

	      if (easingLoop !== null) {
	        clearInterval(easingLoop);
	      }

	      e.stopPropagation();
	    }
	  }
	  function touchMove(e) {
	    if (!inLocalTouch && i.settings.swipePropagation) {
	      touchStart(e);
	    }
	    if (!inGlobalTouch && inLocalTouch && shouldHandle(e)) {
	      var touch = getTouch(e);

	      var currentOffset = {pageX: touch.pageX, pageY: touch.pageY};

	      var differenceX = currentOffset.pageX - startOffset.pageX;
	      var differenceY = currentOffset.pageY - startOffset.pageY;

	      applyTouchMove(differenceX, differenceY);
	      startOffset = currentOffset;

	      var currentTime = (new Date()).getTime();

	      var timeGap = currentTime - startTime;
	      if (timeGap > 0) {
	        speed.x = differenceX / timeGap;
	        speed.y = differenceY / timeGap;
	        startTime = currentTime;
	      }

	      if (shouldPreventDefault(differenceX, differenceY)) {
	        e.stopPropagation();
	        e.preventDefault();
	      }
	    }
	  }
	  function touchEnd() {
	    if (!inGlobalTouch && inLocalTouch) {
	      inLocalTouch = false;

	      clearInterval(easingLoop);
	      easingLoop = setInterval(function () {
	        if (!instances.get(element)) {
	          clearInterval(easingLoop);
	          return;
	        }

	        if (Math.abs(speed.x) < 0.01 && Math.abs(speed.y) < 0.01) {
	          clearInterval(easingLoop);
	          return;
	        }

	        applyTouchMove(speed.x * 30, speed.y * 30);

	        speed.x *= 0.8;
	        speed.y *= 0.8;
	      }, 10);
	    }
	  }

	  if (supportsTouch) {
	    i.event.bind(window, 'touchstart', globalTouchStart);
	    i.event.bind(window, 'touchend', globalTouchEnd);
	    i.event.bind(element, 'touchstart', touchStart);
	    i.event.bind(element, 'touchmove', touchMove);
	    i.event.bind(element, 'touchend', touchEnd);
	  }

	  if (supportsIePointer) {
	    if (window.PointerEvent) {
	      i.event.bind(window, 'pointerdown', globalTouchStart);
	      i.event.bind(window, 'pointerup', globalTouchEnd);
	      i.event.bind(element, 'pointerdown', touchStart);
	      i.event.bind(element, 'pointermove', touchMove);
	      i.event.bind(element, 'pointerup', touchEnd);
	    } else if (window.MSPointerEvent) {
	      i.event.bind(window, 'MSPointerDown', globalTouchStart);
	      i.event.bind(window, 'MSPointerUp', globalTouchEnd);
	      i.event.bind(element, 'MSPointerDown', touchStart);
	      i.event.bind(element, 'MSPointerMove', touchMove);
	      i.event.bind(element, 'MSPointerUp', touchEnd);
	    }
	  }
	}

	module.exports = function (element) {
	  if (!_.env.supportsTouch && !_.env.supportsIePointer) {
	    return;
	  }

	  var i = instances.get(element);
	  bindTouchHandler(element, i, _.env.supportsTouch, _.env.supportsIePointer);
	};


/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _ = __webpack_require__(5);
	var cls = __webpack_require__(18);
	var instances = __webpack_require__(3);
	var updateGeometry = __webpack_require__(8);

	// Handlers
	var handlers = {
	  'click-rail': __webpack_require__(136),
	  'drag-scrollbar': __webpack_require__(137),
	  'keyboard': __webpack_require__(138),
	  'wheel': __webpack_require__(139),
	  'touch': __webpack_require__(142),
	  'selection': __webpack_require__(141)
	};
	var nativeScrollHandler = __webpack_require__(140);

	module.exports = function (element, userSettings) {
	  userSettings = typeof userSettings === 'object' ? userSettings : {};

	  cls.add(element, 'ps-container');

	  // Create a plugin instance.
	  var i = instances.add(element);

	  i.settings = _.extend(i.settings, userSettings);
	  cls.add(element, 'ps-theme-' + i.settings.theme);

	  i.settings.handlers.forEach(function (handlerName) {
	    handlers[handlerName](element);
	  });

	  nativeScrollHandler(element);

	  updateGeometry(element);
	};


/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';

	var _ = __webpack_require__(5);
	var dom = __webpack_require__(10);
	var instances = __webpack_require__(3);
	var updateGeometry = __webpack_require__(8);
	var updateScroll = __webpack_require__(9);

	module.exports = function (element) {
	  var i = instances.get(element);

	  if (!i) {
	    return;
	  }

	  // Recalcuate negative scrollLeft adjustment
	  i.negativeScrollAdjustment = i.isNegativeScroll ? element.scrollWidth - element.clientWidth : 0;

	  // Recalculate rail margins
	  dom.css(i.scrollbarXRail, 'display', 'block');
	  dom.css(i.scrollbarYRail, 'display', 'block');
	  i.railXMarginWidth = _.toInt(dom.css(i.scrollbarXRail, 'marginLeft')) + _.toInt(dom.css(i.scrollbarXRail, 'marginRight'));
	  i.railYMarginHeight = _.toInt(dom.css(i.scrollbarYRail, 'marginTop')) + _.toInt(dom.css(i.scrollbarYRail, 'marginBottom'));

	  // Hide scrollbars not to affect scrollWidth and scrollHeight
	  dom.css(i.scrollbarXRail, 'display', 'none');
	  dom.css(i.scrollbarYRail, 'display', 'none');

	  updateGeometry(element);

	  // Update top/left scroll to trigger events
	  updateScroll(element, 'top', element.scrollTop);
	  updateScroll(element, 'left', element.scrollLeft);

	  dom.css(i.scrollbarXRail, 'display', '');
	  dom.css(i.scrollbarYRail, 'display', '');
	};


/***/ },
/* 145 */
/***/ function(module, exports) {

	// Taken from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind
	if (!Function.prototype.bind) {
	  Function.prototype.bind = function (oThis) {
	    if (typeof this !== "function") {
	      // closest thing possible to the ECMAScript 5
	      // internal IsCallable function
	      throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
	    }

	    var aArgs = Array.prototype.slice.call(arguments, 1),
	        fToBind = this,
	        fNOP = function () {},
	        fBound = function () {
	          return fToBind.apply(this instanceof fNOP && oThis
	                 ? this
	                 : oThis,
	                 aArgs.concat(Array.prototype.slice.call(arguments)));
	        };

	    fNOP.prototype = this.prototype;
	    fBound.prototype = new fNOP();

	    return fBound;
	  };
	}


/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	(function (global, factory) {
		 true ? module.exports = factory() :
		typeof define === 'function' && define.amd ? define(factory) :
		global.Ractive.events.hover = factory();
	}(this, function () { 'use strict';

		var testDiv = typeof document !== 'undefined' ? document.createElement('div') : {};

		var hover = undefined;

		if (testDiv.onmouseenter !== undefined) {
			// Using native mouseenter/mouseleave events
			hover = function (node, fire) {
				function mouseenterHandler(original) {
					fire({ node: node, original: original, hover: true });
				}

				function mouseleaveHandler(original) {
					fire({ node: node, original: original, hover: false });
				}

				node.addEventListener('mouseenter', mouseenterHandler, false);
				node.addEventListener('mouseleave', mouseleaveHandler, false);

				return {
					teardown: function teardown() {
						node.removeEventListener('mouseenter', mouseenterHandler, false);
						node.removeEventListener('mouseleave', mouseleaveHandler, false);
					}
				};
			};
		} else {
			// using mouseover/mouseout
			hover = function (node, fire) {
				function mouseoverHandler(original) {
					if (node.contains(original.relatedTarget)) return;
					fire({ node: node, original: original, hover: true });
				}

				function mouseoutHandler(original) {
					if (node.contains(original.relatedTarget)) return;
					fire({ node: node, original: original, hover: false });
				}

				node.addEventListener('mouseover', mouseoverHandler, false);
				node.addEventListener('mouseout', mouseoutHandler, false);

				return {
					teardown: function teardown() {
						node.removeEventListener('mouseover', mouseoverHandler, false);
						node.removeEventListener('mouseout', mouseoutHandler, false);
					}
				};
			};
		}

		var hover$1 = hover;

		return hover$1;

	}));

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	(function (global, factory) {
		 true ? factory(exports) :
		typeof define === 'function' && define.amd ? define(['exports'], factory) :
		factory(global.Ractive.events)
	}(this, function (exports) { 'use strict';

		// TODO can we just declare the keydowhHandler once? using `this`?
		function makeKeyDefinition(code) {
			return function (node, fire) {
				function keydownHandler(event) {
					var which = event.which || event.keyCode;

					if (which === code) {
						event.preventDefault();

						fire({
							node: node,
							original: event
						});
					}
				}

				node.addEventListener('keydown', keydownHandler, false);

				return {
					teardown: function teardown() {
						node.removeEventListener('keydown', keydownHandler, false);
					}
				};
			};
		}

		var enter = makeKeyDefinition(13);
		var tab = makeKeyDefinition(9);
		var ractive_events_keys__escape = makeKeyDefinition(27);
		var space = makeKeyDefinition(32);

		var leftarrow = makeKeyDefinition(37);
		var rightarrow = makeKeyDefinition(39);
		var downarrow = makeKeyDefinition(40);
		var uparrow = makeKeyDefinition(38);

		exports.enter = enter;
		exports.tab = tab;
		exports.escape = ractive_events_keys__escape;
		exports.space = space;
		exports.leftarrow = leftarrow;
		exports.rightarrow = rightarrow;
		exports.downarrow = downarrow;
		exports.uparrow = uparrow;

	}));

/***/ },
/* 148 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":7,"e":"div","a":{"class":"E_GlobalPageSettings"},"t2":{"n":"attr","a":[{"duration":300}]},"f":[{"t":7,"e":"h2","a":{"class":"E_PageMenu--title"},"f":["Nastavení stránky"]}," ",{"t":7,"e":"section","a":{"class":"E_PageMenu--section E_GlobalPageSettings--font-settings"},"f":[{"t":19,"f":[{"t":7,"e":"h3","a":{"class":["E_PageMenu--sub-title E_PageMenu--sub-title__interactive ",{"t":4,"f":["E_PageMenu--sub-title__active"],"n":50,"x":{"r":[".openGlobalSettingsWidget"],"s":"_0===\"font\""}}]},"v":{"tap":{"m":"set","a":{"r":[".openGlobalSettingsWidget"],"s":"[\"openGlobalSettingsWidget\",_0===\"font\"?null:\"font\"]"}}},"f":["Písmo ",{"t":8,"r":"dropDownIcon"}," ",{"t":7,"e":"span","a":{"class":"E_PageMenu--sub-title-value"},"f":[{"t":2,"rx":{"r":".fontTypes","m":[{"r":[".settings.fontType",".defaultFontType"],"s":"_0||_1"},"title"]}}," + ",{"t":2,"rx":{"r":".fontTypes","m":[{"r":[".settings.fontType",".defaultFontType"],"s":"_0||_1"},"body"]}}]}]}," ",{"t":4,"f":[{"t":7,"e":"PageMenuInlineWidget","a":{"initMaxHeight":"800","close":".openGlobalSettingsWidget"},"f":[{"t":8,"r":"fontSettings"}]}],"n":50,"x":{"r":[".openGlobalSettingsWidget"],"s":"_0===\"font\""}}],"n":54,"z":[{"n":"defaultFontType","x":{"x":{"r":["@ractive"],"s":"_0.findParent(\"Page\").get(\"defaults.settings.fontType\")"}}}]}]}," ",{"t":7,"e":"section","a":{"class":"E_PageMenu--section E_GlobalPageSettings--underline-title"},"f":[{"t":4,"n":53,"f":[{"t":8,"r":"ToggleField"}],"x":{"r":[],"s":"{text:\"Podtržení nadpisů\",size:\"small\",value:\"settings.underlineTitles\"}"}}]}," ",{"t":7,"e":"section","a":{"class":"E_PageMenu--section E_GlobalPageSettings--roundness"},"f":[{"t":7,"e":"h3","a":{"class":"E_PageMenu--sub-title"},"f":["Zaoblení elementů"]}," ",{"t":4,"n":53,"f":[{"t":8,"r":"Switch"}],"x":{"r":["@ractive"],"s":"{adaptive:true,size:\"small\",value:\"settings.roundness\",defaultValue:_0.findParent(\"Page\").get(\"defaults.settings.roundness\"),options:[{text:\"Žádné\",value:0,icon:\"#icon-square\"},{text:\"Mírné\",value:10,icon:\"#icon-round-square\"},{text:\"Střední\",value:20,icon:\"#icon-round-square-2\"},{text:\"Kulaté\",value:30,icon:\"#icon-circle\"},{text:\"Kontrastní\",value:40,icon:\"#icon-square-circle\"}]}"}}]}," ",{"t":7,"e":"section","a":{"class":"E_PageMenu--section E_GlobalPageSettings--animations"},"f":[{"t":7,"e":"h3","a":{"class":"E_PageMenu--sub-title"},"f":["Animace"]}," ",{"t":4,"n":53,"f":[{"t":8,"r":"Switch"}],"x":{"r":["@ractive"],"s":"{adaptive:true,size:\"small\",value:\"settings.animations\",defaultValue:_0.findParent(\"Page\").get(\"defaults.settings.animations\"),options:[{text:\"Jemné\",value:0,icon:\"#icon-magic-1\"},{text:\"Normální\",value:10,icon:\"#icon-magic-2\"},{text:\"Rychlé\",value:20,icon:\"#icon-magic-3\"},{text:\"Zábavné\",value:30,icon:\"#icon-magic-4\"}]}"}}]}," ",{"t":7,"e":"section","a":{"class":"E_PageMenu--section E_GlobalPageSettings--color-palette"},"f":[{"t":7,"e":"h3","a":{"class":"E_PageMenu--sub-title"},"f":["Výchozí barvy ",{"t":7,"e":"ul","a":{"class":"E_GlobalColorPaletteSettings--colors E_GlobalColorPaletteSettings--selected-palette"},"v":{"tap":{"m":"toggle","a":{"r":[],"s":"[\"toggleColorPicker\"]"}}},"f":[{"t":4,"f":[{"t":7,"e":"li","a":{"class":"E_GlobalColorPaletteSettings--color","style":["background-color: ",{"t":2,"r":"."}]},"v":{"tap":{"m":"set","a":{"r":["~/openGlobalSettingsWidget","~/openGlobalSettingsWidget.colorKey","@key"],"s":"[\"openGlobalSettingsWidget\",_0&&_1===_2?null:{colorKey:_2}]"}}}}],"n":52,"r":".settings.colorPalette.colors"}]}]}," ",{"t":4,"n":53,"f":[{"t":8,"r":"Button"}],"x":{"r":[".openGlobalSettingsWidget"],"s":"{size:\"small\",text:\"Palety\",title:\"Vybrat paletu\",set:\"openGlobalSettingsWidget\",value:_0===\"colors\"?null:\"colors\",state:_0===\"colors\"?\"active\":\"\",icon:\"#icon-triangle\",iconW:10,iconH:10,iconR:_0===\"colors\"?180:90,className:\"E_GlobalColorPaletteSettings--palettes-button\"}"}}," ",{"t":7,"e":"div","f":[{"t":19,"f":[{"t":4,"f":[{"t":7,"e":"PageMenuInlineWidget","a":{"initMaxHeight":"320","close":".openGlobalSettingsWidget","connectWith":"{id:'colors', opener: 'openGlobalSettingsWidget'}"},"f":[{"t":8,"r":"colorPaletteSettings"}]}],"n":50,"x":{"r":[".openGlobalSettingsWidget"],"s":"_0===\"colors\""}},{"t":4,"n":51,"f":[{"t":4,"n":50,"x":{"r":[".openGlobalSettingsWidget",".openGlobalSettingsWidget.colorKey"],"s":"typeof _0===\"object\"&&typeof _1!==\"undefined\""},"f":[{"t":7,"e":"PageMenuInlineWidget","a":{"initMaxHeight":"400","close":".openGlobalSettingsWidget","connectWith":"{id:'colors', opener: 'openGlobalSettingsWidget'}"},"f":[{"t":4,"f":[{"t":7,"e":"ColorPicker","a":{"output":[{"t":2,"rx":{"r":".settings.colorPalette.colors","m":[{"t":30,"n":".openGlobalSettingsWidget.colorKey"}]}}],"inputType":[{"t":2,"r":".lastInputType","s":true}],"defer":"true"}}],"n":50,"r":".toggleColorPicker"},{"t":4,"n":51,"f":[{"t":7,"e":"ColorPicker","a":{"output":[{"t":2,"rx":{"r":".settings.colorPalette.colors","m":[{"t":30,"n":".openGlobalSettingsWidget.colorKey"}]}}],"inputType":[{"t":2,"r":".lastInputType","s":true}],"defer":"true"}}],"r":".toggleColorPicker"}]}]}],"x":{"r":[".openGlobalSettingsWidget"],"s":"_0===\"colors\""}}],"n":54,"z":[{"n":"__def","x":{"x":{"r":[".settings.colorPalette","@ractive"],"s":"_0||_1.set(\"settings.colorPalette\",_1.findParent(\"Page\").get(\"defaults.settings.colorPalette\"))"}}}]}]}," ",{"t":4,"n":53,"f":[{"t":8,"r":"Button"}],"x":{"r":[".settings.colorPalette.colors",".settings.colorPalette.headerImg"],"s":"{size:\"small\",text:\"Vygenerovat novou kombinaci\",set:\"settings.colorPalette\",value:{colors:_0.slice(),headerImg:_1},className:\"E_GlobalColorPaletteSettings--regenerate-button\"}"}}]}]}," "],"p":{"dropDownIcon":[{"t":7,"e":"div","a":{"class":"E_PageMenu--sub-title-dropdown"},"f":[{"t":7,"e":"svg","f":[{"t":7,"e":"use","a":{"xlink:href":"#icon-triangle"}}]}]}]},"e":{}};

/***/ },
/* 149 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":7,"e":"div","a":{"class":"E_GlobalColorPaletteSettings"},"f":[{"t":4,"f":[{"t":7,"e":"ul","a":{"class":"E_GlobalColorPaletteSettings--colors"},"v":{"tap":{"m":"set","a":{"r":[".colors",".headerImg"],"s":"[\"settings.colorPalette\",{colors:_0.slice(),headerImg:_1}]"}}},"f":[{"t":4,"f":[{"t":7,"e":"li","a":{"class":"E_GlobalColorPaletteSettings--color","style":["background-color: ",{"t":2,"r":"."}]}}],"n":52,"r":".colors"}]}],"n":52,"r":".colorPalettes"}]}],"e":{}};

/***/ },
/* 150 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":7,"e":"div","a":{"class":"E_GlobalFontSettings"},"f":[{"t":7,"e":"div","a":{"class":"E_GlobalFontSettings--wrapper"},"f":[{"t":4,"f":[{"t":7,"e":"div","a":{"class":["E_GlobalFontSettings--font-type ",{"t":4,"f":["E_GlobalFontSettings--font-type__active"],"n":50,"x":{"r":["../../settings.fontType","../../defaultFontType","@key"],"s":"_0===_2||(!_0&&_1===_2)"}}],"data-font-type":[{"t":2,"r":"@key"}]},"v":{"tap":{"m":"set","a":{"r":["@key"],"s":"[\"settings.fontType\",_0]"}}},"f":[{"t":7,"e":"div","a":{"class":"E_GlobalFontSettings--font-preview"},"f":[{"t":7,"e":"div","a":{"class":"E_GlobalFontSettings--title"},"f":[{"t":2,"r":".title"}]}," ",{"t":7,"e":"div","a":{"class":"E_GlobalFontSettings--body"},"f":[{"t":7,"e":"div","a":{"class":"E_GlobalFontSettings--body-title"},"f":[{"t":2,"r":".body"}]}," ",{"t":7,"e":"div","a":{"class":"E_GlobalFontSettings--body-preview"},"f":["Lorem ipsum dolor sit amet"]}]}]}]}],"n":52,"r":".fontTypes"}]}]}],"e":{}};

/***/ },
/* 151 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":7,"e":"span","a":{"class":["E_SectionThumb E_SectionThumb__",{"t":2,"x":{"r":[".state"],"s":"_0||\"normal\""}}],"data-page-section-type":[{"t":2,"r":".type"}],"tabindex":[{"t":2,"x":{"r":[".tabindex"],"s":"_0||0"}}]},"v":{"tap-enter-space":{"n":[{"t":4,"f":["insertSection"],"n":50,"x":{"r":[".state"],"s":"_0!==\"disabled\""}}],"d":[{"t":2,"r":".type"}]}},"f":[{"t":7,"e":"span","a":{"class":"E_SectionThumb--content"},"f":[{"t":4,"f":[{"t":7,"e":"span","a":{"class":"E_SectionThumb--icon","style":["top: ",{"t":2,"x":{"r":[".iconY"],"s":"_0+\"px\""}},"; left: ",{"t":2,"x":{"r":[".iconX"],"s":"_0+\"px\""}},"; width: ",{"t":2,"x":{"r":[".iconW"],"s":"_0+\"px\""}},"; height: ",{"t":2,"x":{"r":[".iconH"],"s":"_0+\"px\""}},"; transform: rotate(",{"t":2,"x":{"r":[".iconR"],"s":"_0||0"}},"deg);"]},"f":[{"t":7,"e":"svg","f":[{"t":7,"e":"use","a":{"xlink:href":[{"t":2,"r":".icon"}]}}]}]}],"n":50,"r":".icon"}," ",{"t":4,"f":[{"t":7,"e":"span","a":{"class":"E_SectionThumb--name"},"f":[{"t":7,"e":"span","a":{"class":["E_SectionThumb--text ",{"t":4,"f":["E_SectionThumb--text__long"],"n":50,"x":{"r":[".name.length"],"s":"_0>20"}}," ",{"t":4,"f":["E_SectionThumb--text__extra-long"],"n":50,"x":{"r":[".name.length"],"s":"_0>30"}}]},"f":[{"t":2,"r":".name"}]}]}],"n":50,"r":".name"}]}]}],"e":{}};

/***/ },
/* 152 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":7,"e":"div","a":{"class":"E_NewPageSectionSelector"},"f":[{"t":7,"e":"h2","a":{"class":"E_PageMenu--title"},"f":["Vyberte sekci"]}," ",{"t":7,"e":"div","a":{"class":"E_NewPageSectionSelector--thumbs"},"f":[{"t":4,"n":53,"f":[{"t":8,"r":"SectionThumb"}],"x":{"r":[],"s":"{type:\"PageSectionA\",name:\"PageSectionA\",icon:\"#icon-picture\"}"}}," ",{"t":4,"n":53,"f":[{"t":8,"r":"SectionThumb"}],"x":{"r":[],"s":"{type:\"PageSectionB\",name:\"PageSectionB\",icon:\"#icon-magnifier\"}"}}," ",{"t":4,"n":53,"f":[{"t":8,"r":"SectionThumb"}],"x":{"r":[],"s":"{type:\"PageSectionC\",name:\"PageSectionC\",icon:\"#icon-paint-bucket\"}"}}]}]}],"e":{}};

/***/ },
/* 153 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":7,"e":"div","a":{"class":"E_PageElementSettings--transition-wrapper"},"t0":{"n":"fade","a":[{"duration":200,"easing":"linear"}]},"f":[{"t":7,"e":"div","a":{"class":"E_PageElementSettings"},"f":[{"t":7,"e":"div","a":{"class":"E_PageElementSettings--wrapper"},"f":[{"t":7,"e":"div","a":{"class":"E_PageElementSettings--title-bar"},"f":[{"t":7,"e":"div","a":{"class":"E_PageElementSettings--title"},"v":{"mousedown-touchstart":{"m":"activateMover","a":{"r":["event"],"s":"[_0]"}}},"f":[{"t":4,"f":[{"t":7,"e":"span","a":{"class":"E_PageElementSettings--title-self"},"f":[{"t":2,"r":"settingsTitle"}]}],"n":50,"r":"settingsTitle"}," ",{"t":7,"e":"span","a":{"class":"E_PageElementSettings--title-section"},"f":[{"t":2,"r":"section.name"}]}]}," ",{"t":7,"e":"span","a":{"class":"E_PageElementSettings--close ResizableBox--close","title":"Zavřít"},"v":{"tap":"closeThisSettings"},"f":[{"t":7,"e":"svg","f":[{"t":7,"e":"use","a":{"xlink:href":"#icon-x"}}]}]}," ",{"t":7,"e":"span","a":{"class":"E_PageElementSettings--min-max ResizableBox--min-max","title":"Zvětšovat podle obsahu"},"v":{"tap":{"m":"minmax","a":{"r":["event"],"s":"[_0]"}}},"f":[{"t":7,"e":"svg","f":[{"t":7,"e":"use","a":{"xlink:href":"#icon-maximize"}}]}]}]}," ",{"t":7,"e":"div","a":{"class":"E_PageElementSettings--content ResizableBox ResizableBox__floating"},"f":[{"t":4,"f":[{"t":8,"r":"pageElementSettingsContent"}],"n":50,"rx":{"r":"@ractive","m":["partials","pageElementSettingsContent"]}},{"t":4,"n":51,"f":[{"t":8,"r":"content"}],"rx":{"r":"@ractive","m":["partials","pageElementSettingsContent"]}}]}]}," ",{"t":7,"e":"div","a":{"class":"E_PageElementSettings--resizer E_PageElementSettings--resizer__top-left"},"v":{"mousedown-touchstart":{"m":"activateResizer","a":{"r":["event"],"s":"[_0,\"top-left\"]"}}}}," ",{"t":7,"e":"div","a":{"class":"E_PageElementSettings--resizer E_PageElementSettings--resizer__top-right"},"v":{"mousedown-touchstart":{"m":"activateResizer","a":{"r":["event"],"s":"[_0,\"top-right\"]"}}}}," ",{"t":7,"e":"div","a":{"class":"E_PageElementSettings--resizer E_PageElementSettings--resizer__bottom-left"},"v":{"mousedown-touchstart":{"m":"activateResizer","a":{"r":["event"],"s":"[_0,\"bottom-left\"]"}}}}," ",{"t":7,"e":"div","a":{"class":"E_PageElementSettings--resizer E_PageElementSettings--resizer__bottom-right"},"v":{"mousedown-touchstart":{"m":"activateResizer","a":{"r":["event"],"s":"[_0,\"bottom-right\"]"}}}}," ",{"t":7,"e":"div","a":{"class":"E_PageElementSettings--resizer E_PageElementSettings--resizer__top"},"v":{"mousedown-touchstart":{"m":"activateResizer","a":{"r":["event"],"s":"[_0,\"top\"]"}}}}," ",{"t":7,"e":"div","a":{"class":"E_PageElementSettings--resizer E_PageElementSettings--resizer__bottom"},"v":{"mousedown-touchstart":{"m":"activateResizer","a":{"r":["event"],"s":"[_0,\"bottom\"]"}}}}," ",{"t":7,"e":"div","a":{"class":"E_PageElementSettings--resizer E_PageElementSettings--resizer__left"},"v":{"mousedown-touchstart":{"m":"activateResizer","a":{"r":["event"],"s":"[_0,\"left\"]"}}}}," ",{"t":7,"e":"div","a":{"class":"E_PageElementSettings--resizer E_PageElementSettings--resizer__right"},"v":{"mousedown-touchstart":{"m":"activateResizer","a":{"r":["event"],"s":"[_0,\"right\"]"}}}}," ",{"t":7,"e":"div","a":{"class":"E_PageElementSettings--resizer-hover"}}]}]}],"e":{}};

/***/ },
/* 154 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":7,"e":"span","v":{"tap":{"n":"openPageElementSettings","d":[{"t":2,"x":{"r":[],"s":"\"edit1\""}}]}},"f":["upravit"]}," ",{"t":4,"f":[{"t":7,"e":"PageElementSettings","a":{"data":[{"t":2,"r":".element"}],"positionElement":[{"t":2,"r":".pageElementSettingsPositionElement"}]},"f":[{"t":7,"e":"div","a":{"class":"ResizableBox--scrollable","data-min-resize-width":"475","data-max-resize-width":"475","data-max-resize-height":"475","style":"max-width: 240px; max-height: 320px;"},"o":{"n":"ResizableBox","a":[true]},"f":[{"t":7,"e":"div","a":{"class":"E_PageElementSettings--scrolling-content ResizableBox--scrolling-content"},"f":[{"t":7,"e":"ColorPicker","a":{"pathName":"textColor","output":[{"t":2,"r":".data.textColor"}],"input":[{"t":2,"x":{"r":[".data.textColor"],"s":"_0||\"black\""}}],"defer":"true","noColor":"true"},"f":[{"t":7,"e":"ColorPickerPalette","a":{"title":"Nejpoužívanější","colors":[{"t":2,"r":"mostUsedColors"}]}}]}]}]}]}],"n":50,"x":{"r":[".openPageElementSettings"],"s":"_0===\"edit1\""}}],"e":{}};

/***/ },
/* 155 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":7,"e":"span","a":{"class":"\r\n    P_PageElementTextContent E_Editor__content\r\n","style":["color: ",{"t":2,"x":{"r":[".element.textColor",".element.defaultColors.textColor"],"s":"_0||_1"}}],"contenteditable":[{"t":2,"x":{"r":["editMode"],"s":"!!_0"}}],"value":[{"t":2,"r":".element.content"}]}}," ",{"t":4,"f":[{"t":7,"e":"PageElementTextContent","a":{"activateButton":"true","stop":[{"t":2,"x":{"r":[".stop"],"s":"!_0?1:2"}}],"element":[{"t":2,"r":".element"}]}}," ",{"t":7,"e":"PageElementTextContent","a":{"activateButton":"true","stop":[{"t":2,"x":{"r":[".stop"],"s":"!_0?1:2"}}],"element":[{"t":2,"r":".element"}]}}],"n":50,"x":{"r":[".stop"],"s":"parseInt(_0||0)<2"}}],"e":{}};

/***/ },
/* 156 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":7,"e":"span","v":{"tap":{"n":"openPageElementSettings","d":[{"t":2,"x":{"r":[],"s":"\"edit1\""}}]}},"f":["upravit"]}," ",{"t":4,"f":[{"t":7,"e":"PageElementSettings","a":{"data":[{"t":2,"r":".element"}],"positionElement":[{"t":2,"r":".pageElementSettingsPositionElement"}]},"f":[{"t":7,"e":"div","o":{"n":"ResizableBox","a":[true]},"a":{"data-min-resize-width":"464","data-max-resize-width":"464","data-max-resize-height":"464","style":"max-width: 272px; max-height: 336px; display: flex"},"f":[{"t":7,"e":"div","a":{"class":"E_PageElementSettings--scrollable ResizableBox--scrollable","style":"width: 100%"},"f":[{"t":7,"e":"div","a":{"class":"E_PageElementSettings--scrolling-content ResizableBox--scrolling-content"},"f":[{"t":7,"e":"IconBrowser"}]}]}]}]}],"n":50,"x":{"r":[".openPageElementSettings"],"s":"_0===\"edit1\""}}],"e":{}};

/***/ },
/* 157 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":7,"e":"span","a":{"class":"\r\n    P_PageElementTitle E_Editor__title\r\n","style":["color: ",{"t":2,"x":{"r":[".element.textColor",".element.defaultColors.textColor"],"s":"_0||_1"}},";"],"contenteditable":[{"t":2,"x":{"r":["editMode"],"s":"!!_0"}}],"value":[{"t":2,"r":".element.title"}]}}," "],"e":{}};

/***/ },
/* 158 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":7,"e":"div","a":{"class":["P_PageElement P_PageElement__",{"t":2,"x":{"r":[".type"],"s":"_0||\"unknown-type\""},"s":true}," ",{"t":4,"f":["E_PageElement__empty"],"n":50,"x":{"r":[".editMode","@ractive"],"s":"_0&&_1.isEmpty&&_1.isEmpty()"}}," E_PageElement__",{"t":2,"r":".state"}]},"v":{"hover":{"m":"handleHover","a":{"r":["event"],"s":"[_0]"}}},"f":[{"t":4,"f":[{"t":4,"f":[{"t":7,"e":"div","a":{"class":"E_PageElement--activate"},"v":{"tap":{"n":"activate","d":[{"t":2,"r":"event"}]}},"f":[{"t":7,"e":"svg","a":{"width":"24","height":"24"},"f":[{"t":7,"e":"use","a":{"xlink:href":[{"t":2,"x":{"r":[".activateIcon"],"s":"_0||\"#icon-plus\""}}]}}]}]}],"n":50,"r":".activateButton"}," ",{"t":7,"e":"div","a":{"class":["E_PageElement--outline ",{"t":4,"f":["E_PageElement--outline__active"],"n":50,"r":".showOutline"}," ",{"t":4,"f":["E_PageElement--outline__limited"],"n":50,"r":".limitSize"}]},"v":{"touchstart":{"m":"handleTouchstart","a":{"r":["event"],"s":"[_0]"}},"touchend":{"m":"handleTouchend","a":{"r":["event"],"s":"[_0]"}}},"f":[]}," ",{"t":4,"f":[{"t":7,"e":"div","a":{"class":"E_PageElement--EditUI E_PageElementEditUI"},"f":[{"t":8,"r":"pageElementEditUI"}]}],"n":50,"r":".hasEditUI"}],"n":50,"r":".editMode"}," ",{"t":8,"r":"pageElementContent"}]}],"e":{}};

/***/ },
/* 159 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":7,"e":"div","a":{"class":["P_BackgroundImage P_PageSection--background-image ",{"t":4,"f":["P_BackgroundImage__parallax"],"n":50,"r":".parallax"}," ",{"t":4,"f":["P_BackgroundImage__fixed"],"n":50,"r":".fixed"}]},"f":[{"t":7,"e":"div","a":{"class":"P_BackgroundImage--image","style":["background-image: url(",{"t":2,"r":".data.src"},"); -webkit-background-size: ",{"t":2,"r":".backgroundSize"},"; background-size: ",{"t":2,"r":".backgroundSize"},"; background-repeat: ",{"t":2,"r":".backgroundRepeat"},"; ",{"t":4,"f":["height: -webkit-calc(100% + ",{"t":2,"r":".parallaxExtention"},"px); height: -moz-calc(100% + ",{"t":2,"r":".parallaxExtention"},"px); height: calc(100% + ",{"t":2,"r":".parallaxExtention"},"px);"],"n":50,"r":".parallax"}]},"f":[]}]}]};

/***/ },
/* 160 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":7,"e":"div","a":{"class":["E_PageSectionEditUI ",{"t":2,"x":{"r":[".hover"],"s":"_0?\"E_PageSectionEditUI__hover\":\"\""}}]},"f":[{"t":8,"r":"pageSectionEditUIContent"}]}],"e":{}};

/***/ },
/* 161 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":4,"f":[{"t":4,"n":53,"f":[{"t":8,"r":"FlatButton"}],"x":{"r":[],"s":"{type:\"default\",text:\"Skrýt panel\",icon:\"#icon-eye\",iconY:1,title:\"Skrýt ovládací prvky sekce\",touchstart:\"preHideEditUI\",mousedown:\"preHideEditUI\",mouseup:\"hideEditUI\",touchend:\"hideEditUI\",className:\"P_PageSection--hide-edit-ui\"}"}}],"n":50,"x":{"r":[".hideEditUIButton"],"s":"_0!==false"}}],"e":{}};

/***/ },
/* 162 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":4,"n":53,"f":[{"t":8,"r":"FlatButton"}],"x":{"r":["@ractive"],"s":"{text:\"Barvy\",icon:\"#icon-paint-bucket\",title:\"Nastavení barev sekce\",fire:\"openPageSectionSettings\",event:\"colors\",state:_0.parent.get(\"openPageSectionSettings\")===\"colors\"?\"active\":\"\"}"}}," ",{"t":4,"n":53,"f":[{"t":8,"r":"FlatButton"}],"x":{"r":["@ractive"],"s":"{text:\"Pozadí\",icon:\"#icon-picture\",iconY:1,title:\"Nastavení pozadí sekce\",fire:\"openPageSectionSettings\",event:\"background\",state:_0.parent.get(\"openPageSectionSettings\")===\"background\"?\"active\":\"\"}"}}," ",{"t":4,"n":53,"f":[{"t":8,"r":"FlatButton"}],"x":{"r":["@ractive"],"s":"{text:\"Nastavení\",icon:\"#icon-gear\",title:\"Obecné nastavení sekce\",fire:\"openPageSectionSettings\",event:\"section\",state:_0.parent.get(\"openPageSectionSettings\")===\"section\"?\"active\":\"\"}"}}],"e":{}};

/***/ },
/* 163 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":4,"f":[{"t":7,"e":"div","a":{"class":"E_PageSectionEditUI--controls E_PageSectionEditUI--controls__top-left"},"f":[{"t":7,"e":"div","a":{"class":"E_PageSectionEditUI--controls-wrapper"},"f":[{"t":7,"e":"div","a":{"class":"E_PageSectionEditUI--controls-shadow"}}," ",{"t":8,"r":"EditUIControlsTopLeft"}]}]}],"n":50,"x":{"r":[".TopLeftEditUI"],"s":"_0!==false"}},{"t":4,"f":[{"t":7,"e":"div","a":{"class":"E_PageSectionEditUI--controls E_PageSectionEditUI--controls__top-right"},"f":[{"t":7,"e":"div","a":{"class":"E_PageSectionEditUI--controls-wrapper"},"f":[{"t":7,"e":"div","a":{"class":"E_PageSectionEditUI--controls-shadow"}}," ",{"t":8,"r":"EditUIControlsTopRight"}]}]}],"n":50,"x":{"r":[".TopRightEditUI"],"s":"_0!==false"}},{"t":4,"f":[{"t":7,"e":"div","a":{"class":"E_PageSectionEditUI--controls E_PageSectionEditUI--controls__bottom-left"},"f":[{"t":7,"e":"div","a":{"class":"E_PageSectionEditUI--controls-wrapper"},"f":[{"t":7,"e":"div","a":{"class":"E_PageSectionEditUI--controls-shadow"}}," ",{"t":8,"r":"EditUIControlsBottomLeft"}]}]}],"n":50,"x":{"r":[".BottomLeftEditUI"],"s":"_0!==false"}},{"t":4,"f":[{"t":7,"e":"div","a":{"class":"E_PageSectionEditUI--controls E_PageSectionEditUI--controls__bottom-right"},"f":[{"t":7,"e":"div","a":{"class":"E_PageSectionEditUI--controls-wrapper"},"f":[{"t":7,"e":"div","a":{"class":"E_PageSectionEditUI--controls-shadow"}}," ",{"t":8,"r":"EditUIControlsBottomRight"}]}]}],"n":50,"x":{"r":[".BottomRightEditUI"],"s":"_0!==false"}}],"e":{}};

/***/ },
/* 164 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":4,"f":[{"t":4,"n":53,"f":[{"t":8,"r":"FlatButton"}],"x":{"r":["~/removeSectionConfirmation"],"s":"{type:\"default-danger\",text:_0?\"Zrušit\":\"Odstranit\",icon:\"#icon-trash\",title:_0?\"Neodstraňovat sekci\":\"Odstranit sekci ze stránky\",set:\"removeSectionConfirmation\",value:_0?false:true,className:\"P_PageSection--remove\"+(_0?\" P_PageSection--remove__active\":\"\"),state:_0?\"active\":\"\"}"}}," ",{"t":4,"n":53,"f":[{"t":8,"r":"FlatButton"}],"x":{"r":[],"s":"{type:\"ok\",text:\"Odstranit\",icon:\"#icon-check-mark\",title:\"Potvrdit odstranění sekce\",fire:\"removeSection\",className:\"P_PageSection--remove__yes\"}"}}],"n":50,"x":{"r":[".removeSectionButton"],"s":"_0!==false"}}],"e":{}};

/***/ },
/* 165 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":4,"f":[{"t":4,"n":53,"f":[{"t":8,"r":"FlatButton"}],"x":{"r":[],"s":"{text:\"Přesunout\",title:\"Přesunout secki\",icon:\"#icon-up-down\",className:\"P_PageSection--sort-handle\"}"}}],"n":50,"x":{"r":[".sortHandleButton"],"s":"_0!==false"}}],"e":{}};

/***/ },
/* 166 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":7,"e":"div","a":{"class":["E_PageSectionMessage ",{"t":4,"f":["E_PageSectionMessage__active"],"n":50,"r":".message"}]},"f":[{"t":7,"e":"div","a":{"class":["E_PageSectionMessage--message ",{"t":2,"r":".messageStatusClass"}]},"f":[{"t":4,"f":[{"t":7,"e":"h2","a":{"class":"E_PageSectionMessage--title"},"f":[{"t":2,"r":".message.title"}]}],"n":50,"r":".message.title"}," ",{"t":4,"f":[{"t":7,"e":"p","a":{"class":"E_PageSectionMessage--text"},"f":[{"t":2,"r":".message.text"}]}],"n":50,"r":".message.text"}]}]}]};

/***/ },
/* 167 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":7,"e":"div","a":{"class":"E_BackgroundImageSettings","data-max-resize-height":"768","style":"max-height: 320px;"},"o":"ResizableBox","f":[" ",{"t":7,"e":"div","a":{"class":"E_BackgroundImageSettings--background-settings E_PageSectionSettings--scrollable ResizableBox--scrollable"},"f":[{"t":7,"e":"div","a":{"class":"E_PageSectionSettings--scrolling-content ResizableBox--scrolling-content"},"f":[{"t":7,"e":"div","a":{"class":"E_PageSectionSettings--sections"},"f":[{"t":7,"e":"div","a":{"class":"E_PageSectionSettings--section E_BackgroundImageSettings--source"},"f":[{"t":4,"n":53,"f":[{"t":8,"r":"Button"}],"x":{"r":[],"s":"{text:\"Zrušit obrázek na pozadí\",icon:\"#icon-x\",iconW:14,iconH:14,size:\"small\",set:\"data.backgroundImage.src\",value:\"\"}"}}]}]}," ",{"t":7,"e":"div","a":{"class":"E_PageSectionSettings--sections"},"f":[{"t":7,"e":"div","a":{"class":"E_PageSectionSettings--section E_BackgroundImageSettings--display"},"f":[{"t":7,"e":"h2","a":{"class":"E_PageSectionSettings--section-title"},"f":["Zobrazení"]}," ",{"t":4,"n":53,"f":[{"t":8,"r":"Switch"}],"x":{"r":[],"s":"{size:\"small\",value:\".data.backgroundImage.display\",options:[{icon:\"#icon-squares-2x2\",text:\"Opakovat\",value:\"repeat\",title:\"Vyplnit plochu opakováním obrázku\"},{icon:\"#icon-fullscreen\",text:\"Vyplnit\",value:\"cover\",title:\"Vyplnit plochu přizpůsobením obrázku\"}]}"}}]}," ",{"t":7,"e":"div","a":{"class":"E_PageSectionSettings--section E_BackgroundImageSettings--effects"},"f":[{"t":7,"e":"h2","a":{"class":"E_PageSectionSettings--section-title"},"f":["Efekt"]}," ",{"t":4,"n":53,"f":[{"t":8,"r":"Switch"}],"x":{"r":[],"s":"{multiple:true,size:\"small\",value:\".data.backgroundImage.effects\",options:[{icon:\"#icon-pin\",text:\"Fixní\",value:\"fixed\",title:\"Zafixovat jako nepohyblivou tapetu\"},{icon:\"#icon-scroll\",text:\"Parallax\",value:\"parallax\",title:\"Posouvat pozadí pomaleji\"}]}"}}," ",{"t":7,"e":"p","a":{"class":"E_PageSectionSettings--section-note"},"f":["Efekt ",{"t":7,"e":"q","f":["fixní"]}," nemusí fungovat na mobilních zařízeních."]}]}," ",{"t":7,"e":"div","a":{"class":"E_PageSectionSettings--section E_BackgroundImageSettings--effect-strength"},"f":[{"t":7,"e":"h2","a":{"class":"E_PageSectionSettings--section-title"},"f":["Síla efektu"]}," ",{"t":4,"n":53,"f":[{"t":8,"r":"Slider"}],"x":{"r":[".data.backgroundImage.effects"],"s":"{adaptive:true,value:\".data.backgroundImage.effectsStrength\",min:1,max:100,state:_0.indexOf(\"parallax\")===-1?\"disabled\":\"\",maxWidth:\"calc(50% - 12px)\",minWidth:\"200px\",title:\"Míra zpomalení posunu pozadí\",minText:\"1\"}"}}]}]}," ",{"t":7,"e":"div","a":{"class":"E_PageSectionSettings--sections"},"f":[{"t":7,"e":"div","a":{"class":"E_PageSectionSettings--section E_BackgroundImageSettings--bg-color-note"},"f":[{"t":7,"e":"p","a":{"class":"E_PageSectionSettings--section-note"},"f":["Je vhodné také nastavit barvu pozadí, protože než se načte obrázek, text nemusí být čitelný."]}]}]}]}]}," ",{"t":7,"e":"div","a":{"class":"E_BackgroundImageSettings--ImageBrowser E_PageSectionSettings--scrollable ResizableBox--scrollable"},"f":[{"t":7,"e":"div","a":{"class":"E_PageSectionSettings--scrolling-content ResizableBox--scrolling-content"},"f":[{"t":7,"e":"BackgroundImageBrowser","a":{"progressBarId":[{"t":2,"r":".data.internalId"}],"selectedPath":[{"t":2,"r":".data.backgroundImage.src"}]}}]}]}]}],"e":{}};

/***/ },
/* 168 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":4,"f":[{"t":7,"e":"li","a":{"class":["E_PageSectionSettingsMenu--item ",{"t":4,"f":["E_PageSectionSettingsMenu--item__active"],"n":50,"x":{"r":["~/openTab",".index"],"s":"_0===_1"}}," E_ColorSettings--menu-item"]},"v":{"tap":{"m":"set","a":{"r":[".index"],"s":"[\"openTab\",_0]"}}},"f":[{"t":7,"e":"span","a":{"class":"E_PageSectionSettingsMenu--title"},"f":[{"t":2,"rx":{"r":".settings","m":[{"r":[".index"],"s":"\"color\"+_0+\"-title\""}]}}]}," ",{"t":7,"e":"span","a":{"class":"E_PageSectionSettingsMenu--subtitle"},"f":[{"t":2,"rx":{"r":".settings","m":[{"r":[".index"],"s":"\"color\"+_0+\"-subtitle\""}]}}]}]}," ",{"t":4,"n":53,"f":[{"t":8,"r":"ColorSettingsNavItem"}],"x":{"r":[".index",".settings"],"s":"{index:_0+1,settings:_1}"}}],"n":50,"rx":{"r":".settings","m":[{"r":[".index"],"s":"\"color\"+_0+\"-title\""}]}}],"e":{}};

/***/ },
/* 169 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":4,"f":[{"t":7,"e":"ColorPicker","a":{"pathName":[{"t":2,"rx":{"r":".","m":[{"r":[".openTab"],"s":"\"color\"+_0+\"-pathName\""}]}}],"defer":"true","noColor":"true","output":[{"t":2,"rx":{"r":".","m":[{"r":[".openTab"],"s":"\"color\"+_0"}]}}],"input":[{"t":2,"x":{"r":[".openTab","."],"s":"_1[\"color\"+_0]||_1[\"color\"+_0+\"-input-default\"]"}}],"inputType":[{"t":2,"r":".lastInputType","s":true}]},"f":[{"t":7,"e":"ColorPickerPalette","a":{"title":"Nejpoužívanější","colors":[{"t":2,"r":".mostUsedColors"}]}}," ",{"t":7,"e":"ColorPickerPalette","a":{"title":"Výchozí","colors":[{"t":2,"x":{"r":["@ractive"],"s":"_0.findParent(\"Page\").get(\"page.settings.colorPalette.colors\")"}}],"id":"defaultColors"}}," ",{"t":4,"f":[{"t":7,"e":"ColorPickerPalette","a":{"title":"Pozadí","colors":[{"t":2,"r":".imageColors.background.colors"}]}}],"n":50,"r":".imageColors.background","s":true}," ",{"t":4,"f":[{"t":7,"e":"ColorPickerPalette","a":{"id":"background","title":"Pozadí","image":[{"t":2,"r":".image"}]}}],"n":50,"x":{"r":[".imageColors.background"],"s":"!_0"},"s":true}]}],"n":50,"r":".toggleTab"},{"t":4,"f":[{"t":7,"e":"ColorPicker","a":{"pathName":[{"t":2,"rx":{"r":".","m":[{"r":[".openTab"],"s":"\"color\"+_0+\"-pathName\""}]}}],"defer":"true","noColor":"true","output":[{"t":2,"rx":{"r":".","m":[{"r":[".openTab"],"s":"\"color\"+_0"}]}}],"input":[{"t":2,"x":{"r":[".openTab","."],"s":"_1[\"color\"+_0]||_1[\"color\"+_0+\"-input-default\"]"}}],"inputType":[{"t":2,"r":".lastInputType","s":true}]},"f":[{"t":7,"e":"ColorPickerPalette","a":{"title":"Nejpoužívanější","colors":[{"t":2,"r":".mostUsedColors"}]}}," ",{"t":7,"e":"ColorPickerPalette","a":{"title":"Výchozí","colors":[{"t":2,"x":{"r":["@ractive"],"s":"_0.findParent(\"Page\").get(\"page.settings.colorPalette.colors\")"}}],"id":"defaultColors"}}," ",{"t":4,"f":[{"t":7,"e":"ColorPickerPalette","a":{"title":"Pozadí","colors":[{"t":2,"r":".imageColors.background.colors"}]}}],"n":50,"r":".imageColors.background","s":true}," ",{"t":4,"f":[{"t":7,"e":"ColorPickerPalette","a":{"id":"background","title":"Pozadí","image":[{"t":2,"r":".image"}],"delay":[{"t":2,"x":{"r":[".toggleTab","delayOpening"],"s":"_0===undefined?(_1?600:300):0"},"s":true}]}}],"n":50,"x":{"r":[".imageColors.background"],"s":"!_0"},"s":true}]}],"n":50,"x":{"r":[".toggleTab"],"s":"!_0"}}],"e":{}};

/***/ },
/* 170 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":7,"e":"div","a":{"class":"E_ColorSettings","data-max-resize-height":"768","style":"max-height: 320px"},"o":"ResizableBox","f":[{"t":7,"e":"div","a":{"class":"E_ColorSettings--menu E_PageSectionSettings--scrollable ResizableBox--scrollable"},"f":[{"t":7,"e":"div","a":{"class":"E_PageSectionSettingsMenu E_PageSectionSettings--scrolling-content ResizableBox--scrolling-content"},"f":[{"t":7,"e":"ul","a":{"class":"E_PageSectionSettingsMenu--list E_ColorSettings--menu-list"},"f":[{"t":4,"n":53,"f":[{"t":8,"r":"ColorSettingsNavItem"}],"x":{"r":["."],"s":"{index:1,settings:_0}"}}]}," ",{"t":4,"n":53,"f":[{"t":8,"r":"Button"}],"x":{"r":[],"s":"{size:\"small\",text:\"Vygenerovat z výchozích\",fire:\"generateRandomColors\",title:\"Vybere barvy z výchozí palety a všechny nastavené barvy přepíše\",className:\"E_ColorSettings--random-colors-button\"}"}}]}]}," ",{"t":7,"e":"div","a":{"class":"E_ColorSettings--ColorPicker E_PageSectionSettings--scrollable ResizableBox--scrollable"},"f":[{"t":7,"e":"div","a":{"class":"E_PageSectionSettings--scrolling-content ResizableBox--scrolling-content"},"f":[{"t":8,"r":"ColorSettingsTab"}]}]}]}],"e":{}};

/***/ },
/* 171 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":7,"e":"div","a":{"class":"E_SectionSettings","data-max-resize-height":"768","style":"max-height: 320px"},"o":"ResizableBox","f":[{"t":7,"e":"div","a":{"class":"E_PageSectionSettings--scrollable ResizableBox--scrollable"},"f":[{"t":7,"e":"div","a":{"class":"E_PageSectionSettings--scrolling-content ResizableBox--scrolling-content"},"f":[{"t":7,"e":"div","a":{"class":"E_PageSectionSettings--sections E_PageSectionSettings--sections__full"},"f":[{"t":7,"e":"div","a":{"class":"E_PageSectionSettings--section E_BackgroundImageSettings--display"},"f":[{"t":7,"e":"label","a":{"class":"E_PageSectionSettings--section-title","for":"E_SectionSettings--name"},"f":["Název sekce"]}," ",{"t":4,"n":53,"f":[{"t":8,"r":"Text"}],"x":{"r":[],"s":"{adaptive:true,id:\"E_SectionSettings--name\",size:\"small\",value:\"data.name\",required:true}"}}]}]}]}]}]}],"e":{}};

/***/ },
/* 172 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":7,"e":"section","a":{"class":["E_PageSectionSettings ",{"t":4,"f":["E_PageSectionSettings__multiple-tabs"],"n":50,"r":".multipleTabs"}]},"t1":{"n":"slide","d":["{\r\n        delay   : ",{"t":2,"x":{"r":[".delayOpening"],"s":"_0?300:0"}},",\r\n        easing  : 'cubic-bezier(0.1, 0.4, 0.4, 1)'\r\n    }"]},"t2":{"n":"slide","a":[{"easing":"cubic-bezier(0.1, 0.4, 0.4, 1)"}]},"f":[{"t":7,"e":"ProgressBar","a":{"id":[{"t":2,"r":".data.internalId"}]}}," ",{"t":7,"e":"div","a":{"class":"E_PageSectionSettings--wrapper ResizableBox"},"f":[{"t":7,"e":"div","a":{"class":"E_PageSectionSettings--shadow"}}," ",{"t":7,"e":"div","a":{"class":"E_PageSectionSettings--wrapper-2"},"f":[{"t":4,"f":[{"t":8,"r":"pageSectionSettingsContent"}],"n":50,"rx":{"r":"@ractive","m":["partials","pageSectionSettingsContent"]}},{"t":4,"n":51,"f":[{"t":8,"r":"content"}],"rx":{"r":"@ractive","m":["partials","pageSectionSettingsContent"]}}]}," ",{"t":7,"e":"span","a":{"class":"E_PageSectionSettings--close ResizableBox--close","title":"Zavřít"},"v":{"tap":"closeThisSettings"},"f":[{"t":7,"e":"svg","f":[{"t":7,"e":"use","a":{"xlink:href":"#icon-x"}}]}]}," ",{"t":4,"f":[{"t":7,"e":"span","a":{"class":"E_PageSectionSettings--min-max ResizableBox--min-max","title":"Zvětšovat podle obsahu"},"v":{"tap":{"m":"minmax","a":{"r":["event"],"s":"[_0]"}}},"f":[{"t":7,"e":"svg","f":[{"t":7,"e":"use","a":{"xlink:href":"#icon-maximize"}}]}]}],"n":50,"x":{"r":[".notResizable"],"s":"!_0"}}]}," ",{"t":7,"e":"div","a":{"class":"E_PageSectionSettings--resizer ResizableBox--resizer"},"v":{"mousedown-touchstart":{"m":"activateResizer","a":{"r":["event"],"s":"[_0,\"bottom\"]"}}}}]}],"e":{}};

/***/ },
/* 173 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":7,"e":"BackgroundImage","a":{"data":[{"t":2,"r":".section.backgroundImage"}]}}," ",{"t":7,"e":"PageElementTitle","a":{"element":[{"t":2,"r":".section"}],"activateButton":"true"}}]};

/***/ },
/* 174 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":4,"f":[{"t":8,"r":"ColorSettings"}],"n":50,"x":{"r":[".openPageSectionSettings"],"s":"_0===\"colors\""}},{"t":4,"n":51,"f":[{"t":4,"n":50,"x":{"r":[".openPageSectionSettings"],"s":"_0===\"background\""},"f":[{"t":7,"e":"BackgroundImageSettings","a":{"data":[{"t":2,"r":".section"}],"multipleTabs":[{"t":2,"x":{"r":[],"s":"true"},"s":true}]}}]},{"t":4,"n":50,"x":{"r":[".openPageSectionSettings"],"s":"(!(_0===\"background\"))&&(_0===\"section\")"},"f":[" ",{"t":7,"e":"SectionSettings","a":{"data":[{"t":2,"r":".section"}]}}]}],"x":{"r":[".openPageSectionSettings"],"s":"_0===\"colors\""}}],"e":{}};

/***/ },
/* 175 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":7,"e":"BackgroundImage","a":{"data":[{"t":2,"r":".section.backgroundImage"}]}}," ",{"t":7,"e":"PageElementTextContent","a":{"element":[{"t":2,"r":".section"}],"activateButton":"true"}}]};

/***/ },
/* 176 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":4,"f":[{"t":7,"e":"PageSectionSettings","a":{"data":[{"t":2,"r":".section"}]},"f":[{"t":7,"e":"div","a":{"contenteditable":"true","value":[{"t":2,"r":".data.name"}]}}]}],"n":50,"x":{"r":[".openPageSectionSettings"],"s":"_0===\"background\""}},{"t":4,"f":[{"t":7,"e":"SectionSettings","a":{"data":[{"t":2,"r":".section"}]}}],"n":50,"x":{"r":[".openPageSectionSettings"],"s":"_0===\"section\""}},{"t":4,"f":[{"t":8,"r":"ColorSettings"}],"n":50,"x":{"r":[".openPageSectionSettings"],"s":"_0===\"colors\""}}],"e":{}};

/***/ },
/* 177 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":7,"e":"BackgroundImage","a":{"data":[{"t":2,"r":".section.backgroundImage"}]}}," ",{"t":7,"e":"PageElementTitle","a":{"element":[{"t":2,"r":".section"}],"activateButton":"true"}}]};

/***/ },
/* 178 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":4,"f":[{"t":7,"e":"PageSectionSettings","a":{"data":[{"t":2,"r":".section"}]},"f":[{"t":7,"e":"div","a":{"contenteditable":"true","value":[{"t":2,"r":".data.name"}]}}]}],"n":50,"x":{"r":[".openPageSectionSettings"],"s":"_0===\"background\""}},{"t":4,"f":[{"t":7,"e":"SectionSettings","a":{"data":[{"t":2,"r":".section"}]}}],"n":50,"x":{"r":[".openPageSectionSettings"],"s":"_0===\"section\""}},{"t":4,"f":[{"t":8,"r":"ColorSettings"}],"n":50,"x":{"r":[".openPageSectionSettings"],"s":"_0===\"colors\""}}],"e":{}};

/***/ },
/* 179 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":7,"e":"section","a":{"class":"P_PageSection","id":[{"t":2,"r":".section.id"}],"data-page-section-internal-id":[{"t":2,"r":".section.internalId"}],"data-page-section-name":[{"t":2,"r":".section.name"}],"style":"background: white;position: relative; text-align: center; line-height: 200px; font-size: 32px;"},"f":[{"t":7,"e":"div","a":{"class":"P_PageSection--inner-wrapper"},"f":[{"t":7,"e":"div","a":{"class":"P_PageSection--section"},"v":{"hover":{"m":"handleHover","a":{"r":["event"],"s":"[_0]"}},"touchend":{"m":"handleTouchend","a":{"r":["event"],"s":"[_0]"}},"touchstart":{"m":"handleTouchstart","a":{"r":["event"],"s":"[_0]"}}},"f":[{"t":4,"f":[{"t":7,"e":"PageSectionMessage"}," ",{"t":7,"e":"ProgressBar"}," ",{"t":8,"r":"pageSectionEditUI"}],"n":50,"r":".editMode"}," ",{"t":7,"e":"div","a":{"class":["P_PageSection--content ",{"t":4,"f":["E_PageSection__stop-color-transitions"],"n":50,"r":".stopColorTransitions"}]},"f":[{"t":7,"e":"div","a":{"class":"P_PageSection--background-color","style":["background-color: ",{"t":2,"x":{"r":[".section.backgroundColor",".section.defaultColors.backgroundColor"],"s":"_0||_1"}}]},"f":[{"t":8,"r":"pageSectionContent"}]}]}]}," ",{"t":4,"f":[{"t":8,"r":"pageSectionSettings"}],"n":50,"r":".editMode"}]}]}],"e":{}};

/***/ },
/* 180 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":7,"e":"ColorSettings","a":{"data":[{"t":2,"r":".section"}],"multipleTabs":[{"t":2,"x":{"r":[],"s":"true"},"s":true}],"image":[{"t":2,"r":".section.backgroundImage.src"}],"color1-title":"Text","color1":[{"t":2,"r":".section.textColor"}],"color1-pathName":"textColor","color1-input-default":[{"t":2,"r":".section.defaultColors.textColor"}],"color2-title":"Pozadí","color2":[{"t":2,"r":".section.backgroundColor"}],"color2-pathName":"backgroundColor","color2-input-default":[{"t":2,"r":".section.defaultColors.backgroundColor"}]}}],"e":{}};

/***/ },
/* 181 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":7,"e":"div","a":{"class":"E_PageMenu E_PageMenu__left"},"f":[{"t":7,"e":"ul","a":{"class":"E_PageMenu--items"},"f":[{"t":7,"e":"li","a":{"class":["E_PageMenu--item E_PageMenu--item__has-content ",{"t":4,"f":["E_PageMenu--item__show-content"],"n":50,"x":{"r":[".openPageMenu"],"s":"_0===\"settings\""}}]},"f":[{"t":7,"e":"span","a":{"class":"E_PageMenu--button E_PageMenu--button__settings"},"f":[{"t":4,"n":53,"f":[{"t":8,"r":"FlatButton"}],"x":{"r":[],"s":"{type:\"default-2\",size:\"large\",text:\"Nastavení\",icon:\"#icon-gear\",title:\"Globální nastavení stránky\",set:\"openPageMenu\",value:\"settings\",className:\"\"}"}}]}," ",{"t":7,"e":"div","a":{"class":"E_PageMenu--content"},"f":[{"t":7,"e":"span","a":{"class":"E_PageMenu--hide-content"},"v":{"tap":{"m":"set","a":{"r":[],"s":"[\"openPageMenu\",null]"}}},"f":[{"t":7,"e":"svg","f":[{"t":7,"e":"use","a":{"xlink:href":"#icon-x"}}]}]}," ",{"t":7,"e":"span","a":{"class":"E_PageMenu--show-page"},"v":{"touchstart-touchend-hover":"showPage"},"f":[{"t":7,"e":"svg","f":[{"t":7,"e":"use","a":{"xlink:href":"#icon-eye"}}]}]}," ",{"t":7,"e":"div","a":{"class":"E_PageMenu--content-wrapper"},"f":[{"t":4,"f":[{"t":7,"e":"GlobalPageSettings","a":{"settings":[{"t":2,"r":".page.settings"}]}}],"n":50,"x":{"r":[".openPageMenu"],"s":"_0===\"settings\""}}]}]}," ",{"t":7,"e":"div","a":{"class":"E_PageMenu--resizer"},"v":{"mousedown-touchstart":"activateResizer"}}]}," ",{"t":7,"e":"li","a":{"class":["E_PageMenu--item E_PageMenu--item__has-content ",{"t":4,"f":["E_PageMenu--item__show-content E_PageMenu--item__show-content__min"],"n":50,"x":{"r":[".openPageMenu"],"s":"_0===\"add-section\""}}," ",{"t":4,"f":["E_PageMenu--item__adding-section"],"n":50,"r":".draggableActive"}]},"f":[{"t":7,"e":"span","a":{"class":"E_PageMenu--button E_PageMenu--button__add-section"},"f":[{"t":4,"n":53,"f":[{"t":8,"r":"FlatButton"}],"x":{"r":["~/cancelAddSection","~/draggableActive"],"s":"{type:_0?\"danger\":\"default-2\",size:\"large\",text:_1?\"Zrušit\":\"Přidat sekci\",icon:_1?\"#icon-trash\":\"#icon-plus\",title:_1?\"Zrušit přidávání sekce\":\"Přidat novou sekci\",set:\"openPageMenu\",value:\"add-section\",state:_1?\"active\":\"\"}"}}]}," ",{"t":7,"e":"div","a":{"class":"E_PageMenu--content"},"f":[{"t":7,"e":"span","a":{"class":"E_PageMenu--hide-content"},"v":{"tap":{"m":"set","a":{"r":[],"s":"[\"openPageMenu\",null]"}}},"f":[{"t":7,"e":"svg","f":[{"t":7,"e":"use","a":{"xlink:href":"#icon-x"}}]}]}," ",{"t":7,"e":"div","a":{"class":"E_PageMenu--content-wrapper"},"f":[{"t":7,"e":"NewPageSectionSelector"}]}]}," ",{"t":7,"e":"div","a":{"class":"E_PageMenu--resizer"},"v":{"mousedown-touchstart":"activateResizer"}}]}]}," ",{"t":7,"e":"div","a":{"class":"E_PageMenu--position-switcher E_PageMenu--position-switcher__top"},"f":[{"t":7,"e":"span","a":{"class":"icon"},"v":{"tap":{"n":"switchPosition","d":[{"t":2,"x":{"r":[],"s":"\"top\""}}]}},"f":[{"t":7,"e":"svg","a":{"class":"E_PageMenu--icon__arrow"},"f":[{"t":7,"e":"use","a":{"xlink:href":"#icon-arrow-2"}}]}," ",{"t":7,"e":"svg","a":{"class":"E_PageMenu--icon__touch"},"f":[{"t":7,"e":"use","a":{"xlink:href":"#icon-touch-move-up-3"}}]}]}]}," ",{"t":7,"e":"div","a":{"class":"E_PageMenu--position-switcher E_PageMenu--position-switcher__bottom"},"f":[{"t":7,"e":"span","a":{"class":"icon"},"v":{"tap":{"n":"switchPosition","d":[{"t":2,"x":{"r":[],"s":"\"bottom\""}}]}},"f":[{"t":7,"e":"svg","a":{"class":"E_PageMenu--icon__arrow"},"f":[{"t":7,"e":"use","a":{"xlink:href":"#icon-arrow-2"}}]}," ",{"t":7,"e":"svg","a":{"class":"E_PageMenu--icon__touch"},"f":[{"t":7,"e":"use","a":{"xlink:href":"#icon-touch-move-down-3"}}]}]}]}]}," ",{"t":7,"e":"div","a":{"class":"E_PageMenu E_PageMenu__right"},"f":[{"t":7,"e":"ul","a":{"class":"E_PageMenu--items"},"f":[{"t":7,"e":"li","a":{"class":"E_PageMenu--item"},"f":[{"t":7,"e":"span","a":{"class":"E_PageMenu--button E_PageMenu--button__close"},"f":[{"t":4,"n":53,"f":[{"t":8,"r":"FlatButton"}],"x":{"r":[],"s":"{type:\"default-danger\",size:\"large\",text:\"Zavřít\",icon:\"#icon-x\",iconY:1,iconW:30,iconH:30,title:\"Zavřít editaci stránky\",fire:\"closePage\"}"}}]}]}," ",{"t":7,"e":"li","a":{"class":["E_PageMenu--item ",{"t":4,"f":["E_PageMenu--save__unsaved"],"n":50,"r":".unsavedChanges"}]},"f":[{"t":7,"e":"span","a":{"class":"E_PageMenu--button E_PageMenu--button__save"},"f":[{"t":4,"n":53,"f":[{"t":8,"r":"FlatButton"}],"x":{"r":["~/changesSaved","~/unsavedChanges"],"s":"{type:_1?\"warn\":_0?\"ok\":\"default\",size:\"large\",text:\"Uložit\",icon:\"#icon-upload\",iconY:1,title:_1?\"Uložit stránku a publikovat změny\":\"Žádné změny\",fire:\"savePage\"}"}}]}]}]}," ",{"t":7,"e":"div","a":{"class":"E_PageMenu--position-switcher E_PageMenu--position-switcher__top"},"f":[{"t":7,"e":"span","a":{"class":"icon"},"v":{"tap":{"n":"switchPosition","d":[{"t":2,"x":{"r":[],"s":"\"top\""}}]}},"f":[{"t":7,"e":"svg","a":{"class":"E_PageMenu--icon__arrow"},"f":[{"t":7,"e":"use","a":{"xlink:href":"#icon-arrow-2"}}]}]}]}," ",{"t":7,"e":"div","a":{"class":"E_PageMenu--position-switcher E_PageMenu--position-switcher__bottom"},"f":[{"t":7,"e":"span","a":{"class":"icon"},"v":{"tap":{"n":"switchPosition","d":[{"t":2,"x":{"r":[],"s":"\"bottom\""}}]}},"f":[{"t":7,"e":"svg","a":{"class":"E_PageMenu--icon__arrow"},"f":[{"t":7,"e":"use","a":{"xlink:href":"#icon-arrow-2"}}]}]}]}]}],"e":{}};

/***/ },
/* 182 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":4,"f":[{"t":4,"f":[{"t":4,"f":[{"t":7,"e":"div","t2":"fade","a":{"style":"position: fixed; z-index: 99999; top: 0; left: 0; width: 100%; height: 100%; background: black; opacity: 0.75;"}}],"n":50,"r":".pageIsSaving"}," ",{"t":8,"r":"pageMenu"}],"n":50,"r":".editMode"}," ",{"t":7,"e":"div","a":{"id":"page","class":[{"t":4,"f":["E"],"n":50,"r":".editMode"}," ",{"t":2,"x":{"r":[".page.settings.fontType",".defaults.settings.fontType"],"s":"_0||_1"}}," P_roundness-",{"t":2,"x":{"r":[".page.settings.roundness",".defaults.settings.roundness"],"s":"_0||_1"}}," P_animations-",{"t":2,"x":{"r":[".page.settings.animations",".defaults.settings.animations"],"s":"_0||_1"}}," ",{"t":4,"f":["P_underline-titles"],"n":50,"r":".page.settings.underlineTitles"}," ",{"t":2,"r":".sortableActive"}]},"f":[{"t":7,"e":"div","a":{"class":"P_nonsortable-sections","style":"overflow: hidden"},"f":[{"t":4,"f":[{"t":4,"f":[{"t":8,"rx":{"r":".","m":["type"]}}],"n":50,"x":{"r":["./type"],"s":"_0===\"PageSectionHeader\""}}],"n":52,"r":".page.sections"}]}," ",{"t":7,"e":"div","a":{"class":"P_sortable-sections"},"f":[{"t":4,"f":[{"t":4,"f":[{"t":8,"rx":{"r":".","m":["type"]}}],"n":50,"x":{"r":["./type"],"s":"_0&&_0!==\"PageSectionHeader\"&&_0!==\"PageSectionFooter\""}}],"n":52,"r":".page.sections"}]}," ",{"t":7,"e":"div","a":{"class":"P_nonsortable-sections"},"f":[{"t":4,"f":[{"t":4,"f":[{"t":8,"rx":{"r":".","m":["type"]}}],"n":50,"x":{"r":["./type"],"s":"_0===\"PageSectionFooter\""}}],"n":52,"r":".page.sections"}]}]}],"n":50,"x":{"r":["pageId","page._id"],"s":"!_0||_0===_1"}}],"e":{}};

/***/ },
/* 183 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":4,"f":[{"t":7,"e":"div","t1":"fade","a":{"class":"ColorPickerPalette"},"f":[{"t":7,"e":"h6","a":{"class":"ColorPickerPalette--title"},"f":[{"t":2,"r":".title"}]}," ",{"t":7,"e":"div","a":{"class":"ColorPickerPalette--colors"},"f":[{"t":4,"f":[{"t":4,"n":53,"f":[{"t":8,"r":"Color"}],"x":{"r":["i","output",".","inputType"],"s":"{i:_0,output:_1,color:_2,inputType:_3}"}}],"n":52,"i":"i","r":".colors"}," ",{"t":4,"f":[{"t":8,"r":"NoColor"}],"n":50,"r":".addNoColor"}]}]}],"n":50,"r":".colors.length"}," "],"p":{"Color":[{"t":7,"e":"div","a":{"class":["ColorPickerPalette--color ",{"t":4,"f":["ColorPickerPalette--color__remove",{"t":4,"f":["-black"],"n":50,"r":"~/nearToBlack"}],"n":50,"x":{"r":["~/type","~/TYPE_DEFAULT",".i",".output"],"s":"_0===_1&&_2===0&&_3===\"\""}}," "],"style":[" background-color: ",{"t":2,"r":".color"},"; transition: ",{"t":2,"x":{"r":["animate"],"s":"_0?\"\":\"none\""}},"; "],"title":[" ",{"t":4,"f":[{"t":4,"f":["Vybraná: ",{"t":2,"x":{"r":["formatColor",".color",".inputType"],"s":"_0(_1,_2)"}}],"n":50,"x":{"r":["i"],"s":"_0===0"}},{"t":4,"n":51,"f":["Původní: ",{"t":2,"x":{"r":["formatColor",".color",".inputType"],"s":"_0(_1,_2)"}}],"x":{"r":["i"],"s":"_0===0"}}],"n":50,"x":{"r":["~/type","~/TYPE_DEFAULT"],"s":"_0===_1"}},{"t":4,"n":51,"f":[{"t":2,"x":{"r":["formatColor",".color",".inputType"],"s":"_0(_1,_2)"}}],"x":{"r":["~/type","~/TYPE_DEFAULT"],"s":"_0===_1"}}," "]},"v":{"click-touchend":{"n":"setColor","d":[{"t":2,"r":".color"},",",{"t":2,"x":{"r":[],"s":"true"}}]}},"t1":"fade"}],"NoColor":[{"t":7,"e":"div","a":{"class":"ColorPickerPalette--color ColorPickerPalette--color__remove","title":"Odstranit / Výchozí"},"t1":"fade","v":{"click-touchend":{"n":"setColor","d":[{"t":2,"r":"NO_COLOR"}]}}}]},"e":{}};

/***/ },
/* 184 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":7,"e":"div","a":{"class":"ColorPicker"},"f":[{"t":7,"e":"div","a":{"class":"ColorPicker--wrapper-1"},"f":[{"t":7,"e":"div","a":{"class":"ColorPicker--wrapper-2"},"f":[{"t":7,"e":"div","a":{"class":"ColorPicker--widget-wrapper"},"f":[{"t":8,"r":"HSV"}," ",{"t":8,"r":"Input"}]}," ",{"t":7,"e":"div","a":{"class":"ColorPicker--palettes"},"f":[{"t":7,"e":"ColorPickerPalette","a":{"title":"Vybraná / Původní","colors":["[",{"t":2,"r":"current"},", ",{"t":2,"r":"initial"},"]"],"addNoColor":[{"t":2,"r":".noColor"}],"type":"default"}}," ",{"t":16}]}]}]}]}," "],"p":{"HSV":[{"t":7,"e":"div","a":{"class":"ColorPicker--HSV-wrapper"},"f":[{"t":8,"r":"SVBox"}," ",{"t":8,"r":"HBox"}]}],"SVBox":[{"t":7,"e":"div","a":{"class":"ColorPicker--SV-box","style":["background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), #000), linear-gradient(to right, #fff, ",{"t":2,"r":".SVBoxHue"},");"]},"v":{"mousedown-touchstart":{"m":"activateSelector","a":{"r":["event"],"s":"[_0,\"SV\"]"}}},"f":[{"t":7,"e":"div","a":{"class":"ColorPicker--SV-selector","style":[" transform: translate(",{"t":2,"r":"SVSelector.x"},"px, ",{"t":2,"r":"SVSelector.y"},"px); transition: ",{"t":2,"x":{"r":[".animate"],"s":"_0?\"\":\"none\""}},"; background-color: ",{"t":2,"r":".output"},"; "]},"v":{"mousedown-touchstart":{"m":"activateSelector","a":{"r":["event"],"s":"[_0,\"SV\"]"}}}}]}],"HBox":[{"t":7,"e":"div","a":{"class":"ColorPicker--H-box"},"v":{"mousedown-touchstart":{"m":"activateSelector","a":{"r":["event"],"s":"[_0,\"H\"]"}}},"f":[{"t":7,"e":"div","a":{"class":"ColorPicker--H-selector","style":[" transform: translateY(",{"t":2,"r":"HSelector.y"},"px); transition: ",{"t":2,"x":{"r":[".animate"],"s":"_0?\"\":\"none\""}},"; background-color: ",{"t":2,"r":".SVBoxHue"},"; "]},"v":{"mousedown-touchstart":{"m":"activateSelector","a":{"r":["event"],"s":"[_0,\"H\"]"}}}}]}],"Input":[{"t":7,"e":"div","a":{"class":"ColorPicker--input"},"f":[{"t":7,"e":"div","a":{"class":"ColorPicker--input-wrapper-1"},"f":[{"t":7,"e":"div","a":{"class":"ColorPicker--input-wrapper-2"},"f":[{"t":7,"e":"div","a":{"class":"ColorPicker--type-selector-wrapper"},"f":[{"t":4,"f":[{"t":4,"n":53,"f":[{"t":8,"r":"Select"}],"x":{"r":[".TYPE_HEX",".TYPE_RGB"],"s":"{size:\"small\",value:\".inputType\",className:\"ColorPicker--type-selector\",options:[{text:\"HEX\",value:_0},{text:\"RGB\",value:_1}]}"}}],"n":50,"rx":{"r":"@ractive","m":["partials","Select"]}},{"t":4,"n":51,"f":[{"t":7,"e":"select","a":{"class":"ColorPicker--type-selector","value":[{"t":2,"r":".inputType"}]},"f":[{"t":7,"e":"option","a":{"value":[{"t":2,"r":".TYPE_HEX"}]},"f":["HEX"]}," ",{"t":7,"e":"option","a":{"value":[{"t":2,"r":".TYPE_RGB"}]},"f":["RGB"]}]}],"rx":{"r":"@ractive","m":["partials","Select"]}}]}," ",{"t":7,"e":"div","a":{"class":"ColorPicker--input-text-wrapper"},"f":[{"t":4,"f":[{"t":4,"f":[{"t":4,"n":53,"f":[{"t":8,"r":"Text"}],"x":{"r":[],"s":"{size:\"small\",value:\"inputTextHEX\",placeholder:\"RRGGBB\",keyup:\"inputTextHEXChanged\",className:\"ColorPicker--input-text ColorPicker--input-text__hex\"}"}}],"n":50,"x":{"r":[".inputType",".TYPE_HEX"],"s":"_0===_1"}},{"t":4,"n":51,"f":[{"t":4,"n":53,"f":[{"t":8,"r":"Text"}],"x":{"r":[],"s":"{size:\"small\",value:\"inputTextR\",placeholder:\"R\",title:\"Červená [0–255]\",keyup:\"inputTextRGBChanged\",className:\"ColorPicker--input-text ColorPicker--input-text__rgb\"}"}}," ",{"t":4,"n":53,"f":[{"t":8,"r":"Text"}],"x":{"r":[],"s":"{size:\"small\",value:\"inputTextG\",placeholder:\"G\",title:\"Zelená [0–255]\",keyup:\"inputTextRGBChanged\",className:\"ColorPicker--input-text ColorPicker--input-text__rgb\"}"}}," ",{"t":4,"n":53,"f":[{"t":8,"r":"Text"}],"x":{"r":[],"s":"{size:\"small\",value:\"inputTextB\",placeholder:\"B\",title:\"Modrá [0–255]\",keyup:\"inputTextRGBChanged\",className:\"ColorPicker--input-text ColorPicker--input-text__rgb\"}"}}],"x":{"r":[".inputType",".TYPE_HEX"],"s":"_0===_1"}}],"n":50,"rx":{"r":"@ractive","m":["partials","Text"]}},{"t":4,"n":51,"f":[{"t":4,"f":[{"t":7,"e":"input","a":{"type":"text","value":[{"t":2,"r":".inputTextHEX"}],"class":"ColorPicker--input-text ColorPicker--input-text__hex","placeholder":"RRGGBB"},"v":{"keyup":{"m":"inputTextHEXChanged"}}}],"n":50,"x":{"r":[".inputType",".TYPE_HEX"],"s":"_0===_1"}},{"t":4,"n":51,"f":[{"t":7,"e":"input","a":{"type":"text","value":[{"t":2,"r":".inputTextR"}],"class":"ColorPicker--input-text ColorPicker--input-text-rgb","placeholder":"R","title":"Červená [0–255]"},"v":{"keyup":{"m":"inputTextRGBChanged"}}}," ",{"t":7,"e":"input","a":{"type":"text","value":[{"t":2,"r":".inputTextG"}],"class":"ColorPicker--input-text ColorPicker--input-text-rgb","placeholder":"G","title":"Zelená [0–255]"},"v":{"keyup":{"m":"inputTextRGBChanged"}}}," ",{"t":7,"e":"input","a":{"type":"text","value":[{"t":2,"r":".inputTextB"}],"class":"ColorPicker--input-text ColorPicker--input-text-rgb","placeholder":"B","title":"Modrá [0–255]"},"v":{"keyup":{"m":"inputTextRGBChanged"}}}],"x":{"r":[".inputType",".TYPE_HEX"],"s":"_0===_1"}}],"rx":{"r":"@ractive","m":["partials","Text"]}}]}]}]}]}]}};

/***/ },
/* 185 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":4,"f":[{"t":7,"e":"div","a":{"class":"Dialog Dialog--overlay"},"t1":{"n":"fade","a":[{"duration":300}]},"t2":{"n":"fade","a":[{"delay":200,"duration":300}]},"f":[{"t":4,"f":[{"t":8,"r":"dialogBox"}],"n":50,"x":{"r":["~/messages.length"],"s":"_0%2"}},{"t":4,"n":51,"f":[{"t":8,"r":"dialogBox"}],"x":{"r":["~/messages.length"],"s":"_0%2"}}]}],"n":50,"r":"~/messages.0"}],"p":{"dialogBox":[{"t":7,"e":"div","a":{"class":["Dialog--box Dialog--box__",{"t":2,"r":"~/messages.0.type"}]},"t0":{"n":"attr","a":[{"duration":500}]},"v":{"escape":{"n":[{"t":2,"x":{"r":["~/messages.0.close","~/messages.0.dismiss"],"s":"_0||_1?\"handleUserInput\":\"closeDialog\""}}],"d":[{"t":2,"x":{"r":["~/messages.0.close","~/messages.0.close.fire","~/messages.0.close.event","~/messages.0.close.context","~/messages.0.dismiss","~/messages.0.dismiss.fire","~/messages.0.dismiss.event","~/messages.0.dismiss.context"],"s":"_0?[_1,_2,_3]:_4?[_5,_6,_7]:undefined"}}]}},"f":[{"t":7,"e":"div","a":{"class":"Dialog--close","tabindex":"1003"},"v":{"tap-space-enter":{"n":[{"t":2,"x":{"r":["~/messages.0.close","~/messages.0.dismiss"],"s":"_0||_1?\"handleUserInput\":\"closeDialog\""}}],"d":[{"t":2,"x":{"r":["~/messages.0.close","~/messages.0.close.fire","~/messages.0.close.event","~/messages.0.close.context","~/messages.0.dismiss","~/messages.0.dismiss.fire","~/messages.0.dismiss.event","~/messages.0.dismiss.context"],"s":"_0?[_1,_2,_3]:_4?[_5,_6,_7]:undefined"}}]}},"f":[{"t":7,"e":"svg","f":[{"t":7,"e":"use","a":{"xlink:href":"#icon-x"}}]}]}," ",{"t":7,"e":"h2","a":{"class":"Dialog--title"},"f":[{"t":2,"r":"~/messages.0.title"}]}," ",{"t":7,"e":"p","a":{"class":"Dialog--text"},"f":[{"t":2,"r":"~/messages.0.text"}]}," ",{"t":4,"f":[{"t":4,"n":53,"f":[{"t":8,"r":"Button"}],"x":{"r":["~/messages.0.confirm.fire","~/messages.0.confirm.event","~/messages.0.confirm.context","~/messages.0.confirm.exec","~/messages.0.confirm.title","~/messages.0.confirm.text","~/messages.0.confirm.icon"],"s":"{size:\"small\",type:\"ok\",fire:\"handleUserInput\",event:[_0,_1,_2,_3],title:_4,text:_5||\"Potvrdit\",icon:_6||\"#icon-check-mark\",tabindex:1002}"}}],"n":50,"r":"~/messages.0.confirm"}," ",{"t":4,"f":[{"t":4,"n":53,"f":[{"t":8,"r":"Button"}],"x":{"r":["~/messages.0.close.fire","~/messages.0.close.event","~/messages.0.close.context","~/messages.0.close.exec","~/messages.0.close.title","~/messages.0.close.text","~/messages.0.close.icon","~/messages.0.close.iconW","~/messages.0.close.iconH"],"s":"{size:\"small\",type:\"default\",fire:\"handleUserInput\",event:[_0,_1,_2,_3],title:_4,text:_5||\"Zavřít\",icon:_6||\"#icon-x\",iconW:_7||14,iconH:_8||14,tabindex:1001}"}}],"n":50,"r":"~/messages.0.close"}," ",{"t":4,"f":[{"t":4,"n":53,"f":[{"t":8,"r":"Button"}],"x":{"r":["~/messages.0.dismiss.fire","~/messages.0.dismiss.event","~/messages.0.dismiss.context","~/messages.0.dismiss.exec","~/messages.0.dismiss.title","~/messages.0.dismiss.text","~/messages.0.dismiss.icon","~/messages.0.close.iconW","~/messages.0.close.iconH"],"s":"{size:\"small\",type:\"danger\",fire:\"handleUserInput\",event:[_0,_1,_2,_3],title:_4,text:_5||\"Zavřít\",icon:_6||\"#icon-x\",iconW:_7||14,iconH:_8||14,tabindex:1001}"}}],"n":50,"r":"~/messages.0.dismiss"}]}]},"e":{}};

/***/ },
/* 186 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":7,"e":"section","a":{"class":["InlineWidget InlineWidget__",{"t":2,"r":".type"}]},"t1":{"n":"slide","d":["{\r\n        delay   : ",{"t":2,"x":{"r":[".delayOpening"],"s":"_0?300:0"}},",\r\n        easing  : 'cubic-bezier(0.1, 0.4, 0.4, 1)'\r\n    }"]},"t2":{"n":"slide","a":[{"easing":"cubic-bezier(0.1, 0.4, 0.4, 1)"}]},"f":[{"t":7,"e":"div","a":{"class":"InlineWidget--wrapper ResizableBox"},"f":[{"t":7,"e":"div","a":{"class":"InlineWidget--shadow"}}," ",{"t":7,"e":"div","a":{"class":"InlineWidget--content ResizableBox--content","data-max-resize-height":[{"t":2,"x":{"r":[".maxResize"],"s":"_0||768"}}],"style":["max-height: ",{"t":2,"x":{"r":[".initMaxHeight"],"s":"_0||320"}},"px"]},"o":{"n":"ResizableBox","a":[false,true]},"f":[{"t":7,"e":"div","a":{"class":"InlineWidget--scrollable ResizableBox--scrollable ps-child"},"f":[{"t":7,"e":"div","a":{"class":"InlineWidget--scrolling-content ResizableBox--scrolling-content"},"f":[{"t":16}]}]}]}," ",{"t":4,"f":[{"t":7,"e":"span","a":{"class":"InlineWidget--close ResizableBox--close","title":"Zavřít"},"v":{"tap":{"m":"setOnParent","a":{"r":[".close"],"s":"[_0.replace(/^\\./,\"\"),null]"}}},"f":[{"t":7,"e":"svg","f":[{"t":7,"e":"use","a":{"xlink:href":"#icon-x"}}]}]}],"n":50,"r":".close"},{"t":4,"n":51,"f":[{"t":7,"e":"span","a":{"class":"InlineWidget--close ResizableBox--close","title":"Zavřít"},"v":{"tap":"InlineWidget--close"},"f":[{"t":7,"e":"svg","f":[{"t":7,"e":"use","a":{"xlink:href":"#icon-x"}}]}]}],"r":".close"}," ",{"t":7,"e":"span","a":{"class":"InlineWidget--min-max ResizableBox--min-max","title":"Zvětšovat podle obsahu"},"v":{"tap":{"m":"minmax","a":{"r":["event"],"s":"[_0]"}}},"f":[{"t":7,"e":"svg","f":[{"t":7,"e":"use","a":{"xlink:href":"#icon-maximize"}}]}]}]}," ",{"t":7,"e":"div","a":{"class":"InlineWidget--resizer ResizableBox--resizer"},"v":{"mousedown-touchstart":{"m":"activateResizer","a":{"r":["event"],"s":"[_0,\"bottom\"]"}}}}]}],"e":{}};

/***/ },
/* 187 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":7,"e":"div","a":{"class":["E_ProgressBar ",{"t":4,"f":["E_ProgressBar__active"],"n":50,"r":".active"}," ",{"t":4,"f":["E_ProgressBar__error"],"n":50,"r":".error"}," ",{"t":4,"f":["E_ProgressBar__warn"],"n":50,"r":".warn"}," ",{"t":4,"f":["E_ProgressBar__success"],"n":50,"r":".success"}]},"f":[{"t":7,"e":"div","a":{"class":"E_ProgressBar--progress","style":["width: ",{"t":2,"r":".progress"},"%"]}}]}]};

/***/ },
/* 188 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":7,"e":"span","a":{"class":["Slider Slider__",{"t":2,"x":{"r":[".type"],"s":"_0||\"default\""}}," Slider__",{"t":2,"x":{"r":[".size"],"s":"_0||\"medium\""}}," Slider__",{"t":2,"x":{"r":[".state"],"s":"_0||\"normal\""}}," ",{"t":4,"f":["Slider__adaptive"],"n":50,"r":".adaptive"}," ",{"t":2,"r":".className"}],"style":["min-width: ",{"t":2,"r":".minWidth"},"; max-width: ",{"t":2,"r":".maxWidth"},";"],"title":[{"t":2,"r":".title"}]},"v":{"mouseup-touchend-keyup":{"m":"set","a":{"r":[".value"],"s":"[\"__Slider.\"+_0.replace(/\\./g,\"_\")+\"-no-transition\",false]"}}},"f":[{"t":4,"f":[{"t":4,"f":[{"t":7,"e":"span","a":{"class":"Slider--text Slider--text__min"},"f":[{"t":2,"x":{"r":[".data.min",".data.minText"],"s":"typeof _1===\"undefined\"?_0:_1"}}]}," ",{"t":7,"e":"span","a":{"class":"Slider--text Slider--text__max"},"f":[{"t":2,"x":{"r":[".data.max",".data.maxText"],"s":"typeof _1===\"undefined\"?_0:_1"}}]}],"n":50,"x":{"r":[".data.state"],"s":"_0===\"disabled\""}},{"t":4,"n":51,"f":[{"t":7,"e":"span","a":{"class":"Slider--text Slider--text__min"},"v":{"tap":{"m":"set","a":{"r":["._value",".data.min"],"s":"[\"__Slider.\"+_0,_1]"}}},"f":[{"t":2,"x":{"r":[".data.min",".data.minText"],"s":"typeof _1===\"undefined\"?_0:_1"}}]}," ",{"t":7,"e":"span","a":{"class":"Slider--text Slider--text__max"},"v":{"tap":{"m":"set","a":{"r":["._value",".data.max"],"s":"[\"__Slider.\"+_0,_1]"}}},"f":[{"t":2,"x":{"r":[".data.max",".data.maxText"],"s":"typeof _1===\"undefined\"?_0:_1"}}]}],"x":{"r":[".data.state"],"s":"_0===\"disabled\""}}," ",{"t":7,"e":"input","a":{"type":"range","class":"Slider--input","value":[{"t":2,"rx":{"r":"~/__Slider","m":[{"t":30,"n":"._value"}]}}],"id":[{"t":2,"r":".id"}],"min":[{"t":2,"x":{"r":[".data.min"],"s":"_0||0"}}],"max":[{"t":2,"x":{"r":[".data.max"],"s":"_0||100"}}]},"m":[{"t":4,"f":["disabled"],"n":50,"x":{"r":[".data.state"],"s":"_0===\"disabled\""}}],"v":{"mousemove-touchmove":{"m":"set","a":{"r":["._value","event.original","event.original.buttons","event.original.type"],"s":"[\"__Slider.\"+_0+\"-no-transition\",_1.stopPropagation()||!!_2||_3===\"touchmove\"]"}},"keydown":{"m":"set","a":{"r":["._value"],"s":"[\"__Slider.\"+_0+\"-no-transition\",true]"}},"mousedown-touchstart":{"m":"set","a":{"r":["._value"],"s":"[\"__Slider.\"+_0+\"-no-transition\",false]"}}}}," ",{"t":7,"e":"span","a":{"class":"Slider--custom-track"},"f":[{"t":7,"e":"span","a":{"class":"Slider--custom-handle","style":[" ",{"t":4,"f":["transition: none;"],"n":50,"x":{"r":["._value","~/__Slider"],"s":"_1&&_1[_0+\"-no-transition\"]"}}," left: ",{"t":2,"x":{"r":["._value","~/__Slider",".middle",".data.max"],"s":"((!isNaN(_1&&_1[_0])?_1[_0]:_2)/(_3||100))*100"}},"%; "]}}]}," ",{"t":7,"e":"span","a":{"class":"Slider--text Slider--text__current"},"f":[{"t":2,"x":{"r":["._value","~/__Slider",".middle"],"s":"_1&&!isNaN(_1[_0])?_1[_0]:_2"}}]}],"n":54,"x":{"r":[".id",".","@ractive",".value",".data.max",".data.min"],"s":"{id:_0||\"Slider--\"+Date.now(),data:_1,link:_2.link(_3.replace(/^\\./,\"\"),\"__Slider.\"+_3.replace(/\\./g,\"_\")),_value:_3.replace(/\\./g,\"_\"),middle:((_4||100)-(_5||0))/2}"}}]}],"e":{}};

/***/ },
/* 189 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":7,"e":"span","a":{"class":["Switch Switch__",{"t":2,"x":{"r":[".type"],"s":"_0||\"default\""}}," Switch__",{"t":2,"x":{"r":[".size"],"s":"_0||\"medium\""}}," Switch__",{"t":2,"x":{"r":[".state"],"s":"_0||\"normal\""}}," ",{"t":4,"f":["Switch__adaptive"],"n":50,"r":".adaptive"}," ",{"t":2,"r":".className"}]},"f":[{"t":4,"f":[{"t":7,"e":"span","a":{"class":"Switch--options"},"f":[{"t":4,"f":[{"t":4,"f":[{"t":7,"e":"input","a":{"type":"checkbox","class":"Switch--input","id":[{"t":2,"x":{"r":["../../../id","@key"],"s":"_0+_1"}}],"name":[{"t":2,"rx":{"r":"~/__Switch","m":[{"t":30,"n":"../../../_value"}]}}],"value":[{"t":2,"r":".value"}]},"m":[{"t":4,"f":["disabled"],"n":50,"x":{"r":[".state","../../state"],"s":"_0===\"disabled\"||_1===\"disabled\""}}]}],"n":50,"r":"../../multiple"},{"t":4,"n":51,"f":[{"t":7,"e":"input","a":{"type":"radio","class":"Switch--input","id":[{"t":2,"x":{"r":["../../../id","@key"],"s":"_0+_1"}}],"name":[{"t":2,"rx":{"r":"~/__Switch","m":[{"t":30,"n":"../../../_value"}]}}],"value":[{"t":2,"r":".value"}]},"m":[{"t":4,"f":["disabled"],"n":50,"x":{"r":[".state","../../state"],"s":"_0===\"disabled\"||_1===\"disabled\""}}]}],"r":"../../multiple"}," ",{"t":7,"e":"label","a":{"class":["Switch--option ",{"t":4,"f":["Switch--option__no-icon"],"n":50,"x":{"r":[".icon"],"s":"!_0"}}," ",{"t":4,"f":["Switch--option__no-text"],"n":50,"x":{"r":[".text"],"s":"!_0"}}," ",{"t":2,"r":".className"}],"for":[{"t":2,"x":{"r":["../../../id","@key"],"s":"_0+_1"}}],"title":[{"t":2,"r":".title"}]},"v":{"touchstart":""},"f":[{"t":7,"e":"span","a":{"class":"Switch--option-background"}}," ",{"t":4,"f":[{"t":7,"e":"span","a":{"class":"Switch--icon","style":["top: ",{"t":2,"x":{"r":[".iconY"],"s":"_0+\"px\""}},"; left: ",{"t":2,"x":{"r":[".iconX"],"s":"_0+\"px\""}},"; width: ",{"t":2,"x":{"r":[".iconW"],"s":"_0+\"px\""}},"; height: ",{"t":2,"x":{"r":[".iconH"],"s":"_0+\"px\""}},"; transform: rotate(",{"t":2,"x":{"r":[".iconR"],"s":"_0||0"}},"deg);"]},"f":[{"t":7,"e":"svg","f":[{"t":7,"e":"use","a":{"xlink:href":[{"t":2,"r":".icon"}]}}]}]}],"n":50,"r":".icon"}," ",{"t":4,"f":[{"t":7,"e":"span","a":{"class":"Switch--text-wrapper"},"f":[{"t":7,"e":"span","a":{"class":["Switch--text ",{"t":4,"f":["Switch--text__short"],"n":50,"x":{"r":[".text.length"],"s":"_0<5"}}," ",{"t":4,"f":["Switch--text__long"],"n":50,"x":{"r":[".text.length"],"s":"_0>10"}}," ",{"t":4,"f":["Switch--text__extra-long"],"n":50,"x":{"r":[".text.length"],"s":"_0>15"}}]},"f":[{"t":2,"r":".text"}]}]}],"n":50,"r":".text"}]}],"n":52,"r":".data.options"}]}],"n":54,"x":{"r":[".","@ractive",".defaultValue",".value"],"s":"{id:\"Switch--\"+Date.now()+\"__\",data:_0,link:_1.link(_3.replace(/^\\./,\"\"),\"__Switch.\"+_3.replace(/\\./g,\"_\")),_default:typeof _2!==\"undefined\"&&typeof _1.get(_3.replace(/^\\./,\"\"))===\"undefined\"&&_1.set(_3.replace(/^\\./,\"\"),_2),_value:_3.replace(/\\./g,\"_\")}"}}]}],"e":{}};

/***/ },
/* 190 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":4,"f":[{"t":7,"e":"label","a":{"for":[{"t":2,"r":".id"}],"class":["ToggleField ToggleField__",{"t":2,"x":{"r":[".data.type"],"s":"_0||\"default\""}}," ToggleField__",{"t":2,"x":{"r":[".data.size"],"s":"_0||\"medium\""}}," ToggleField__",{"t":2,"x":{"r":[".data.state"],"s":"_0||\"normal\""}}," ",{"t":2,"r":".data.className"}]},"m":[{"t":4,"f":["tabindex=\"",{"t":2,"x":{"r":[".data.tabindex"],"s":"_0||0"}},"\""],"n":50,"x":{"r":[".data.state"],"s":"_0!==\"disabled\""}}],"v":{"space-enter":{"m":"toggle","a":{"r":[".data.state",".data.value"],"s":"[_0!==\"disabled\"?_1.replace(/^\\./,\"\"):undefined]"}}},"f":[{"t":7,"e":"span","a":{"class":"ToggleField--text"},"f":[{"t":2,"r":".data.text"}]}," ",{"t":4,"n":53,"f":[{"t":8,"r":"Toggle"}],"x":{"r":[".id",".data.type",".data.title",".data.state",".data.size",".data.value",".data.onText",".data.offText"],"s":"{id:_0,type:_1,title:_2,state:_3,size:_4,value:_5,onText:_6,offText:_7,tabindex:-1}"}}]}],"n":54,"x":{"r":[".id","."],"s":"{id:_0||\"ToggleField--\"+Date.now(),data:_1}"}}],"e":{}};

/***/ },
/* 191 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":7,"e":"span","a":{"class":["Toggle Toggle__",{"t":2,"x":{"r":[".type"],"s":"_0||\"default\""}}," Toggle__",{"t":2,"x":{"r":[".size"],"s":"_0||\"medium\""}}," Toggle__",{"t":2,"x":{"r":[".state"],"s":"_0||\"normal\""}}," ",{"t":2,"r":".className"}],"title":[{"t":2,"r":".title"}]},"f":[{"t":4,"f":[{"t":7,"e":"input","a":{"type":"checkbox","class":"Toggle--input","checked":[{"t":2,"rx":{"r":"~/__Toggle","m":[{"t":30,"n":"._value"}]}}],"id":[{"t":2,"r":".id"}]},"m":[{"t":4,"f":["disabled"],"n":50,"x":{"r":[".data.state"],"s":"_0===\"disabled\""}}]}," ",{"t":7,"e":"label","a":{"class":"Toggle--event","for":[{"t":2,"r":".id"}]},"f":[{"t":4,"f":[{"t":7,"e":"span","a":{"class":"Toggle--handle"}}],"n":50,"x":{"r":[".data.state","@ractive"],"s":"_0===\"disabled\"||!_1.root.events.windowMousemove"}},{"t":4,"n":51,"f":[{"t":7,"e":"span","a":{"class":"Toggle--handle","style":[{"t":4,"f":["transform: translateX( ",{"t":2,"x":{"r":["._value","~/__Toggle"],"s":"!_1[_0]?Math.max(0,Math.min(_1[_0+\"-transform\"],_1[_0+\"-move\"].maxHMove)):Math.min(_1[_0+\"-move\"].maxHMove,Math.max(_1[_0+\"-move\"].maxHMove+_1[_0+\"-transform\"],0))"}},"px );"],"n":50,"rx":{"r":"~/__Toggle","m":[{"r":["._value"],"s":"_0+\"-move\""}]}}," ",{"t":4,"f":["transition: none;"],"n":50,"rx":{"r":"~/__Toggle","m":[{"r":["._value"],"s":"_0+\"-move\""}]}}]},"v":{"mousedown":{"m":"set","a":{"r":["._value","event.original.clientX","event.node.offsetParent.offsetWidth","event.node.offsetWidth"],"s":"[\"__Toggle.\"+_0+\"-move\",{initX:_1,lastX:_1,beforeLastX:_1,maxHMove:_2-_3-2,handleW:_3}]"}},"touchstart":{"m":"set","a":{"r":["._value","event.original.changedTouches.0.clientX","event.node.offsetParent.offsetWidth","event.node.offsetWidth"],"s":"[\"__Toggle.\"+_0+\"-move\",{initX:_1,lastX:_1,beforeLastX:_1,maxHMove:_2-_3-2,handleW:_3}]"}},"windowMousemove-windowTouchmove":{"m":"set","a":{"r":["event.original.type","event.original","@ractive","event.clientX","._value","~/__Toggle"],"s":"[\"__Toggle.\"+_4+\"-transform\",_5[_4+\"-move\"]?(_0.match(/touch/)&&_1.stopPropagation()||_1.preventDefault())||(_2.set(\"__Toggle.\"+_4+\"-move.beforeLastX\",_5[_4+\"-move\"].lastX)&&_2.set(\"__Toggle.\"+_4+\"-move.lastX\",_3)&&_3-_5[_4+\"-move\"].initX):\"\"]"}},"mouseup-touchend-click":{"m":"set","a":{"r":["event.original"],"s":"[\"__Toggle.__X\",_0.preventDefault()]"}},"windowMouseup-windowTouchend":{"m":"set","a":{"r":["@ractive","._value","~/__Toggle","event.clientX"],"s":"[\"__Toggle.\"+_1+\"-move\",_2[_1+\"-move\"]?_0.set(\"__Toggle.\"+_1,_2[_1]?_2[_1+\"-move\"].beforeLastX<_3:_2[_1+\"-move\"].beforeLastX<=_3)&&false:false]"}}},"f":[]}],"x":{"r":[".data.state","@ractive"],"s":"_0===\"disabled\"||!_1.root.events.windowMousemove"}}," ",{"t":7,"e":"span","a":{"class":"Toggle--state"},"f":[{"t":7,"e":"span","a":{"class":"Toggle--on","style":[{"t":4,"f":["transform: translateX( ",{"t":2,"x":{"r":["._value","~/__Toggle"],"s":"_1[_0]?-100+(Math.min(1,Math.max(0,(_1[_0+\"-move\"].maxHMove+_1[_0+\"-transform\"])/_1[_0+\"-move\"].maxHMove))*100):-100+(Math.min(1,Math.max(0,_1[_0+\"-transform\"]/_1[_0+\"-move\"].maxHMove))*100)"}},"%); padding-right: ",{"t":2,"x":{"r":["._value","~/__Toggle"],"s":"_1[_0]?_1[_0+\"-move\"].handleW*(Math.min(1,Math.max(0,(_1[_0+\"-move\"].maxHMove+_1[_0+\"-transform\"])/_1[_0+\"-move\"].maxHMove))):_1[_0+\"-move\"].handleW*(Math.min(1,Math.max(0,_1[_0+\"-transform\"]/_1[_0+\"-move\"].maxHMove)))"}},"px;"],"n":50,"rx":{"r":"~/__Toggle","m":[{"r":["._value"],"s":"_0+\"-move\""}]}}," ",{"t":4,"f":["transition: none;"],"n":50,"rx":{"r":"~/__Toggle","m":[{"r":["._value"],"s":"_0+\"-move\""}]}}]},"f":[{"t":7,"e":"span","a":{"class":"Toggle--text"},"f":[{"t":2,"x":{"r":[".data.onText"],"s":"typeof _0!==\"undefined\"?_0:\"Ano\""}}]}]}," ",{"t":7,"e":"span","a":{"class":"Toggle--off","style":[{"t":4,"f":["transform: translateX( ",{"t":2,"x":{"r":["._value","~/__Toggle"],"s":"_1[_0]?-100+(Math.min(1,Math.max(0,(_1[_0+\"-move\"].maxHMove+_1[_0+\"-transform\"])/_1[_0+\"-move\"].maxHMove))*100):-100+(Math.min(1,Math.max(0,_1[_0+\"-transform\"]/_1[_0+\"-move\"].maxHMove))*100)"}},"%); padding-left: ",{"t":2,"x":{"r":["._value","~/__Toggle"],"s":"_1[_0]?_1[_0+\"-move\"].handleW-(_1[_0+\"-move\"].handleW*(Math.min(1,Math.max(0,(_1[_0+\"-move\"].maxHMove+_1[_0+\"-transform\"])/_1[_0+\"-move\"].maxHMove)))):_1[_0+\"-move\"].handleW-(_1[_0+\"-move\"].handleW*(Math.min(1,Math.max(0,_1[_0+\"-transform\"]/_1[_0+\"-move\"].maxHMove))))"}},"px;"],"n":50,"rx":{"r":"~/__Toggle","m":[{"r":["._value"],"s":"_0+\"-move\""}]}}," ",{"t":4,"f":["transition: none;"],"n":50,"rx":{"r":"~/__Toggle","m":[{"r":["._value"],"s":"_0+\"-move\""}]}}]},"f":[{"t":7,"e":"span","a":{"class":"Toggle--text"},"f":[{"t":2,"x":{"r":[".data.offText"],"s":"typeof _0!==\"undefined\"?_0:\"Ne\""}}]}]}]}]}],"n":54,"x":{"r":[".id",".","@ractive",".value"],"s":"{id:_0||\"Toggle--\"+Date.now(),data:_1,link:_2.link(_3.replace(/^\\./,\"\"),\"__Toggle.\"+_3.replace(/\\./g,\"_\")),_value:_3.replace(/\\./g,\"_\")}"}}]}],"e":{}};

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;;(function (root, factory) {

	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0), __webpack_require__(119)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }

	  else if (typeof module !== 'undefined') {
	    factory(require('ractive'), require('hammerjs'));
	  }

	  else {
	    factory(root.Ractive, root.Hammer);
	  }

	}(this, function (Ractive, Hammer) {

	  // Check the recognizers documentation.
	  // http://hammerjs.github.io/recognizer-tap

	  var defaults = {
	    tap: {
	      recognizerClass: Hammer.Tap,
	      options: {
	        time: 500
	      },
	      events: [
	        'tap'
	      ]
	    },
	    doubletap: {
	      recognizerClass: Hammer.Tap,
	      options: {
	        taps: 2,
	        event: 'doubletap'
	      },
	      recognizeWith: ['tap'],
	      events: [
	        'doubletap'
	      ]
	    },
	    swipe: {
	      recognizerClass: Hammer.Swipe,
	      options: {},
	      events: [
	        'swipe',
	        'swipeleft',
	        'swiperight',
	        'swipeup',
	        'swipedown'
	      ]
	    },
	    pan: {
	      recognizerClass: Hammer.Pan,
	      options: {
	        direction: Hammer.DIRECTION_HORIZONTAL
	      },
	      recognizeWith: ['swipe'],
	      events: [
	        'pan',
	        'panstart',
	        'panmove',
	        'panend',
	        'pancancel',
	        'panleft',
	        'panright',
	        'panup',
	        'pandown'
	      ]
	    },
	    press: {
	      recognizerClass: Hammer.Press,
	      options: {},
	      events: [
	        'press'
	      ]
	    },
	    rotate: {
	      recognizerClass: Hammer.Rotate,
	      options: {},
	      events: [
	        'rotate',
	        'rotatestart',
	        'rotatemove',
	        'rotateend',
	        'rotatecancel'
	      ]
	    },
	    pinch: {
	      recognizerClass: Hammer.Pinch,
	      options: {},
	      recognizeWith: ['rotate'],
	      events: [
	        'pinch',
	        'pinchstart',
	        'pinchmove',
	        'pinchend',
	        'pinchcancel',
	        'pinchin',
	        'pinchout'
	      ]
	    }
	  };

	  var aliases;

	  // bind all events using buildEvent
	  for (var recognizerName in defaults) {
	    if (!defaults.hasOwnProperty(recognizerName)) continue;

	    var events = defaults[recognizerName].events;
	    for (var i = 0; i < events.length; i++) {
	      buildEvent(events[i], recognizerName, defaults[recognizerName]);
	    }
	  }

	  /**
	   * buildEvent : buildEvent(event, recognizerName, config)
	   * (private) registers an event handler for buildEvent.
	   *
	   *     buildEvent('panstart', 'pan', { ... });
	   */

	  function buildEvent(eventName, recognizerName, config) {
	    Ractive.events[eventName] = buildEventHandler(eventName, recognizerName, config);
	  }

	  /**
	   * buildEventHandler() : buildEventHandler(event, recognizerName, config)
	   * (private) Creates the event handler for a given `eventName` that will be
	   * registered to `Ractive.events`.
	   */

	  function buildEventHandler(eventName, recognizerName, config) {
	    return function (node, fire) {
	      var hammerManager = getHammerManager(node);

	      var recognizerExists = (hammerManager.get(recognizerName) !== null);

	      if (!recognizerExists) {
	        // init with default options
	        var recognizer = new config.recognizerClass(config.options);

	        // Hammer.Recognizer.set merges it on top of the defaults supplied above
	        var options = parseOptions(node, recognizerName);
	        if (options)
	          recognizer.set(options);

	        hammerManager.add(recognizer);

	        updateRecognizeWith(hammerManager);
	      }

	      // register the handler
	      hammerManager.on(eventName, function (e) {
	        fire({
	          node: node,
	          original: e
	        });
	      });

	      // handle exits
	      function teardown() {
	        getHammerManager(node).destroy();
	        delete node._hammer;
	      }

	      return { teardown: teardown };
	    };
	  }

	  /**
	   * updateRecognizeWith : updateRecognizeWith(hammerManager)
	   * (private) Sets recognizeWith if defaults have it
	   *
	   * Since we add recognizers dynamically and without any strict order,
	   *  we need to guard against trying to set a requireWith for a recognizer
	   *  that haven't been created yet.
	   *
	   */
	  function updateRecognizeWith(hammerManager) {
	    for (var i = 0; i < hammerManager.recognizers.length; i++) {
	      var recognizer = hammerManager.recognizers[i];
	      var recognizerName = recognizer.options.event;

	      if (!defaults[recognizerName].hasOwnProperty('recognizeWith')) continue;

	      var recognizeWiths = defaults[recognizerName].recognizeWith;
	      for (var k = 0; k < recognizeWiths.length; k++) {
	        // Verify that the recgonizer we're trying to depend on is really there
	        if (!hammerManager.get(recognizeWiths[k])) continue;

	        // It's safe to recognizeWith multiple times for the same recognizer
	        recognizer.recognizeWith(recognizeWiths[k]);
	      }
	    }
	  }

	  /**
	   * parseOptions : parseOptions(node, key)
	   * (private) Returns options for a given DOM node.
	   *
	   *     node = <div data-swipe-direction='left' data-swipe-threshold='2'>
	   *
	   *     parseOptions(node, 'swipe')
	   *     => { direction: 'left', threshold: 2 }
	   */

	  function parseOptions(node, key) {
	    var attrs = node.attributes,
	        output,
	        re = new RegExp("^(?:data-)?"+key+"-(.*)$");

	    for (var i = attrs.length-1; i >= 0; i--) {
	      var attr = attrs[i],
	          m = attr.name.match(re);

	      if (!m) continue;
	      if (!output) output = {};
	      output[m[1]] = parseHammerValue(attr.value, m[1]);
	    }

	    return output;
	  }

	  /**
	   * parseHammerValue : parseHammerValue(str, key)
	   * (private) Value-izes a given string `str`, converting it to a number as
	   * needed. If `key` is given, it can also resolve aliases for that given
	   * key.
	   *
	   * Used by `getData()`.
	   *
	   *     parseHammerValue("100")   => 100
	   *     parseHammerValue("right") => "right"
	   *     parseHammerValue("right", "direction") => Hammer.DIRECTION_RIGHT
	   */

	  function parseHammerValue(str, key) {
	    if (str.match && str.match(/^-?\d+(?:\.\d+)?$/)) return +str;
	    return (aliases[key] && aliases[key][str]) ||
	      aliases.all[str] || str;
	  }

	  /*
	   * Aliases for `val()`.
	   */

	  aliases = {
	    all: {
	      'true': true,
	      'false': false,
	      'undefined': undefined,
	      'null': null
	    },
	    direction: {
	      'none': Hammer.DIRECTION_NONE,
	      'all': Hammer.DIRECTION_ALL,
	      'up': Hammer.DIRECTION_UP,
	      'down': Hammer.DIRECTION_DOWN,
	      'left': Hammer.DIRECTION_LEFT,
	      'right': Hammer.DIRECTION_RIGHT,
	      'horizontal': Hammer.DIRECTION_HORIZONTAL,
	      'vertical': Hammer.DIRECTION_VERTICAL
	    }
	  };

	  /**
	   * getHammerManager : getHammerManager(node)
	   * (private) Returns the `HammerManager` instance for the given node.
	   */

	  function getHammerManager(node) {
	    if (node._hammer) return node._hammer;

	    node._hammer = new Hammer.Manager(node, {recognizers: []});
	    return node._hammer;
	  }


	  return {defaults: defaults};

	}));


/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	(function (global, factory) {
		 true ? module.exports = factory() :
		typeof define === 'function' && define.amd ? define(factory) :
		global.Ractive.transitions.attr = factory();
	}(this, function () { 'use strict';

		var DEFAULTS = {
			duration: 300,
	        delay: 0
		};

	    var id = 1,

	        timeouts = {};

		function attr(t, params) {

			params = t.processParams(params, DEFAULTS);

	        var newId = id++,
	            currentId = t.node.getAttribute("data-ractive-transition-id");

	        if (currentId) {

	            clearTimeout(timeouts[currentId]);
	            delete timeouts[currentId];
	        }

	        t.node.setAttribute("data-ractive-transition-id", newId);
	        t.node.setAttribute("data-ractive-transition", t.isIntro ? "intro" : "outro");

	        if (params.delay) {

	            timeouts[newId] = setTimeout(function() {

	                timeouts[newId] = setTimeout(function () {

	                    t.node.setAttribute("data-ractive-transition", t.isIntro ? "intro-complete" : "outro-complete");
	                    t.node.removeAttribute("data-ractive-transition-id");

	                    t.complete();

	                }, params.duration);

	            }, params.delay);

	            return;
	        }

	        timeouts[newId] = setTimeout(function () {

	            delete timeouts[newId];

	            t.node.setAttribute("data-ractive-transition", t.isIntro ? "intro-complete" : "outro-complete");
	            t.node.removeAttribute("data-ractive-transition-id");

	            t.complete();

	        }, params.duration);
		}

		return attr;

	}));

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	(function (global, factory) {
		 true ? module.exports = factory() :
		typeof define === 'function' && define.amd ? define(factory) :
		global.Ractive.transitions.fade = factory();
	}(this, function () { 'use strict';

		var DEFAULTS = {
			delay: 0,
			duration: 300,
			easing: 'linear'
		};

		function fade(t, params) {
			var targetOpacity;

			params = t.processParams(params, DEFAULTS);

			if (t.isIntro) {
				targetOpacity = t.getStyle('opacity');
				t.setStyle('opacity', 0);
			} else {
				targetOpacity = 0;
			}

			t.animateStyle('opacity', targetOpacity, params).then(t.complete);
		}

		return fade;

	}));

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	(function (global, factory) {
		 true ? module.exports = factory() :
		typeof define === 'function' && define.amd ? define(factory) :
		(global.Ractive = global.Ractive || {}, global.Ractive.transitions = global.Ractive.transitions || {}, global.Ractive.transitions.slide = factory());
	}(this, function () { 'use strict';

		var DEFAULTS = {
			duration: 300,
			easing: 'easeInOut'
		};

		var PROPS = ['height', 'borderTopWidth', 'borderBottomWidth', 'paddingTop', 'paddingBottom', 'marginTop', 'marginBottom'];

		var COLLAPSED = {
			height: 0,
			borderTopWidth: 0,
			borderBottomWidth: 0,
			paddingTop: 0,
			paddingBottom: 0,
			marginTop: 0,
			marginBottom: 0
		};

		function slide(t, params) {
			var targetStyle;

			params = t.processParams(params, DEFAULTS);

			if (t.isIntro) {
				targetStyle = t.getStyle(PROPS);
				t.setStyle(COLLAPSED);
			} else {
				// make style explicit, so we're not transitioning to 'auto'
				t.setStyle(t.getStyle(PROPS));
				targetStyle = COLLAPSED;
			}

			t.setStyle('overflowY', 'hidden');

			t.animateStyle(targetStyle, params).then(t.complete);
		}

		return slide;

	}));
	//# sourceMappingURL=ractive-transitions-slide.umd.js.map

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 *  request-frame - requestAnimationFrame & cancelAnimationFrame polyfill for
	 *   optimal cross-browser development.
	 *    Version:  v1.4.0
	 *     License:  MIT
	 *      Copyright Julien Etienne 2015 All Rights Reserved.
	 *        github:  https://github.com/julienetie/request-frame
	 *‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
	 */
	(function (window) {

	/**
	 * @param  {String} type - request | cancel | native.
	 * @return {Function} Timing function.
	 */
	function requestFrame(type) {
	    // The only vendor prefixes required.
	    var vendors = ['moz', 'webkit'],

	        // Disassembled timing function abbreviations.
	        aF = 'AnimationFrame',
	        rqAF = 'Request' + aF,

	        // Final assigned functions.
	        assignedRequestAnimationFrame,
	        assignedCancelAnimationFrame,

	        // Initial time of the timing lapse.
	        previousTime = 0,

	        mozRAF = window.mozRequestAnimationFrame,
	        mozCAF = window.mozCancelAnimationFrame,

	        // Checks for firefox 4 - 10 function pair mismatch.
	        hasMozMismatch = mozRAF && !mozCAF,

	        func;

	    // Date.now polyfill, mainly for legacy IE versions.
	    if (!Date.now) {
	        Date.now = function() {
	            return new Date().getTime();
	        };
	    }

	    /**
	     * hasIOS6RequestAnimationFrameBug.
	     * @See {@Link https://gist.github.com/julienetie/86ac394ec41f1271ff0a}
	     * - for Commentary.
	     * @Copyright 2015 - Julien Etienne.
	     * @License: MIT.
	     */
	    function hasIOS6RequestAnimationFrameBug() {
	        var webkitRAF = window.webkitRequestAnimationFrame,
	            rAF = window.requestAnimationFrame,

	            // CSS/ Device with max for iOS6 Devices.
	            hasMobileDeviceWidth = screen.width <= 768 ? true : false,

	            // Only supports webkit prefixed requestAnimtionFrane.
	            requiresWebkitprefix = !(webkitRAF && rAF),

	            // iOS6 webkit browsers don't support performance now.
	            hasNoNavigationTiming = window.performance ? false : true,

	            iOS6Notice = 'setTimeout is being used as a substitiue for' +
	            'requestAnimationFrame due to a bug within iOS 6 builds',

	            hasIOS6Bug = requiresWebkitprefix && hasMobileDeviceWidth &&
	            hasNoNavigationTiming;

	        function bugCheckresults(timingFnA, timingFnB, notice) {
	            if (timingFnA || timingFnB) {
	                console.warn(notice);
	                return true;
	            } else {
	                return false;
	            }
	        }

	        function displayResults() {
	            if (hasIOS6Bug) {
	                return bugCheckresults(webkitRAF, rAF, iOS6Notice);
	            } else {
	                return false;
	            }
	        }

	        return displayResults();
	    }

	    /**
	     * Native clearTimeout function.
	     * @return {Function}
	     */
	    function clearTimeoutWithId(id) {
	        clearTimeout(id);
	    }

	    /**
	     * Based on a polyfill by Erik, introduced by Paul Irish &
	     * further improved by Darius Bacon.
	     * @see  {@link http://www.paulirish.com/2011/
	     * requestanimationframe-for-smart-animating}
	     * @see  {@link https://github.com/darius/requestAnimationFrame/blob/
	     * master/requestAnimationFrame.js}
	     * @callback {Number} Timestamp.
	     * @return {Function} setTimeout Function.
	     */
	    function setTimeoutWithTimestamp(callback) {
	        var immediateTime = Date.now(),
	            lapsedTime = Math.max(previousTime + 16, immediateTime);
	        return setTimeout(function() {
	                callback(previousTime = lapsedTime);
	            },
	            lapsedTime - immediateTime);
	    }

	    /**
	     * Queries the native function, prefixed function
	     * or use the setTimeoutWithTimestamp function.
	     * @return {Function}
	     */
	    function queryRequestAnimationFrame() {
	        if (Array.prototype.filter) {
	            assignedRequestAnimationFrame = window['request' + aF] ||
	                window[vendors.filter(function(vendor) {
	                    if (window[vendor + rqAF] !== undefined)
	                        return vendor;
	                }) + rqAF] || setTimeoutWithTimestamp;
	        } else {
	            return setTimeoutWithTimestamp;
	        }
	        if (!hasIOS6RequestAnimationFrameBug()) {
	            return assignedRequestAnimationFrame;
	        } else {
	            return setTimeoutWithTimestamp;
	        }
	    }

	    /**
	     * Queries the native function, prefixed function
	     * or use the clearTimeoutWithId function.
	     * @return {Function}
	     */
	    function queryCancelAnimationFrame() {
	        var cancellationNames = [];
	        if (Array.prototype.map) {
	            vendors.map(function(vendor) {
	                return ['Cancel', 'CancelRequest'].map(
	                    function(cancellationNamePrefix) {
	                        cancellationNames.push(vendor +
	                            cancellationNamePrefix + aF);
	                    });
	            });
	        } else {
	            return clearTimeoutWithId;
	        }

	        /**
	         * Checks for the prefixed cancelAnimationFrame implementation.
	         * @param  {Array} prefixedNames - An array of the prefixed names.
	         * @param  {Number} i - Iteration start point.
	         * @return {Function} prefixed cancelAnimationFrame function.
	         */
	        function prefixedCancelAnimationFrame(prefixedNames, i) {
	            var cancellationFunction;
	            for (; i < prefixedNames.length; i++) {
	                if (window[prefixedNames[i]]) {
	                    cancellationFunction = window[prefixedNames[i]];
	                    break;
	                }
	            }
	            return cancellationFunction;
	        }

	        // Use truthly function
	        assignedCancelAnimationFrame = window['cancel' + aF] ||
	            prefixedCancelAnimationFrame(cancellationNames, 0) ||
	            clearTimeoutWithId;

	        // Check for iOS 6 bug
	        if (!hasIOS6RequestAnimationFrameBug()) {
	            return assignedCancelAnimationFrame;
	        } else {
	            return clearTimeoutWithId;
	        }
	    }

	    function getRequestFn() {
	        if (hasMozMismatch) {
	            return setTimeoutWithTimestamp;
	        } else {
	            return queryRequestAnimationFrame();
	        }
	    }

	    function getCancelFn() {
	        return queryCancelAnimationFrame();
	    }

	    function setNativeFn() {
	        if (hasMozMismatch) {
	            window.requestAnimationFrame = setTimeoutWithTimestamp;
	            window.cancelAnimationFrame = clearTimeoutWithId;
	        } else {
	            window.requestAnimationFrame = queryRequestAnimationFrame();
	            window.cancelAnimationFrame = queryCancelAnimationFrame();
	        }
	    }

	    /**
	     * The type value "request" singles out firefox 4 - 10 and
	     * assigns the setTimeout function if plausible.
	     */

	    switch (type) {
	        case 'request':
	        case '':
	            func = getRequestFn();
	            break;

	        case 'cancel':
	            func = getCancelFn();
	            break;

	        case 'native':
	            setNativeFn();
	            break;
	        default:
	            throw new Error('RequestFrame parameter is not a type.');
	    }
	    return func;
	}


	// Node.js/ CommonJS
	if (typeof module === 'object' && typeof module.exports === 'object') {
	module.exports = exports = requestFrame;
	}

	// AMD
	else if (true) {
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	  return requestFrame;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}

	// Default to window as global
	else if (typeof window === 'object') {
	window.requestFrame = requestFrame;
	}
	/* global -module, -exports, -define */

	}((typeof window === "undefined" ? {} : window)));


/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root) {

	var defaultSeparator = '-'

	function slugg(string, separator, toStrip) {

	  // Separator is optional
	  if (typeof separator === 'undefined') separator = defaultSeparator

	  // Separator might be omitted and toStrip in its place
	  if (separator instanceof RegExp) {
	    toStrip = separator
	    separator = defaultSeparator
	  }

	  // Only a separator was passed
	  if (typeof toStrip === 'undefined') toStrip = /['"’‘”“]/g

	  // Swap out non-english characters for their english equivalent
	  for (var i = 0, len = string.length; i < len; i++) {
	    if (chars[string.charAt(i)]) {
	      string = string.replace(string.charAt(i), chars[string.charAt(i)])
	    }
	  }

	  string = string
	    // Make lower-case
	    .toLowerCase()
	    // Strip chars that shouldn't be replaced with separator
	    .replace(toStrip, '')
	    // Replace non-word characters with separator
	    .replace(/[\W|_]+/g, separator)
	    // Strip dashes from the beginning
	    .replace(new RegExp('^' + separator + '+'), '')
	    // Strip dashes from the end
	    .replace(new RegExp(separator + '+$'), '')

	  return string

	}

	// Conversion table. Modified version of:
	// https://github.com/dodo/node-slug/blob/master/src/slug.coffee
	var chars = slugg.chars = {
	  // Latin
	  'À': 'A', 'Á': 'A', 'Â': 'A', 'Ã': 'A', 'Ä': 'A', 'Å': 'A', 'Æ': 'AE',
	  'Ç': 'C', 'È': 'E', 'É': 'E', 'Ê': 'E', 'Ë': 'E', 'Ì': 'I', 'Í': 'I',
	  'Î': 'I', 'Ï': 'I', 'Ð': 'D', 'Ñ': 'N', 'Ò': 'O', 'Ó': 'O', 'Ô': 'O',
	  'Õ': 'O', 'Ö': 'O', 'Ő': 'O', 'Ø': 'O', 'Ù': 'U', 'Ú': 'U', 'Û': 'U',
	  'Ü': 'U', 'Ű': 'U', 'Ý': 'Y', 'Þ': 'TH', 'ß': 'ss', 'à': 'a', 'á': 'a',
	  'â': 'a', 'ã': 'a', 'ä': 'a', 'å': 'a', 'æ': 'ae', 'ç': 'c', 'è': 'e',
	  'é': 'e', 'ê': 'e', 'ë': 'e', 'ì': 'i', 'í': 'i', 'î': 'i', 'ï': 'i',
	  'ð': 'd', 'ñ': 'n', 'ò': 'o', 'ó': 'o', 'ô': 'o', 'õ': 'o', 'ö': 'o',
	  'ő': 'o', 'ø': 'o', 'ù': 'u', 'ú': 'u', 'û': 'u', 'ü': 'u', 'ű': 'u',
	  'ý': 'y', 'þ': 'th', 'ÿ': 'y', 'ẞ': 'SS', 'œ': 'oe', 'Œ': 'OE',
	  // Greek
	  'α': 'a', 'β': 'b', 'γ': 'g', 'δ': 'd', 'ε': 'e', 'ζ': 'z', 'η': 'h',
	  'θ': '8', 'ι': 'i', 'κ': 'k', 'λ': 'l', 'μ': 'm', 'ν': 'n', 'ξ': '3',
	  'ο': 'o', 'π': 'p', 'ρ': 'r', 'σ': 's', 'τ': 't', 'υ': 'y', 'φ': 'f',
	  'χ': 'x', 'ψ': 'ps', 'ω': 'w', 'ά': 'a', 'έ': 'e', 'ί': 'i', 'ό': 'o',
	  'ύ': 'y', 'ή': 'h', 'ώ': 'w', 'ς': 's', 'ϊ': 'i', 'ΰ': 'y', 'ϋ': 'y',
	  'ΐ': 'i', 'Α': 'A', 'Β': 'B', 'Γ': 'G', 'Δ': 'D', 'Ε': 'E', 'Ζ': 'Z',
	  'Η': 'H', 'Θ': '8', 'Ι': 'I', 'Κ': 'K', 'Λ': 'L', 'Μ': 'M', 'Ν': 'N',
	  'Ξ': '3', 'Ο': 'O', 'Π': 'P', 'Ρ': 'R', 'Σ': 'S', 'Τ': 'T', 'Υ': 'Y',
	  'Φ': 'F', 'Χ': 'X', 'Ψ': 'PS', 'Ω': 'W', 'Ά': 'A', 'Έ': 'E', 'Ί': 'I',
	  'Ό': 'O', 'Ύ': 'Y', 'Ή': 'H', 'Ώ': 'W', 'Ϊ': 'I', 'Ϋ': 'Y',
	  // Turkish
	  'ş': 's', 'Ş': 'S', 'ı': 'i', 'İ': 'I', 'ğ': 'g', 'Ğ': 'G',
	  // Russian
	  'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ё': 'yo',
	  'ж': 'zh', 'з': 'z', 'и': 'i', 'й': 'j', 'к': 'k', 'л': 'l', 'м': 'm',
	  'н': 'n', 'о': 'o', 'п': 'p', 'р': 'r', 'с': 's', 'т': 't', 'у': 'u',
	  'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh', 'щ': 'sh', 'ъ': 'u',
	  'ы': 'y', 'э': 'e', 'ю': 'yu', 'я': 'ya', 'А': 'A', 'Б': 'B',
	  'В': 'V', 'Г': 'G', 'Д': 'D', 'Е': 'E', 'Ё': 'Yo', 'Ж': 'Zh', 'З': 'Z',
	  'И': 'I', 'Й': 'J', 'К': 'K', 'Л': 'L', 'М': 'M', 'Н': 'N', 'О': 'O',
	  'П': 'P', 'Р': 'R', 'С': 'S', 'Т': 'T', 'У': 'U', 'Ф': 'F', 'Х': 'H',
	  'Ц': 'C', 'Ч': 'Ch', 'Ш': 'Sh', 'Щ': 'Sh', 'Ъ': 'U', 'Ы': 'Y',
	  'Э': 'E', 'Ю': 'Yu', 'Я': 'Ya',
	  // Ukranian
	  'Є': 'Ye', 'І': 'I', 'Ї': 'Yi', 'Ґ': 'G',
	  'є': 'ye', 'і': 'i', 'ї': 'yi', 'ґ': 'g',
	  // Czech
	  'č': 'c', 'ď': 'd', 'ě': 'e', 'ň': 'n', 'ř': 'r', 'š': 's',
	  'ť': 't', 'ů': 'u', 'ž': 'z', 'Č': 'C', 'Ď': 'D', 'Ě': 'E',
	  'Ň': 'N', 'Ř': 'R', 'Š': 'S', 'Ť': 'T', 'Ů': 'U', 'Ž': 'Z',
	  // Polish
	  'ą': 'a', 'ć': 'c', 'ę': 'e', 'ł': 'l', 'ń': 'n', 'ś': 's',
	  'ź': 'z', 'ż': 'z', 'Ą': 'A', 'Ć': 'C', 'Ę': 'e', 'Ł': 'L',
	  'Ń': 'N', 'Ś': 'S', 'Ź': 'Z', 'Ż': 'Z',
	  // Latvian
	  'ā': 'a', 'ē': 'e', 'ģ': 'g', 'ī': 'i', 'ķ': 'k', 'ļ': 'l',
	  'ņ': 'n', 'ū': 'u', 'Ā': 'A', 'Ē': 'E', 'Ģ': 'G', 'Ī': 'i',
	  'Ķ': 'k', 'Ļ': 'L', 'Ņ': 'N', 'Ū': 'u'
	}

	// Be compatible with different module systems

	if (true) {
	  // AMD
	  !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	    return slugg
	  }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
	} else if (typeof module !== 'undefined' && module.exports) {
	  // CommonJS
	  module.exports = slugg
	} else {
	  // Script tag
	  root.slugg = slugg
	}

	}(this))


/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {


	/**
	 * Module dependencies.
	 */

	var url = __webpack_require__(199);
	var parser = __webpack_require__(28);
	var Manager = __webpack_require__(49);
	var debug = __webpack_require__(7)('socket.io-client');

	/**
	 * Module exports.
	 */

	module.exports = exports = lookup;

	/**
	 * Managers cache.
	 */

	var cache = exports.managers = {};

	/**
	 * Looks up an existing `Manager` for multiplexing.
	 * If the user summons:
	 *
	 *   `io('http://localhost/a');`
	 *   `io('http://localhost/b');`
	 *
	 * We reuse the existing instance based on same scheme/port/host,
	 * and we initialize sockets for each namespace.
	 *
	 * @api public
	 */

	function lookup(uri, opts) {
	  if (typeof uri == 'object') {
	    opts = uri;
	    uri = undefined;
	  }

	  opts = opts || {};

	  var parsed = url(uri);
	  var source = parsed.source;
	  var id = parsed.id;
	  var path = parsed.path;
	  var sameNamespace = cache[id] && path in cache[id].nsps;
	  var newConnection = opts.forceNew || opts['force new connection'] ||
	                      false === opts.multiplex || sameNamespace;

	  var io;

	  if (newConnection) {
	    debug('ignoring socket cache for %s', source);
	    io = Manager(source, opts);
	  } else {
	    if (!cache[id]) {
	      debug('new io instance for %s', source);
	      cache[id] = Manager(source, opts);
	    }
	    io = cache[id];
	  }

	  return io.socket(parsed.path);
	}

	/**
	 * Protocol version.
	 *
	 * @api public
	 */

	exports.protocol = parser.protocol;

	/**
	 * `connect`.
	 *
	 * @param {String} uri
	 * @api public
	 */

	exports.connect = lookup;

	/**
	 * Expose constructors for standalone build.
	 *
	 * @api public
	 */

	exports.Manager = __webpack_require__(49);
	exports.Socket = __webpack_require__(51);


/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/**
	 * Module dependencies.
	 */

	var parseuri = __webpack_require__(43);
	var debug = __webpack_require__(7)('socket.io-client:url');

	/**
	 * Module exports.
	 */

	module.exports = url;

	/**
	 * URL parser.
	 *
	 * @param {String} url
	 * @param {Object} An object meant to mimic window.location.
	 *                 Defaults to window.location.
	 * @api public
	 */

	function url(uri, loc){
	  var obj = uri;

	  // default to window.location
	  var loc = loc || global.location;
	  if (null == uri) uri = loc.protocol + '//' + loc.host;

	  // relative path support
	  if ('string' == typeof uri) {
	    if ('/' == uri.charAt(0)) {
	      if ('/' == uri.charAt(1)) {
	        uri = loc.protocol + uri;
	      } else {
	        uri = loc.host + uri;
	      }
	    }

	    if (!/^(https?|wss?):\/\//.test(uri)) {
	      debug('protocol-less url %s', uri);
	      if ('undefined' != typeof loc) {
	        uri = loc.protocol + '//' + uri;
	      } else {
	        uri = 'https://' + uri;
	      }
	    }

	    // parse
	    debug('parse %s', uri);
	    obj = parseuri(uri);
	  }

	  // make sure we treat `localhost:80` and `localhost` equally
	  if (!obj.port) {
	    if (/^(http|ws)$/.test(obj.protocol)) {
	      obj.port = '80';
	    }
	    else if (/^(http|ws)s$/.test(obj.protocol)) {
	      obj.port = '443';
	    }
	  }

	  obj.path = obj.path || '/';

	  var ipv6 = obj.host.indexOf(':') !== -1;
	  var host = ipv6 ? '[' + obj.host + ']' : obj.host;

	  // define unique id
	  obj.id = obj.protocol + '://' + host + ':' + obj.port;
	  // define href
	  obj.href = obj.protocol + '://' + host + (loc && loc.port == obj.port ? '' : (':' + obj.port));

	  return obj;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*global Blob,File*/

	/**
	 * Module requirements
	 */

	var isArray = __webpack_require__(17);
	var isBuf = __webpack_require__(53);

	/**
	 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
	 * Anything with blobs or files should be fed through removeBlobs before coming
	 * here.
	 *
	 * @param {Object} packet - socket.io event packet
	 * @return {Object} with deconstructed packet and list of buffers
	 * @api public
	 */

	exports.deconstructPacket = function(packet){
	  var buffers = [];
	  var packetData = packet.data;

	  function _deconstructPacket(data) {
	    if (!data) return data;

	    if (isBuf(data)) {
	      var placeholder = { _placeholder: true, num: buffers.length };
	      buffers.push(data);
	      return placeholder;
	    } else if (isArray(data)) {
	      var newData = new Array(data.length);
	      for (var i = 0; i < data.length; i++) {
	        newData[i] = _deconstructPacket(data[i]);
	      }
	      return newData;
	    } else if ('object' == typeof data && !(data instanceof Date)) {
	      var newData = {};
	      for (var key in data) {
	        newData[key] = _deconstructPacket(data[key]);
	      }
	      return newData;
	    }
	    return data;
	  }

	  var pack = packet;
	  pack.data = _deconstructPacket(packetData);
	  pack.attachments = buffers.length; // number of binary 'attachments'
	  return {packet: pack, buffers: buffers};
	};

	/**
	 * Reconstructs a binary packet from its placeholder packet and buffers
	 *
	 * @param {Object} packet - event packet with placeholders
	 * @param {Array} buffers - binary buffers to put in placeholder positions
	 * @return {Object} reconstructed packet
	 * @api public
	 */

	exports.reconstructPacket = function(packet, buffers) {
	  var curPlaceHolder = 0;

	  function _reconstructPacket(data) {
	    if (data && data._placeholder) {
	      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
	      return buf;
	    } else if (isArray(data)) {
	      for (var i = 0; i < data.length; i++) {
	        data[i] = _reconstructPacket(data[i]);
	      }
	      return data;
	    } else if (data && 'object' == typeof data) {
	      for (var key in data) {
	        data[key] = _reconstructPacket(data[key]);
	      }
	      return data;
	    }
	    return data;
	  }

	  packet.data = _reconstructPacket(packet.data);
	  packet.attachments = undefined; // no longer useful
	  return packet;
	};

	/**
	 * Asynchronously removes Blobs or Files from data via
	 * FileReader's readAsArrayBuffer method. Used before encoding
	 * data as msgpack. Calls callback with the blobless data.
	 *
	 * @param {Object} data
	 * @param {Function} callback
	 * @api private
	 */

	exports.removeBlobs = function(data, callback) {
	  function _removeBlobs(obj, curKey, containingObject) {
	    if (!obj) return obj;

	    // convert any blob
	    if ((global.Blob && obj instanceof Blob) ||
	        (global.File && obj instanceof File)) {
	      pendingBlobs++;

	      // async filereader
	      var fileReader = new FileReader();
	      fileReader.onload = function() { // this.result == arraybuffer
	        if (containingObject) {
	          containingObject[curKey] = this.result;
	        }
	        else {
	          bloblessData = this.result;
	        }

	        // if nothing pending its callback time
	        if(! --pendingBlobs) {
	          callback(bloblessData);
	        }
	      };

	      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
	    } else if (isArray(obj)) { // handle array
	      for (var i = 0; i < obj.length; i++) {
	        _removeBlobs(obj[i], i, obj);
	      }
	    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object
	      for (var key in obj) {
	        _removeBlobs(obj[key], key, obj);
	      }
	    }
	  }

	  var pendingBlobs = 0;
	  var bloblessData = data;
	  _removeBlobs(bloblessData);
	  if (!pendingBlobs) {
	    callback(bloblessData);
	  }
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
	;(function () {
	  // Detect the `define` function exposed by asynchronous module loaders. The
	  // strict `define` check is necessary for compatibility with `r.js`.
	  var isLoader = "function" === "function" && __webpack_require__(207);

	  // A set of types used to distinguish objects from primitives.
	  var objectTypes = {
	    "function": true,
	    "object": true
	  };

	  // Detect the `exports` object exposed by CommonJS implementations.
	  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

	  // Use the `global` object exposed by Node (including Browserify via
	  // `insert-module-globals`), Narwhal, and Ringo as the default context,
	  // and the `window` object in browsers. Rhino exports a `global` function
	  // instead.
	  var root = objectTypes[typeof window] && window || this,
	      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

	  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
	    root = freeGlobal;
	  }

	  // Public: Initializes JSON 3 using the given `context` object, attaching the
	  // `stringify` and `parse` functions to the specified `exports` object.
	  function runInContext(context, exports) {
	    context || (context = root["Object"]());
	    exports || (exports = root["Object"]());

	    // Native constructor aliases.
	    var Number = context["Number"] || root["Number"],
	        String = context["String"] || root["String"],
	        Object = context["Object"] || root["Object"],
	        Date = context["Date"] || root["Date"],
	        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
	        TypeError = context["TypeError"] || root["TypeError"],
	        Math = context["Math"] || root["Math"],
	        nativeJSON = context["JSON"] || root["JSON"];

	    // Delegate to the native `stringify` and `parse` implementations.
	    if (typeof nativeJSON == "object" && nativeJSON) {
	      exports.stringify = nativeJSON.stringify;
	      exports.parse = nativeJSON.parse;
	    }

	    // Convenience aliases.
	    var objectProto = Object.prototype,
	        getClass = objectProto.toString,
	        isProperty, forEach, undef;

	    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
	    var isExtended = new Date(-3509827334573292);
	    try {
	      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
	      // results for certain dates in Opera >= 10.53.
	      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
	        // Safari < 2.0.2 stores the internal millisecond time value correctly,
	        // but clips the values returned by the date methods to the range of
	        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
	        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
	    } catch (exception) {}

	    // Internal: Determines whether the native `JSON.stringify` and `parse`
	    // implementations are spec-compliant. Based on work by Ken Snyder.
	    function has(name) {
	      if (has[name] !== undef) {
	        // Return cached feature test result.
	        return has[name];
	      }
	      var isSupported;
	      if (name == "bug-string-char-index") {
	        // IE <= 7 doesn't support accessing string characters using square
	        // bracket notation. IE 8 only supports this for primitives.
	        isSupported = "a"[0] != "a";
	      } else if (name == "json") {
	        // Indicates whether both `JSON.stringify` and `JSON.parse` are
	        // supported.
	        isSupported = has("json-stringify") && has("json-parse");
	      } else {
	        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
	        // Test `JSON.stringify`.
	        if (name == "json-stringify") {
	          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
	          if (stringifySupported) {
	            // A test function object with a custom `toJSON` method.
	            (value = function () {
	              return 1;
	            }).toJSON = value;
	            try {
	              stringifySupported =
	                // Firefox 3.1b1 and b2 serialize string, number, and boolean
	                // primitives as object literals.
	                stringify(0) === "0" &&
	                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
	                // literals.
	                stringify(new Number()) === "0" &&
	                stringify(new String()) == '""' &&
	                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
	                // does not define a canonical JSON representation (this applies to
	                // objects with `toJSON` properties as well, *unless* they are nested
	                // within an object or array).
	                stringify(getClass) === undef &&
	                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
	                // FF 3.1b3 pass this test.
	                stringify(undef) === undef &&
	                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
	                // respectively, if the value is omitted entirely.
	                stringify() === undef &&
	                // FF 3.1b1, 2 throw an error if the given value is not a number,
	                // string, array, object, Boolean, or `null` literal. This applies to
	                // objects with custom `toJSON` methods as well, unless they are nested
	                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
	                // methods entirely.
	                stringify(value) === "1" &&
	                stringify([value]) == "[1]" &&
	                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
	                // `"[null]"`.
	                stringify([undef]) == "[null]" &&
	                // YUI 3.0.0b1 fails to serialize `null` literals.
	                stringify(null) == "null" &&
	                // FF 3.1b1, 2 halts serialization if an array contains a function:
	                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
	                // elides non-JSON values from objects and arrays, unless they
	                // define custom `toJSON` methods.
	                stringify([undef, getClass, null]) == "[null,null,null]" &&
	                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
	                // where character escape codes are expected (e.g., `\b` => `\u0008`).
	                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
	                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
	                stringify(null, value) === "1" &&
	                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
	                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
	                // serialize extended years.
	                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
	                // The milliseconds are optional in ES 5, but required in 5.1.
	                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
	                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
	                // four-digit years instead of six-digit years. Credits: @Yaffle.
	                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
	                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
	                // values less than 1000. Credits: @Yaffle.
	                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
	            } catch (exception) {
	              stringifySupported = false;
	            }
	          }
	          isSupported = stringifySupported;
	        }
	        // Test `JSON.parse`.
	        if (name == "json-parse") {
	          var parse = exports.parse;
	          if (typeof parse == "function") {
	            try {
	              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
	              // Conforming implementations should also coerce the initial argument to
	              // a string prior to parsing.
	              if (parse("0") === 0 && !parse(false)) {
	                // Simple parsing test.
	                value = parse(serialized);
	                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
	                if (parseSupported) {
	                  try {
	                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
	                    parseSupported = !parse('"\t"');
	                  } catch (exception) {}
	                  if (parseSupported) {
	                    try {
	                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
	                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
	                      // certain octal literals.
	                      parseSupported = parse("01") !== 1;
	                    } catch (exception) {}
	                  }
	                  if (parseSupported) {
	                    try {
	                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
	                      // points. These environments, along with FF 3.1b1 and 2,
	                      // also allow trailing commas in JSON objects and arrays.
	                      parseSupported = parse("1.") !== 1;
	                    } catch (exception) {}
	                  }
	                }
	              }
	            } catch (exception) {
	              parseSupported = false;
	            }
	          }
	          isSupported = parseSupported;
	        }
	      }
	      return has[name] = !!isSupported;
	    }

	    if (!has("json")) {
	      // Common `[[Class]]` name aliases.
	      var functionClass = "[object Function]",
	          dateClass = "[object Date]",
	          numberClass = "[object Number]",
	          stringClass = "[object String]",
	          arrayClass = "[object Array]",
	          booleanClass = "[object Boolean]";

	      // Detect incomplete support for accessing string characters by index.
	      var charIndexBuggy = has("bug-string-char-index");

	      // Define additional utility methods if the `Date` methods are buggy.
	      if (!isExtended) {
	        var floor = Math.floor;
	        // A mapping between the months of the year and the number of days between
	        // January 1st and the first of the respective month.
	        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
	        // Internal: Calculates the number of days between the Unix epoch and the
	        // first day of the given month.
	        var getDay = function (year, month) {
	          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
	        };
	      }

	      // Internal: Determines if a property is a direct property of the given
	      // object. Delegates to the native `Object#hasOwnProperty` method.
	      if (!(isProperty = objectProto.hasOwnProperty)) {
	        isProperty = function (property) {
	          var members = {}, constructor;
	          if ((members.__proto__ = null, members.__proto__ = {
	            // The *proto* property cannot be set multiple times in recent
	            // versions of Firefox and SeaMonkey.
	            "toString": 1
	          }, members).toString != getClass) {
	            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
	            // supports the mutable *proto* property.
	            isProperty = function (property) {
	              // Capture and break the object's prototype chain (see section 8.6.2
	              // of the ES 5.1 spec). The parenthesized expression prevents an
	              // unsafe transformation by the Closure Compiler.
	              var original = this.__proto__, result = property in (this.__proto__ = null, this);
	              // Restore the original prototype chain.
	              this.__proto__ = original;
	              return result;
	            };
	          } else {
	            // Capture a reference to the top-level `Object` constructor.
	            constructor = members.constructor;
	            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
	            // other environments.
	            isProperty = function (property) {
	              var parent = (this.constructor || constructor).prototype;
	              return property in this && !(property in parent && this[property] === parent[property]);
	            };
	          }
	          members = null;
	          return isProperty.call(this, property);
	        };
	      }

	      // Internal: Normalizes the `for...in` iteration algorithm across
	      // environments. Each enumerated key is yielded to a `callback` function.
	      forEach = function (object, callback) {
	        var size = 0, Properties, members, property;

	        // Tests for bugs in the current environment's `for...in` algorithm. The
	        // `valueOf` property inherits the non-enumerable flag from
	        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
	        (Properties = function () {
	          this.valueOf = 0;
	        }).prototype.valueOf = 0;

	        // Iterate over a new instance of the `Properties` class.
	        members = new Properties();
	        for (property in members) {
	          // Ignore all properties inherited from `Object.prototype`.
	          if (isProperty.call(members, property)) {
	            size++;
	          }
	        }
	        Properties = members = null;

	        // Normalize the iteration algorithm.
	        if (!size) {
	          // A list of non-enumerable properties inherited from `Object.prototype`.
	          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
	          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
	          // properties.
	          forEach = function (object, callback) {
	            var isFunction = getClass.call(object) == functionClass, property, length;
	            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
	            for (property in object) {
	              // Gecko <= 1.0 enumerates the `prototype` property of functions under
	              // certain conditions; IE does not.
	              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
	                callback(property);
	              }
	            }
	            // Manually invoke the callback for each non-enumerable property.
	            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
	          };
	        } else if (size == 2) {
	          // Safari <= 2.0.4 enumerates shadowed properties twice.
	          forEach = function (object, callback) {
	            // Create a set of iterated properties.
	            var members = {}, isFunction = getClass.call(object) == functionClass, property;
	            for (property in object) {
	              // Store each property name to prevent double enumeration. The
	              // `prototype` property of functions is not enumerated due to cross-
	              // environment inconsistencies.
	              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
	                callback(property);
	              }
	            }
	          };
	        } else {
	          // No bugs detected; use the standard `for...in` algorithm.
	          forEach = function (object, callback) {
	            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
	            for (property in object) {
	              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
	                callback(property);
	              }
	            }
	            // Manually invoke the callback for the `constructor` property due to
	            // cross-environment inconsistencies.
	            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
	              callback(property);
	            }
	          };
	        }
	        return forEach(object, callback);
	      };

	      // Public: Serializes a JavaScript `value` as a JSON string. The optional
	      // `filter` argument may specify either a function that alters how object and
	      // array members are serialized, or an array of strings and numbers that
	      // indicates which properties should be serialized. The optional `width`
	      // argument may be either a string or number that specifies the indentation
	      // level of the output.
	      if (!has("json-stringify")) {
	        // Internal: A map of control characters and their escaped equivalents.
	        var Escapes = {
	          92: "\\\\",
	          34: '\\"',
	          8: "\\b",
	          12: "\\f",
	          10: "\\n",
	          13: "\\r",
	          9: "\\t"
	        };

	        // Internal: Converts `value` into a zero-padded string such that its
	        // length is at least equal to `width`. The `width` must be <= 6.
	        var leadingZeroes = "000000";
	        var toPaddedString = function (width, value) {
	          // The `|| 0` expression is necessary to work around a bug in
	          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
	          return (leadingZeroes + (value || 0)).slice(-width);
	        };

	        // Internal: Double-quotes a string `value`, replacing all ASCII control
	        // characters (characters with code unit values between 0 and 31) with
	        // their escaped equivalents. This is an implementation of the
	        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
	        var unicodePrefix = "\\u00";
	        var quote = function (value) {
	          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
	          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
	          for (; index < length; index++) {
	            var charCode = value.charCodeAt(index);
	            // If the character is a control character, append its Unicode or
	            // shorthand escape sequence; otherwise, append the character as-is.
	            switch (charCode) {
	              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
	                result += Escapes[charCode];
	                break;
	              default:
	                if (charCode < 32) {
	                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
	                  break;
	                }
	                result += useCharIndex ? symbols[index] : value.charAt(index);
	            }
	          }
	          return result + '"';
	        };

	        // Internal: Recursively serializes an object. Implements the
	        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
	        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
	          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
	          try {
	            // Necessary for host object support.
	            value = object[property];
	          } catch (exception) {}
	          if (typeof value == "object" && value) {
	            className = getClass.call(value);
	            if (className == dateClass && !isProperty.call(value, "toJSON")) {
	              if (value > -1 / 0 && value < 1 / 0) {
	                // Dates are serialized according to the `Date#toJSON` method
	                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
	                // for the ISO 8601 date time string format.
	                if (getDay) {
	                  // Manually compute the year, month, date, hours, minutes,
	                  // seconds, and milliseconds if the `getUTC*` methods are
	                  // buggy. Adapted from @Yaffle's `date-shim` project.
	                  date = floor(value / 864e5);
	                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
	                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
	                  date = 1 + date - getDay(year, month);
	                  // The `time` value specifies the time within the day (see ES
	                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
	                  // to compute `A modulo B`, as the `%` operator does not
	                  // correspond to the `modulo` operation for negative numbers.
	                  time = (value % 864e5 + 864e5) % 864e5;
	                  // The hours, minutes, seconds, and milliseconds are obtained by
	                  // decomposing the time within the day. See section 15.9.1.10.
	                  hours = floor(time / 36e5) % 24;
	                  minutes = floor(time / 6e4) % 60;
	                  seconds = floor(time / 1e3) % 60;
	                  milliseconds = time % 1e3;
	                } else {
	                  year = value.getUTCFullYear();
	                  month = value.getUTCMonth();
	                  date = value.getUTCDate();
	                  hours = value.getUTCHours();
	                  minutes = value.getUTCMinutes();
	                  seconds = value.getUTCSeconds();
	                  milliseconds = value.getUTCMilliseconds();
	                }
	                // Serialize extended years correctly.
	                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
	                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
	                  // Months, dates, hours, minutes, and seconds should have two
	                  // digits; milliseconds should have three.
	                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
	                  // Milliseconds are optional in ES 5.0, but required in 5.1.
	                  "." + toPaddedString(3, milliseconds) + "Z";
	              } else {
	                value = null;
	              }
	            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
	              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
	              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
	              // ignores all `toJSON` methods on these objects unless they are
	              // defined directly on an instance.
	              value = value.toJSON(property);
	            }
	          }
	          if (callback) {
	            // If a replacement function was provided, call it to obtain the value
	            // for serialization.
	            value = callback.call(object, property, value);
	          }
	          if (value === null) {
	            return "null";
	          }
	          className = getClass.call(value);
	          if (className == booleanClass) {
	            // Booleans are represented literally.
	            return "" + value;
	          } else if (className == numberClass) {
	            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
	            // `"null"`.
	            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
	          } else if (className == stringClass) {
	            // Strings are double-quoted and escaped.
	            return quote("" + value);
	          }
	          // Recursively serialize objects and arrays.
	          if (typeof value == "object") {
	            // Check for cyclic structures. This is a linear search; performance
	            // is inversely proportional to the number of unique nested objects.
	            for (length = stack.length; length--;) {
	              if (stack[length] === value) {
	                // Cyclic structures cannot be serialized by `JSON.stringify`.
	                throw TypeError();
	              }
	            }
	            // Add the object to the stack of traversed objects.
	            stack.push(value);
	            results = [];
	            // Save the current indentation level and indent one additional level.
	            prefix = indentation;
	            indentation += whitespace;
	            if (className == arrayClass) {
	              // Recursively serialize array elements.
	              for (index = 0, length = value.length; index < length; index++) {
	                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
	                results.push(element === undef ? "null" : element);
	              }
	              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
	            } else {
	              // Recursively serialize object members. Members are selected from
	              // either a user-specified list of property names, or the object
	              // itself.
	              forEach(properties || value, function (property) {
	                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
	                if (element !== undef) {
	                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
	                  // is not the empty string, let `member` {quote(property) + ":"}
	                  // be the concatenation of `member` and the `space` character."
	                  // The "`space` character" refers to the literal space
	                  // character, not the `space` {width} argument provided to
	                  // `JSON.stringify`.
	                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
	                }
	              });
	              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
	            }
	            // Remove the object from the traversed object stack.
	            stack.pop();
	            return result;
	          }
	        };

	        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
	        exports.stringify = function (source, filter, width) {
	          var whitespace, callback, properties, className;
	          if (objectTypes[typeof filter] && filter) {
	            if ((className = getClass.call(filter)) == functionClass) {
	              callback = filter;
	            } else if (className == arrayClass) {
	              // Convert the property names array into a makeshift set.
	              properties = {};
	              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
	            }
	          }
	          if (width) {
	            if ((className = getClass.call(width)) == numberClass) {
	              // Convert the `width` to an integer and create a string containing
	              // `width` number of space characters.
	              if ((width -= width % 1) > 0) {
	                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
	              }
	            } else if (className == stringClass) {
	              whitespace = width.length <= 10 ? width : width.slice(0, 10);
	            }
	          }
	          // Opera <= 7.54u2 discards the values associated with empty string keys
	          // (`""`) only if they are used directly within an object member list
	          // (e.g., `!("" in { "": 1})`).
	          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
	        };
	      }

	      // Public: Parses a JSON source string.
	      if (!has("json-parse")) {
	        var fromCharCode = String.fromCharCode;

	        // Internal: A map of escaped control characters and their unescaped
	        // equivalents.
	        var Unescapes = {
	          92: "\\",
	          34: '"',
	          47: "/",
	          98: "\b",
	          116: "\t",
	          110: "\n",
	          102: "\f",
	          114: "\r"
	        };

	        // Internal: Stores the parser state.
	        var Index, Source;

	        // Internal: Resets the parser state and throws a `SyntaxError`.
	        var abort = function () {
	          Index = Source = null;
	          throw SyntaxError();
	        };

	        // Internal: Returns the next token, or `"$"` if the parser has reached
	        // the end of the source string. A token may be a string, number, `null`
	        // literal, or Boolean literal.
	        var lex = function () {
	          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
	          while (Index < length) {
	            charCode = source.charCodeAt(Index);
	            switch (charCode) {
	              case 9: case 10: case 13: case 32:
	                // Skip whitespace tokens, including tabs, carriage returns, line
	                // feeds, and space characters.
	                Index++;
	                break;
	              case 123: case 125: case 91: case 93: case 58: case 44:
	                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
	                // the current position.
	                value = charIndexBuggy ? source.charAt(Index) : source[Index];
	                Index++;
	                return value;
	              case 34:
	                // `"` delimits a JSON string; advance to the next character and
	                // begin parsing the string. String tokens are prefixed with the
	                // sentinel `@` character to distinguish them from punctuators and
	                // end-of-string tokens.
	                for (value = "@", Index++; Index < length;) {
	                  charCode = source.charCodeAt(Index);
	                  if (charCode < 32) {
	                    // Unescaped ASCII control characters (those with a code unit
	                    // less than the space character) are not permitted.
	                    abort();
	                  } else if (charCode == 92) {
	                    // A reverse solidus (`\`) marks the beginning of an escaped
	                    // control character (including `"`, `\`, and `/`) or Unicode
	                    // escape sequence.
	                    charCode = source.charCodeAt(++Index);
	                    switch (charCode) {
	                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
	                        // Revive escaped control characters.
	                        value += Unescapes[charCode];
	                        Index++;
	                        break;
	                      case 117:
	                        // `\u` marks the beginning of a Unicode escape sequence.
	                        // Advance to the first character and validate the
	                        // four-digit code point.
	                        begin = ++Index;
	                        for (position = Index + 4; Index < position; Index++) {
	                          charCode = source.charCodeAt(Index);
	                          // A valid sequence comprises four hexdigits (case-
	                          // insensitive) that form a single hexadecimal value.
	                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
	                            // Invalid Unicode escape sequence.
	                            abort();
	                          }
	                        }
	                        // Revive the escaped character.
	                        value += fromCharCode("0x" + source.slice(begin, Index));
	                        break;
	                      default:
	                        // Invalid escape sequence.
	                        abort();
	                    }
	                  } else {
	                    if (charCode == 34) {
	                      // An unescaped double-quote character marks the end of the
	                      // string.
	                      break;
	                    }
	                    charCode = source.charCodeAt(Index);
	                    begin = Index;
	                    // Optimize for the common case where a string is valid.
	                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
	                      charCode = source.charCodeAt(++Index);
	                    }
	                    // Append the string as-is.
	                    value += source.slice(begin, Index);
	                  }
	                }
	                if (source.charCodeAt(Index) == 34) {
	                  // Advance to the next character and return the revived string.
	                  Index++;
	                  return value;
	                }
	                // Unterminated string.
	                abort();
	              default:
	                // Parse numbers and literals.
	                begin = Index;
	                // Advance past the negative sign, if one is specified.
	                if (charCode == 45) {
	                  isSigned = true;
	                  charCode = source.charCodeAt(++Index);
	                }
	                // Parse an integer or floating-point value.
	                if (charCode >= 48 && charCode <= 57) {
	                  // Leading zeroes are interpreted as octal literals.
	                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
	                    // Illegal octal literal.
	                    abort();
	                  }
	                  isSigned = false;
	                  // Parse the integer component.
	                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
	                  // Floats cannot contain a leading decimal point; however, this
	                  // case is already accounted for by the parser.
	                  if (source.charCodeAt(Index) == 46) {
	                    position = ++Index;
	                    // Parse the decimal component.
	                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
	                    if (position == Index) {
	                      // Illegal trailing decimal.
	                      abort();
	                    }
	                    Index = position;
	                  }
	                  // Parse exponents. The `e` denoting the exponent is
	                  // case-insensitive.
	                  charCode = source.charCodeAt(Index);
	                  if (charCode == 101 || charCode == 69) {
	                    charCode = source.charCodeAt(++Index);
	                    // Skip past the sign following the exponent, if one is
	                    // specified.
	                    if (charCode == 43 || charCode == 45) {
	                      Index++;
	                    }
	                    // Parse the exponential component.
	                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
	                    if (position == Index) {
	                      // Illegal empty exponent.
	                      abort();
	                    }
	                    Index = position;
	                  }
	                  // Coerce the parsed value to a JavaScript number.
	                  return +source.slice(begin, Index);
	                }
	                // A negative sign may only precede numbers.
	                if (isSigned) {
	                  abort();
	                }
	                // `true`, `false`, and `null` literals.
	                if (source.slice(Index, Index + 4) == "true") {
	                  Index += 4;
	                  return true;
	                } else if (source.slice(Index, Index + 5) == "false") {
	                  Index += 5;
	                  return false;
	                } else if (source.slice(Index, Index + 4) == "null") {
	                  Index += 4;
	                  return null;
	                }
	                // Unrecognized token.
	                abort();
	            }
	          }
	          // Return the sentinel `$` character if the parser has reached the end
	          // of the source string.
	          return "$";
	        };

	        // Internal: Parses a JSON `value` token.
	        var get = function (value) {
	          var results, hasMembers;
	          if (value == "$") {
	            // Unexpected end of input.
	            abort();
	          }
	          if (typeof value == "string") {
	            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
	              // Remove the sentinel `@` character.
	              return value.slice(1);
	            }
	            // Parse object and array literals.
	            if (value == "[") {
	              // Parses a JSON array, returning a new JavaScript array.
	              results = [];
	              for (;; hasMembers || (hasMembers = true)) {
	                value = lex();
	                // A closing square bracket marks the end of the array literal.
	                if (value == "]") {
	                  break;
	                }
	                // If the array literal contains elements, the current token
	                // should be a comma separating the previous element from the
	                // next.
	                if (hasMembers) {
	                  if (value == ",") {
	                    value = lex();
	                    if (value == "]") {
	                      // Unexpected trailing `,` in array literal.
	                      abort();
	                    }
	                  } else {
	                    // A `,` must separate each array element.
	                    abort();
	                  }
	                }
	                // Elisions and leading commas are not permitted.
	                if (value == ",") {
	                  abort();
	                }
	                results.push(get(value));
	              }
	              return results;
	            } else if (value == "{") {
	              // Parses a JSON object, returning a new JavaScript object.
	              results = {};
	              for (;; hasMembers || (hasMembers = true)) {
	                value = lex();
	                // A closing curly brace marks the end of the object literal.
	                if (value == "}") {
	                  break;
	                }
	                // If the object literal contains members, the current token
	                // should be a comma separator.
	                if (hasMembers) {
	                  if (value == ",") {
	                    value = lex();
	                    if (value == "}") {
	                      // Unexpected trailing `,` in object literal.
	                      abort();
	                    }
	                  } else {
	                    // A `,` must separate each object member.
	                    abort();
	                  }
	                }
	                // Leading commas are not permitted, object property names must be
	                // double-quoted strings, and a `:` must separate each property
	                // name and value.
	                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
	                  abort();
	                }
	                results[value.slice(1)] = get(lex());
	              }
	              return results;
	            }
	            // Unexpected token encountered.
	            abort();
	          }
	          return value;
	        };

	        // Internal: Updates a traversed object member.
	        var update = function (source, property, callback) {
	          var element = walk(source, property, callback);
	          if (element === undef) {
	            delete source[property];
	          } else {
	            source[property] = element;
	          }
	        };

	        // Internal: Recursively traverses a parsed JSON object, invoking the
	        // `callback` function for each value. This is an implementation of the
	        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
	        var walk = function (source, property, callback) {
	          var value = source[property], length;
	          if (typeof value == "object" && value) {
	            // `forEach` can't be used to traverse an array in Opera <= 8.54
	            // because its `Object#hasOwnProperty` implementation returns `false`
	            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
	            if (getClass.call(value) == arrayClass) {
	              for (length = value.length; length--;) {
	                update(value, length, callback);
	              }
	            } else {
	              forEach(value, function (property) {
	                update(value, property, callback);
	              });
	            }
	          }
	          return callback.call(source, property, value);
	        };

	        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
	        exports.parse = function (source, callback) {
	          var result, value;
	          Index = 0;
	          Source = "" + source;
	          result = get(lex());
	          // If a JSON string contains multiple tokens, it is invalid.
	          if (lex() != "$") {
	            abort();
	          }
	          // Reset the parser state.
	          Index = Source = null;
	          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
	        };
	      }
	    }

	    exports["runInContext"] = runInContext;
	    return exports;
	  }

	  if (freeExports && !isLoader) {
	    // Export for CommonJS environments.
	    runInContext(root, freeExports);
	  } else {
	    // Export for web browsers and JavaScript engines.
	    var nativeJSON = root.JSON,
	        previousJSON = root["JSON3"],
	        isRestored = false;

	    var JSON3 = runInContext(root, (root["JSON3"] = {
	      // Public: Restores the original value of the global `JSON` object and
	      // returns a reference to the `JSON3` object.
	      "noConflict": function () {
	        if (!isRestored) {
	          isRestored = true;
	          root.JSON = nativeJSON;
	          root["JSON3"] = previousJSON;
	          nativeJSON = previousJSON = null;
	        }
	        return JSON3;
	      }
	    }));

	    root.JSON = {
	      "parse": JSON3.parse,
	      "stringify": JSON3.stringify
	    };
	  }

	  // Export for asynchronous module loaders.
	  if (isLoader) {
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	      return JSON3;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	}).call(this);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(19)(module), __webpack_require__(2)))

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	'use strict';
	var ansiRegex = __webpack_require__(103)();

	module.exports = function (str) {
		return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
	};


/***/ },
/* 203 */
/***/ function(module, exports) {

	module.exports = toArray

	function toArray(list, index) {
	    var array = []

	    index = index || 0

	    for (var i = index || 0; i < list.length; i++) {
	        array[i - index] = list[i]
	    }

	    return array
	}


/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/utf8js v2.0.0 by @mathias */
	;(function(root) {

		// Detect free variables `exports`
		var freeExports = typeof exports == 'object' && exports;

		// Detect free variable `module`
		var freeModule = typeof module == 'object' && module &&
			module.exports == freeExports && module;

		// Detect free variable `global`, from Node.js or Browserified code,
		// and use it as `root`
		var freeGlobal = typeof global == 'object' && global;
		if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
			root = freeGlobal;
		}

		/*--------------------------------------------------------------------------*/

		var stringFromCharCode = String.fromCharCode;

		// Taken from https://mths.be/punycode
		function ucs2decode(string) {
			var output = [];
			var counter = 0;
			var length = string.length;
			var value;
			var extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}

		// Taken from https://mths.be/punycode
		function ucs2encode(array) {
			var length = array.length;
			var index = -1;
			var value;
			var output = '';
			while (++index < length) {
				value = array[index];
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
			}
			return output;
		}

		function checkScalarValue(codePoint) {
			if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
				throw Error(
					'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
					' is not a scalar value'
				);
			}
		}
		/*--------------------------------------------------------------------------*/

		function createByte(codePoint, shift) {
			return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
		}

		function encodeCodePoint(codePoint) {
			if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
				return stringFromCharCode(codePoint);
			}
			var symbol = '';
			if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
				symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
			}
			else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
				checkScalarValue(codePoint);
				symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
				symbol += createByte(codePoint, 6);
			}
			else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
				symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
				symbol += createByte(codePoint, 12);
				symbol += createByte(codePoint, 6);
			}
			symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
			return symbol;
		}

		function utf8encode(string) {
			var codePoints = ucs2decode(string);
			var length = codePoints.length;
			var index = -1;
			var codePoint;
			var byteString = '';
			while (++index < length) {
				codePoint = codePoints[index];
				byteString += encodeCodePoint(codePoint);
			}
			return byteString;
		}

		/*--------------------------------------------------------------------------*/

		function readContinuationByte() {
			if (byteIndex >= byteCount) {
				throw Error('Invalid byte index');
			}

			var continuationByte = byteArray[byteIndex] & 0xFF;
			byteIndex++;

			if ((continuationByte & 0xC0) == 0x80) {
				return continuationByte & 0x3F;
			}

			// If we end up here, it’s not a continuation byte
			throw Error('Invalid continuation byte');
		}

		function decodeSymbol() {
			var byte1;
			var byte2;
			var byte3;
			var byte4;
			var codePoint;

			if (byteIndex > byteCount) {
				throw Error('Invalid byte index');
			}

			if (byteIndex == byteCount) {
				return false;
			}

			// Read first byte
			byte1 = byteArray[byteIndex] & 0xFF;
			byteIndex++;

			// 1-byte sequence (no continuation bytes)
			if ((byte1 & 0x80) == 0) {
				return byte1;
			}

			// 2-byte sequence
			if ((byte1 & 0xE0) == 0xC0) {
				var byte2 = readContinuationByte();
				codePoint = ((byte1 & 0x1F) << 6) | byte2;
				if (codePoint >= 0x80) {
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}

			// 3-byte sequence (may include unpaired surrogates)
			if ((byte1 & 0xF0) == 0xE0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
				if (codePoint >= 0x0800) {
					checkScalarValue(codePoint);
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}

			// 4-byte sequence
			if ((byte1 & 0xF8) == 0xF0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				byte4 = readContinuationByte();
				codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |
					(byte3 << 0x06) | byte4;
				if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
					return codePoint;
				}
			}

			throw Error('Invalid UTF-8 detected');
		}

		var byteArray;
		var byteCount;
		var byteIndex;
		function utf8decode(byteString) {
			byteArray = ucs2decode(byteString);
			byteCount = byteArray.length;
			byteIndex = 0;
			var codePoints = [];
			var tmp;
			while ((tmp = decodeSymbol()) !== false) {
				codePoints.push(tmp);
			}
			return ucs2encode(codePoints);
		}

		/*--------------------------------------------------------------------------*/

		var utf8 = {
			'version': '2.0.0',
			'encode': utf8encode,
			'decode': utf8decode
		};

		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return utf8;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}	else if (freeExports && !freeExports.nodeType) {
			if (freeModule) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = utf8;
			} else { // in Narwhal or RingoJS v0.7.0-
				var object = {};
				var hasOwnProperty = object.hasOwnProperty;
				for (var key in utf8) {
					hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.utf8 = utf8;
		}

	}(this));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(19)(module), __webpack_require__(2)))

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	/*eslint-env browser*/

	var clientOverlay = document.createElement('div');
	var styles = {
	  display: 'none',
	  background: 'rgba(0,0,0,0.85)',
	  color: '#E8E8E8',
	  lineHeight: '1.2',
	  whiteSpace: 'pre',
	  fontFamily: 'Menlo, Consolas, monospace',
	  fontSize: '13px',
	  position: 'fixed',
	  zIndex: 9999,
	  padding: '10px',
	  left: 0,
	  right: 0,
	  top: 0,
	  bottom: 0,
	  overflow: 'auto'
	};
	for (var key in styles) {
	  clientOverlay.style[key] = styles[key];
	}

	if (document.body) {
	  document.body.appendChild(clientOverlay);
	}

	var ansiHTML = __webpack_require__(102);
	var colors = {
	  reset: ['transparent', 'transparent'],
	  black: '181818',
	  red: 'E36049',
	  green: 'B3CB74',
	  yellow: 'FFD080',
	  blue: '7CAFC2',
	  magenta: '7FACCA',
	  cyan: 'C3C2EF',
	  lightgrey: 'EBE7E3',
	  darkgrey: '6D7891'
	};
	ansiHTML.setColors(colors);

	var Entities = __webpack_require__(122).AllHtmlEntities;
	var entities = new Entities();

	exports.showProblems =
	function showProblems(type, lines) {
	  clientOverlay.innerHTML = '';
	  clientOverlay.style.display = 'block';
	  lines.forEach(function(msg) {
	    msg = ansiHTML(entities.encode(msg));
	    var div = document.createElement('div');
	    div.style.marginBottom = '26px';
	    div.innerHTML = problemType(type) + ' in ' + msg;
	    clientOverlay.appendChild(div);
	  });
	};

	exports.clear =
	function clear() {
	  clientOverlay.innerHTML = '';
	  clientOverlay.style.display = 'none';
	};

	var problemColors = {
	  errors: colors.red,
	  warnings: colors.yellow
	};

	function problemType (type) {
	  var color = problemColors[type] || colors.red;
	  return (
	    '<span style="background-color:#' + color + '; color:#fff; padding:2px 4px; border-radius: 2px">' +
	      type.slice(0, -1).toUpperCase() +
	    '</span>'
	  );
	}


/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Based heavily on https://github.com/webpack/webpack/blob/
	 *  c0afdf9c6abc1dd70707c594e473802a566f7b6e/hot/only-dev-server.js
	 * Original copyright Tobias Koppers @sokra (MIT license)
	 */

	/* global window __webpack_hash__ */

	if (false) {
	  throw new Error("[HMR] Hot Module Replacement is disabled.");
	}

	var hmrDocsUrl = "http://webpack.github.io/docs/hot-module-replacement-with-webpack.html"; // eslint-disable-line max-len

	var lastHash;
	var failureStatuses = { abort: 1, fail: 1 };
	var applyOptions = { ignoreUnaccepted: true };

	function upToDate(hash) {
	  if (hash) lastHash = hash;
	  return lastHash == __webpack_require__.h();
	}

	module.exports = function(hash, moduleMap, options) {
	  var reload = options.reload;
	  if (!upToDate(hash) && module.hot.status() == "idle") {
	    if (options.log) console.log("[HMR] Checking for updates on the server...");
	    check();
	  }

	  function check() {
	    module.hot.check(function(err, updatedModules) {
	      if (err) return handleError(err);

	      if(!updatedModules) {
	        if (options.warn) {
	          console.warn("[HMR] Cannot find update (Full reload needed)");
	          console.warn("[HMR] (Probably because of restarting the server)");
	        }
	        performReload();
	        return null;
	      }

	      module.hot.apply(applyOptions, function(applyErr, renewedModules) {
	        if (applyErr) return handleError(applyErr);

	        if (!upToDate()) check();

	        logUpdates(updatedModules, renewedModules);
	      });
	    });
	  }

	  function logUpdates(updatedModules, renewedModules) {
	    var unacceptedModules = updatedModules.filter(function(moduleId) {
	      return renewedModules && renewedModules.indexOf(moduleId) < 0;
	    });

	    if(unacceptedModules.length > 0) {
	      if (options.warn) {
	        console.warn(
	          "[HMR] The following modules couldn't be hot updated: " +
	          "(Full reload needed)\n" +
	          "This is usually because the modules which have changed " +
	          "(and their parents) do not know how to hot reload themselves. " +
	          "See " + hmrDocsUrl + " for more details."
	        );
	        unacceptedModules.forEach(function(moduleId) {
	          console.warn("[HMR]  - " + moduleMap[moduleId]);
	        });
	      }
	      performReload();
	      return;
	    }

	    if (options.log) {
	      if(!renewedModules || renewedModules.length === 0) {
	        console.log("[HMR] Nothing hot updated.");
	      } else {
	        console.log("[HMR] Updated modules:");
	        renewedModules.forEach(function(moduleId) {
	          console.log("[HMR]  - " + moduleMap[moduleId]);
	        });
	      }

	      if (upToDate()) {
	        console.log("[HMR] App is up to date.");
	      }
	    }
	  }

	  function handleError(err) {
	    if (module.hot.status() in failureStatuses) {
	      if (options.warn) {
	        console.warn("[HMR] Cannot check for update (Full reload needed)");
	        console.warn("[HMR] " + err.stack || err.message);
	      }
	      performReload();
	      return;
	    }
	    if (options.warn) {
	      console.warn("[HMR] Update check failed: " + err.stack || err.message);
	    }
	  }

	  function performReload() {
	    if (reload) {
	      if (options.warn) console.warn("[HMR] Reloading page");
	      window.location.reload();
	    }
	  }
	};


/***/ },
/* 207 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;

	/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	var EventEmitter = __webpack_require__(117);
	module.exports = new EventEmitter();


/***/ },
/* 209 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	module.exports = function(updatedModules, renewedModules) {
		var unacceptedModules = updatedModules.filter(function(moduleId) {
			return renewedModules && renewedModules.indexOf(moduleId) < 0;
		});

		if(unacceptedModules.length > 0) {
			console.warn("[HMR] The following modules couldn't be hot updated: (They would need a full reload!)");
			unacceptedModules.forEach(function(moduleId) {
				console.warn("[HMR]  - " + moduleId);
			});
		}

		if(!renewedModules || renewedModules.length === 0) {
			console.log("[HMR] Nothing hot updated.");
		} else {
			console.log("[HMR] Updated modules:");
			renewedModules.forEach(function(moduleId) {
				console.log("[HMR]  - " + moduleId);
			});
		}
	};


/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	var on = __webpack_require__(1);

	var serverReq = function (socket, onReq, reqPrefix, resPrefix) {

	    var requestTimes = {};

	    reqPrefix = typeof reqPrefix !== "string" ? "req." : reqPrefix + ".";

	    resPrefix = typeof resPrefix !== "string" ? "res." : resPrefix + ".";

	    function req(name, reqHandler) {

	        socket.on(reqPrefix + name, function (request) {

	            if (!request.doNotForceLastRequest && requestTimes[name] > request.timestamp) {

	                if (typeof onReq === "function") {

	                    request.rejected = true;

	                    onReq(request);
	                }

	                return;
	            }

	            requestTimes[name] = request.timestamp;

	            if (typeof onReq === "function") {

	                onReq(request);
	            }

	            reqHandler(request, function (data, broadcast) {

	                if (broadcast === true) {

	                    socket.broadcast.emit(resPrefix + name, data);

	                } else if (typeof broadcast === "string") {

	                    socket.broadcast.to(broadcast).emit(resPrefix + name, data);

	                } else {

	                    socket.emit(resPrefix + name + (request.doNotForceLastRequest ? "" : request.timestamp), data);
	                }
	            });
	        });

	        return {
	            cancelReq: function () {

	                socket.removeAllListeners(resPrefix + name);
	            },

	            reqName: reqPrefix + name
	        };
	    }

	    req.socket = socket;

	    req.removeListener = function (reqName, reqHandler) {

	        socket.removeListener(reqName, reqHandler);
	    };

	    req.removeAllListeners = function (reqName) {

	        socket.removeListener(reqName);
	    };

	    return req;
	};

	var clientReq = function (socket, onRes, reqPrefix, resPrefix) {

	    var requestTimes = {};

	    reqPrefix = typeof reqPrefix !== "string" ? "req." : reqPrefix + ".";

	    resPrefix = typeof resPrefix !== "string" ? "res." : resPrefix + ".";

	    function req(name, params, sendOnly, doNotForceLastRequest) {

	        var timestamp = Date.now();

	        requestTimes[name] = timestamp;

	        var request = {
	            params: params || {},
	            name: name,
	            hostname: window.location.hostname,
	            timestamp: timestamp,
	            doNotForceLastRequest: doNotForceLastRequest
	        },

	            promise = {},

	            promiseReject = function () {};

	        if (!sendOnly) {

	            promise = new Promise(function (resolve, reject) {

	                promiseReject = reject;

	                socket.once(resPrefix + name + (doNotForceLastRequest ? "" : timestamp), function (response) {

	                    if (timestamp !== requestTimes[name]) {

	                        if (typeof onRes === "function") {

	                            response.rejected = true;

	                            onRes(response);
	                        }

	                        return;
	                    }

	                    if (typeof onRes === "function") {

	                        onRes(response);
	                    }

	                    if (response.error) {

	                        return reject(response);
	                    }

	                    resolve(response);
	                });
	            });
	        }

	        promise.reqName = resPrefix + name + (doNotForceLastRequest ? "" : timestamp);

	        promise.cancelReq = function (rejectPromise) {

	            socket.removeAllListeners(resPrefix + name + (doNotForceLastRequest ? "" : timestamp));

	            if (rejectPromise) {

	                promiseReject({ canceled: true });
	            }
	        };

	        socket.emit(reqPrefix + name, request);

	        return promise;
	    }

	    req.socket = socket;

	    req.removeListener = function (reqName, reqHandler) {

	        socket.removeListener(reqName, reqHandler);
	    };

	    req.removeAllListeners = function (reqName) {

	        socket.removeListener(reqName);
	    };

	    return req;
	};

	module.exports = on.server ? serverReq : clientReq;


/***/ },
/* 211 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true, node: true*/
	/*global ractiveData*/

	var Ractive = __webpack_require__(0);
	var config = __webpack_require__(98);
	var on = __webpack_require__(1);

	var ractive = function (settings) {

	    Ractive.EDIT_MODE = !settings.data.page || settings.data.page.editMode;

	    return new Ractive({

	        enhance: true,

	        el: settings.el,

	        template: __webpack_require__(216),

	        components: {
	            Page: __webpack_require__(89),
	            Admin: __webpack_require__(214),
	            Dialog: __webpack_require__(92)
	        },

	        partials: {

	        },

	        events: settings.events,

	        transitions: settings.transitions,

	        data: settings.data,

	        onconfig: function () {
	        },

	        onrender: function () {
	        }

	    });

	};

	if (on.client) {

	    ractive = __webpack_require__(91)(ractive, ractiveData, config);

	    ractiveData = null;
	}

	module.exports = ractive;



/***/ },
/* 213 */,
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
	var Ractive = __webpack_require__(0);

	module.exports = Ractive.extend({

	    template: __webpack_require__(215),

	    data: function () {

	        return {
	            selectedPage: null,
	            editPage: null
	        };

	    },

	    onrender: function () {

	        this.observe("selectedPage", function (page) {

	            if (!page || page._id === this.get("pageId")) {

	                return;
	            }

	            this.loadPage(page._id);

	        }, {init: false});
	    },

	    oncomplete: function () {
	        this.observe("editPage", function (state) {

	            state && console.time("pageLoaded");
	        }, {init: false})
	    },

	    loadPage: function (pageId) {

	        var pageReq = this.req("page", { _id: pageId });

	        pageReq.then(function (page) {

	            this.set("pageId", page._id);

	        }.bind(this));
	    }
	});


/***/ },
/* 215 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":7,"e":"div","f":[{"t":7,"e":"h1","f":["Admin: ",{"t":2,"r":"user"}]}," ",{"t":7,"e":"p","f":[{"t":7,"e":"a","a":{"href":"/users/logout"},"f":["odhlásit se"]}]}," ",{"t":4,"f":[{"t":7,"e":"button","a":{"style":[{"t":4,"f":["background: red; border: 1px solid;"],"n":50,"x":{"r":["selectedPage._id","./_id"],"s":"_0===_1"}}]},"v":{"tap":{"m":"set","a":{"r":["."],"s":"[\"selectedPage\",_0]"}}},"f":[{"t":2,"r":"./name"}]}],"n":52,"r":"pages"}," ",{"t":4,"f":[{"t":7,"e":"br"}," ",{"t":7,"e":"button","v":{"tap":{"m":"set","a":{"r":[],"s":"[\"selectedPage\",null]"}}},"f":["Zrušit výběr"]}," ",{"t":7,"e":"button","v":{"tap":{"m":"set","a":{"r":[".selectedPage._id"],"s":"[\"editPage\",_0]"}}},"f":["Upravit: ",{"t":2,"r":".pageId"}]}],"n":50,"r":".selectedPage"}]}," ",{"t":4,"f":[{"t":7,"e":"div","a":{"id":"pageWrapper","style":"position:relative;z-index: 2000;"},"f":[{"t":7,"e":"div","t0":"fade","a":{"style":"background:white;"},"f":[{"t":7,"e":"Page","a":{"editMode":"true","isAdmin":"true","pageId":[{"t":2,"r":".editPage"}]}}]}]}],"n":50,"r":".editPage"}],"e":{}};

/***/ },
/* 216 */
/***/ function(module, exports) {

	module.exports={"v":3,"t":[{"t":7,"e":"Admin"}," ",{"t":7,"e":"Dialog"}]};

/***/ },
/* 217 */,
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(57);
	__webpack_require__(212);
	__webpack_require__(56);
	module.exports = __webpack_require__(55);


/***/ }
/******/ ]);
