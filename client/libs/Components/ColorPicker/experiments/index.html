<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <style>

        * {
            box-sizing: border-box;
        }

        .wrapper {
            width: 240px;
        }

    </style>

    <link rel="stylesheet" href="styles.css">

</head>
<body>

    <div id="app"></div>

    <script id="App" type="text/html">

        <ColorPicker output="{{.bg}}" >
            <ColorPickerPalette title="RGB" colors="['red', '#0f0', 'blue']" />
            <ColorPickerPalette title="CMYK" colors="['rgb(0, 255, 255)', 'rgb(255, 0, 255)', 'rgb(255, 255, 0)', 'rgb(0, 0, 0)']" />
            <ColorPickerPalette title="Obrázek" image="img21.jpg" />
        </ColorPicker>

        <div class="wrapper">
<!--            <ColorPicker defer="true" on-output="changeColor:{{.switchToBorder ? 'border' : 'color'}}" input="{{#if .switchToBorder}}{{#if .border !== undefined}}[[.border]]{{else}}rgb(250, 35, 0){{/if}}{{else}}{{#if .color !== undefined}}[[.color]]{{else}}rgb(12, 35, 90){{/if}}{{/if}}" vertical="true">-->
            <ColorPicker output="{{.color}}" input="[[#if .color]][[.color]][[else]]rgb(12, 35, 90)[[/if]]" vertical="true">
                <ColorPickerPalette title="Barvy" colors="['rgb(255, 0, 0)', 'rgb(0, 255, 0)', 'rgb(0, 0, 255)']" />
                <ColorPickerPalette title="Obrázek" image="img21.jpg" />
            </ColorPicker>
        </div>

        <div class="selected" style="display: inline-block; margin-top: 24px; height: 50px; background: {{.bg}}; border: 1px solid {{.border}};">
            <h1 style="margin: 0; line-height: 50px; color: {{.color}}">Text Text Text</h1>
            <img style="width: 100%; float: left" src="img21.jpg" alt="">
        </div>

    </script>

    <script id="ColorPicker" type="text/html">

        <div class="ColorPicker {{#if vertical}}ColorPicker__vertical{{/if}}">

            <div class="ColorPicker--widget-wrapper">

                <div class="ColorPicker--HSV-wrapper">

                    <div on-mousedown-touchstart="activateSelector(event, 'SV')" class="ColorPicker--SV-box" style="background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), #000), linear-gradient(to right, #fff, {{.SVBoxHue}});">
                        <div on-mousedown-touchstart="activateSelector(event, 'SV')" style="transform: translate({{SVSelector.x}}px, {{SVSelector.y}}px); transition: {{.animate ? '' : 'none'}}" class="ColorPicker--SV-selector"></div>
                    </div>

                    <div on-mousedown-touchstart="activateSelector(event, 'H')" class="ColorPicker--H-box">
                        <div on-mousedown-touchstart="activateSelector(event, 'H')" style="transform: translateY({{HSelector.y}}px); transition: {{.animate ? '' : 'none'}}" class="ColorPicker--H-selector"></div>
                    </div>

                </div>

                <div class="ColorPicker--input">

                    <div class="ColorPicker--input-wrapper-1">
                        <div class="ColorPicker--input-wrapper-2">

                            <div class="ColorPicker--type-selector-wrapper">

                                <select class="ColorPicker--type-selector" value="{{.inputType}}">
                                    <option value="RGB">RGB</option>
                                    <option value="HEX">HEX</option>
                                </select>

                            </div>

                            <div class="ColorPicker--input-text-wrapper">

                                {{#if .inputType === "HEX"}}
                                    <input placeholder="RRGGBB" class="ColorPicker--input-text ColorPicker--input-text__hex" type="text" on-keyup="inputTextHEXChanged(event)" value="{{.inputTextHEX}}">
                                {{else}}
                                    <input placeholder="R" title="Červená [0–255]" class="ColorPicker--input-text ColorPicker--input-text-rgb" type="text" on-keyup="inputTextRGBChanged(event)" value="{{.inputTextR}}">
                                    <input placeholder="G" title="Zelená [0–255]" class="ColorPicker--input-text ColorPicker--input-text-rgb" type="text" on-keyup="inputTextRGBChanged(event)" value="{{.inputTextG}}">
                                    <input placeholder="B" title="Modrá [0–255]" class="ColorPicker--input-text ColorPicker--input-text-rgb" type="text" on-keyup="inputTextRGBChanged(event)" value="{{.inputTextB}}">
                                {{/if}}

                            </div>

                        </div>
                    </div>

                </div>
            </div>

            <div class="ColorPicker--palettes">

                <ColorPickerPalette title="Vybraná / Původní" colors="[{{current}}, {{initial}}]" />

                {{> content}}

            </div>

        </div>

    </script>

    <script id="ColorPickerPalette" type="text/html">

        {{#if .colors && .colors.length}}

        <div intro="fade" class="ColorPickerPalette ColorPickerPalette">

            <h6 class="ColorPickerPalette--title">{{.title}}</h6>

            <div class="ColorPickerPalette--colors">
            {{#each .colors}}
                <div intro="fade" style="background-color: {{this}}; transition: {{animate ? '' : 'none'}}" on-click-touchend="setColor:{{this}},{{true}}" class="ColorPickerPalette--color"></div>
            {{/each}}
            </div>
        </div>

        {{/if}}

    </script>

    <script src="../../../U.js"></script>
    <script src="http://code.jquery.com/jquery-1.12.1.min.js"></script>
    <script src="hammer.min.js"></script>
    <script src="http://cdn.ractivejs.org/edge/ractive.min.js"></script>
    <script src="ractive-touch.js"></script>
    <script src="spectra.js"></script>
    <script src="VibrantForWorker.js"></script>
    <script src="ractive-transitions-fade.umd.js"></script>
    <script>/*jslint indent: 4, white: true, nomen: true, regexp: true, unparam: true, node: true, browser: true, devel: true, nomen: true, plusplus: true, regexp: true, sloppy: true, vars: true*/
    /*global Ractive, Spectra, $, U, Vibrant*/

        window.Promise = window.Promise || Ractive.Promise;

        var ColorPickerPalette = Ractive.extend({
            template: "#ColorPickerPalette",

            onconfig: function () {

                if (this.get("image")) {

                    setTimeout(function() {

                        this.getPaletteFromImage();

                    }.bind(this), 0);
                }
            },

            getPaletteFromImage: function () {

                this.image = new Image();

                this.image.onload = function (e) {
                    var id = Math.round(Math.random() * 100);
                    var img = e.target;
                    console.time("1: " + id);

                    var vibrant = new Vibrant(e.target, 32, 7);

                    vibrant.then(function (vibrant) {

                        var palette = vibrant.swatches(),

                            rgbs = [];

                        $.each(palette, function (i, color) {

                            if (color) {

                                color.rgb[0] = Math.round(color.rgb[0]);
                                color.rgb[1] = Math.round(color.rgb[1]);
                                color.rgb[2] = Math.round(color.rgb[2]);

                                var rgbString = "rgb(" + color.rgb.join(",") + ")";

                                if (!~rgbs.indexOf(rgbString)) {

                                    rgbs.push(rgbString);
                                }
                            }
                        });

                        if (rgbs.length < 5) {
                            console.time("2: " + id);

                            var vibrant2 = new Vibrant(img, 5, 10, true);

                            vibrant2.then(function (colors) {

                                var rgbs2 = [];

                                $.each(colors, function (i, color) {

                                    if (color) {

                                        color[0] = Math.round(color[0]);
                                        color[1] = Math.round(color[1]);
                                        color[2] = Math.round(color[2]);

                                        var rgbString = "rgb(" + color.join(",") + ")";

                                        if (!~rgbs2.indexOf(rgbString)) {

                                            rgbs2.push(rgbString);
                                        }
                                    }
                                });

                                var similarity = {};

                                $.each(rgbs2, function (i, color) {

                                    var spectra = Spectra(color);

                                    similarity[color] = 0;

                                    $.each(rgbs, function (i, color2) {

                                        var spectra2 = Spectra(color2);

                                        if (spectra.near(spectra2, 10)) {

                                            similarity[color] += 3;

                                        } else if (spectra.near(spectra2, 20)) {

                                            similarity[color] += 2;

                                        } else if (spectra.near(spectra2, 30)) {

                                            similarity[color] += 1;
                                        }

                                    });

                                });

                                var sorted = Object.keys(similarity).sort(function (a, b) {
                                    return similarity[b] - similarity[a]
                                }).reverse();

                                var cut = sorted.splice(0, 5 - rgbs.length);

                                this.merge("colors", this.get("colors").concat(cut));

                                console.timeEnd("2: " + id);
                                console.timeEnd("1: " + id);
                                console.log(cut.length);

                            }.bind(this));

                        } else {
                            console.timeEnd("1: " + id);
                        }

                        this.set("colors", rgbs);

                    }.bind(this));

                }.bind(this);

                this.image.src = this.get("image");
            }
        });

        var ColorPicker = Ractive.extend({

            template: "#ColorPicker",

            components: {
                ColorPickerPalette: ColorPickerPalette
            },

            computed: {
                SVBoxHue: function () {

                    return this.HBoxColor.hue(this.get("hue") || 0).rgbaString();
                },
                current: function () {

                    return this.currentColor.rgbaString();
                }
            },

            data: function () {

                return {
                    initial: "rgb(255, 255, 255)",

                    SVSelector: {
                        x: 0,
                        y: 0
                    },

                    HSelector: {
                        y: 0
                    },

                    animate: false,

                    inputType: "HEX",
                    inputTextHEX: "",
                    inputTextR: "",
                    inputTextG: "",
                    inputTextB: ""
                };
            },

            onconstruct: function () {

                ColorPicker.instanceCounter = !ColorPicker.instanceCounter ? 1 : ++ColorPicker.instanceCounter;

                this.EVENT_NS = "ColorPicker-" + ColorPicker.instanceCounter;

                this.$win = $(window);
            },

            initializeColors: function () {

                var input = this.get("input");

                input = input || this.get("output");

                if (input) {

                    this.set("initial", input);
                }

                var current = input || this.get("initial");

                this.currentColor = Spectra(current);
                //slouží pro získání barvy gradientu v SVBoxu
                this.HBoxColor = Spectra({ h: 0, s: 1, v: 1 });

                //počáteční hodnoty barvy
                this.skipUdateCurrent = true;
                this.set("hue", this.currentColor.hue());
                this.set("saturation", this.currentColor.saturationv());
                this.skipUdateCurrent = false;
                this.set("value", this.currentColor.value());
            },

            onconfig: function () {

                this.waitForUserInteraction = !!this.get("defer");

                this.initializeColors();

                this.observe("hue", function (hue) {

                    if (this.skipHueObserver) {

                        return;
                    }

                    this.currentColor.hue(hue);

                    this.update("current");

                }, {init: false});

                this.observe("saturation", function (saturation) {

                    this.currentColor.saturationv(saturation);

                    this.preserveHue = true;

                    this.update("current");

                    this.preserveHue = false;

                }, {init: false});

                this.observe("value", function (value) {

                    this.currentColor.value(value);

                    this.preserveHue = true;

                    this.update("current");

                    this.preserveHue = false;

                }, {init: false});

                this.observe("current", function (color) {

                    if (this.skipUpdateCurrent)  {

                        return;
                    }

                    //pokud se saturace změní na 0, pak si barva nezachová odstín
                    if (!this.preserveHue) {

                        this.skipHueObserver = this.skipUpdateColor;

                        this.set("hue", this.currentColor.hue());

                        this.skipHueObserver = false;
                    }

                    //pokud si barva nezachovala odstín je potřeba ho vrátit, jakmile barva získá saturaci
                    if (this.currentColor.hue() !== this.get("hue") && this.currentColor.saturationv()) {

                        this.currentColor.hue(this.get("hue"));
                    }

                    if (!this.waitForUserInteraction) {

                        this.set("output", this.getCurrentRGB());
                        this.fire("output", this.getCurrentRGB());
                    }

                    this.set("inputTextHEX", this.currentColor.hex());
                    this.set("inputTextR",   this.currentColor.red());
                    this.set("inputTextG",   this.currentColor.green());
                    this.set("inputTextB",   this.currentColor.blue());

                }, {init: false});

                this.observe("HSelector.y", function () {

                    if (!this.skipUpdateColor) {

                        this.updateHue.apply(this, arguments);
                    }
                }, {init: false});

                this.observe("SVSelector.x", function () {

                    if (!this.skipUpdateColor) {

                        this.updateSaturation.apply(this, arguments);
                    }
                }, {init: false});

                this.observe("SVSelector.y", function () {

                    if (!this.skipUpdateColor) {

                        this.updateValue.apply(this, arguments);
                    }
                }, {init: false});

                this.on("ColorPickerPalette.setColor", function (event, color, animate) {

                    this.setColor(color, animate);

                    event.original.preventDefault();
                });

                this.set("inputTextHEX", this.currentColor.hex());
                this.set("inputTextR",   this.currentColor.red());
                this.set("inputTextG",   this.currentColor.green());
                this.set("inputTextB",   this.currentColor.blue());

                this.observe("input", function (value) {

//                                        this.waitForUserInteraction = this.get("defer");
//
//                    this.initializeColors();
//
//                    this.moveSelectorsToCurrentColorPosition(true);
//
//                    this.waitForUserInteraction = false;

                }, {init: false});

            },

            onrender: function () {

                this.SVBox = this.find(".ColorPicker--SV-box");
                this.SVSelector = this.find(".ColorPicker--SV-selector");

                this.HBox = this.find(".ColorPicker--H-box");
                this.HSelector = this.find(".ColorPicker--H-selector");

                this.moveSelectorsToCurrentColorPosition();

                if (!this.waitForUserInteraction) {

                    this.fire("output", this.getCurrentRGB());
                }

                this.$win.on("resize", this.windowResizeHandler.bind(this));

                this.waitForUserInteraction = false;
            },

            onteardown: function () {

                this.$win.off("." + this.EVENT_NS);
            },

            windowResizeHandler: function () {

                clearTimeout(this.windowResizeThrottle);

                this.windowResizeThrottle = setTimeout(function() {

                    this.moveSelectorsToCurrentColorPosition();

                }.bind(this), 100);
            },

            getCurrentRGB: function () {

                return "rgb(" + this.currentColor.red() + ", " + this.currentColor.green() + ", " + this.currentColor.blue() + ")";
            },

            updateSaturation: function () {

                var width = this.SVBox.offsetWidth,

                    x = this.get("SVSelector.x"),

                    saturation = Math.min(1, Math.max(0, (x / width)));

                this.set("saturation", saturation);
            },

            updateValue: function () {

                var height = this.SVBox.offsetHeight,

                    y = this.get("SVSelector.y"),

                    value = 1 - Math.min(1, Math.max(0, (y / height)));

                this.set("value", value);
            },

            updateHue: function () {

                var height = this.HBox.offsetHeight,

                    y = this.get("HSelector.y"),

                    hue = 360 - Math.min(360, Math.max(0, (y / height) * 360));

                this.preserveHue = true;

                this.set("hue", hue);

                this.preserveHue = false;
            },

            moveSelectorsToCurrentColorPosition: function (animate) {

                this.skipUpdateCurrent = true;
                this.moveHSelector(this.getHSelectorPosition(), animate);
                this.skipUpdateCurrent = false;
                this.moveSVSelector(this.getSSelectorPosition(), this.getVSelectorPosition(), animate);
            },

            moveSVSelector: function (x, y, animate) {

                if (this.SVSelector) {

                    var width = this.SVBox.offsetWidth,
                        height = this.SVBox.offsetHeight;

                    x = Math.min(width, Math.max(0, x));
                    y = Math.min(height, Math.max(0, y));

                    this.set("animate", !!animate);

                    this.skipUpdateCurrent = true;
                    this.set("SVSelector.x", x);
                    this.skipUpdateCurrent = false;
                    this.set("SVSelector.y", y);
                }
            },

            moveHSelector: function (y, animate) {

                if (this.HSelector) {

                    var height = this.HBox.offsetHeight;

                    y = Math.min(height, Math.max(0, y));

                    this.set("animate", !!animate);

                    this.set("HSelector.y", y);
                }
            },

            setColor: function (color, animate) {

                this.currentColor = Spectra(color);

                //při zadávání barvy klávesnicí může dojít k malé změně barvy,
                //proto je potřeba zabránit její změně
                this.skipUpdateColor = true;

                this.update("current");

                this.moveHSelector(this.getHSelectorPosition(), animate);
                this.moveSVSelector(this.getSSelectorPosition(), this.getVSelectorPosition(), animate);

                this.skipUpdateColor = false;
            },

            getHSelectorPosition: function () {

                return this.HBox.offsetHeight - ((this.HBox.offsetHeight * (this.HBoxColor.hue() / 360) || this.HBox.offsetHeight));
            },

            getSSelectorPosition: function () {

                return this.SVBox.offsetWidth * this.currentColor.saturationv();
            },

            getVSelectorPosition: function () {

                return this.SVBox.offsetHeight * (1 - this.currentColor.value());
            },

            activateSelector: function(e, type) {

                var eventData = U.eventData(e);

                if (eventData.pointers > 1) {

                    this.$win.off("mousemove." + this.EVENT_NS + " touchmove." + this.EVENT_NS + " mouseup." + this.EVENT_NS + " touchend." + this.EVENT_NS)

                    clearTimeout(this[type === "SV" ? "moveSVToPositionTimeout"   : "moveHToPositionTimeout"]);

                    return;
                }

                var movedToPosition = false,

                    selector              = type === "SV" ? ".ColorPicker--SV-selector" : ".ColorPicker--H-selector",
                    box                   = type === "SV" ? ".ColorPicker--SV-box"      : ".ColorPicker--H-box",
                    moveToPositionTimeout = type === "SV" ? "moveSVToPositionTimeout"   : "moveHToPositionTimeout",
                    moveSelectorFn        = type === "SV" ? "moveSVSelector"            : "moveHSelector",
                    dataSelector          = type === "SV" ? "SVSelector"                : "HSelector",

                    $selector = $(eventData.target).closest(selector),

                    selectorPosition = $selector.position(),
                    selectorHeight = $selector.height(),
                    selectorWidth = $selector.width(),

                    initPositions = {};

                initPositions.pointerY = eventData.clientY;
                initPositions.pointerX = eventData.clientX;

                initPositions.handleY = this.get(dataSelector + ".y");

                if (type === "SV") {

                    initPositions.handleX = this.get(dataSelector + ".x");
                }

                initPositions.startOffsetX = eventData.offsetX;
                initPositions.startOffsetY = eventData.offsetY;

                //událost vznikla na selektoru - je potřeba upravit pozici
                if ($selector.length) {

                    initPositions.startOffsetX += selectorPosition.left;
                    initPositions.startOffsetY += selectorPosition.top;
                }

                var moveToStartEventPosition = function (animate, byEndEvent) {

                    var args = [initPositions.startOffsetY, animate];

                        if (type === "SV") {

                            args.unshift(initPositions.startOffsetX);
                        }

                        this[moveSelectorFn].apply(this, args);

                        if (!byEndEvent) {

                            if (type === "SV") {

                                initPositions.handleY = this.getVSelectorPosition();
                                initPositions.handleX = this.getSSelectorPosition();

                            } else {

                                initPositions.handleY = this.getHSelectorPosition();
                            }
                        }

                        movedToPosition = true;

                    }.bind(this);

                clearTimeout(this[moveToPositionTimeout]);

                //pokud uživatel nepohne myší/prstem => přesunout na místo
                this[moveToPositionTimeout] = setTimeout(moveToStartEventPosition.bind(this, true), eventData.isTouchEvent ? 200 : 100);

                this.$win
                    .off("mousemove." + this.EVENT_NS + " touchmove." + this.EVENT_NS + " mouseup." + this.EVENT_NS + " touchend." + this.EVENT_NS)
                    .on("mousemove." + this.EVENT_NS + " touchmove." + this.EVENT_NS, function (e) {

                        var eventData = U.eventData(e);

                        if (eventData.pointers > 1) {

                            clearTimeout(this[moveToPositionTimeout]);

                            this.$win.off("mousemove." + this.EVENT_NS + " touchmove." + this.EVENT_NS + " mouseup." + this.EVENT_NS + " touchend." + this.EVENT_NS)

                            return;
                        }

                        if (!movedToPosition) {

                            clearTimeout(this[moveToPositionTimeout]);

                            //nejdříve je potřeba přesunout selektor na pozici myši/prstu
                            moveToStartEventPosition();
                        }

                        var args = [
                            initPositions.handleY + eventData.clientY - initPositions.pointerY
                        ];

                        if (type === "SV") {

                            args.unshift(initPositions.handleX + eventData.clientX - initPositions.pointerX);
                        }

                        this[moveSelectorFn].apply(this, args);

                        e.preventDefault();
                        return false;

                    }.bind(this))
                    .one("mouseup." + this.EVENT_NS + " touchend." + this.EVENT_NS, function (e) {

                        if (!movedToPosition) {

                            clearTimeout(this[moveToPositionTimeout]);

                            moveToStartEventPosition(true, true);
                        }

                        this.$win.off("mousemove." + this.EVENT_NS + " touchmove." + this.EVENT_NS);

                        e.preventDefault();
                        return false;

                    }.bind(this));

                eventData.preventDefault();
                return false;
            },

            validateRGB: function (color) {

                return /rgb\(\s*(?:\d{1,3})\s*,\s*(?:\d{1,3})\s*,\s*(?:\d{1,3})\s*\)/.test(color);
            },

            validateHEX: function (color) {

                return /#?(?:[0-9a-f]{6})/i.test(color);
            },

            inputTextHEXChanged: function (event) {

                var currentHEX = this.get("inputTextHEX");

                if (this.validateHEX(currentHEX)) {

                    this.setColor(~currentHEX.indexOf("#") ? currentHEX : "#" + currentHEX, true);
                }
            },

            inputTextRGBChanged: function (event) {

                var currentRGB = "rgb(" + this.get("inputTextR") + ", " + this.get("inputTextG") + ", " + this.get("inputTextB") + ")";

                if (this.validateRGB(currentRGB)) {

                    this.setColor(currentRGB, true);
                }
            }

        });

        var app = new Ractive({
            el: "#app",
            template: "#App",

            components: {
                ColorPicker: ColorPicker
            },

            partials: {

            },
            data: {
//                color: "rgb(255, 255, 0)",
//                border: "rgb(0, 0, 250)"
            },

            onconfig: function () {

                this.on("changeColor", this.changeColor);

            },

            changeColor: function (type, color) {
                console.log(arguments);
                this.set(type, color);
            }
        });

        var picker = app.findComponent("ColorPicker")
    </script>



</body>
</html>
